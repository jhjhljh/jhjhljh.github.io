<!doctype html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"> ﻿<meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><meta name="keywords" content="线性表,"><link rel="alternate" href="/atom.xml" title="Abo" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="http://prc4nro7n.bkt.clouddn.com/favicon.ico?v=5.1.3"><meta name="description" content="数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习 链表练习"><meta name="keywords" content="线性表"><meta property="og:type" content="article"><meta property="og:title" content="数据结构-线性表"><meta property="og:url" content="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01.html"><meta property="og:site_name" content="Abo"><meta property="og:description" content="数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习 链表练习"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01/fade.jpg"><meta property="og:updated_time" content="2019-05-12T16:10:01.941Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构-线性表"><meta name="twitter:description" content="数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习 链表练习"><meta name="twitter:image" content="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01/fade.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",sidebar:"",fancybox:!0,motion:!0,duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:"",labels:""}}</script><link rel="canonical" href="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01.html"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><title> 数据结构-线性表 | Abo</title></head><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("W0twhOKHT901IOCEADaiuynP-gzGzoHsz","zQfRdGCiWzVvsSpXKOJsbvHe")</script><script>function showTime(e){var t=new AV.Query(e);$(".leancloud_visitors").each(function(){var r=$(this).attr("id").trim();t.equalTo("url",r),t.find({success:function(e){if(0!=e.length)for(var t=0;t<e.length;t++){var n=e[t];o=$(document.getElementById(r)).text()+": "+n.get("time");$(document.getElementById(r)).text(o)}else{var o=$(document.getElementById(r)).text()+": 0";$(document.getElementById(r)).text(o)}},error:function(e,t){console.log("Error: "+t.code+" "+t.message)}})})}function addCount(o){o=AV.Object.extend("Counter");url=$(".leancloud_visitors").attr("id").trim(),title=$(".leancloud_visitors").attr("data-flag-title").trim();var e=new AV.Query(o);e.equalTo("url",url),e.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){var t=$(document.getElementById(url)).text()+": "+e.get("time");$(document.getElementById(url)).text(t)},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new o;n.set("title",title),n.set("url",url),n.set("time",1),n.save(null,{success:function(e){console.log("newcounter.get('time')="+e.get("time"));var t=$(document.getElementById(url)).text()+": "+e.get("time");$(document.getElementById(url)).text(t)},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4f040a6ebf9ae0c7337c462df961942c";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Abo</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">阿波同学</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-futbol-o"></i><br> 关于</a></li><li class="menu-item menu-item-top"><a href="/top" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i><br> 排行</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01.html"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林加鸿"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abo"> <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abo" src></span></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 数据结构-线性表</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-10T19:21:38+08:00">2019-05-10</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DataStructure/" itemprop="url" rel="index"><span itemprop="name">DataStructure</span></a></span></span> <span id="/DataStructure/2019/05/10/DataStructure-01.html" class="leancloud_visitors" data-flag-title="数据结构-线性表"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">热度</span><span class="leancloud-visitors-count"></span> <span>℃</span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计</span> <span title="字数统计">6.3k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">24</span></div></div></header><div class="post-body" itemprop="articleBody"><p></p><p class="description"><br> 数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习<br></p><p></p><blockquote class="question">链表练习</blockquote><p><img src="/DataStructure/2019/05/10/DataStructure-01/fade.jpg" alt="fade"></p><a id="more"></a><hr><blockquote class="question">“即使只有一条路，也没有什么好困扰的，重要的是该怎么走那条路，对吧？”</blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=489970551&auto=1&height=32"></iframe><h4 id="线性表-List-：零个或多个数据元素的有限序列"><a href="#线性表-List-：零个或多个数据元素的有限序列" class="headerlink" title="线性表 (List)：零个或多个数据元素的有限序列"></a>线性表 (List)：零个或多个数据元素的有限序列</h4><ul><li>线性表元素的个数n（n≥0）定义为线性表的长度，当n=0时，称为空表。</li><li>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</li></ul><hr><h4 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data 线性表的数据对象集合为&#123;a1，a2，....an&#125;每个元素类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an之外，每一个元素有且只有一个直接后继元素。数据元素之间是一对一的关系</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line"><span class="function"><span class="title">InitList</span><span class="params">(*L)</span></span>:初始化操作，建立一个空的线性表L</span><br><span class="line"><span class="function"><span class="title">ListEmpty</span><span class="params">(L)</span></span>:判断线性表是否为空表，若线性表为空，返回True，否则返回false</span><br><span class="line"><span class="function"><span class="title">ClearList</span><span class="params">(*L)</span></span>:将线性表清空</span><br><span class="line"><span class="function"><span class="title">GetElem</span><span class="params">(L,I,*e)</span></span>:将线性表L中的第i个位置元素返回给e</span><br><span class="line"><span class="function"><span class="title">LocateElem</span><span class="params">(L,e)</span></span>:在线性表L中查找与给定值e相等的元素如果查找成功，返回该元素在表中序号，表示成功，否则返回<span class="number">0</span>，表示失败。</span><br><span class="line"><span class="function"><span class="title">ListInsert</span><span class="params">(*L,i,e)</span></span>:在线性表L的第i个位置插入新元素e</span><br><span class="line"><span class="function"><span class="title">ListDelete</span><span class="params">(*L,i,*e)</span></span>:删除线性表L中第i个位置元素，并用e返回其值</span><br><span class="line"><span class="function"><span class="title">ListLength</span><span class="params">(L)</span></span>:返回线性表L的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>实现两个线性表集合A跟B的并集操作！<br></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将所有的在线性表Lb但不在La的数据元素插入到La中*/</span></span><br><span class="line">void union(<span class="keyword">List</span> *<span class="keyword">La</span>,<span class="keyword">List</span> Lb)</span><br><span class="line">&#123;</span><br><span class="line">    int La_len,Lb_len,i;</span><br><span class="line">    ElemType <span class="keyword">e</span>; <span class="comment">/*声明与La和Lb相同的数据元素e*/</span></span><br><span class="line">    La_len = ListLength(<span class="keyword">La</span>); <span class="comment">/*求线性表的长度*/</span></span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span>(i = 1;i &lt;= Lb_len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(Lb,i,<span class="keyword">e</span>);<span class="comment">/*取Lb中第i个数据元素赋给e*/</span></span><br><span class="line">        <span class="keyword">if</span>(!LocateElem(<span class="keyword">La</span>,<span class="keyword">e</span>,equal)) <span class="comment">/*La中不存在和e相同数据元素*/</span></span><br><span class="line">        ListInsert(<span class="keyword">La</span>, ++La_len, <span class="keyword">e</span>); <span class="comment">/*插入*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h4><ul><li><p>定义:指的是用一段地址连续的存储单元以此存储线性表的数据元素。</p><blockquote><p>以下是线性表的顺序存储的结构代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/*存储空间的初始分配量 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType； <span class="comment">/*ElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]； <span class="comment">/*数组存储数据元素，最大值为MAXSIZE*/</span></span><br><span class="line">    <span class="keyword">int</span> length； <span class="comment">/*线性表当前长度*/</span></span><br><span class="line">&#125;SqList； <span class="comment">/*Sequence List*/</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>数组长度和线性表长度的区别：</p></li></ul><ol><li>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的</li><li>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是会变化的</li><li>在任意时刻，线性表的长度应该小于等于数组的长度。</li></ol><ul><li>地址计算方法</li></ul><ol><li>线性表的第i个元素是要存储在数组下标为i-1的位置，即线性表从1开始</li><li>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，由此分配的数组空间要大于等于当前线性表的长度</li><li>存储器中的每个存储单元都有自己的编号，这个编号称为地址</li></ol><blockquote><p> LOC(a(i+1))=LOC(ai)+c</p></blockquote><blockquote><p> LOC(ai)=LOC(a1)+(i-1)*c</p></blockquote><hr><h4 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h4><ul><li>GetElem:将线性表L中的第i个位置元素值返回，就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="comment">/*Status（状态，身份，地位）是函数的类型，其值是函数结果状态代码，如OK*/</span></span><br><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:用e返回L中第i个数据元素的值*/</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(L.length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">   <span class="keyword">return</span> ERROR;</span><br><span class="line">   *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>==疑问：为什么是*e？==</p><ul><li>ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e</li><li>插入算法的思路：</li></ul><ol><li>如果插入位置不合理，抛出异常</li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li><li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置</li><li>将要插入元素填入位置i处</li><li>表长加一<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在,1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/</span></span><br><span class="line">Status ListInsert(SqList *L,<span class="keyword">int</span> i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length==MAXSIZE) <span class="comment">/*顺序线性表已经满*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>) <span class="comment">/*当i不在范围内时*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length) <span class="comment">/*若插入数据位置不在表尾*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) <span class="comment">/*将要插入位置后数据元素向后移一位*/</span></span><br><span class="line">            L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=e;<span class="comment">/*将新元素插入*/</span></span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><ul><li>ListDelete</li><li>删除算法的思路:</li></ul><ol><li>如果删除位置不合理，抛出异常</li><li>取出删除元素</li><li>从删除元素位置开始遍历到最后一个元素，分别将它们都往前移动一个位置</li><li>表长减1<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete(SqList *L,<span class="type">int</span> i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;<span class="built_in">length</span> == <span class="number">0</span>) <span class="comment">/*线性表为空*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;<span class="built_in">length</span>) <span class="comment">/*删除位置不正确*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-<span class="built_in">length</span>) <span class="comment">/*如果删除不是最后位置*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;L-<span class="built_in">length</span>;k++) <span class="comment">/*将删除位置后继元素前移*/</span></span><br><span class="line">            L-data[k<span class="number">-1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;<span class="built_in">length</span>--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>-线性表顺序存储结构的优缺点</p><ol><li>优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间，可以快速地存取表中任一位置的元素</li><li>缺点：插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量，造成存储空间的“碎片”</li></ol><hr><h4 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h4><ul><li>为了表示每个数据元素a1与其直接后继元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置).我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)</li><li>n个结点(ai的存储映像)链结成一个链表，即为线性表(a1，a2，…an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做==单链表==</li><li>我们把链表中第一个结点的存储位置叫做头指针，规定最后一个结点指针为“空”(通常用NULL或^符号表)；有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，头结点的指针域存储指向第一个结点的指针。<h5 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h5></li><li>头指针</li></ul><ol><li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li><li>头指针具有标识作用，所以常用头指针冠以链表的名字</li><li>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</li></ol><ul><li>头结点</li></ul><ol><li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度)</li><li>有了头结点，对在第一元素结点前插入节点和删除第一结点，其操作与其它节点的操作就==统一==了</li><li>头结点不一定是链表必要元素</li></ol><ul><li>线性表链式存储结构代码描述</li></ul><ol><li>若线性表为空表，则头结点的指针域为“空”<blockquote><p>单链表中，我们在C语言可用结构指针来描述</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*线性表的单链表存储结构*/</span><br><span class="line">typedef struct <span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    ElemType</span> data;</span><br><span class="line">    struct <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125; <span class="keyword">Node</span><span class="title">;</span></span><br><span class="line"><span class="title">typedef</span> struct <span class="keyword">Node</span> <span class="title">*LinkList</span>;/*定义LinkList*/</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>这波操作事后==了解==一下,翻一下结构体</p><ol start="2"><li>结点由存放数据元素的数据域,存放后继结点地址的指针域组成</li></ol></blockquote><hr><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><ul><li>获得链表第i个数据的算法思路：</li></ul><ol><li>声明一个结点p指向链表第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，返回结点p的数据<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:用e返回L中的第i个数据元素的值*/</span></span><br><span class="line">Status GetElem(LinkList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p; <span class="comment">/*声明一结点p*/</span></span><br><span class="line">    <span class="function"><span class="title">p</span> = L-&gt;</span>next; <span class="comment">/*让p指向链表L的第一个结点*/</span></span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">/*j为计数器*/</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i) <span class="comment">/*p不为空或者计数器j还没有等于i时，循环继续*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next; <span class="comment">/*让p指向下一个结点*/</span></span><br><span class="line">        ++j；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( !p || j&gt;i )</span><br><span class="line">        return ERROR; <span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    *<span class="function"><span class="title">e</span> = p-&gt;</span><span class="keyword">data</span>; <span class="comment">/*取第i个元素的数据*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h4><blockquote><p>s-&gt;next=p-&gt;next; p-&gt;next=s<br>这两句的顺序==不可交换==，自己想</p><ul><li>单链表第i个数据插入结点的算法思路：</li></ul><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，在系列中生成一个空结点s</li><li>将数据元素e赋值给s-&gt;data</li><li>单链表的插入标准语句s-&gt;next=p-&gt;next; p-&gt;next=s</li><li>返回成功<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/</span></span><br><span class="line">Status ListInsert(LinkList *L,int i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p,s;</span><br><span class="line">    p = *L;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j &lt; i) <span class="comment">/*寻找第i个结点*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">        return ERROR; <span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    s =(LinkList)malloc(sizeof(Node));<span class="comment">/*生成新结点(C标准函数)*/</span></span><br><span class="line">    <span class="function"><span class="title">s</span>-&gt;</span><span class="keyword">data</span> = e;</span><br><span class="line">    <span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;<span class="comment">/*将p的后继结点赋值给s的后继*/</span></span><br><span class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next = s; <span class="comment">/*将s赋值给p的后继*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>单链表的删除实质：p-&gt;next=p-&gt;next-&gt;next</p><blockquote><p>用q来取代p-&gt;next,就是q=p-&gt;next;p-&gt;next=q-&gt;next;</p><ul><li>单链表第i个数据删除结点的算法思路:</li></ul><ol><li>声明一结点p指向链表的第一个节点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，将欲删除的结点p-&gt;next赋值给q</li><li>单链表的标准删除语句p-&gt;next=q-&gt;next</li><li>将q结点中的数据赋值给e，作为返回</li><li>释放q结点</li><li>返回成功<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:删除L的第i个数据元素，并用e返回其值，L的长度减1*/</span></span><br><span class="line">Status ListDelete(LinkList *L,int i, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = *L;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">while</span>(p-&gt;</span>next &amp;&amp; j &lt; i) <span class="comment">/*遍历寻找第i个元素*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span>(!(p-&gt;</span>next) || j&gt;i)</span><br><span class="line">        return ERROR;<span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    <span class="function"><span class="title">q</span> = p-&gt;</span>next;</span><br><span class="line">    p</span><br><span class="line">    -&gt;<span class="function"><span class="title">next</span> = q-&gt;</span>next;<span class="comment">/*将q的后继赋值给p的后继*/</span></span><br><span class="line">    *<span class="function"><span class="title">e</span>=q-&gt;</span><span class="keyword">data</span>;<span class="comment">/*将q结点中的数据给e*/</span></span><br><span class="line">    free(q);<span class="comment">/*让系统回收此结点，释放内存*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote></blockquote><hr><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><ul><li>创建单链表的过程就是一个动态生成链表的过程，即从”空表”的初始状态起，依次建立各元素结点，并逐个插入链表</li><li>单链表整表创建的算法思路:</li></ul><ol><li>声明一结点p和计数器变量i</li><li>初始化一空链表L</li><li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表</li><li>循环:<br>生成一新结点赋值给p；随机生成一数字赋值给p的数据域p-&gt;data;将p插入到头结点与前一新结点之间<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*随机生成n个元素的值，建立带表头结点的单链线性表L(头插法)*/</span></span><br><span class="line"><span class="literal">void</span> CreateListHead(LinkList *L,int n)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    int i;</span><br><span class="line">    srand(time(<span class="number">0</span>)); <span class="comment">/*初始化随机数种子*/</span></span><br><span class="line">    *L = ( LinkList)malloc(sizeof(Node));</span><br><span class="line">    <span class="function"><span class="params">(*L)</span>-&gt;</span>next = NULL; <span class="comment">/*先建立一个带头结点的单链表*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (LinkList)malloc(sizeof(Node));<span class="comment">/*生成新结点*/</span></span><br><span class="line">        p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>; <span class="comment">/*随机生成100以内的数字*/</span></span><br><span class="line">        p-&gt;<span class="function"><span class="title">next</span> = <span class="params">(*L)</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="params">(*L)</span>-&gt;</span>next = p; <span class="comment">/*插入到表头*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>求问L,<em>L,(</em>L)的区别？ 如果要改变变量的值就用指针，不改变就用变量本身<br>LinkList等同于Node <em>，所以L要加</em></p><blockquote><p>函数rand()跟srand()<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*随机生成n个元素的值，建立带表头结点的单链线性表L(尾插法)*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList *L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p,r;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    srand(time(<span class="number">0</span>));<span class="comment">/*初始化随机数种子*/</span></span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))；<span class="comment">/*为整个线性表*/</span></span><br><span class="line">    r=*L;<span class="comment">/*r为指向尾部的结点*/</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">/*生成新结点*/</span></span><br><span class="line">        p-&gt;data=rand()%<span class="number">100</span>+<span class="number">1</span>;<span class="comment">/*随机生成100以内的数字*/</span></span><br><span class="line">        r-&gt;next = p;<span class="comment">/*将表尾终端结点的指针指向新结点*/</span></span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;<span class="comment">/*表示当前链表结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote></blockquote><hr><h4 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h4><ul><li>单链表整表删除的算法思路如下:</li></ul><ol><li>声明一结点p和q；</li><li>将第一个结点赋值给p</li><li>循环：将下一结点赋值给q；释放p；将q赋值给p。<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件：顺序线性表L已存在，操作结果：将L重置为空表*/</span></span><br><span class="line">Status ClearList(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    <span class="function"><span class="title">p</span>=<span class="params">(*L)</span>-&gt;</span>next; <span class="comment">/*p指向第一个结点*/</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        free(p);</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="params">(*L)</span>-&gt;</span>next=NULL;<span class="comment">/*头结点指针域为空*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><blockquote><p>简单地对单链表结构和顺序存储结构做对比：</p><ul><li>存储分配方式</li></ul><ol><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li></ol><ul><li>时间性能</li></ul><ol><li>查找：①顺序存储结构O(1)；②单链表O(n)</li><li>插入与删除：①顺序存储结构需要平均移动表长一半的元素，时间为O(n)； ②单链表在线出某位置的指针后，插入和删除时间仅为O(1)</li></ol><ul><li>空间性能</li></ul><ol><li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制<br>通过上面对比，我们可以得出一些经验性的结论</li><li>若线性表需要频繁查找，很少进行插入或删除时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。比如游戏开发，对于用户注册的个人信息，出来注册时插入数据外，绝大多数情况都是读取，所以应该考虑顺序存储结构。而游戏装备道具就用单链表结构。</li><li>当线性表元素个数变化很大或者不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，则用顺序存储结构效率会高很多。</li></ol></blockquote><hr><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><ul><li>背景:数组代替指针描述单链表，首先让数组的元素由两个数据域组成，data和cur，也就是说，数组的每一个下标都对应一个data和一个cur.数据域data，用来存放数据元素，也就是通常我们要处理的数据，而游标cur相当于单链表的next指针，用于存放该元素后继在数组中的下标。我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<blockquote><p>为了方便插入数据，通常会把数组建立得大一些，以便有一些空闲空间插入不至于溢出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的静态链表存储结构*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">/*假设链表的最大长度是1000*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur; <span class="comment">/*游标(cursor),为0</span></span><br><span class="line"><span class="comment">    时表示无指向*/</span></span><br><span class="line">&#125;Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据，把未被使用的数组元素称为备用链表。</p><blockquote><p>数组第一个元素，即下标为0的元素的cur存放备用链表的第一个结点的下标;而数组的最后一个元素的cur则存放第一个有数值的元素的下表，相当于单链表中的头结点，当整个链表为空时，则为0<br></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*将一维数组<span class="literal">space</span>中各分量链成一备用链表*/</span><br><span class="line">/*<span class="literal">space</span>[<span class="number">0</span>].cur为头指针，<span class="string">"0"</span>表示空指针*/</span><br><span class="line">Status InitList(StaticLinkList <span class="literal">space</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXSIZE<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="literal">space</span>[i].cur = i+<span class="number">1</span>;</span><br><span class="line">    <span class="literal">space</span>[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>/*目前静态链表为空，最后一个元素的cur为<span class="number">0</span>*/</span><br><span class="line"><span class="built_in">    return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote></blockquote><ul><li>静态链表的插入操作<blockquote><p>静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放</p><blockquote><p>动态链表，结点的申请和释放分别借用malloc()和free()两个函数来实现，而静态链表操作的是数组，我们需要自己实现这两个函数</p><blockquote><p>为了辨明数组中哪些分量未被使用，解决方法是将所有未被使用过的及被删除的分量用游标链成一个备用的链表，每当插入时，可以从备用链表上取得第一个结点作为待插入的新结点</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若备用空间链表为空，则返回分配的结点下标，否则为0*/</span></span><br><span class="line">int Malloc_SLL(StaticLinkList <span class="built_in">space</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="built_in">space</span>[<span class="number">0</span>].cur;<span class="comment">/*当前数组第一个元素的cur存的值就是要返回的第一个备用空闲的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">space</span>[<span class="number">0</span>].cur)</span><br><span class="line">        <span class="built_in">space</span>[<span class="number">0</span>].cur = <span class="built_in">space</span>[i].cur<span class="comment">/*由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用*/</span></span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote></li></ul><blockquote><p>需要找到接替者才能继续分配新的空闲分量</p><blockquote><p>现在我们如果需要在乙丁之间插入丙，我们只需要让丙在7号备用位待着，把乙的cur改为7，再让丙的cur改为3即可<br></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="built_in">ListInsert</span>(StaticLinkList L,int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int j,k,l;</span><br><span class="line">    k = MAX_SIZE - <span class="number">1</span>;<span class="comment">/*注意k首先是最后一个元素的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; <span class="built_in">ListLength</span>(L) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">    j = <span class="built_in">Malloc_SSL</span>(L);<span class="comment">/*获得空闲分量的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(j)</span><br><span class="line">    &#123;</span><br><span class="line">        L[j].data = e; <span class="comment">/*将数据赋值给此分量的data*/</span></span><br><span class="line">        <span class="keyword">for</span>(l = <span class="number">1</span>;l &lt;= i<span class="number">-1</span>;l++) <span class="comment">/*找到第i个元素之前的位置*/</span></span><br><span class="line">        k = L[k].cur;</span><br><span class="line">        L[j].cur = L[k].cur;<span class="comment">/*把第i个元素之前的cur赋值给新元素的cur*/</span></span><br><span class="line">        L[k].cur = j;<span class="comment">/*把新元素的下标赋值给第i个元素之前元素的cur*/</span></span><br><span class="line">        <span class="keyword">return</span> OK；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ERROR</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote></blockquote><ul><li>静态链表的删除操作<blockquote><p>和前面一样，删除元素时，原来是需要释放结点的函数free().现在我们也得自己实现它:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除在L中第i个数据元素e*/</span></span><br><span class="line">Status ListDelete(StaticLinkList L,int i)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">j,k;</span></span><br><span class="line"><span class="keyword"> </span>   if(i &lt; <span class="number">1</span> <span class="title">||</span> i &gt; LIstLength(L))</span><br><span class="line">        return ERROR<span class="comment">;</span></span><br><span class="line">    k = MAX_SIZE - <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">j </span>= <span class="number">1</span><span class="comment">;j &lt;= i-1;j++)</span></span><br><span class="line">        k = L[k].cur<span class="comment">;</span></span><br><span class="line">    <span class="keyword">j </span>= L[k].cur<span class="comment">;</span></span><br><span class="line">    L[k].cur = L[<span class="keyword">j].cur;</span></span><br><span class="line"><span class="keyword"> </span>   Free_SSL(L,<span class="keyword">j);</span></span><br><span class="line"><span class="keyword"> </span>   return OK<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>而关于Free_SSL(L,j)<br></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将下列为k的空闲结点回收到备用链表*/</span></span><br><span class="line">void Free_SSL(StaticLinkList <span class="built_in">space</span>,int k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">space</span>[k].cur = <span class="built_in">space</span>[<span class="number">0</span>].cur;<span class="comment">/*把第一个元素cur赋值给要删除的分量cur*/</span></span><br><span class="line">    <span class="built_in">space</span>[<span class="number">0</span>].cur = k;<span class="comment">/*把要删除的分量下标赋值给第一个元素的cur*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>当然，静态链表也有相应的其他操作的相关实现，比如代码中的ListLength<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件：静态链表L已存在，操作结果：返回L中的数据个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        i = L[i].cur;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>回顾：sizeof()和strlen</p></blockquote><hr><h4 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h4><ul><li>优点</li></ul><ol><li>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点</li></ol><ul><li>缺点</li></ul><ol><li>没有解决连续存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性<blockquote><p>总的来说，静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法。</p></blockquote></li></ol><hr><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ul><li>定义:将单链表中终端结点的指针端由空指针改为指向头结点就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)</li><li>循环链表和单链表的主要差异在判断条件上：原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束<blockquote><p>在单链表中，我们有了头结点，可以用O(1)的时间访问第一个结点，但对于要访问到最后一个结点，却需要O(n)时间，因为我们需要将单链表全部扫描一遍</p><blockquote><p>如用O(1)的时间由链表指针访问到最后一个结点,则需改造一下循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便</p><blockquote><p>终端结点用尾指针rear指示，则查找终端结点是O(1),而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂也为O(1)</p></blockquote></blockquote></blockquote></li><li>举个程序的例子，要将两个循环链表合成一个表时，有了尾指针就非常简单<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span> = rearA-&gt;</span>next;<span class="comment">/*保存A表的头结点*/</span></span><br><span class="line"><span class="function"><span class="title">rearA</span>-&gt;</span><span class="function"><span class="title">next</span>=rearB-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>;/*将本是指向B表的第一个结点(不是头结点)赋值给rearA-&gt;</span>next*/</span><br><span class="line"><span class="function"><span class="title">rearB</span>-&gt;</span><span class="function"><span class="title">next</span>=p;/*将原A表的头结点赋值给rearB-&gt;</span>next*/</span><br><span class="line">free(p);<span class="comment">/*释放p*/</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul><li>定义：双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的双向链表存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span><span class="comment">/*直接前驱指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span><span class="comment">/*直接后继指针*/</span></span><br><span class="line">&#125;DulNode,*DuLinkList;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>既然单链表有循环链表，那么双向链表也可以是循环链表</p><blockquote><p>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</p><ul><li>双向链表的插入<br>将结点s插入到结点p和p-&gt;next之间</li></ul></blockquote><blockquote><p>顺序很重要，不能写反<br></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span>-&gt;</span>prior = p;<span class="comment">/*将p赋值给s的前驱*/</span></span><br><span class="line"><span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span><span class="function"><span class="title">next</span>;/*把p-&gt;</span>next赋值给s的后继*/</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">prior</span> = s;/*把s赋值给p-&gt;</span>next的前驱*/</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>next = s;<span class="comment">/*把s赋值给p的后继*/</span></span><br></pre></td></tr></table></figure><p></p></blockquote></blockquote><blockquote><p>顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继</p><ul><li>双向链表的删除<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">prior</span>-&gt;</span><span class="function"><span class="title">next</span>=p-&gt;</span>next;</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">prior</span>=p-&gt;</span>prior;</span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>多结合图形记忆</p></blockquote><hr><h4 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h4><ul><li>线性表</li></ul><ol><li>顺序存储结构</li><li>链式存储结构</li></ol><ul><li>单链表</li><li>静态链表</li><li>循环链表</li><li>双向链表</li></ul></div><div></div><div class="post-tags"><a href="/tags/线性表/" rel="tag"><i class="fa fa-tag"></i> 线性表</a></div><div> ﻿</div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/DataStructure/2019/05/10/DataStructure-02.html" rel="prev" title="数据结构-栈与队列"><i class="fa fa-chevron-left"></i> 数据结构-栈与队列</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/DataStructure/2019/05/10/DataStructure-introduction.html" rel="next" title="数据结构概论">数据结构概论<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDE0Mi8yMDY3Ng=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <a href="/"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="林加鸿"></a><p class="site-author-name" itemprop="name">林加鸿</p><p class="site-description motion-element" itemprop="description">阿波的个人博客，主要涉及但不局限前端与算法等编程学习，图文算法分享，以记录生活或者读书笔记为主，（づ￣3￣）づ╭❤～</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">25</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">23</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jhjhljh" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/jhjhljh" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span><span class="links-of-author-item"><a href="http://www.zhihu.com/people/jhjhljh" target="_blank" title="知乎"><i class="fa fa-fw fa-battery-3"></i> 知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> 神奇的链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://music.163.com/#/user/home?id=84597901" title="😆 网易云音乐 😆" target="_blank">😆 网易云音乐 😆</a></li><li class="links-of-blogroll-item"> <a href="https://www.taylorswift.com/" title="Taylor Swift Official Website" target="_blank">Taylor Swift Official Website</a></li><li class="links-of-blogroll-item"> <a href="https://tophub.today/" title="今日热榜(各大网站)" target="_blank">今日热榜(各大网站)</a></li><li class="links-of-blogroll-item"> <a href="https://www.bilibili.com/video/av46959835/" title="独狼(Lone Wolf)——献给那些独自行走的人们" target="_blank">独狼(Lone Wolf)——献给那些独自行走的人们</a></li><li class="links-of-blogroll-item"> <a href="https://jhjhljh.github.io/about/" title="关于此博客" target="_blank">关于此博客</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#线性表-List-：零个或多个数据元素的有限序列"><span class="nav-number">1.</span> <span class="nav-text">线性表 (List)：零个或多个数据元素的有限序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性表的抽象数据类型"><span class="nav-number">2.</span> <span class="nav-text">线性表的抽象数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性表的顺序存储结构"><span class="nav-number">3.</span> <span class="nav-text">线性表的顺序存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序存储结构的插入与删除"><span class="nav-number">4.</span> <span class="nav-text">顺序存储结构的插入与删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性表的链式存储结构"><span class="nav-number">5.</span> <span class="nav-text">线性表的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#头指针与头结点的异同"><span class="nav-number">5.1.</span> <span class="nav-text">头指针与头结点的异同</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单链表的读取"><span class="nav-number">6.</span> <span class="nav-text">单链表的读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单链表的插入与删除"><span class="nav-number">7.</span> <span class="nav-text">单链表的插入与删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单链表的整表创建"><span class="nav-number">8.</span> <span class="nav-text">单链表的整表创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单链表的整表删除"><span class="nav-number">9.</span> <span class="nav-text">单链表的整表删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单链表结构与顺序存储结构优缺点"><span class="nav-number">10.</span> <span class="nav-text">单链表结构与顺序存储结构优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态链表"><span class="nav-number">11.</span> <span class="nav-text">静态链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态链表优缺点"><span class="nav-number">12.</span> <span class="nav-text">静态链表优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环链表"><span class="nav-number">13.</span> <span class="nav-text">循环链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双向链表"><span class="nav-number">14.</span> <span class="nav-text">双向链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结回顾"><span class="nav-number">15.</span> <span class="nav-text">总结回顾</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright"> &copy; 2018 - <span itemprop="copyrightYear">2019</span><span class="with-love" id="heart"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">林加鸿</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user-circle-o"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span><i class="fa fa-eye"></i></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script type="text/javascript">var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,n){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(n);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),n=-1,s=-1,o=-1;if(""!=r&&f.forEach(function(e,t){n=r.indexOf(e),s=c.indexOf(e),(0<=n||0<=s)&&(a=!0,0==t&&(o=s))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=o){var l=o-20,p=o+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("W0twhOKHT901IOCEADaiuynP-gzGzoHsz","zQfRdGCiWzVvsSpXKOJsbvHe")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script type="text/javascript" src="/js/src/love.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script>$("body").backstretch("http://prc4nro7n.bkt.clouddn.com/landscape-4208571_1280.jpg")</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{scale:1,jsonPath:"/live2dw/assets/wanko.model.json"},display:{superSample:2,width:200,height:200,position:"left"},mobile:{show:!1},react:{opacityDefault:.9,opacityOnHover:.5},log:!1})</script></body></html>