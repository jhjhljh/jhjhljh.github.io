<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  ﻿<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">











  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="树,">





  <link rel="alternate" href="/atom.xml" title="Abo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="http://prc4nro7n.bkt.clouddn.com/favicon.ico?v=5.1.0">






<meta name="description" content="众所周知，树一直是数据结构的重点，此处摘要不做多介绍">
<meta name="keywords" content="树">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构-树">
<meta property="og:url" content="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04.html">
<meta property="og:site_name" content="Abo">
<meta property="og:description" content="众所周知，树一直是数据结构的重点，此处摘要不做多介绍">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04/coldplay.jpg">
<meta property="og:updated_time" content="2019-05-12T10:56:06.121Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构-树">
<meta name="twitter:description" content="众所周知，树一直是数据结构的重点，此处摘要不做多介绍">
<meta name="twitter:image" content="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04/coldplay.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04.html">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


  <title> 数据结构-树 | Abo </title>
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>

  	 <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("W0twhOKHT901IOCEADaiuynP-gzGzoHsz", "zQfRdGCiWzVvsSpXKOJsbvHe");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = $(document.getElementById(url)).text() + ': 0';
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = $(document.getElementById(url)).text() + ': ' + object.get('time');
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content = $(document.getElementById(url)).text() + ': ' + counter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = $(document.getElementById(url)).text() + ': ' + newcounter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
});
</script>
  


<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4f040a6ebf9ae0c7337c462df961942c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Abo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">阿波同学</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="林加鸿">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/Abo.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Abo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Abo" src="/images/avatar.jpg">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                数据结构-树
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-11T01:22:40+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataStructure/" itemprop="url" rel="index">
                    <span itemprop="name">DataStructure</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
		  
			 
          
          
             <span id="/DataStructure/2019/05/11/DataStructure-04.html" class="leancloud_visitors" data-flag-title="数据结构-树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度 </span>
               
                 <span class="leancloud-visitors-count"></span>
				 <span>℃</span>
             </span>
          
		   
          

		  
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  4.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          
		  
          
 
        


        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p class="description">众所周知，树一直是数据结构的重点，此处摘要不做多介绍</p>

<p><img src="/DataStructure/2019/05/11/DataStructure-04/coldplay.jpg" alt="coldplay"></p>
<a id="more"></a>
<blockquote class="question">最近一直在循环coldplay的歌，分享一波</blockquote>


        <div id="aplayer-RQzaZkmb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-RQzaZkmb"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "Viva la Vida",
              author: "Coldplay",
              url: "http://prc4nro7n.bkt.clouddn.com/Viva%20la%20Vida.mp3",
              pic: "http://prc4nro7n.bkt.clouddn.com/Viva.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>前言:树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：</li>
</ul>
<ol>
<li>有且仅有一个特定的称为根(Root)的结点</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2…..Tm，其中每一个集合本身又是一棵树，并且称为根的子数(SubTree)<h5 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h5></li>
</ol>
<ul>
<li>树的结点包含一个数据元素以及若干指向其子树的分支。结点拥有的字树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。</li>
<li>树的度是树内各结点的度的最大值<h5 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h5></li>
<li>结点的子树的根称为该结点的孩子(Child)，相应的，该结点称为孩子的双亲(Parent)<blockquote>
<p>对于结点来说其父母同体，唯一的一个，所以称为双亲</p>
</blockquote>
</li>
<li>同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所近分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙.<h5 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h5></li>
<li>结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。<blockquote>
<p>若某结点在第I层，则其子树的根就在第I+1层。</p>
</blockquote>
</li>
<li>其双亲在同一层的结点互为堂兄弟。</li>
<li>树中结点的最大层次称为树的深度(Depth)或高度<blockquote>
<p>如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</p>
</blockquote>
</li>
<li>森林(Forest)是m(m≥0)棵互不相交的树的集合<blockquote>
<p>对树种的每个结点而言，其子树的集合即为森林。</p>
</blockquote>
</li>
<li>对比线性表与树的结构，它们有很大的不同</li>
</ul>
<ol>
<li>线性结构：①第一个数据元素：无前驱；②最后一个数据元素：无后继；③中间元素：一个前驱一个后继</li>
<li>树结构：①根节点：无双亲，唯一；②叶节点：无孩子，可以多个；③中间结点：一个双亲多个孩子</li>
</ol>
<hr>
<h4 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h4><p>对于线性结构，树的操作就完全不同了<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT 树(Tree)</span><br><span class="line">Data 树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系.</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line">    InitTree(*<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    DestroyTree(*<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    CreateTree(*<span class="built_in">T</span>,definition)<span class="symbol">:</span></span><br><span class="line">    ClearTree(*<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    TreeEmpty(<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    TreeDepth(<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    Root(<span class="built_in">T</span>)<span class="symbol">:</span>返回树的根节点</span><br><span class="line">    <span class="built_in">Value</span>(<span class="built_in">T</span>,cur_e)<span class="symbol">:cu</span>r_e是树<span class="built_in">T</span>中的一个结点，返回此结点的值</span><br><span class="line">    Assign(<span class="built_in">T</span>,cur_e,<span class="built_in">value</span>)<span class="symbol">:</span>给树<span class="built_in">T</span>的结点cur_e赋值为<span class="built_in">value</span></span><br><span class="line">    Parent(<span class="built_in">T</span>,cur_e)<span class="symbol">:</span>若cur_e是树<span class="built_in">T</span>的非根结点，则返回它的双亲，否则返回空</span><br><span class="line">    LeftChild(<span class="built_in">T</span>,cur_e)<span class="symbol">:</span>若cur_e是树<span class="built_in">T</span>的非叶节点，则返回它的最左孩子，否则返回空</span><br><span class="line">    RightSibling(<span class="built_in">T</span>,cur_e)<span class="symbol">:</span>若cur_e有右兄弟，则返回它的右兄弟，否则返回空</span><br><span class="line">    InsertChild(*<span class="built_in">T</span>,&amp;p,i,c)<span class="symbol">:</span>其中p指向树<span class="built_in">T</span>的某个结点，i为所指结点p的度加上<span class="number">1</span>，非空树c与<span class="built_in">T</span>不相交，操作结果为插入c为树<span class="built_in">T</span>中p指结点的第i棵子树</span><br><span class="line">    DeleteChild(*<span class="built_in">T</span>,*p,i)<span class="symbol">:</span>其中p指向树<span class="built_in">T</span>的某个结点，i为所指结点p的度，操作结果为删除<span class="built_in">T</span>中p所指结点的第i棵子树</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul>
<li>双亲表示法(在每个结点中，附设一个指示器指示其双亲结点到链表中的位置)<blockquote>
<p>每个结点除了知道自己是谁之外，还知道它的双亲在哪里,结点结构分为data(数据域，存储结点的数据信息)跟parent(指针域，存储该结点的双亲在数组的下标)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*树的双亲表示法结点结构定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TElemType;  <span class="comment">/*树结点的数据类型，目前暂定为整型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>  /*结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;  <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="keyword">int</span> parent;  <span class="comment">/*双亲位置*/</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  /*树结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];  <span class="comment">/*结点数组*/</span></span><br><span class="line">    <span class="keyword">int</span> r,n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>双亲域，长子域，右兄弟域</p>
<blockquote>
<p>根节点的双亲域，长子域，右兄弟域都是-1</p>
<ul>
<li>孩子表示法<br>每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法，不过树的每个结点的度，也就是它的孩子个数是不同的，所以我们可以设计两种反案来解决</li>
</ul>
<ol>
<li>一种是指针域的个数等于树的度(树的度是树各个结点度的最大值<br>这种方法在树中各结点的度相差很大时，显然是浪费空间的</li>
<li>第二种是每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数(degree)<br>这种方法克服了空间的浪费，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗<br>思考：能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同？<blockquote>
<p>我们把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系.<br>这就是所谓的孩子表示法</p>
</blockquote>
</li>
</ol>
<ul>
<li>孩子表示法:把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*树的孩子表示法结构定义*/</span></span><br><span class="line"><span class="meta">#define MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CTNode</span> <span class="comment">/*孩子结点*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="comment">/*表头结构*/</span></span><br><span class="line">&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;<span class="built_in">CTbox</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="comment">/*树结构*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CTBox</span> nodes[MAX_TREE_SIZE];  <span class="comment">/*结点数组*/</span></span><br><span class="line">    <span class="keyword">int</span> r,n;</span><br><span class="line">&#125;<span class="built_in">CTree</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li>双亲孩子表示法<blockquote>
<p>算是孩子表示法的改进，略过</p>
</blockquote>
</li>
<li>孩子兄弟表示法<blockquote>
<p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*树的孩子兄弟表示法结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightsib</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>其实这个表达法最大好处就是把一棵复杂的树变成了一棵二叉树</p>
</blockquote>
<hr>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul>
<li>二叉树的五种基本形态：</li>
</ul>
<ol>
<li>空二叉树</li>
<li>只有一个根节点</li>
<li>根节点只有左子树</li>
<li>根节点只有右子树</li>
<li>根节点既有左子树又有右子树<blockquote>
<p>注意：三个结点的树有两种情况，而三个结点的二叉树有五种形态</p>
</blockquote>
</li>
</ol>
<ul>
<li>特殊二叉树</li>
</ul>
<ol>
<li>斜树(左斜树跟右斜树)</li>
<li>满二叉树<blockquote>
<p>注意满二叉树的叶子只能出现在最下一层，单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有叶子都在同一层上</p>
</blockquote>
</li>
<li>完全二叉树</li>
</ol>
<ul>
<li>二叉树的性质</li>
</ul>
<ol>
<li>在二叉树的第i层上至多有2^i-1^个结点</li>
<li>深度为k的二叉树至多有2^k^-1个结点<blockquote>
<p>这里要看清楚，很容易把性质1跟性质2弄混</p>
</blockquote>
</li>
<li>对任意一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</li>
<li>具有n个结点的完全二叉树的深度为(log2n)+1</li>
<li>如果对一棵有n个结点的完全二叉树(其深度为(log2n)+1)的结点按层序编号，对任一节点i(1≤i≤n)有：</li>
</ol>
<ul>
<li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]</li>
<li>如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i</li>
<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1</li>
</ul>
<hr>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul>
<li>顺序存储:二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，还原成完全二叉树的方法<blockquote>
<p>考虑一种极端的情况，比如一棵深度为k的右斜树，它只有k个结点，却要分配2^k^-1个存储单元空间，这显然是对存储空间的浪费，所以顺序存储结构一般只用于完全二叉树.</p>
</blockquote>
</li>
<li>二叉链表：二叉树的每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表为二叉链表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>  /*结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;  <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">/*左右孩子指针*/</span></span><br><span class="line">&#125;BiTNode,*BiTree</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><ul>
<li>二叉树的遍历(traversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问一次且仅被访问一次.</li>
</ul>
<ol>
<li><p>前序遍历</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*二叉树的前序遍历递归算法*/</span><br><span class="line">void PreOrderTraverse(BiTree <span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    printf(<span class="string">"c%"</span>,<span class="literal">T</span>-&gt;data); </span><br><span class="line">    PreOrderTraverse(<span class="literal">T</span>-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(<span class="literal">T</span>-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*二叉树的中序遍历递归算法*/</span><br><span class="line">void InOrderTraverse(BiTree <span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(<span class="literal">T</span>-&gt;lchild);</span><br><span class="line">    printf(<span class="string">"c%"</span>,<span class="literal">T</span>-&gt;data); </span><br><span class="line">    InOrderTraverse(<span class="literal">T</span>-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*二叉树的后序遍历递归算法*/</span><br><span class="line">void PostOrderTraverse(BiTree <span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(<span class="literal">T</span>-&gt;lchild);</span><br><span class="line">    PostOrderTraverse(<span class="literal">T</span>-&gt;rchild);</span><br><span class="line">    printf(<span class="string">"c%"</span>,<span class="literal">T</span>-&gt;data); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>层序遍历</p>
</li>
</ol>
<ul>
<li>推导遍历结果</li>
</ul>
<ol>
<li>已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，求这棵二叉树的后序遍历结果?<blockquote>
<p>CBEFDA</p>
</blockquote>
</li>
<li>已知一棵二叉树的中序序列是ABCDEFG，后序序列是BDCAFGE,求前序序列?<blockquote>
<p>EACBDGF 重要</p>
</blockquote>
</li>
</ol>
<p>从这里我们可以得到两个二叉树遍历的性质</p>
<ol>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树<blockquote>
<p>已知前序和后序遍历，是不能确定一棵二叉树的，例如已知前序序列ABC和后序序列CBA，我们可以确定A一定是根节点，但接下来我们无法知道哪个结点是左结点和右结点，所以有4种情况</p>
</blockquote>
</li>
</ol>
<hr>
<h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><ul>
<li>利用扩展二叉树，比如假设二叉树的结点均为一个字符，我们把刚才前序遍历序列AB#D##C##用键盘挨个输入<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/*按前序输入二叉树中结点的值(一个字符)*/</span></span><br><span class="line"><span class="regexp">/* #表示空树，构造二叉链表示二叉树T */</span></span><br><span class="line">void CreateBiTree(BiTree *T)</span><br><span class="line">&#123;</span><br><span class="line">    TElemType ch;</span><br><span class="line">    scanf(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'#'</span>)</span><br><span class="line">        *T=NULL;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T=(BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        <span class="keyword">if</span>(!*T)</span><br><span class="line">            <span class="keyword">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;data=ch; <span class="regexp">/*生成根节点*/</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild); <span class="regexp">/*构造左子树*/</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild); <span class="regexp">/*构造右子树*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>其实建立二叉树，也是利用了递归的原理，只不过在原来应该打印结点的地方改成了生成结点，给结点赋值的操作而已，所以如果换成中序和后序遍历的方式，只要调整一下生成结点和构造左右子树的代码顺序即可</p>
</blockquote>
<hr>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><blockquote>
<p>我们考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址</p>
<ul>
<li>我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)</li>
<li>对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化，我们将这棵二叉树中所有空指针域中的lchild改为指向当前结点的前驱，rchild改为指向当前结点的后继<br>但是问题没有彻底解决，我们如何知道某一结点的lchild是指它的左孩子还是指向前驱？rchild是指向右孩子还是指向后继？<blockquote>
<p>这里我们引入两个标志域ltag和rtag，注意ltag和rtag只是存放0或1数字的布尔型变量</p>
<blockquote>
<p>tag为0时指向结点的孩子，为1时指向该结点的前驱/后继</p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<hr>
<h4 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉线索存储结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Link,Thread&#125; PointerTag;  <span class="comment">/*Link == 0表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>  /*二叉线索存储结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;  <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">/*左右孩子指针*/</span></span><br><span class="line">    PointerTag LTag;</span><br><span class="line">    PointerTag RTag;</span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索，由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。</p>
</blockquote>
<p>中序遍历线索化的递归函数代码如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre;  <span class="comment">/*全局变量，始终指向刚刚访问过的结点*/</span></span><br><span class="line"><span class="comment">/*中序遍历进行中序线索化*/</span></span><br><span class="line">void InThreading(BiThrTree p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>lchild);  <span class="comment">/*递归左子树线索化*/</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(!p-&gt;</span>lchild)  <span class="comment">/*没有左孩子*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>LTag=Thread;  <span class="comment">/*前驱线索*/</span></span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>lchild=pre;  <span class="comment">/*左孩子指针指向前驱*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!pre-&gt;</span>rchild)  <span class="comment">/*前驱没有右孩子*/</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>Tag=Thread;  <span class="comment">/*后继线索*/</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rchild=p;   <span class="comment">/*前驱右孩子指针指向后继(当前结点p)*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre=p;  <span class="comment">/*保持pre指向p的前驱*/</span></span><br><span class="line">    I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>rchild);  <span class="comment">/*递归右子树线索化*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这段代码和二叉树中序遍历的递归代码几乎一样，只不过是将打印结点的功能改成了线索化的功能</p>
<blockquote>
<p>有了线索二叉树后，我们对它进行遍历时发现，其实就等于操作一个双向链表结构</p>
</blockquote>
</blockquote>
<p>遍历的代码如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*T指向头结点，头结点左链lchild指向根节点，头结点右链rchild指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T*/</span></span><br><span class="line">Status InOrderTraverse_Thr(BiThrTree T)</span><br><span class="line">&#123;</span><br><span class="line">    BiThrTree p;</span><br><span class="line">    <span class="function"><span class="title">p</span> = T-&gt;</span>lchild;  <span class="comment">/*p指向根节点*/</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)  <span class="comment">/*空树或遍历结束时，p==T*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>LTag==Link)  <span class="comment">/*当LTag==0时循环到中序序列第一个结点*/</span></span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>lchild；</span><br><span class="line">        <span class="function"><span class="title">printf</span>("c%",p-&gt;</span><span class="keyword">data</span>);  <span class="comment">/*显示结点数据，可以更改为其他对结点操作*/</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>RT<span class="function"><span class="title">ag</span>==Thread &amp;&amp; p-&gt;</span>rchild! =T)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;</span><br><span class="line">            <span class="function"><span class="title">printf</span>("%c",p-&gt;</span><span class="keyword">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;  <span class="comment">/*p进至其右子树根*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择.</li>
</ul>
<hr>
<h4 id="树，森林与二叉树的转换"><a href="#树，森林与二叉树的转换" class="headerlink" title="树，森林与二叉树的转换"></a>树，森林与二叉树的转换</h4><ul>
<li>转换</li>
<li>树与森林的遍历</li>
</ul>
<p>树的遍历分为两种形式</p>
<ol>
<li>先根遍历</li>
<li>后根遍历</li>
</ol>
<p>森林的遍历也分两种</p>
<ol>
<li>前序遍历</li>
<li>后序遍历<blockquote>
<p>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同</p>
</blockquote>
</li>
</ol>
<hr>
<h4 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h4><ul>
<li>赫夫曼树定义及原理</li>
</ul>
<ol>
<li>从树中的一个结点到另一个结点之间的分支构成的两个结点之间的路径，路径上的分支数目称为路径长度</li>
<li>树的路径长度就是从树根到每个结点的路径长度之和。</li>
<li>其中带权路径长度WPL最小的二叉树称为赫夫曼树，也称为最优二叉树.</li>
</ol>
<ul>
<li>赫夫曼编码</li>
<li>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码</li>
</ul>
<blockquote>
<p>线索二叉树记得回顾理解一下</p>
</blockquote>
<hr>


      
    </div>

    <div>
      
        

      
    </div>
  
        <div class="post-tags">
          
            <a href="/tags/树/" rel="tag"><i class="fa fa-tag"></i> 树</a>
          
        </div>
      


    <div>
      
        ﻿
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>🐶 您的支持将鼓励我继续创作 🐶</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赞赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward-img.jpg" alt="林加鸿 WeChat Pay">
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward-img.jpg" alt="林加鸿 Alipay">
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
        
     <div>    
      
      <ul class="post-copyright">
         <li class="post-copyright-link">
          <strong>本文作者：</strong>
          <a href="/" title="欢迎访问 林加鸿 的个人博客">林加鸿</a>
        </li>

        <li class="post-copyright-link">
          <strong>本文标题：</strong>
          <a href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04.html" title="数据结构-树">数据结构-树</a>
        </li>

        <li class="post-copyright-link">
          <strong>本文链接：</strong>
          <a href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04.html" title="数据结构-树">http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04.html</a>
        </li>

        <li class="post-copyright-date">
            <strong>发布时间：</strong>2019年5月11日 - 01时05分
        </li>  

        <li class="post-copyright-license">
          <strong>版权声明： </strong>
          本文由 林加鸿 原创，采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="license" target="_blank">保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a> 
        </li>
      </ul>
    
  </div>  
      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/DataStructure/2019/05/11/DataStructure-03.html" rel="next" title="数据结构-串">
                <i class="fa fa-chevron-left"></i> 数据结构-串
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/DataStructure/2019/05/11/DataStructure-05.html" rel="prev" title="数据结构-图">
                数据结构-图 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NDE0Mi8yMDY3Ng=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
 <a href="/">
          <img class="site-author-image" itemprop="image" src="/images/Abo.gif" alt="林加鸿">
</a>
          <p class="site-author-name" itemprop="name">林加鸿</p>
          <p class="site-description motion-element" itemprop="description">阿波的个人博客，主要涉及到编程（Java，Python，Linux等），个人提升学习，图文算法分享，记书写读书笔记为主</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jhjhljh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jhjhljh" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/jhjhljh" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-battery-3"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.woaitqs.cc/" title="Qisen Tang" target="_blank">Qisen Tang</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://jhjhljh.github.io/" title="jhjhljh的博客" target="_blank">jhjhljh的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://python.zhangwei.website" title="JuniorCoder" target="_blank">JuniorCoder</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hippo-jessy.com" title="Hippo" target="_blank">Hippo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.zhihu.com/people/lippi-ouyang" title="友链出租" target="_blank">友链出租</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://music.163.com/" title="网易云音乐" target="_blank">网易云音乐</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#结点分类"><span class="nav-number">1.1.</span> <span class="nav-text">结点分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#结点间关系"><span class="nav-number">1.2.</span> <span class="nav-text">结点间关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的其他相关概念"><span class="nav-number">1.3.</span> <span class="nav-text">树的其他相关概念</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树的抽象数据类型"><span class="nav-number">2.</span> <span class="nav-text">树的抽象数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树的存储结构"><span class="nav-number">3.</span> <span class="nav-text">树的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树"><span class="nav-number">4.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的存储结构"><span class="nav-number">5.</span> <span class="nav-text">二叉树的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历二叉树"><span class="nav-number">6.</span> <span class="nav-text">遍历二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的建立"><span class="nav-number">7.</span> <span class="nav-text">二叉树的建立</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线索二叉树"><span class="nav-number">8.</span> <span class="nav-text">线索二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线索二叉树结构实现"><span class="nav-number">9.</span> <span class="nav-text">线索二叉树结构实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树，森林与二叉树的转换"><span class="nav-number">10.</span> <span class="nav-text">树，森林与二叉树的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#赫夫曼树及其应用"><span class="nav-number">11.</span> <span class="nav-text">赫夫曼树及其应用</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林加鸿</span>
</div>






        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  



  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  


  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("W0twhOKHT901IOCEADaiuynP-gzGzoHsz", "zQfRdGCiWzVvsSpXKOJsbvHe");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

	<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<script type="text/javascript" color="255,0,204" opacity="0.5" zindex="-2" count="80" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":150,"height":150,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>
</html>
