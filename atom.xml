<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abo</title>
  
  <subtitle>阿波同学</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jhjhljh.github.io/"/>
  <updated>2019-05-12T16:11:32.287Z</updated>
  <id>http://jhjhljh.github.io/</id>
  
  <author>
    <name>林加鸿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈回家安顿的一周</title>
    <link href="http://jhjhljh.github.io/%E5%90%B9%E6%B0%B4/2019/05/11/bbforfun.html"/>
    <id>http://jhjhljh.github.io/吹水/2019/05/11/bbforfun.html</id>
    <published>2019-05-11T15:54:32.000Z</published>
    <updated>2019-05-12T16:11:32.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">既然生活多有不堪，那就更应花费时间在自己喜欢的事情上面，随之拥抱生活</p><p><img src="/吹水/2019/05/11/bbforfun/ipe-yellow-1741843_1280.jpg" alt="ipe-yellow-1741843_1280"></p><a id="more"></a><blockquote class="question">“其实孤独并不可怕，只要你学会了自己与自己对话。”</blockquote>        <div id="aplayer-BCfqvkRl" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-BCfqvkRl"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "长子",              author: "杨坤",              url: "http://prc4nro7n.bkt.clouddn.com/%E9%95%BF%E5%AD%90.mp3",              pic: "http://prc4nro7n.bkt.clouddn.com/ykun.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h2 id="花费三天时间搭建自己的博客"><a href="#花费三天时间搭建自己的博客" class="headerlink" title="花费三天时间搭建自己的博客"></a>花费三天时间搭建自己的博客</h2><p>曾经自己老是觉得也感叹自己对于编程类学习的无力感，这种感觉不知道什么时候飘离了自己，但是有个朋友说到心坎上了：<u>“做自己喜欢的事情，从而带动兴趣，挖掘自己的潜能”</u>，这几天脱离了学习的功课，而去尝试全心投入于搭建博客，这是之前自己一直想做却又不敢去做的事情。事实证明，我做到了，在参考hexo的next主题，而且也“云拜访”各家博主的博客，最终找到了自己希望的风格，一直不喜欢文章的我，在搭建完博客完，居然会沉迷于写文，像是现在也不想停手，然而明天就要离去前往大学继续上课了~╯︿╰</p><h2 id="关于概率论这位大叔"><a href="#关于概率论这位大叔" class="headerlink" title="关于概率论这位大叔"></a>关于概率论这位<del>大叔</del></h2><p>哇，谁能想到，假期刚结束的周末就要开始概率论考试了，接下来要回去好好刷题练习了，争取<strong>&gt;=90</strong>,然后再继续研究完成easySale的项目吧，希望能够从这个项目找到自己的<strong>属性</strong>。</p><h2 id="拥抱生活吧"><a href="#拥抱生活吧" class="headerlink" title="拥抱生活吧"></a>拥抱生活吧</h2><p>愿你即使生活在泥泞之中，也不要放弃仰望星空，有一天，你将如浩瀚星河，在平凡的生活里发出最耀眼的光。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;既然生活多有不堪，那就更应花费时间在自己喜欢的事情上面，随之拥抱生活&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/吹水/2019/05/11/bbforfun/ipe-yellow-1741843_1280.jpg&quot; alt=&quot;ipe-yellow-1741843_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="吹水" scheme="http://jhjhljh.github.io/categories/%E5%90%B9%E6%B0%B4/"/>
    
    
      <category term="心得" scheme="http://jhjhljh.github.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构课程设计-平衡二叉树</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructureAssign.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructureAssign.html</id>
    <published>2019-05-11T13:09:56.000Z</published>
    <updated>2019-05-11T15:44:28.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">当年的数据结构课程设计-平衡二叉树，想了想还是放上来吧，当初费尽心思，怕是如今都已看不懂了இ௰இ</p><p><img src="/DataStructure/2019/05/11/DataStructureAssign/write-593333_1280.jpg" alt="write-593333_1280"></p><a id="more"></a><blockquote class="question">“那片笑声让我想起我的那些花儿，在我生命每个角落静静为我开着~”</blockquote>        <div id="aplayer-mzdIcNbn" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-mzdIcNbn"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "那些花儿",              author: "吴青峰",              url: "http://prc4nro7n.bkt.clouddn.com/%E9%82%A3%E4%BA%9B%E8%8A%B1%E5%84%BF+%E6%9C%9B%E6%98%A5%E9%A3%8E.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>“平衡二叉树操作演示”系统是利用平衡二叉树实现一个动态查找表的三种基本功能：查找、插入和删除，同时，还能拓展实现新的功能：初始化、求深度、求最大最小结点、先中后序及层序遍历、打印平衡二叉树、判空、合并和分裂平衡二叉树等功能，并通过括号表示方法和凹入表表示方法将动态查找表和平衡二叉树的详细信息展示给用户知晓；同时，还要求系统界面设计简洁明了、用户操作简单方便，提高系统实用性与运行效率。</p><p>说明：使用anyview或者codeblock运行；输入值形式是数字，无论对功能的选则还是对数据的录入，都是以数字的形式进行输入，如若超过规定范围程序将直接结束。</p><h2 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h2><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>Status InitBBST(BBSTree &amp;T)</p><p>  初始化平衡二叉树</p><p> void DestroyBBSTree(BBSTree &amp;T)</p><p> 销毁平衡二叉树</p><p>Status BBSTreeEmpty(BBSTree T)</p><p> 判空平衡二叉树</p><p>void PrintTree(BBSTree &amp;T)</p><p>打印平衡二叉树</p><p>void CreateBBST(BBSTree &amp;T)</p><p>输入结点数目，动态创建一棵平衡二叉树</p><p>Status InsertAVL(BBSTree &amp;T, RcdType e, Status &amp;taller)</p><p>平衡二叉树的插入操作，将e插入到T中</p><p>插入成功返回TRUE，失败返回FALSE</p><p>Status DeleteAVL(BBSTree &amp;t, RcdType e, Status &amp;shorter) </p><p>平衡二叉树的删除操作，将e从T中删除</p><p>删除成功返回TRUE，失败返回FALSE</p><p>void L_Rotate(BBSTree &amp;p)</p><p>对p左旋操作</p><p>void R_Rotate(BBSTree &amp;p)</p><p>对p右旋操作</p><p>void LeftBalance(BBSTree &amp;T)</p><p>对T左平衡操作</p><p>void RightBalance(BBSTree &amp;T)</p><p>对T右平衡操作</p><p>Status PreOrder(BBSTree T)</p><p>递归先序遍历输出</p><p>Status InOrder(BBSTree T)</p><p>递归中序遍历输出</p><p>Status PostOrder(BBSTree T)</p><p>递归后序遍历输出</p><p>void PreOrderTravese_I(BBSTree T)</p><p>非递归先序遍历输出</p><p>void InOrderTraverse_I(BBSTree T)</p><p>非递归中序遍历输出</p><p>void LastOrderTravese_I(BBSTree T)</p><p>非递归后序遍历输出</p><p>void LevelOrederTraverse_Print(BBSTree T)</p><p>层次遍历输出</p><p>BBSTree SearchBBST(BBSTree T,RcdType key)</p><p>二叉平衡树查找的递归实现</p><p>BBSTree SearchBBST_I(BBSTree T,RcdType e)</p><p>二叉平衡树查找的非递归实现</p><p>BBSTree FindMin(BBSTree T)</p><p>寻找平衡二叉树最小元素所在结点地址</p><p>BBSTree FindMax(BBSTree T)</p><p>寻找平衡二叉树最大元素所在结点地址</p><p>int BBSTreeDepth(BBSTree T)</p><p>求平衡二叉树的深度</p><p>void MergeBBST(BBSTree &amp;T1, BBSTree T2)</p><p>合并两棵平衡二叉树</p><p>void SpiltBBST(BBSTree T, RcdType key, BBSTree &amp;T1, BBSTree &amp;T2)</p><p>按关键值key分裂T成两棵二叉树</p><h4 id="主程序与各接口函数的调用"><a href="#主程序与各接口函数的调用" class="headerlink" title="主程序与各接口函数的调用"></a>主程序与各接口函数的调用</h4><p>int main(){</p><p>​    BBSTree T = NULL;</p><p>​    int choice;</p><p>​    printf(“================================================\n”);</p><p>​    printf(“<strong><strong><strong><strong>*</strong></strong></strong></strong>平衡二叉树<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>\n”);</p><p>​    printf(“================================================\n”);</p><p>​    printf(“        1：创建一棵平衡二叉树\n”);</p><p>​    printf(“        2：平衡二叉树的插入\n”);</p><p>​    printf(“        3：平衡二叉树的删除\n”);</p><p>​    printf(“        4：平衡二叉树的查找\n”);</p><p>​    printf(“        5：平衡二叉树的遍历\n”);</p><p>​    printf(“        6：求平衡二叉树的深度\n”);</p><p>​    printf(“        7：合并平衡二叉树\n”);</p><p>​    printf(“        8：分裂平衡二叉树\n”);</p><p>​    printf(“   请根据上述说明选择所需操作1-8: “);</p><p>​    scanf(“%d”,&amp;choice);</p><p>​    while(choice &gt; 0 &amp;&amp; choice &lt;= 3)</p><p>​    {</p><p>​    if(choice == 1)</p><p>​    {</p><p>​        if(OK == InitBBST(T));</p><p>​            CreateBBST(T);</p><p>​        printf(“平衡二叉树表示为：\n”);</p><p>​        PrintTree(T,0);</p><p>​        printf(“\n”);</p><p>​        PrintTree1(T);</p><p>​        printf(“\n请重新输入你的选择: “);</p><p>​        scanf(“%d”,&amp;choice);</p><p>​    }</p><p>​    if(choice == 2)</p><p>​    {</p><p>​        int num;</p><p>​        RcdType s;</p><p>​        Status taller = TRUE;</p><p>​        printf(“请输入要插入的元素：”);</p><p>​        scanf(“%d”,&amp;num);</p><p>​        s = num;</p><p>​        InsertAVL(T,s,taller);</p><p>​        printf(“平衡二叉树表示为：\n”);</p><p>​        PrintTree(T,0);</p><p>​        PrintTree1(T);</p><p>​        printf(“\n请重新输入你的选择: “);</p><p>​        scanf(“%d”,&amp;choice);</p><p>​    }</p><p>​    if(choice == 3){</p><p>​        RcdType e;</p><p>​        Status shorter = TRUE;</p><p>​        printf(“请输入要删除的元素：”);</p><p>​        scanf(“%d”,&amp;e);</p><p>​        DeleteAVL(T, e, shorter);</p><p>​        printf(“平衡二叉树表示为：\n”);</p><p>​        PrintTree(T,0);</p><p>​        PrintTree1(T);</p><p>​        printf(“\n请重新输入你的选择: “);</p><p>​        scanf(“%d”,&amp;choice);</p><p>​    }</p><p>​    }</p><p>​    if(choice == 4){</p><p>​        int choice2;</p><p>​        printf(“40:递归查找\n41:非递归查找\n”);</p><p>​        printf(“42:查找最小元素\n43:查找最大元素\n”);</p><p>​        printf(“请选择一种查找方式：”);</p><p>​        scanf(“%d”,&amp;choice2);</p><p>​        switch(choice2){</p><p>​            case 40:</p><p>​            int key1;</p><p>​            printf(“\n请输入欲查找元素：”);</p><p>​            scanf(“%d”,&amp;key1);</p><p>​            if(NULL != SearchBBST(T,key1))</p><p>​                printf(“\n查找成功”);</p><p>​            else</p><p>​                printf(“\n查找失败”);</p><p>​            break;</p><p>​            case 41:</p><p>​            int key2;</p><p>​            printf(“\n请输入欲查找元素：”);</p><p>​            scanf(“%d”,&amp;key2);</p><p>​            if(NULL != SearchBBST_I(T,key2))</p><p>​                printf(“\n查找成功”);</p><p>​            else</p><p>​                printf(“\n查找失败”);</p><p>​            break;</p><p>​            case 42:</p><p>​            BBSTree T1 = FindMin(T);</p><p>​            if(T1)</p><p>​                printf(“\n查找成功，且为%d”,T1-&gt;data);</p><p>​            break;</p><p>​    //        case 43:</p><p>​            BBSTree T2 = FindMax(T);</p><p>​            if(T2)</p><p>​                printf(“\n查找成功，且为%d”,T2-&gt;data);</p><p>​            break;</p><p>​        }</p><p>​    }</p><p>​    if(choice == 5){</p><p>​        int choice2;</p><p>​        printf(“50:递归先序\n51:递归中序\n52:递归后序\n”);</p><p>​        printf(“53:非递归先序\n54:非递归中序\n55:非递归后序\n56:层次遍历\n”);</p><p>​        printf(“请选择一种遍历方式：”);</p><p>​        scanf(“%d”,&amp;choice2);</p><p>​        switch(choice2){</p><p>​            case 50:</p><p>​            printf(“\n递归先序遍历输出：”);</p><p>​            PreOrder(T); break;</p><p>​            case 51:</p><p>​            printf(“\n递归中序遍历输出：”);</p><p>​            InOrder(T);  break;</p><p>​            case 52:</p><p>​            printf(“\n递归后序遍历输出：”);</p><p>​            PostOrder(T);break;</p><p>​            case 53:</p><p>​            printf(“\n非递归先序遍历输出：”);</p><p>​            PreOrderTravese_I(T);break;</p><p>​            case 54:</p><p>​            printf(“\n非递归中序遍历输出：”);</p><p>​            InOrderTraverse_I(T);  break;</p><p>​            case 55:</p><p>​            printf(“\n非递归后序遍历输出：”);</p><p>​            LastOrderTravese_I(T);</p><p>​            printf(“\n”);  break;</p><p>​            case 56:</p><p>​            printf(“\n层次遍历输出：”);</p><p>​            LevelOrederTraverse_Print(T);</p><p>​            printf(“\n”);  break;</p><p>​        }</p><p>​    }</p><p>​    if(choice == 6)</p><p>​    {</p><p>​        printf(“深度为：%d\n”,BBSTreeDepth(T));</p><p>​    }</p><p>​    if(choice == 7)</p><p>​    {</p><p>​        BBSTree T1,T2,T3;</p><p>​        if(OK == (InitBBST(T1))&amp;&amp;(InitBBST(T2))&amp;&amp;(InitBBST(T)))</p><p>​        {</p><p>​            printf(“请构造第一棵子树\n”);</p><p>​            CreateBBST(T1);</p><p>​            printf(“平衡二叉树表示为：\n”);</p><p>​            PrintTree(T1,0);</p><p>​            PrintTree1(T1);</p><p>​            printf(“\n”);</p><p>​            printf(“请构造第二棵子树\n”);</p><p>​            CreateBBST(T2);</p><p>​            printf(“平衡二叉树表示为：\n”);</p><p>​            PrintTree(T2,0);</p><p>​            PrintTree1(T2);</p><p>​            printf(“\n”);</p><p>​            printf(“合并后为：”);</p><p>​            MergeBBST(T,T1);</p><p>​            MergeBBST(T,T2);</p><p>​            printf(“平衡二叉树表示为：\n”);</p><p>​            PrintTree(T,0);</p><p>​            PrintTree1(T);</p><p>​        }</p><p>​    }</p><p>​    if(choice == 8)</p><p>​    {</p><p>​        BBSTree T1,T2;</p><p>​        if(OK == (InitBBST(T1))&amp;&amp;(InitBBST(T2)))</p><p>​        {</p><p>​            int x;</p><p>​            printf(“请输入要分裂时作为参照的关键字：”);</p><p>​            scanf(“%d”,&amp;x);</p><p>​            SpiltBBST(T,x,T1,T2);</p><p>​            printf(“分裂后的第一棵树为：”);</p><p>​            printf(“平衡二叉树表示为：\n”);</p><p>​            PrintTree(T1,0);</p><p>​            PrintTree1(T1);</p><p>​            printf(“\n”);</p><p>​            printf(“分裂后的第二棵树为：”);</p><p>​            printf(“平衡二叉树表示为：\n”);</p><p>​            PrintTree(T2,0);</p><p>​            PrintTree1(T2);</p><p>​        }</p><p>​    }</p><p>}</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2> <blockquote class="question">以下高能代码段，慎看吧(╯‵□′)╯炸弹！•••*～●</blockquote><h3 id="重要变量和存储结构定义"><a href="#重要变量和存储结构定义" class="headerlink" title="重要变量和存储结构定义"></a>重要变量和存储结构定义</h3><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>#define LH +1  //左高</p><p>#define EH 0   //等高</p><p>#define RH -1  //右高</p><p>#define FALSE 0</p><p>#define TRUE 1</p><p>#define OK 1</p><p>#define ERROR 0</p><p>#define OVERFLOW -1</p><p>typedef int Status;</p><p>typedef int RcdType;</p><p>/<em>平衡二叉树结构体</em>/</p><p>typedef struct BBSTNode {</p><p>​    RcdType data;</p><p>​    int bf;</p><p>​    struct BBSTNode <em>lchild, </em>rchild;</p><p>}*BBSTree;</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a><strong>算法设计</strong></h3><h4 id="初始化平衡二叉树"><a href="#初始化平衡二叉树" class="headerlink" title="/初始化平衡二叉树/"></a>/<em>初始化平衡二叉树</em>/</h4><p>Status InitBBST(BBSTree &amp;T){</p><p>​    T = NULL;</p><p>​    return OK;</p><p>}</p><h4 id="销毁平衡二叉树"><a href="#销毁平衡二叉树" class="headerlink" title="/销毁平衡二叉树/"></a>/<em>销毁平衡二叉树</em>/</h4><p>void DestroyBBSTree(BBSTree &amp;T){</p><p>​    if(T != NULL){</p><p>​        DestroyBBSTree(T -&gt; lchild);</p><p>​        DestroyBBSTree(T -&gt; rchild);</p><p>​        free(T);</p><p>​        T = NULL;</p><p>​    }</p><p>}</p><h4 id="判空平衡二叉树"><a href="#判空平衡二叉树" class="headerlink" title="/判空平衡二叉树/"></a>/<em>判空平衡二叉树</em>/</h4><p>Status BBSTreeEmpty(BBSTree T){</p><p>​    if(!T){</p><p>​        return TRUE;</p><p>​    }</p><p>​    else{</p><p>​        return FALSE;</p><p>​    }</p><p>}</p><h4 id="创建一棵平衡二叉树"><a href="#创建一棵平衡二叉树" class="headerlink" title="/创建一棵平衡二叉树/"></a>/<em>创建一棵平衡二叉树</em>/</h4><p>void CreateBBST(BBSTree &amp;T)</p><p>{</p><p>​    RcdType e;</p><p>​    int num;</p><p>​    Status taller = TRUE;</p><p>​    printf(“\n请输入平衡二叉树的结点个数:”);</p><p>​    scanf(“%d”, &amp;num);</p><p>​    getchar();</p><p>​    printf(“请顺序输入元素(按’回车键’结束):”);</p><p>​    for (int i = 0; i &lt; num; i++) {</p><p>​        scanf(“%d”, &amp;e);</p><p>​        InsertAVL(T, e, taller);</p><p>​    }</p><p>}</p><h4 id="输出平衡二叉树"><a href="#输出平衡二叉树" class="headerlink" title="/输出平衡二叉树/"></a>/<em>输出平衡二叉树</em>/</h4><p>void PrintTree(BBSTree T, int nLayer){</p><p>​    if(T == NULL) {</p><p>​        return;</p><p>​    }</p><p>​    PrintTree(T-&gt;rchild, nLayer + 4);</p><p>​    for(int i = 0; i &lt; nLayer; i++) {</p><p>​        printf(“ “);</p><p>​    }</p><p>​    printf(“%d\n”, T-&gt;data);</p><p>​    PrintTree(T-&gt;lchild, nLayer + 4);</p><p>}</p><h4 id="输出平衡二叉树-1"><a href="#输出平衡二叉树-1" class="headerlink" title="/输出平衡二叉树/"></a>/<em>输出平衡二叉树</em>/</h4><p>void PrintTree1(BBSTree &amp;T)</p><p>{</p><p>​    if(T)</p><p>​    {</p><p>​        printf(“%d”,T-&gt;data);</p><p>​        if(T-&gt;lchild || T-&gt;rchild)</p><p>​        {</p><p>​            printf(“(“);</p><p>​            PrintTree1(T-&gt;lchild);</p><p>​            if(T-&gt;rchild)</p><p>​                printf(“,”);</p><p>​            PrintTree1(T-&gt;rchild);</p><p>​            printf(“)”);</p><p>​        }</p><p>​    }</p><p>}</p><h4 id="平衡二叉树的插入操作"><a href="#平衡二叉树的插入操作" class="headerlink" title="/平衡二叉树的插入操作/"></a>/<em>平衡二叉树的插入操作</em>/</h4><p>/若平衡二叉树中不存在值为e的结点，则插入到T/</p><p>Status InsertAVL(BBSTree &amp;T, RcdType e, Status &amp;taller){</p><p>​    if(NULL==T){</p><p>​        T = (BBSTree)malloc(sizeof(BBSTNode));</p><p>​        T-&gt;data = e;</p><p>​        T-&gt;bf = EH; </p><p>​        T-&gt;lchild = NULL; </p><p>​        T-&gt;rchild = NULL;</p><p>​    }else if(e==T-&gt;data){ //书中已存在和e相等的结点 </p><p>​        taller = FALSE; return FALSE;        </p><p>​    }else if(e<t->data){</t-></p><p>​        if(FALSE==InsertAVL(T-&gt;lchild, e, taller)) return FALSE;</p><p>​        if(TRUE==taller){</p><p>​            switch(T-&gt;bf){</p><p>​                case LH: LeftBalance(T); taller = FALSE; break;</p><p>​                case EH: T-&gt;bf = LH; taller = TRUE; break;</p><p>​                case RH: T-&gt;bf = EH; taller = FALSE; break;</p><p>​            }</p><p>​        }</p><p>​    }else{</p><p>​        if(FALSE==InsertAVL(T-&gt;rchild, e, taller)) return FALSE;</p><p>​        if(TRUE==taller){</p><p>​            switch(T-&gt;bf){</p><p>​                case LH: T-&gt;bf = EH; taller = FALSE; break;</p><p>​                case EH: T-&gt;bf = RH; taller = TRUE; break;</p><p>​                case RH: RightBalance(T); taller = FALSE; break;</p><p>​            }</p><p>​        }</p><p>​    }</p><p>​    return TRUE;</p><p>}</p><h4 id="左旋调整（右旋与之类似，不再列出）"><a href="#左旋调整（右旋与之类似，不再列出）" class="headerlink" title="/左旋调整（右旋与之类似，不再列出）/"></a>/<em>左旋调整（右旋与之类似，不再列出）</em>/</h4><p>void L_Rotate(BBSTree &amp;p) {</p><p>​    BBSTree rc = p -&gt; rchild;</p><p>​    p -&gt; rchild = rc -&gt; lchild;</p><p>​    rc -&gt; lchild = p;</p><p>​    p = rc;</p><p>}</p><h4 id="左平衡处理操作（右平衡与之类似，不再列出）"><a href="#左平衡处理操作（右平衡与之类似，不再列出）" class="headerlink" title="/左平衡处理操作（右平衡与之类似，不再列出）/"></a>/<em>左平衡处理操作（右平衡与之类似，不再列出）</em>/</h4><p>void LeftBalance(BBSTree &amp;T){</p><p>​    BBSTree lc, rd;</p><p>​    lc = T-&gt;lchild;</p><p>​    switch(lc-&gt;bf){</p><p>​        case LH:</p><p>​            T-&gt;bf = lc-&gt;bf = EH; R_Rotate(T); break;</p><p>​        case RH:</p><p>​            rd = lc-&gt;rchild;</p><p>​            switch(rd-&gt;bf){</p><p>​                case LH: T-&gt;bf = RH; lc-&gt;bf = EH; break;</p><p>​                case EH: T-&gt;bf = lc-&gt;bf = EH; break;</p><p>​                case RH: T-&gt;bf = EH; lc-&gt;bf = LH; break;</p><p>​            }</p><p>​            rd-&gt;bf = EH;</p><p>​            L_Rotate(T-&gt;lchild);</p><p>​            R_Rotate(T);</p><p>​            break;</p><p>​    }</p><p>}</p><h4 id="平衡二叉树的删除操作"><a href="#平衡二叉树的删除操作" class="headerlink" title="/平衡二叉树的删除操作/"></a>/<em>平衡二叉树的删除操作/</em></h4><h4 id="平衡二叉树中存在值为key的结点，则删除"><a href="#平衡二叉树中存在值为key的结点，则删除" class="headerlink" title="/平衡二叉树中存在值为key的结点，则删除/"></a>/<em>平衡二叉树中存在值为key的结点，则删除</em>/</h4><p>Status DeleteAVL(BBSTree &amp;T, RcdType e, Status &amp;shorter){</p><p> //当被删结点是有两个孩子，且其前驱结点是左孩子时，tag=1</p><p>​    int tag = 0;</p><p>​    if(T == NULL){</p><p>​        return FALSE;    //如果不存在元素，返回失败</p><p>​    }else if(e==T-&gt;data){</p><p>​        BBSTNode *q = NULL;</p><p>​        //如果该结点只有一个孩子，则将自子树取代该结点</p><p>​        if(T-&gt;lchild == NULL){</p><p>​            q = T;</p><p>​            T = T-&gt;rchild;</p><p>​            free(q);</p><p>​            shorter = TRUE;</p><p>​        }</p><p>​        else if(T-&gt;rchild == NULL){</p><p>​            q = T;</p><p>​            T = T-&gt;lchild;</p><p>​            free(q);</p><p>​            shorter = TRUE;</p><p>​        }</p><p>​        //如果被删结点有两个孩子，则找到结点的前驱结点，</p><p>​        //并将前驱结点的值赋给该结点，然后删除前驱结点</p><p>​        else{</p><p>​            q = T-&gt;lchild;</p><p>​            while(q-&gt;rchild){</p><p>​                q = q-&gt;rchild;</p><p>​            }</p><p>​            T-&gt;data = q-&gt;data;</p><p>​            if(T-&gt;lchild-&gt;data==q-&gt;data){</p><p>​                tag = 1;</p><p>​            }</p><p>​            DeleteAVL(T-&gt;lchild, q-&gt;data, shorter);</p><p>​            if(tag==1){</p><p>​                BBSTree r = T-&gt;rchild;</p><p>​                if(NULL==r) T-&gt;bf = 0;</p><p>​                else{</p><p>​                    switch(r-&gt;bf){</p><p>​                        case EH: T-&gt;bf=-1;break;</p><p>​                        default: RightBalance(T);break;</p><p>​                    }</p><p>​                }</p><p>​            }</p><p>​        }</p><p>​    }else if(e<t->data){        //左子树中继续查找</t-></p><p>​        if(!DeleteAVL(T-&gt;lchild, e, shorter)){</p><p>​            return FALSE;</p><p>​        }</p><p>​        //删除完结点之后，调整结点的平衡因子</p><p>​        if(shorter&amp;&amp;(tag==0))  {</p><p>​            switch(T-&gt;bf){</p><p>​                case LH:</p><p>​                    T-&gt;bf = EH;</p><p>​                    shorter = TRUE;</p><p>​                    break;</p><p>​                case EH:</p><p>​                    T-&gt;bf = RH;</p><p>​                    shorter = FALSE;</p><p>​                    break;</p><p>​                //如果本来就是右子树较高，删除之后就不平衡，需要做右平衡操作</p><p>​                case RH:</p><p>​                    RightBalance(T);    //右平衡处理</p><p>​                    if(T-&gt;rchild-&gt;bf == EH)</p><p>​                        shorter = FALSE;</p><p>​                    else</p><p>​                        shorter = TRUE;</p><p>​                    break;</p><p>​            }</p><p>​        }</p><p>​    }else if(e&gt;T-&gt;data){ //右子树中继续查找</p><p>​        if(!DeleteAVL(T-&gt;rchild, e, shorter)){</p><p>​            return FALSE;</p><p>​        }</p><p>​        //删除完结点之后，调整结点的平衡因子</p><p>​        if(shorter&amp;&amp;(tag==0))  {</p><p>​            switch(T-&gt;bf){</p><p>​                case LH:</p><p>​                    LeftBalance(T);     //左平衡处理</p><p>​                    if(T-&gt;lchild-&gt;bf == EH)</p><p>​                        shorter = FALSE;</p><p>​                    else</p><p>​                        shorter = TRUE;</p><p>​                    break;</p><p>​                case EH:</p><p>​                    T-&gt;bf = LH;</p><p>​                    shorter = FALSE;</p><p>​                    break;</p><p>​                case RH:</p><p>​                    T-&gt;bf = EH;</p><p>​                    shorter = TRUE;</p><p>​                    break;</p><p>​            }</p><p>​        }</p><p>​        if(tag==1){</p><p>​            int depthLeft = BBSTreeDepth(T-&gt;lchild);</p><p>​            int depthRight = BBSTreeDepth(T-&gt;rchild);</p><p>​            T-&gt;bf = depthLeft - depthRight;</p><p>​        }</p><p>​    }</p><p>​    return TRUE;</p><p>}</p><h4 id="二叉平衡树查找的递归实现"><a href="#二叉平衡树查找的递归实现" class="headerlink" title="/二叉平衡树查找的递归实现/"></a>/<em>二叉平衡树查找的递归实现/</em></h4><p>/<em>若平衡二叉树中存在值为key的结点，则返回该结点指针，否则返回NULL</em>/</p><p>BBSTree SearchBBST(BBSTree T,RcdType key) {</p><p>​    if(NULL == T)</p><p>​        return NULL;</p><p>​    if(T -&gt; data == key)</p><p>​        return T;</p><p>​    if(T -&gt; data &gt; key)</p><p>​        return SearchBBST(T -&gt; lchild,key);</p><p>​    return SearchBBST(T -&gt; rchild,key);</p><p>}</p><h4 id="二叉平衡树查找的非递归实现"><a href="#二叉平衡树查找的非递归实现" class="headerlink" title="/二叉平衡树查找的非递归实现/"></a>/<em>二叉平衡树查找的非递归实现/</em></h4><p>/若平衡二叉树中存在值为key的结点，则返回该结点指针，否则返回NULL*/</p><p>BBSTree SearchBBST_I(BBSTree T,RcdType e) {</p><p>​    while(T) {</p><p>​        if(e &lt; T -&gt; data)</p><p>​            T = T -&gt; lchild;</p><p>​        else if(e &gt; T -&gt; data)</p><p>​            T = T -&gt; rchild;</p><p>​        else</p><p>​            return T;</p><p>​    }</p><p>​    return NULL;</p><p>}</p><h4 id="寻找平衡二叉树最小元素所在结点地址（寻找最大元素类似不再列出）"><a href="#寻找平衡二叉树最小元素所在结点地址（寻找最大元素类似不再列出）" class="headerlink" title="/寻找平衡二叉树最小元素所在结点地址（寻找最大元素类似不再列出）/"></a>/<em>寻找平衡二叉树最小元素所在结点地址（寻找最大元素类似不再列出）</em>/</h4><p>BBSTree FindMin(BBSTree T){</p><p>​    if(T)</p><p>​        while(T -&gt; lchild)</p><p>​            T = T -&gt; lchild;</p><p>​    return T;</p><p>}</p><h4 id="递归先序遍历（中序、后序遍历类似不再列出）"><a href="#递归先序遍历（中序、后序遍历类似不再列出）" class="headerlink" title="/递归先序遍历（中序、后序遍历类似不再列出）/"></a>/<em>递归先序遍历（中序、后序遍历类似不再列出）</em>/</h4><p>Status PreOrder(BBSTree T){</p><p>​    if(T) {</p><p>​        printf(“%5d”,T-&gt;data);</p><p>​        PreOrder(T -&gt; lchild);</p><p>​        PreOrder(T -&gt; rchild);</p><p>​    }</p><p>​    return OK;</p><p>}</p><h4 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="/非递归中序遍历/"></a>/<em>非递归中序遍历</em>/</h4><p>void InOrderTraverse_I(BBSTree T){</p><p>​    LStack S;</p><p>​    InitStack_LS(S);</p><p>​    BBSTree p = NULL;</p><p>​    p = GoFarLeft(T, S);</p><p>​    while(p!=NULL){</p><p>​        printf(“%d “,p-&gt;data);</p><p>​        if(p-&gt;rchild!=NULL){</p><p>​            p = GoFarLeft(p-&gt;rchild, S);</p><p>​        }</p><p>​        else if(StackEmpty_LS(S)!=TRUE) Pop_LS(S, p);</p><p>​        else p = NULL;</p><p>​    }        </p><p>}</p><h4 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="/非递归先序遍历/"></a>/非递归先序遍历/</h4><p>void PreOrderTravese_I(BBSTree T){</p><p>​    LStack S;</p><p>​    InitStack_LS(S);</p><p>​    BBSTree p;</p><p>​    p = VisitFarLeft(T, S);       //先将左边的数据先序读取</p><p>​    while(p!=NULL){</p><p>​        if(p-&gt;rchild!=NULL)              //如果最左下结点的右子树不为空</p><p>​            p = VisitFarLeft(p-&gt;rchild, S);   //执行遍历该结点的左子树</p><p>​        else if(StackEmpty_LS(S)!=TRUE) Pop_LS(S,p);    //如果S不为空栈，出栈</p><p>​        else p = NULL;    //如果为空栈，p赋予空</p><p>​    }</p><p>}</p><h4 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="/非递归后序遍历/"></a>/<em>非递归后序遍历</em>/</h4><p>void LastOrderTravese_I(BBSTree root){</p><p>​    BBSTree p = root;</p><p>​    BBSTree stack[30];</p><p>​    int num=0;</p><p>​    BBSTree have_visited = NULL;</p><p>​    while(NULL!=p||num&gt;0){</p><p>​        while(NULL!=p){</p><p>​            stack[num++]=p;</p><p>​            p=p-&gt;lchild;        </p><p>​        }</p><p>​        p=stack[num-1];</p><p>​        if(NULL==p-&gt;rchild||have_visited==p-&gt;rchild){</p><p>​            printf(“%d  “,p-&gt;data);</p><p>​            num–;</p><p>​            have_visited=p;</p><p>​            p=NULL;</p><p>​        }</p><p>​        else{</p><p>​            p=p-&gt;rchild;</p><p>​        }</p><p>​    }</p><p>​    printf(“\n”);</p><p>}</p><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="/层次遍历/"></a>/<em>层次遍历</em>/</h4><p>void LevelOrederTraverse_Print(BBSTree T){ </p><p>​    if(T==NULL){</p><p>​        printf(“这是一棵空树!”);</p><p>​    }</p><p>​    if(T!=NULL){</p><p>​        LQueue Q;</p><p>​        InitQueue_LQ(Q);</p><p>​        BBSTree p = T;</p><p>​        printf(“%d “,p-&gt;data); EnQueue_LQ(Q,p);//首先访问根结点，并将根节点入队</p><p>​        while(DeQueue_LQ(Q,p)){ //队非空时重复操作，出队</p><p>​            if(p-&gt;lchild!=NULL){ //访问左孩子并入队</p><p>​                printf(“%d “, p-&gt;lchild-&gt;data);</p><p>​                EnQueue_LQ(Q, p-&gt;lchild);</p><p>​            }</p><p>​            if(p-&gt;rchild!=NULL){ //访问右孩子并入队</p><p>​                printf(“%d “, p-&gt;rchild-&gt;data);</p><p>​                EnQueue_LQ(Q, p-&gt;rchild);</p><p>​            }</p><p>​        }</p><p>​    }</p><p>}</p><h4 id="求平衡二叉树的深度"><a href="#求平衡二叉树的深度" class="headerlink" title="/求平衡二叉树的深度/"></a>/<em>求平衡二叉树的深度</em>/</h4><p>int BBSTreeDepth(BBSTree T){</p><p>​    int depthLeft, depthRight;</p><p>​    if(NULL==T) return 0;</p><p>​    else{</p><p>​        depthLeft = BBSTreeDepth(T-&gt;lchild);</p><p>​        depthRight = BBSTreeDepth(T-&gt;rchild);</p><p>​        return 1+(depthLeft &gt; depthRight ? depthLeft : depthRight);</p><p>​    }</p><p>}</p><h4 id="合并平衡二叉树"><a href="#合并平衡二叉树" class="headerlink" title="/合并平衡二叉树/"></a>/<em>合并平衡二叉树</em>/</h4><p>void MergeBBST(BBSTree &amp;T1, BBSTree T2) {</p><p>​    Status taller = FALSE;</p><p>​    if (T2 != NULL) {</p><p>​        MergeBBST(T1, T2-&gt;lchild);</p><p>​        InsertAVL(T1, T2-&gt;data, taller);</p><p>​        MergeBBST(T1, T2-&gt;rchild);</p><p>​    }</p><p>}</p><h4 id="分裂平衡二叉树"><a href="#分裂平衡二叉树" class="headerlink" title="/分裂平衡二叉树/"></a>/<em>分裂平衡二叉树</em>/</h4><p>void SpiltBBST(BBSTree T, RcdType key, BBSTree &amp;T1, BBSTree &amp;T2) {</p><p>​    Status taller = FALSE;</p><p>​    if (T != NULL) {</p><p>​        SpiltBBST(T-&gt;lchild, key, T1, T2); // 递归访问左子树</p><p>​        if(T-&gt;data &gt; key) {</p><p>​            InsertAVL(T1, T-&gt;data, taller);</p><p>​        } else {</p><p>​            InsertAVL(T2, T-&gt;data, taller);</p><p>​        }</p><p>​        SpiltBBST(T-&gt;rchild, key, T1, T2);</p><p>​    }</p><p>}</p><h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><h3 id="调试过程中遇到的问题及处理方法"><a href="#调试过程中遇到的问题及处理方法" class="headerlink" title="调试过程中遇到的问题及处理方法"></a>调试过程中遇到的问题及处理方法</h3><p>一开始运行过程中程序停止运行。遇到这个情况一开始我以为是编译器有问题，但是换了个编译器还是同样的问题，后来我上网查询了有关资料，大概明白了是自己的代码出现了问题。所以只能将新增的代码注释掉，一条一条测试，调试过程很漫长，最后才发现是内存泄露和空指针异常，将指针不适用之后指向为 NULL，才把问题解决了。</p><h3 id="算法改进与设想"><a href="#算法改进与设想" class="headerlink" title="算法改进与设想"></a>算法改进与设想</h3><p>在对动态查找表的查找方式上，课程设计选择的是平衡二叉树，那么当查找的结点元素与关键字数量庞大的时候，就会造成平衡二叉树的高度过高，查找、添加、删除等操作的时候效率就会变得很低，而且输入后的排序与整合平衡二叉树T所需要用到的时间就会很长，所以，如果动态查找表中的元素数量庞大的时候可以优先选择B树和B+树等，可以有效降低查找树的高度，提高查找处理效率。</p><h3 id="经验与体会"><a href="#经验与体会" class="headerlink" title="经验与体会"></a>经验与体会</h3><p>本次课程设计主要实现平衡二叉树的查找，插入和删除，增加合并和分裂的功能。许多接口的实现都是基于之前二叉树等的操作，根据平衡二叉树的特性进行改动和完善，删除的难点在于找待删除点的前驱结点和删除后对失衡情况的调节.合并和分裂平衡二叉树，一开始我是想用一个数组先把元素汇总再进行创建新的平衡二叉树，但查阅资料后，觉得这一种方法有些死板，不及直接递归访问结点元素并进行插入操作。总结来说，平衡二叉树是一种基于二叉树的抽象数据类型，平衡这一特性，给一些基本操作增加了不小的难度，值得去思考和研究。</p><p>在做一个比较大的程序过程中，应该学会边编写程序边运行，即当你完成了一个比较小的功能时便对其调试， 这样有助于我们高效地完成项目，而且在调试 BUG 的过程也可以大大减小其难度。必须要有良好的编程习惯。首先编码风格一定要规范，这样不仅有利于读者和编程者对代码的阅读，更有利于对代码的维护。其次要对代码要细心，比较一些指针的初始化和不需要时指为空，这些都是可以极大减少我们出现 BUG 的几率</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;当年的数据结构课程设计-平衡二叉树，想了想还是放上来吧，当初费尽心思，怕是如今都已看不懂了இ௰இ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/DataStructure/2019/05/11/DataStructureAssign/write-593333_1280.jpg&quot; alt=&quot;write-593333_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="树" scheme="http://jhjhljh.github.io/tags/%E6%A0%91/"/>
    
      <category term="课设" scheme="http://jhjhljh.github.io/tags/%E8%AF%BE%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习笔记</title>
    <link href="http://jhjhljh.github.io/canvas/2019/05/11/canvas.html"/>
    <id>http://jhjhljh.github.io/canvas/2019/05/11/canvas.html</id>
    <published>2019-05-11T12:12:07.000Z</published>
    <updated>2019-05-11T15:39:30.493Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">canvas画布，不容小觑的“标签”，得有一定的数学几何底子，虽然目前我还是没用到就是了，但是以后总该会用到的，有想过利用canvas制作小游戏_〆(´Д｀ )</p><blockquote class="question">canvas画布，顾名思义即是如图所示绘图的“工具”，然而并不简单(lll￢ω￢)~</blockquote><p><img src="/canvas/2019/05/11/canvas/business-1031754_1280.jpg" alt="business-1031754_1280"></p><a id="more"></a><blockquote class="question">最近毛毛的《奉献》特别耐人寻味，有跟原版不一样的感觉~</blockquote>        <div id="aplayer-iDHcQpwN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-iDHcQpwN"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "奉献",              author: "毛不易",              url: "http://prc4nro7n.bkt.clouddn.com/%E5%A5%89%E7%8C%AE.mp3",              pic: "http://prc4nro7n.bkt.clouddn.com/maomao.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h1 id="canvas简介"><a href="#canvas简介" class="headerlink" title="canvas简介"></a>canvas简介</h1><h2 id="什么是canvas？（了解）"><a href="#什么是canvas？（了解）" class="headerlink" title="什么是canvas？（了解）"></a>什么是canvas？（了解）</h2><ul><li>是HTML5提供的一种新标签</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"> 英 [<span class="string">'kænvəs]  美 ['</span>kænvəs]   帆布 画布</span><br></pre></td></tr></table></figure><ul><li>Canvas是一个矩形区域的画布，可以用JavaScript在上面绘画。控制其每一个像素。</li><li>canvas 标签使用 JavaScript 在网页上绘制图像，本身不具备绘图功能。</li><li>canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li><li>HTML5之前的web页面只能用一些固定样式的标签：比如p、div、h1等</li></ul><h2 id="canvas主要应用的领域（了解）"><a href="#canvas主要应用的领域（了解）" class="headerlink" title="canvas主要应用的领域（了解）"></a>canvas主要应用的领域（了解）</h2><ol><li>游戏：canvas在基于Web的图像显示方面比Flash更加立体、更加精巧，canvas游戏在流畅度和跨平台方面更牛。<br><a href="http://www.oschina.net/news/20143/top-25-best-html5-canvas-games-you-love-to-play" target="_blank" rel="noopener">25 超棒的 HTML5 Canvas 游戏</a></li><li><strong>可视化数据</strong>.数据图表话，比如:<a href="http://echarts.baidu.com/" target="_blank" rel="noopener">百度的echart</a>    </li><li><strong>banner广告</strong>：Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。</li><li>未来=&gt; 模拟器：无论从视觉效果还是核心功能方面来说，模拟器产品可以完全由JavaScript来实现。</li><li>未来=&gt; 远程计算机控制：Canvas可以让开发者更好地实现基于Web的数据传输，构建一个完美的可视化控制界面。</li><li>未来=&gt; 图形编辑器：Photoshop图形编辑器将能够100%基于Web实现。</li><li>其他可嵌入网站的内容(多用于活动页面、特效)：类似图表、音频、视频，还有许多元素能够更好地与Web融合，并且不需要任何插件。</li><li><strong>完整的canvas移动化应用</strong></li><li>我们课程的目标<ul><li>我们不是主要做游戏开发的</li><li>要求必须会做基本的用canvas绘制的特效页面：比如，传智前端官网。</li><li>会用canvas做一些简单的广告、活动页面</li></ul></li><li>我们课程的案例和项目演示</li><li>canvas的标准： <ul><li>最新标准：<a href="http://www.w3.org/TR/2dcontext/" target="_blank" rel="noopener">http://www.w3.org/TR/2dcontext/</a></li><li>稳定版本的标准：<a href="http://www.w3.org/TR/2013/CR-2dcontext-20130806/" target="_blank" rel="noopener">http://www.w3.org/TR/2013/CR-2dcontext-20130806/</a></li><li>目前来说，标准还在完善中。先用早期的api足够完成所有的应用</li></ul></li></ol><h1 id="canvas绘图基础"><a href="#canvas绘图基础" class="headerlink" title="canvas绘图基础"></a>canvas绘图基础</h1><h2 id="sublime配置canvas插件（推荐）"><a href="#sublime配置canvas插件（推荐）" class="headerlink" title="sublime配置canvas插件（推荐）"></a>sublime配置canvas插件（推荐）</h2><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">推荐：</span><br><span class="line">    安装插件：AndyJS2</span><br><span class="line">    github地址： https://github.com/malun666/AndyJS2</span><br><span class="line">    直接下载到：X:<span class="symbol">\U</span>sers<span class="symbol">\用</span>户名<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\S</span>ublime Text 3<span class="symbol">\P</span>ackages</span><br></pre></td></tr></table></figure><h2 id="Canvas标签"><a href="#Canvas标签" class="headerlink" title="Canvas标签"></a>Canvas标签</h2><h3 id="canvas标签语法和属性-（重点）"><a href="#canvas标签语法和属性-（重点）" class="headerlink" title="canvas标签语法和属性  （重点）"></a>canvas标签语法和属性  （重点）</h3><ul><li>canvas：画布油布的意思 ==英 [‘kænvəs]   美 [‘kænvəs] ==</li><li>标签名canvas，需要进行闭合。就是一普通的html标签。</li><li>可以设置width和height属性，但是属性值<strong>单位必须是px</strong>，否则忽略。</li><li>width和hegiht：默认300*150像素</li><li>注意：<ul><li>不要用CSS控制它的宽和高,会走出图片拉伸，</li><li>重新设置canvas标签的宽高属性会让画布擦除所有的内容。</li><li>可以给canvas画布设置背景色</li></ul></li></ul><h3 id="浏览器不兼容处理（重点）"><a href="#浏览器不兼容处理（重点）" class="headerlink" title="浏览器不兼容处理（重点）"></a>浏览器不兼容处理（重点）</h3><ul><li>ie9以上才支持canvas, 其他chrome、ff、苹果浏览器等都支持</li><li>只要浏览器兼容canvas，那么就会支持绝大部分api(个别最新api除外)</li><li>移动端的兼容情况非常理想，基本上随便使用</li><li>2d的支持的都非常好，3d（webgl）ie11才支持，其他都支持</li><li>如果浏览器不兼容，最好进行友好提示         </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：                     </span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"cavsElem"</span>&gt;</span></span><br><span class="line">    你的浏览器不支持canvas，请升级浏览器.浏览器不支持，显示此行文本</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>浏览器不兼容，可以使用<em>flash</em>等手段进行<strong>优雅降级</strong></li></ul><h2 id="canvas绘图上下文context"><a href="#canvas绘图上下文context" class="headerlink" title="canvas绘图上下文context"></a>canvas绘图上下文context</h2><h3 id="Context：Canvas的上下文、绘制环境。（重点掌握）"><a href="#Context：Canvas的上下文、绘制环境。（重点掌握）" class="headerlink" title="Context：Canvas的上下文、绘制环境。（重点掌握）"></a>Context：Canvas的上下文、绘制环境。（重点掌握）</h3><ul><li>上下文：上知天文，下知地理。是所有的绘制操作api的入口或者集合。</li><li>Canvas自身无法绘制任何内容。Canvas的绘图是使用JavaScript操作的。</li><li>Context对象就是JavaScript操作Canvas的接口。<br>*使用[CanvasElement].getContext(‘2d’)来获取2D绘图上下文。        </li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas  = <span class="built_in">document</span>.getElementById( <span class="string">'cavsElem'</span> ); <span class="comment">//获得画布</span></span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext( <span class="string">'2d'</span> );<span class="comment">//注意：2d小写， 3d：webgl</span></span><br></pre></td></tr></table></figure><h2 id="基本的绘制路径（重点）"><a href="#基本的绘制路径（重点）" class="headerlink" title="基本的绘制路径（重点）"></a>基本的绘制路径（重点）</h2><h3 id="canvas坐标系"><a href="#canvas坐标系" class="headerlink" title="canvas坐标系"></a>canvas坐标系</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas坐标系，从最左上角<span class="number">0</span>,<span class="number">0</span>开始。x向右增大， y向下增大</span><br></pre></td></tr></table></figure><p><img src="/canvas/2019/05/11/canvas/canvas-x-y.png" alt="canvas-x-y"></p><h3 id="设置绘制起点-moveTo"><a href="#设置绘制起点-moveTo" class="headerlink" title="设置绘制起点(moveTo)"></a>设置绘制起点(moveTo)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>语法：ctx.moveTo(x, y); </span><br><span class="line"><span class="bullet">* </span>解释：设置上下文绘制路径的起点。相当于移动画笔到某个位置</span><br><span class="line"><span class="bullet">* </span>参数：x,y 都是相对于 canvas盒子的最左上角。</span><br><span class="line"><span class="bullet">* </span>注意：*<span class="strong">*绘制线段前必须先设置起点，不然绘制无效。*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><h3 id="绘制直线-lineTo"><a href="#绘制直线-lineTo" class="headerlink" title="绘制直线(lineTo)"></a>绘制直线(lineTo)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>语法：ctx.lineTo(x, y);</span><br><span class="line"><span class="bullet">* </span>解释：从x,y的位置绘制一条直线到起点或者上一个线头点。</span><br><span class="line"><span class="bullet">* </span>参数：x,y 线头点坐标。</span><br></pre></td></tr></table></figure><h3 id="路径开始和闭合"><a href="#路径开始和闭合" class="headerlink" title="路径开始和闭合"></a>路径开始和闭合</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>开始路径：ctx.beginPath();</span><br><span class="line"><span class="bullet">* </span>闭合路径：ctx.closePath();</span><br><span class="line"><span class="bullet">* </span>解释：如果复杂路径绘制，必须使用路径开始和结束。闭合路径会自动把最后的线头和开始的线头连在一起。</span><br><span class="line"><span class="bullet">* </span>beginPath: 核心的作用是将 不同绘制的形状进行隔离，</span><br><span class="line"><span class="code">  每次执行此方法，表示重新绘制一个路径,跟之前的绘制的墨迹可以进行分开样式设置和管理。</span></span><br></pre></td></tr></table></figure><h3 id="描边-stroke"><a href="#描边-stroke" class="headerlink" title="描边(stroke)"></a>描边(stroke)</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 语法：ctx.<span class="keyword">stroke();</span></span><br><span class="line"><span class="keyword">* </span>解释：根据路径绘制线。路径只是草稿，真正绘制线必须执行<span class="keyword">stroke</span></span><br><span class="line"><span class="keyword">* </span><span class="keyword">stroke: </span>（用笔等）画；轻抚；轻挪；敲击；划尾桨；划掉；（打字时）击打键盘</span><br><span class="line"> 英 [<span class="keyword">strəʊk] </span>  美 [<span class="keyword">strok]</span></span><br></pre></td></tr></table></figure><ul><li>canvas绘制的基本步骤：<ul><li>第一步：获得上下文 =&gt;canvasElem.getContext(‘2d’);</li><li>第二步：开始路径规划 =&gt;ctx.beginPath()</li><li>第三步：移动起始点 =&gt;ctx.moveTo(x, y)</li><li>第四步：绘制线(矩形、圆形、图片…) =&gt;ctx.lineTo(x, y)</li><li>第五步：闭合路径 =&gt;ctx.closePath();</li><li>第六步：绘制描边 =&gt;ctx.stroke();</li></ul></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html部分：</span><br><span class="line">    &lt;canvas id=<span class="string">"cavsElem"</span>&gt;</span><br><span class="line">        你的浏览器不支持canvas，请升级浏览器</span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">javascript部分：</span><br><span class="line"></span><br><span class="line"><span class="comment">//===============基本绘制api====================</span></span><br><span class="line"><span class="comment">//获得画布</span></span><br><span class="line">var canvas = document.querySelector('#cavsElem');</span><br><span class="line">var ctx = canvas.getContext('<span class="number">2</span>d');  <span class="comment">//获得上下文</span></span><br><span class="line"></span><br><span class="line">canvas.width = <span class="number">900</span>;     <span class="comment">//设置标签的属性宽高</span></span><br><span class="line">canvas.height = <span class="number">600</span>;    <span class="comment">//千万不要用 canvas.style.height</span></span><br><span class="line">canvas.style.border = <span class="string">"1px solid #000"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制三角形</span></span><br><span class="line">ctx.beginPath();        <span class="comment">//开始路径</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);    <span class="comment">//三角形，左顶点</span></span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">100</span>);   <span class="comment">//右顶点</span></span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">300</span>);   <span class="comment">//底部的点</span></span><br><span class="line">ctx.closePath();        <span class="comment">//结束路径</span></span><br><span class="line">ctx.stroke();           <span class="comment">//描边路径</span></span><br></pre></td></tr></table></figure><ul><li>综合案例：02绘制定位表格.html</li><li>综合案例：03画画板.html</li></ul><h3 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充(fill)"></a>填充(fill)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>语法：ctx.fill(); </span><br><span class="line"><span class="bullet">* </span>解释：填充，是将闭合的路径的内容填充具体的颜色。默认黑色。</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 注意：交叉路径的填充问题，“非零环绕原则”，顺逆时针穿插次数决定是否填充。</span><br><span class="line">    </span><br><span class="line">    以下是非<span class="number">0</span>环绕原则的原理：（了解即可，非常少会用到复杂的路径）</span><br><span class="line">    “非零环绕规则”是这么来判断有自我交叉情况的路径的：对于路径中的任意给定区域，从该区域内部画一条足够长的线段，</span><br><span class="line">    使此线段的终点完全落在路径范围之外。</span><br><span class="line">    图<span class="number">2</span><span class="number">-14</span>中的那三个箭头所描述的就是上面这个步骤。</span><br><span class="line">    接下来，将计数器初始化为<span class="number">0</span>，</span><br><span class="line">    然后，每当这条线段与路径上的直线或曲线相交时，</span><br><span class="line">    就改变计数器的值。如果是与路径的顺时针部分相交，则加<span class="number">1</span>，</span><br><span class="line">    如果是与路径的逆时针部分相交，则减<span class="number">1</span>。若计数器的最终值不是<span class="number">0</span>，那么此区域就在路径里面，在调用fill()方法时，</span><br><span class="line">    浏览器就会对其进行填充。</span><br><span class="line">    如果最终值是<span class="number">0</span>，那么此区域就不在路径内部，浏览器也就不会对其进行填充了</span><br><span class="line">* 案例： <span class="number">04</span>填充矩形.html</span><br></pre></td></tr></table></figure><p><img src="/canvas/2019/05/11/canvas/fill-0-prin.jpg" alt="fill-0-prin"></p><h3 id="快速创建矩形rect-方法"><a href="#快速创建矩形rect-方法" class="headerlink" title="快速创建矩形rect()方法"></a>快速创建矩形rect()方法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 语法：ctx.<span class="built_in">rect</span>(x, y, <span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">* 解释：x, y是矩形左上角坐标， <span class="built_in">width</span>和<span class="built_in">height</span>都是以像素计</span><br><span class="line">* <span class="built_in">rect</span>方法只是规划了矩形的路径，并没有填充和描边。</span><br><span class="line">* 改造案例：<span class="number">04</span>填充矩形.html</span><br><span class="line">*<span class="built_in">rect</span>: abbr. 矩形（rectangular）；收据（receipt）</span><br></pre></td></tr></table></figure><h3 id="快速创建描边矩形和填充矩形"><a href="#快速创建描边矩形和填充矩形" class="headerlink" title="快速创建描边矩形和填充矩形"></a>快速创建描边矩形和填充矩形</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 语法： ctx.strokeRect(x, y, <span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">    - 参数跟<span class="number">2.3</span><span class="number">.8</span>相同，注意此方法绘制完路径后立即进行<span class="built_in">stroke</span>绘制</span><br><span class="line">* 语法：ctx.fillRect(x, y, <span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">    - 参数跟<span class="number">2.3</span><span class="number">.8</span>相同， 此方法执行完成后。立即对当前矩形进行<span class="built_in">fill</span>填充。</span><br></pre></td></tr></table></figure><h3 id="清除矩形-clearRect"><a href="#清除矩形-clearRect" class="headerlink" title="清除矩形(clearRect)"></a>清除矩形(clearRect)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>语法：ctx.clearRect(x, y, width, hegiht);</span><br><span class="line"><span class="bullet">* </span>解释：清除某个矩形内的绘制的内容，相当于橡皮擦。</span><br></pre></td></tr></table></figure><h2 id="绘制圆形（arc"><a href="#绘制圆形（arc" class="headerlink" title="绘制圆形（arc)"></a>绘制圆形（arc)</h2><ul><li>概述：arc() 方法创建弧/曲线（用于创建圆或部分圆）。<ul><li>语法：ctx.arc(x,y,r,sAngle,eAngle,counterclockwise);</li><li>arc:  弧（度）弧形物；天穹 英 [ɑːk]   美 [ɑrk]</li><li>counter 反击，还击；反向移动，对着干；反驳，回答  [‘kaʊntə]   美 [‘kaʊntɚ]</li><li>解释：<ul><li>x,y：圆心坐标。 </li><li>r：半径大小。</li><li>sAngle:绘制开始的角度。 圆心到最右边点是0度，顺时针方向弧度增大。</li><li>eAngel:结束的角度，注意是弧度。π</li><li>counterclockwise：是否是逆时针。true是逆时针，false：顺时针</li><li>弧度和角度的转换公式： rad = deg*Math.PI/180;  </li><li>在Math提供的方法中<strong>sin、cos等都使用的弧度</strong><br> <img src="/canvas/2019/05/11/canvas/arc.gif" alt="arc">  </li></ul></li></ul></li><li>案例：05绘制圆形.html</li><li>案例：06绘制饼状图.html</li></ul><h2 id="绘制文字（会使用就可以了）"><a href="#绘制文字（会使用就可以了）" class="headerlink" title="绘制文字（会使用就可以了）"></a>绘制文字（会使用就可以了）</h2><h3 id="绘制上下文的文字属性-（有印象就行了）"><a href="#绘制上下文的文字属性-（有印象就行了）" class="headerlink" title="绘制上下文的文字属性 （有印象就行了）"></a>绘制上下文的文字属性 （有印象就行了）</h3><ul><li>font            设置或返回文本内容的当前字体属性<ul><li>font 属性使用的语法与 CSS font 属性相同。</li></ul></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：ctx.font = <span class="string">"18px '微软雅黑'"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>textAlign       设置或返回文本内容的当前对齐方式<ul><li>start :    默认。文本在指定的位置开始。</li><li>end   :    文本在指定的位置结束。</li><li>center:    文本的中心被放置在指定的位置。</li><li>left  :    文本左对齐。</li><li>right :    文本右对齐。      </li></ul></li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 例如：ctx.<span class="built_in">textAlign</span> = <span class="string">'left'</span>;</span><br></pre></td></tr></table></figure><p><img src="/canvas/2019/05/11/canvas/textAsign.png" alt="textAsign"></p><ul><li>textBaseline      设置或返回在绘制文本时使用的当前文本基线   <ul><li>alphabetic ：   默认。文本基线是普通的字母基线。</li><li>top        ：   文本基线是 em 方框的顶端。。</li><li>hanging    ：   文本基线是悬挂基线。</li><li>middle     ：   文本基线是 em 方框的正中。</li><li>ideographic：   文本基线是em基线。</li><li>bottom     ：   文本基线是 em 方框的底端。     </li></ul></li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如： ctx.textBaseline = 'top';</span><br><span class="line">单词:</span><br><span class="line"> alphabetic: 字母的；照字母次序的   <span class="string">[,ælfə'bɛtɪk]</span></span><br><span class="line"> ideographic：表意的；表意字构成的   英 <span class="string">[,ɪdɪəʊ'ɡræfɪk]</span>   美 <span class="string">[,ɪdɪə'græfɪk]</span></span><br></pre></td></tr></table></figure><p>​     <img src="/canvas/2019/05/11/canvas/font-line1.png" alt="font-line1"><br>  <img src="/canvas/2019/05/11/canvas/textBaseline.gif" alt="textBaseline"></p><h3 id="上下文绘制文字方法"><a href="#上下文绘制文字方法" class="headerlink" title="上下文绘制文字方法"></a>上下文绘制文字方法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="selector-tag">ctx</span><span class="selector-class">.fillText</span>()      在画布上绘制“被填充的”文本</span><br><span class="line">* <span class="selector-tag">ctx</span><span class="selector-class">.strokeText</span>()    在画布上绘制文本（无填充）</span><br><span class="line">* <span class="selector-tag">ctx</span><span class="selector-class">.measureText</span>()   返回包含指定文本宽度的对象</span><br><span class="line">* 单词：<span class="selector-tag">measure</span> 测量；估量；权衡   英 <span class="selector-attr">['meʒə]</span>   美 <span class="selector-attr">['mɛʒɚ]</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//综合案例代码：</span></span><br><span class="line">ctx.moveTo( <span class="number">300</span>, <span class="number">300</span> );</span><br><span class="line">ctx.fillStyle = <span class="string">"purple"</span>;               <span class="comment">//设置填充颜色为紫色</span></span><br><span class="line">ctx.font = '<span class="number">20</span>px <span class="string">"微软雅黑"</span>';           <span class="comment">//设置字体</span></span><br><span class="line">ctx.textBaseline = <span class="string">"bottom"</span>;            <span class="comment">//设置字体底线对齐绘制基线</span></span><br><span class="line">ctx.textAlign = <span class="string">"left"</span>;                 <span class="comment">//设置字体对齐的方式</span></span><br><span class="line"><span class="comment">//ctx.strokeText( "left", 450, 400 );</span></span><br><span class="line">ctx.fillText( <span class="string">"Top-g"</span>, <span class="number">100</span>, <span class="number">300</span> );        <span class="comment">//填充文字</span></span><br></pre></td></tr></table></figure><hr><h2 id="绘制图片（drawImage）-（重点）"><a href="#绘制图片（drawImage）-（重点）" class="headerlink" title="绘制图片（drawImage）  （重点）"></a>绘制图片（drawImage）  （重点）</h2><h3 id="基本绘制图片的方式"><a href="#基本绘制图片的方式" class="headerlink" title="基本绘制图片的方式"></a>基本绘制图片的方式</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage(img,<span class="keyword">x</span>,y)<span class="comment">;</span></span><br><span class="line"><span class="comment">参数说明： x,y 绘制图片左上角的坐标， img是绘制图片的dom对象。</span></span><br></pre></td></tr></table></figure><h3 id="在画布上绘制图像，并规定图像的宽度和高度"><a href="#在画布上绘制图像，并规定图像的宽度和高度" class="headerlink" title="在画布上绘制图像，并规定图像的宽度和高度"></a>在画布上绘制图像，并规定图像的宽度和高度</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage(img,x,y,<span class="built_in">width</span>,<span class="built_in">height</span>);   </span><br><span class="line">参数说明：<span class="built_in">width</span> 绘制图片的宽度，  <span class="built_in">height</span>：绘制图片的高度</span><br><span class="line">如果指定宽高，最好成比例，不然图片会被拉伸&lt;/em&gt;</span><br><span class="line">    等比公式：  toH = Height * toW   /  Width;  <span class="comment">//等比 </span></span><br><span class="line">             设置高 = 原高度 * 设置宽/ 原宽度;</span><br></pre></td></tr></table></figure><h3 id="图片裁剪，并在画布上定位被剪切的部分"><a href="#图片裁剪，并在画布上定位被剪切的部分" class="headerlink" title="图片裁剪，并在画布上定位被剪切的部分"></a>图片裁剪，并在画布上定位被剪切的部分</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">context</span>.drawImage(img,sx,sy,<span class="keyword">swidth,sheight,x,y,width,height);</span></span><br><span class="line"><span class="keyword">参数说明：</span></span><br><span class="line"><span class="keyword"> </span>   sx,sy 裁剪的左上角坐标，</span><br><span class="line">    <span class="keyword">swidth：裁剪图片的高度。 </span><span class="keyword">sheight:裁剪的高度 </span></span><br><span class="line">    其他同上</span><br></pre></td></tr></table></figure><h3 id="用JavaScript创建img对象"><a href="#用JavaScript创建img对象" class="headerlink" title="用JavaScript创建img对象"></a>用JavaScript创建img对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一种方式： </span><br><span class="line">   <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"imgId"</span>);</span><br><span class="line">第二种方式：</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();<span class="comment">//这个就是 img标签的dom对象</span></span><br><span class="line">    img.src = <span class="string">"imgs/arc.gif"</span>;</span><br><span class="line">    img.alt = <span class="string">"文本信息"</span>;</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//图片加载完成后，执行此方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象基础复习补充："><a href="#面向对象基础复习补充：" class="headerlink" title="面向对象基础复习补充："></a>面向对象基础复习补充：</h3><ul><li>创建对象的方式：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* <span class="keyword">var</span> o = &#123; name: <span class="string">'123'</span>, age: <span class="number">18</span> &#125;; <span class="comment">//json方式创建</span></span><br><span class="line">* <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();  <span class="comment">//通过new的方式创建</span></span><br><span class="line">* <span class="keyword">var</span> o = <span class="keyword">new</span> Persion(); <span class="comment">//通过类的构造函数创建</span></span><br></pre></td></tr></table></figure><ul><li>JS中对象的属性创建方式</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>json的方式： var o = &#123; age: 19 &#125;;</span><br><span class="line"><span class="bullet">* </span>直接添加属性：var o = &#123;&#125;;  o.age = 19;//太分散了，不利于管理</span><br><span class="line"><span class="bullet">* </span>由于js动态语言的特性，如果属性不存在的时候，直接添加属性。</span><br><span class="line"><span class="bullet">* </span>构造函数添加属性</span><br><span class="line"><span class="bullet">* </span>原型添加公共的属性</span><br></pre></td></tr></table></figure><ul><li>JS的构造函数的原型<br>构造函数的原型就是：构造对象的模板，构造函数原型里面的所有的属性和方法都会共享给所有的 构造函数构造出来的所有实例。<br><img src="/canvas/2019/05/11/canvas/prototype.png" alt="prototype"></li><li>案例： 08绘制图片.html</li><li>案例： 09绘制图片裁剪.html</li><li>案例： 10序列帧动画.html</li><li>案例： 11面向对象版本的动画帧.html  <strong>重点</strong></li></ul><h2 id="补充-sublime制作代码段（推荐–已结讲过了）"><a href="#补充-sublime制作代码段（推荐–已结讲过了）" class="headerlink" title="补充 sublime制作代码段（推荐–已结讲过了）"></a>补充 sublime制作代码段（推荐–已结讲过了）</h2><p>第一步：sublime菜单栏→ 工具 → 制作代码段 </p><p>第二步：修改输出的sublime代码段文本</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">snippet</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">content</span>&gt;</span>&lt;![CDATA[</span></span><br><span class="line"><span class="xml">1、这里放要tab键 输出的内容</span></span><br><span class="line"><span class="xml">2、 $</span><span class="template-variable">&#123;1:this&#125;</span><span class="xml"> 占位符，tab可以进行切换，数字是切换的索引。</span></span><br><span class="line"><span class="xml">    ：后面的是默认的文本。</span></span><br><span class="line"><span class="xml">]]&gt;<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">tabTrigger</span>&gt;</span>简写的字母<span class="tag">&lt;/<span class="name">tabTrigger</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">snippet</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>第三步：保存到插件的文件夹中，后缀名为：.sublime-snippet<br>比如我存放的位置：<br> C:\Users\malunmac\AppData\Roaming\Sublime Text 3\Packages\User\snippets<br><strong>snippets是我自己新建的文件夹。</strong></p><hr><h1 id="canvas进阶"><a href="#canvas进阶" class="headerlink" title="canvas进阶"></a>canvas进阶</h1><h2 id="Canvas颜色样式和阴影"><a href="#Canvas颜色样式和阴影" class="headerlink" title="Canvas颜色样式和阴影"></a>Canvas颜色样式和阴影</h2><h3 id="设置填充和描边的颜色（掌握）"><a href="#设置填充和描边的颜色（掌握）" class="headerlink" title="设置填充和描边的颜色（掌握）"></a>设置填充和描边的颜色（掌握）</h3><ul><li>fillStyle  : 设置或返回用于填充绘画的颜色</li><li>strokeStyle: 设置或返回用于笔触的颜色</li></ul><p>以上两个值都可以接受颜色名,16进制数据，rgb值，甚至rgba.<br>一般先进行设置样式然后进行绘制。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">ctx.strokeStyle = <span class="string">"red"</span><span class="comment">;      </span></span><br><span class="line">ctx.strokeStyle = <span class="string">"#ccc"</span><span class="comment">;      </span></span><br><span class="line">ctx.strokeStyle = <span class="string">"rgb(255,0,0)"</span><span class="comment">;      </span></span><br><span class="line">ctx.strokeStyle = <span class="string">"rgba(255,0,0,6)"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="设置阴影（了解，少用，性能差）"><a href="#设置阴影（了解，少用，性能差）" class="headerlink" title="设置阴影（了解，少用，性能差）"></a>设置阴影（了解，少用，性能差）</h3><ul><li>类比于CSS3的阴影。</li><li>shadowColor  ：   设置或返回用于阴影的颜色</li><li>shadowBlur   ：   设置或返回用于阴影的模糊级别,大于1的正整数，数值越高，模糊程度越大</li><li>shadowOffsetX：   设置或返回阴影距形状的水平距离</li><li>shadowOffsetY：   设置或返回阴影距形状的垂直距离</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">"rgba(255,0,0, .9)"</span></span><br><span class="line">ctx.<span class="keyword">shadowColor </span>= <span class="string">"teal"</span><span class="comment">;</span></span><br><span class="line">ctx.<span class="keyword">shadowBlur </span>= <span class="number">10</span><span class="comment">;</span></span><br><span class="line">ctx.<span class="keyword">shadowOffsetX </span>= <span class="number">10</span><span class="comment">;</span></span><br><span class="line">ctx.<span class="keyword">shadowOffsetY </span>= <span class="number">10</span><span class="comment">;</span></span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>例如：</p><ul><li>案例： 12设置box盒子阴影.html</li><li>设置png图片的阴影，图片透明部分不会被投影。</li></ul><h2 id="复杂样式（了解）"><a href="#复杂样式（了解）" class="headerlink" title="复杂样式（了解）"></a>复杂样式（了解）</h2><h3 id="创建线性渐变的样式（了解）"><a href="#创建线性渐变的样式（了解）" class="headerlink" title="创建线性渐变的样式（了解）"></a>创建线性渐变的样式（了解）</h3><ul><li>一般不用，都是用图片代替，canvas绘制图片效率更高。</li><li>线性渐变可以用于 矩形、圆形、文字等颜色样式</li><li>线性渐变是一个对象</li><li>语法：ctx.createLinearGradient(x0,y0,x1,y1); //参数：x0,y0起始坐标，x1,y1结束坐标</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="comment">//创建线性渐变的对象，</span></span><br><span class="line">var grd=ctx.createLinearGradient(<span class="number">0</span>,<span class="number">0</span>,<span class="number">170</span>,<span class="number">0</span>);</span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">"black"</span>);  <span class="comment">//添加一个渐变颜色，第一个参数介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。</span></span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">"white"</span>);  <span class="comment">//添加一个渐变颜色</span></span><br><span class="line">ctx.fillStyle =grd;           <span class="comment">//关键点，把渐变设置到 填充的样式</span></span><br></pre></td></tr></table></figure><p>案例13设置线性渐变.html</p><h3 id="设置圆形渐变（径向渐变）-了解"><a href="#设置圆形渐变（径向渐变）-了解" class="headerlink" title="设置圆形渐变（径向渐变） 了解"></a>设置圆形渐变（径向渐变） 了解</h3><ul><li>创建放射状/圆形渐变对象。可以填充文本、形状等</li><li>context.createRadialGradient(x0,y0,r0,x1,y1,r1);</li><li>radial   半径的；放射状的；光线的；光线状的   英 [‘reɪdɪəl]   美 [‘redɪəl]</li><li>参数详解：<ul><li>x0:  渐变的开始圆的 x 坐标</li><li>y0:  渐变的开始圆的 y 坐标</li><li>r0:  开始圆的半径</li><li>x1:  渐变的结束圆的 x 坐标</li><li>y1:  渐变的结束圆的 y 坐标</li><li>r1:  结束圆的半径</li></ul></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var rlg = ctx.createRadialGradient(<span class="number">300</span>,<span class="number">300</span>,<span class="number">10</span>,<span class="number">300</span>,<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">rlg.addColorStop(<span class="number">0</span>, 'teal');    <span class="comment">//添加一个渐变颜色</span></span><br><span class="line">rlg.addColorStop(<span class="number">.4</span>, 'navy');</span><br><span class="line">rlg.addColorStop(<span class="number">1</span>, 'purple');</span><br><span class="line">ctx.fillStyle = rlg;<span class="comment">//设置 填充样式为延续渐变的样式</span></span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><ul><li>案例14圆形渐变.html</li></ul><h3 id="绘制背景图（了解）"><a href="#绘制背景图（了解）" class="headerlink" title="绘制背景图（了解）"></a>绘制背景图（了解）</h3><ul><li>ctx.createPattern(img,repeat) 方法在指定的方向内重复指定的元素了解</li><li>pattern：n. 模式；图案；样品  英 [‘pæt(ə)n]   美 [‘pætɚn]</li><li>第一参数：设置平铺背景的图片，第二个背景平铺的方式。<ul><li>image    ：   规定要使用的图片、画布或视频元素。</li><li>repeat   ：   默认。该模式在水平和垂直方向重复。</li><li>repeat-x ：   该模式只在水平方向重复。</li><li>repeat-y ：   该模式只在垂直方向重复。</li><li>no-repeat：   该模式只显示一次（不重复）。</li></ul></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ctx=c.getContext(<span class="string">"2d"</span>)<span class="comment">;</span></span><br><span class="line">var img=document.getElementById(<span class="string">"lamp"</span>)<span class="comment">;</span></span><br><span class="line">var pat=ctx.createPattern(img,<span class="string">"repeat"</span>)<span class="comment">;</span></span><br><span class="line">ctx.rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">100</span>)<span class="comment">;</span></span><br><span class="line">ctx.fillStyle=pat<span class="comment">;//  把背景图设置给填充的样式</span></span><br><span class="line">ctx.fill()<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>案例15背景图填充.html</li></ul><h2 id="变换（重点）"><a href="#变换（重点）" class="headerlink" title="变换（重点）"></a>变换（重点）</h2><h3 id="缩放（重点）"><a href="#缩放（重点）" class="headerlink" title="缩放（重点）"></a>缩放（重点）</h3><ul><li>scale() 方法缩放当前绘图，更大或更小</li><li>语法：context.scale(scalewidth,scaleheight)<ul><li>scalewidth  :  缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推)</li><li>scaleheight :  缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.)<br>+注意：缩放的是整个画布，缩放后，继续绘制的图形会被放大或缩小。</li></ul></li><li>案例16缩放案例.html</li></ul><h3 id="位移画布（重点）"><a href="#位移画布（重点）" class="headerlink" title="位移画布（重点）"></a>位移画布（重点）</h3><ul><li>ctx.translate(x,y) 方法重新映射画布上的 (0,0) 位置</li><li>参数说明：<ul><li>x：   添加到水平坐标（x）上的值</li><li>y：   添加到垂直坐标（y）上的值</li></ul></li><li>发生位移后，相当于把画布的0,0坐标 更换到新的x,y的位置，所有绘制的新元素都被影响。</li><li>位移画布一般配合缩放和旋转等。</li><li>案例： 17位移画布.html</li></ul><h3 id="旋转（重点）"><a href="#旋转（重点）" class="headerlink" title="旋转（重点）"></a>旋转（重点）</h3><ul><li>context.rotate(angle); 方法旋转当前的绘图</li><li>注意参数是弧度（PI）</li><li>如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。</li><li>案例：18旋转画布.html</li></ul><h2 id="绘制环境保存和还原（重要）"><a href="#绘制环境保存和还原（重要）" class="headerlink" title="绘制环境保存和还原（重要）"></a>绘制环境保存和还原（重要）</h2><ul><li>ctx.save()  保存当前环境的状态<ul><li>可以把当前绘制环境进行保存到缓存中。</li></ul></li><li>ctx.restore()   返回之前保存过的路径状态和属性<ul><li>获取最近缓存的ctx</li></ul></li><li>一般配合位移画布使用。</li><li>案例： 19矩形旋转案例.html</li></ul><h2 id="设置绘制环境的透明度（了解）"><a href="#设置绘制环境的透明度（了解）" class="headerlink" title="设置绘制环境的透明度（了解）"></a>设置绘制环境的透明度（了解）</h2><ul><li>context.globalAlpha=number;</li><li>number:透明值。必须介于 0.0（完全透明） 与 1.0（不透明） 之间。</li><li>设置透明度是全局的透明度的样式。注意是全局的。</li></ul><h2 id="画布限定区域绘制（了解）"><a href="#画布限定区域绘制（了解）" class="headerlink" title="画布限定区域绘制（了解）"></a>画布限定区域绘制（了解）</h2><ul><li>ctx.clip(); 方法从原始画布中剪切任意形状和尺寸</li><li>一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）</li><li>一般配合绘制环境的保存和还原。</li></ul><h2 id="画布保存base64编码内容（重要）"><a href="#画布保存base64编码内容（重要）" class="headerlink" title="画布保存base64编码内容（重要）"></a>画布保存base64编码内容（重要）</h2><ul><li>把canvas绘制的内容输出成base64内容。 </li><li>语法：canvas.toDataURL(type, encoderOptions);</li><li>例如：canvas.toDataURL(“image/jpg”,1);</li><li>参数说明：<ul><li>type，设置输出的类型，比如 image/png   image/jpeg等</li><li>encoderOptions： 0-1之间的数字，用于标识输出图片的质量，1表示无损压缩，类型为： image/jpeg 或者image/webp才起作用。</li></ul></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">案例<span class="number">1</span>：</span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> dataURL = canvas.toDataURL();</span><br><span class="line">console.log(dataURL);</span><br><span class="line"><span class="comment">// "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby</span></span><br><span class="line"><span class="comment">// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">"#img-demo"</span>);<span class="comment">//拿到图片的dom对象</span></span><br><span class="line">img.src = canvas.toDataURL(<span class="string">"image/png"</span>);      <span class="comment">//将画布的内容给图片标签显示</span></span><br></pre></td></tr></table></figure><h2 id="画布渲染画布（重要）"><a href="#画布渲染画布（重要）" class="headerlink" title="画布渲染画布（重要）"></a>画布渲染画布（重要）</h2><ul><li>context.drawImage(img,x,y);</li><li>img参数也可以是画布，也就是把一个画布整体的渲染到另外一个画布上。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas1 = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'#cavsElem1'</span>);</span><br><span class="line"><span class="keyword">var</span> canvas2 = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'#cavsElem2'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx1 = canvas1.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx2 = canvas2.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx1.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">40</span>);      <span class="comment">//在第一个画布上绘制矩形</span></span><br><span class="line"></span><br><span class="line">ctx2.drawImage(canvas1, <span class="number">10</span>, <span class="number">10</span>);    <span class="comment">//将第一个画布整体绘制到第二个画布上</span></span><br></pre></td></tr></table></figure><h2 id="了解：线条样式（了解）"><a href="#了解：线条样式（了解）" class="headerlink" title="了解：线条样式（了解）"></a>了解：线条样式（了解）</h2><ul><li>lineCap     设置或返回线条的结束端点(线头、线冒)样式<ul><li>butt  ：  默认。向线条的每个末端添加平直的边缘。<ul><li>翻译.：屁股；烟头；笑柄；靶垛；粗大的一端  英 [bʌt]   美 [bʌt]</li></ul></li><li>round ：  向线条的每个末端添加圆形线帽。</li><li>square：  向线条的每个末端添加正方形线帽。<br>  <img src="/canvas/2019/05/11/canvas/linecap.png" alt="linecap"><br>参考：23线的样式.html</li></ul></li><li>lineJoin    设置或返回两条线相交时，所创建的拐角类型<ul><li>bevel:   创建斜角。<ul><li>翻译. 斜角；斜面；[测] 斜角规  英 [‘bev(ə)l]   美 [‘bɛvl]</li></ul></li><li>round:   创建圆角。</li><li>miter:   默认。创建尖角<br><img src="/canvas/2019/05/11/canvas/linejoin.png" alt="linejoin"></li></ul></li><li>lineWidth   设置或返回当前的线条宽度</li><li>miterLimit  设置或返回最大斜接长度<ul><li>意思:  斜接 英 [‘maɪtə]  </li><li>斜接长度指的是在两条线交汇处内角和外角之间的距离。</li><li>一般用默认值：10就可以了。除非需要特别长的尖角时，使用此属性。<br><img src="/canvas/2019/05/11/canvas/MiterLimet.png" alt="MiterLimet"></li></ul></li></ul><h2 id="了解贝塞尔曲线（知道有）"><a href="#了解贝塞尔曲线（知道有）" class="headerlink" title="了解贝塞尔曲线（知道有）"></a>了解贝塞尔曲线（知道有）</h2><h3 id="绘制一条二次方曲线。"><a href="#绘制一条二次方曲线。" class="headerlink" title="绘制一条二次方曲线。"></a>绘制一条二次方曲线。</h3><ul><li>微软的画图板中的曲线的颜色。</li><li>quadratic：二次方的意思， 英 [kwɒ’drætɪk]   美 [kwɑ’drætɪk]</li><li>Curve：曲线的意思， 英 [kɜːv]   美 [kɝv]</li><li>语法： context.quadraticCurveTo(cpx,cpy,x,y);</li><li>参数：<ul><li>cpx：   贝塞尔控制点的 x 坐标</li><li>cpy：   贝塞尔控制点的 y 坐标</li><li>x  ：   结束点的 x 坐标</li><li>y  ：   结束点的 y 坐标<br><img src="/canvas/2019/05/11/canvas/quadraticcurve.gif" alt="quadraticcurve"></li></ul></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//绘制2次方曲线，贝赛尔曲线</span></span><br><span class="line">ctx.quadraticCurveTo(<span class="number">20</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">20</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><h3 id="绘制贝塞尔曲线（知道有）"><a href="#绘制贝塞尔曲线（知道有）" class="headerlink" title="绘制贝塞尔曲线（知道有）"></a>绘制贝塞尔曲线（知道有）</h3><ul><li>绘制一条三次贝塞尔曲线</li><li>语法：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);</li><li>提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。</li><li>参数说明：<ul><li>cp1x：    第一个贝塞尔控制点的 x 坐标</li><li>cp1y：    第一个贝塞尔控制点的 y 坐标</li><li>cp2x：    第二个贝塞尔控制点的 x 坐标</li><li>cp2y：    第二个贝塞尔控制点的 y 坐标</li><li>x:        结束点的 x 坐标</li><li>y:        结束点的 y 坐标   </li></ul></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制复杂的贝塞尔曲线</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line"><span class="comment">//参数说明：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);</span></span><br><span class="line"><span class="comment">// cp1x： 第一个贝塞尔控制点的 x 坐标</span></span><br><span class="line"><span class="comment">// cp1y： 第一个贝塞尔控制点的 y 坐标</span></span><br><span class="line"><span class="comment">// cp2x： 第二个贝塞尔控制点的 x 坐标</span></span><br><span class="line"><span class="comment">// cp2y： 第二个贝塞尔控制点的 y 坐标</span></span><br><span class="line"><span class="comment">// x: 结束点的 x 坐标</span></span><br><span class="line"><span class="comment">// y: 结束点的 y 坐标</span></span><br><span class="line">ctx.bezierCurveTo(<span class="number">500</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">600</span>, <span class="number">700</span>, <span class="number">300</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><ul><li>案例：25绘制贝塞尔曲线.html<br><img src="/canvas/2019/05/11/canvas/beziercurve.gif" alt="beziercurve"></li></ul><h2 id="了解创建两条切线的弧（知道有）"><a href="#了解创建两条切线的弧（知道有）" class="headerlink" title="了解创建两条切线的弧（知道有）"></a>了解创建两条切线的弧（知道有）</h2><ul><li>在画布上创建介于当前起点和两个点形成的夹角的切线之间的弧</li><li>语法： context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。</li><li>例如： ctx.arcTo(240, 100, 240, 110, 40);</li><li>参数：<ul><li>x1:  弧的端点1的 x 坐标</li><li>y1:  弧的端点1的 y 坐标</li><li>x2:  弧的端点2(终点)的 x 坐标</li><li>y2:  弧的端点2(终点)的 y 坐标</li><li>r :  弧的半径   </li></ul></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码demo：</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。</span></span><br><span class="line">ctx.arcTo(<span class="number">240</span>, <span class="number">100</span>, <span class="number">240</span>, <span class="number">110</span>, <span class="number">40</span>);</span><br><span class="line">ctx.lineTo(<span class="number">240</span>, <span class="number">300</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/canvas/2019/05/11/canvas/canvas-arcto-1.png" alt="canvas-arcto-1"></p><h2 id="了解判断点是否在路径中（知道有）"><a href="#了解判断点是否在路径中（知道有）" class="headerlink" title="了解判断点是否在路径中（知道有）"></a>了解判断点是否在路径中（知道有）</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.isPointInPath<span class="params">(x,y)</span>;</span><br><span class="line"><span class="string">//isPointInPath</span><span class="params">()</span> 方法返回 <span class="literal">true</span>，如果指定的点位于当前路径中；否则返回 <span class="literal">false</span>。</span><br><span class="line"><span class="string">//</span>判断x,y坐标的点是否在当前的路径中。</span><br></pre></td></tr></table></figure><h2 id="了解文本宽度计算（知道有）"><a href="#了解文本宽度计算（知道有）" class="headerlink" title="了解文本宽度计算（知道有）"></a>了解文本宽度计算（知道有）</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">context</span>.measureText(<span class="literal">text</span>).<span class="literal">width</span>;</span><br></pre></td></tr></table></figure><h2 id="如果以后做canvas游戏方向开发深入学习可以扩展内以下容："><a href="#如果以后做canvas游戏方向开发深入学习可以扩展内以下容：" class="headerlink" title="如果以后做canvas游戏方向开发深入学习可以扩展内以下容："></a>如果以后做canvas游戏方向开发深入学习可以扩展内以下容：</h2><ul><li>setTransform()  将当前转换重置为单位矩阵。然后运行 transform()</li><li>transform() 替换绘图的当前转换矩阵</li><li>globalCompositeOperation    设置或返回新图像如何绘制到已有的图像上</li><li>像素操作</li></ul><h1 id="Canvas开发库封装"><a href="#Canvas开发库封装" class="headerlink" title="Canvas开发库封装"></a>Canvas开发库封装</h1><h2 id="封装常用的绘制函数"><a href="#封装常用的绘制函数" class="headerlink" title="封装常用的绘制函数"></a>封装常用的绘制函数</h2><h3 id="封装一个矩形"><a href="#封装一个矩形" class="headerlink" title="封装一个矩形"></a>封装一个矩形</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思考：我们用到的矩形需要哪些绘制的东西呢？</span></span><br><span class="line"><span class="number">1</span>、矩形的 x、y坐标</span><br><span class="line"><span class="number">2</span>、矩形的宽高</span><br><span class="line"><span class="number">3</span>、矩形的边框的线条样式、线条宽度</span><br><span class="line"><span class="number">4</span>、矩形填充的样式</span><br><span class="line"><span class="number">5</span>、矩形的旋转角度</span><br><span class="line"><span class="number">6</span>、矩形的缩小放大</span><br><span class="line"><span class="comment">//下面是把上面所有的功能进行封装的代码：</span></span><br><span class="line">function ItcastRect( option ) &#123;<span class="comment">//矩形构造函数</span></span><br><span class="line">    <span class="keyword">this</span>._init(option);</span><br><span class="line">&#125;</span><br><span class="line">ItcastRect.prototype = &#123;  <span class="comment">//矩形的原型对象</span></span><br><span class="line">    _init: function( option ) &#123;  <span class="comment">//初始化方法</span></span><br><span class="line">        option = option || &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.x = option.x === <span class="number">0</span> ? <span class="number">0</span> : option.x || <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.y = option.y === <span class="number">0</span> ? <span class="number">0</span> : option.y || <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.w = option.w || <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.h = option.h || <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.angle = option.angle === <span class="number">0</span> ? <span class="number">0</span> : option.angle || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.fillStyle = option.fillStyle || <span class="string">'silver'</span>;</span><br><span class="line">        <span class="keyword">this</span>.strokeStyle = option.strokeStyle || <span class="string">'red'</span>;</span><br><span class="line">        <span class="keyword">this</span>.strokeWidth = option.strokeWidth || <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">this</span>.scaleX = option.scaleX || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.scaleY = option.Y || <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function( ctx ) &#123;<span class="comment">//把矩形渲染到canvas中</span></span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate( <span class="keyword">this</span>.x, <span class="keyword">this</span>.y );<span class="comment">//位移画布</span></span><br><span class="line">        ctx.rotate( <span class="keyword">this</span>.angle * Math.PI / <span class="number">180</span> );<span class="comment">//旋转角度</span></span><br><span class="line">        ctx.scale( <span class="keyword">this</span>.scaleX, <span class="keyword">this</span>.scaleY );<span class="comment">//缩放</span></span><br><span class="line">        ctx.fillStyle = <span class="keyword">this</span>.fillStyle;</span><br><span class="line">        ctx.fillRect( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.w, <span class="keyword">this</span>.h ); <span class="comment">//填充矩形</span></span><br><span class="line">        ctx.lineWidth = <span class="keyword">this</span>.strokeWidth;     <span class="comment">//线宽</span></span><br><span class="line">        ctx.strokeStyle = <span class="keyword">this</span>.strokeStyle;   <span class="comment">//填充样式</span></span><br><span class="line">        ctx.strokeRect( <span class="number">0</span>,<span class="number">0</span>,<span class="keyword">this</span>.w,<span class="keyword">this</span>.h );  <span class="comment">//描边样式</span></span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">constructor</span>: ItcastRect</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>4.1.2作业：尝试着封装一个圆形？</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装圆形的代码的答案：不要偷看</span></span><br><span class="line">function ItcastCircle( option ) &#123;</span><br><span class="line">    <span class="keyword">this</span>._init( option );</span><br><span class="line">&#125;</span><br><span class="line">ItcastCircle.prototype = &#123;</span><br><span class="line">    _init: function( option ) &#123;</span><br><span class="line">        option = option || &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.x = option.x === <span class="number">0</span> ? <span class="number">0</span> : option.x || <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.y = option.y === <span class="number">0</span> ? <span class="number">0</span> : option.y || <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.w = option.w || <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.h = option.h || <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.angle = option.angle === <span class="number">0</span> ? <span class="number">0</span> : option.angle || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.fillStyle = option.fillStyle || <span class="string">'silver'</span>;</span><br><span class="line">        <span class="keyword">this</span>.strokeStyle = option.strokeStyle || <span class="string">'red'</span>;</span><br><span class="line">        <span class="keyword">this</span>.strokeWidth = option.strokeWidth || <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">this</span>.scaleX = option.scaleX || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.scaleY = option.Y || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.opactity = option.opactity || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.counterclockwise = </span><br><span class="line">            option.counterclockwise === <span class="literal">true</span> ? <span class="literal">true</span> : option.counterclockwise || <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.startAngle = option.startAngle == <span class="number">0</span> ? <span class="number">0</span> : option.startAngle || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.endAngle = option.endAngle == <span class="number">0</span> ? <span class="number">0</span> : option.endAngle || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.startAngle = <span class="keyword">this</span>.startAngle * Math.PI/<span class="number">180</span>;</span><br><span class="line">        <span class="keyword">this</span>.endAngle = <span class="keyword">this</span>.endAngle * Math.PI / <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">this</span>.r = option.r || <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function( ctx ) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate( <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">        ctx.scale( <span class="keyword">this</span>.scaleX, <span class="keyword">this</span>.scaleY );</span><br><span class="line">        ctx.rotate( <span class="keyword">this</span>.agnle * Math.PI / <span class="number">180</span> );</span><br><span class="line">        ctx.globalAlpha = <span class="keyword">this</span>.opacity;</span><br><span class="line">        ctx.fillStyle = <span class="keyword">this</span>.fillStyle;</span><br><span class="line">        ctx.strokeStyle = <span class="keyword">this</span>.strokeStyle;</span><br><span class="line">        ctx.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        ctx.arc( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.r, <span class="keyword">this</span>.startAngle, <span class="keyword">this</span>.endAngle, <span class="keyword">this</span>.counterclockwise);</span><br><span class="line">        ctx.fill();</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">constructor</span>: ItcastCircle</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第三方库使用"><a href="#第三方库使用" class="headerlink" title="第三方库使用"></a>第三方库使用</h2><ul><li>Rgraph vs 百度的echart</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>roopons.com.au<span class="regexp">/wp-content/</span>plugins<span class="regexp">/viral-optins/</span>js<span class="regexp">/rgraph/</span></span><br></pre></td></tr></table></figure><ul><li>国产的egret引擎</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>//www.egret-labs<span class="meta">.org</span>/</span><br></pre></td></tr></table></figure><ul><li>比较火的3d引擎：treejs</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>//threejs<span class="meta">.org</span>/</span><br></pre></td></tr></table></figure><ul><li>Konva</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">官网：http:<span class="comment">//konvajs.github.io/</span></span><br><span class="line">    特点：</span><br><span class="line"><span class="comment">     * 小巧、使用方便、适合移动端和pc端</span></span><br><span class="line"><span class="comment">     * 支持丰富的事件处理操作</span></span><br><span class="line"><span class="comment">     * 支持类似JQuery的操作方式（顺带能复习jQueyr）</span></span><br><span class="line"><span class="comment">     * 开源，可以随意更改</span></span><br><span class="line"><span class="comment">     * 社区更新比较活跃，github托管源码</span></span><br><span class="line"><span class="comment">     * 性能也不错</span></span><br></pre></td></tr></table></figure><ul><li>其他的还有很多，希望以后能用到你们的库。</li></ul><h1 id="Konva的使用快速上手"><a href="#Konva的使用快速上手" class="headerlink" title="Konva的使用快速上手"></a>Konva的使用快速上手</h1><h2 id="Konva的整体理念"><a href="#Konva的整体理念" class="headerlink" title="Konva的整体理念"></a>Konva的整体理念</h2><ul><li>舞台的概念的引入。整个视图看做是一个舞台 stage</li><li>舞台中可以绘制很多个层 layer</li><li>layer下面可以有很多的group</li><li>group下面可以有 矩形、图片、其他形状等</li><li>参看：快速上手文档—查看翻译文档</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">              Stage</span><br><span class="line">                |</span><br><span class="line">         +------+------+</span><br><span class="line">         |             |</span><br><span class="line">       Layer         Layer</span><br><span class="line">         |             |</span><br><span class="line">   +-----+-----+     Shape</span><br><span class="line">   |           |</span><br><span class="line"><span class="built_in"> Group </span>      Group</span><br><span class="line">   |           |</span><br><span class="line">   +       +---+---+</span><br><span class="line">   |       |       |</span><br><span class="line">Shape  <span class="built_in"> Group </span>   Shape</span><br><span class="line">           |</span><br><span class="line">           +</span><br><span class="line">           |</span><br><span class="line">         Shape</span><br></pre></td></tr></table></figure><h2 id="Konva矩形案例"><a href="#Konva矩形案例" class="headerlink" title="Konva矩形案例"></a>Konva矩形案例</h2><h3 id="创建一个矩形：-Konva-Rect-option"><a href="#创建一个矩形：-Konva-Rect-option" class="headerlink" title="创建一个矩形： Konva.Rect(option);"></a>创建一个矩形： Konva.Rect(option);</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Konva使用的基本案例</span></span><br><span class="line"><span class="comment">//第一步：创建舞台</span></span><br><span class="line">var stage = <span class="keyword">new</span> Konva.Stage(&#123;</span><br><span class="line">    container: <span class="string">'container'</span>,     <span class="comment">//需要存放舞台的Dom容器</span></span><br><span class="line">    <span class="built_in">width</span>: window.innerWidth,   <span class="comment">//设置全屏</span></span><br><span class="line">    <span class="built_in">height</span>: window.innerHeight</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：创建层</span></span><br><span class="line">var layer = <span class="keyword">new</span> Konva.Layer();  <span class="comment">//创建一个层</span></span><br><span class="line">stage.<span class="built_in">add</span>(layer);               <span class="comment">//把层添加到舞台</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步： 创建矩形</span></span><br><span class="line">var <span class="built_in">rect</span> = <span class="keyword">new</span> Konva.Rect(&#123;     <span class="comment">//创建一个矩形</span></span><br><span class="line">    x: <span class="number">100</span>,                     <span class="comment">//矩形的x坐标，相对其父容器的坐标</span></span><br><span class="line">    y: <span class="number">100</span>,                      </span><br><span class="line">    <span class="built_in">width</span>: <span class="number">100</span>,                 <span class="comment">//矩形的宽度</span></span><br><span class="line">    <span class="built_in">height</span>: <span class="number">100</span>,                <span class="comment">//矩形高度</span></span><br><span class="line">    <span class="built_in">fill</span>: <span class="string">'gold'</span>,               <span class="comment">//矩形填充的颜色</span></span><br><span class="line">    <span class="built_in">stroke</span>: <span class="string">'navy'</span>,             <span class="comment">//矩形描边的颜色</span></span><br><span class="line">    strokeWidth: <span class="number">4</span>,             <span class="comment">//填充宽度</span></span><br><span class="line">    opactity: <span class="number">.2</span>,               <span class="comment">//矩形的透明度</span></span><br><span class="line">    <span class="built_in">scale</span>: <span class="number">1.2</span>,                 <span class="comment">//矩形的缩放 1：原来大小</span></span><br><span class="line">    rotation: <span class="number">30</span>,               <span class="comment">//旋转的角度，是deg不是弧度。</span></span><br><span class="line">    cornerRadius: <span class="number">10</span>,           <span class="comment">//圆角的大小（像素） </span></span><br><span class="line">    id: <span class="string">'rect1'</span>,                <span class="comment">//id属性，类似dom的id属性</span></span><br><span class="line">    name: <span class="string">'rect'</span>,</span><br><span class="line">    draggable: <span class="keyword">true</span>             <span class="comment">//是否可以进行拖拽</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个组</span></span><br><span class="line">var group = <span class="keyword">new</span> Konva.Group(&#123;</span><br><span class="line">    x: <span class="number">40</span>,      </span><br><span class="line">    y: <span class="number">40</span>,</span><br><span class="line">&#125;);</span><br><span class="line">group.<span class="built_in">add</span>( <span class="built_in">rect</span> );  <span class="comment">//把矩形添加到组中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步： 把形状放到层中</span></span><br><span class="line">layer.<span class="built_in">add</span>( group ); <span class="comment">//把组添加到层中</span></span><br><span class="line">layer.<span class="title">draw</span>();       <span class="comment">//绘制层到舞台上</span></span><br></pre></td></tr></table></figure><h2 id="Konva的动画系统"><a href="#Konva的动画系统" class="headerlink" title="Konva的动画系统"></a>Konva的动画系统</h2><h3 id="tween对象-重点"><a href="#tween对象-重点" class="headerlink" title="tween对象(重点)"></a>tween对象(重点)</h3><ul><li>tween，英文意思：两者之间， 英 [twiːn]   美 [twin]</li><li>tween是控制Konva对象进行动画的核心对象。</li><li>tween可以控制所有数字类型的属性进行动画处理，比如：x, y, rotation,<br>width, height, radius, strokeWidth, opacity, scaleX等</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例：</span></span><br><span class="line">var tween = new Konva.Tween(&#123;</span><br><span class="line"><span class="symbol">    node:</span> rect,             <span class="comment">//要进行动画的Konva对象</span></span><br><span class="line"><span class="symbol">    x:</span> <span class="number">300</span>,                 <span class="comment">//要进行动画的属性</span></span><br><span class="line"><span class="symbol">    opacity:</span> <span class="number">.8</span>,            </span><br><span class="line"><span class="symbol">    duration:</span> <span class="number">1</span>,            <span class="comment">//持续时间</span></span><br><span class="line"><span class="symbol">    easing:</span> Konva.Easings.EaseIn, <span class="comment">//动画的动画效果</span></span><br><span class="line"><span class="symbol">    yoyo:</span> true,             <span class="comment">//是否进行循环播放的设置</span></span><br><span class="line"><span class="symbol">    onFinish:</span> function() &#123;</span><br><span class="line">        <span class="comment">//动画执行结束后，执行此方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">tween.play();   <span class="comment">//启动动画</span></span><br></pre></td></tr></table></figure><ul><li>tween的控制方法<ul><li>tween.play(),     //播放动画</li><li>tween.pause(),    //暂停动画</li><li>tween.reverse(),  //动画逆播放</li><li>tween.reset(),    //重置动画</li><li>tween.finish(),   //立即结束动画</li><li>seek：英文：寻找 英 [siːk]   美 [sik]</li></ul></li><li>tween的缓动控制选项<ul><li>Konva.Easings.Linear            //线性</li><li>Konva.Easings.EaseIn            //缓动，先慢后快</li><li>Konva.Easings.EaseOut //先快后慢</li><li>Konva.Easings.EaseInOut //两头慢，中间快</li><li>Konva.Easings.BackEaseIn //往回来一点，然后往前冲，汽车启动类似…</li><li>Konva.Easings.BackEaseOut</li><li>Konva.Easings.BackEaseInOut </li><li>Konva.Easings.ElasticEaseIn  //橡皮筋 英 [ɪ’læstɪk]   美 [ɪ’læstɪk] </li><li>Konva.Easings.ElasticEaseOut </li><li>Konva.Easings.ElasticEaseInOut </li><li>Konva.Easings.BounceEaseIn   //弹跳；弹起，反跳；弹回  英 [baʊns]   美 [baʊns]</li><li>Konva.Easings.BounceEaseOut </li><li>Konva.Easings.BounceEaseInOut </li><li>Konva.Easings.StrongEaseIn //强力</li><li>Konva.Easings.StrongEaseOut </li><li>Konva.Easings.StrongEaseInOut </li></ul></li><li>动画效果参考： 29Konva动画缓动效果案例.html</li></ul><h3 id="动画to的使用"><a href="#动画to的使用" class="headerlink" title="动画to的使用"></a>动画to的使用</h3><ul><li>to就是对tween的封装，比较简单好用。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例：</span></span><br><span class="line">var <span class="built_in">rect</span> = <span class="keyword">new</span> Konva.Rect(&#123;</span><br><span class="line">    x: <span class="number">10</span>,</span><br><span class="line">    y: <span class="number">10</span>,</span><br><span class="line">    <span class="built_in">width</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="built_in">height</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="built_in">fill</span>: <span class="string">'red'</span></span><br><span class="line">&#125;);</span><br><span class="line">layer.<span class="built_in">add</span>(<span class="built_in">rect</span>);</span><br><span class="line">layer.<span class="title">draw</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//动画系统</span></span><br><span class="line"><span class="built_in">rect</span>.to(&#123;</span><br><span class="line">    x: <span class="number">100</span>,</span><br><span class="line">    y: <span class="number">100</span>,</span><br><span class="line">    opactity: <span class="number">.1</span>,</span><br><span class="line">    duration: <span class="number">3</span>,</span><br><span class="line">    onFinish: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//to: 就是对tween的简单应用。</span></span><br></pre></td></tr></table></figure><h3 id="Animate的应用"><a href="#Animate的应用" class="headerlink" title="Animate的应用"></a>Animate的应用</h3><ul><li>Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anim = <span class="keyword">new</span> Konva.Animation(<span class="function"><span class="keyword">function</span><span class="params">(frame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//动画系统提供的frame有三个属性可以使用：</span></span><br><span class="line">    <span class="keyword">var</span> time = frame.time, <span class="comment">// 动画执行的总时间</span></span><br><span class="line">        timeDiff = frame.timeDiff, <span class="comment">// 距离上一帧的时间</span></span><br><span class="line">        frameRate = frame.frameRate; <span class="comment">// 帧率（既1000/间隔时间）</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//动画的动作</span></span><br><span class="line"></span><br><span class="line">&#125;, layer);</span><br><span class="line"></span><br><span class="line">anim.start();<span class="comment">//启动动画</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//anim.stop();//结束动画</span></span><br></pre></td></tr></table></figure><h3 id="循环播放动画的实现"><a href="#循环播放动画的实现" class="headerlink" title="循环播放动画的实现"></a>循环播放动画的实现</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总体思路，使用tween 配合onFinish事件中重新播放动画，达到循环播放的效果</span></span><br><span class="line"><span class="keyword">var</span> loopTween = <span class="keyword">new</span> Konva.Tween(&#123;</span><br><span class="line">    node: star, <span class="comment">//设置要表现动画的 Konva对象</span></span><br><span class="line">    rotation: <span class="number">360</span>,  <span class="comment">//旋转360度</span></span><br><span class="line">    duration: <span class="number">2</span>,    <span class="comment">//动画持续时间</span></span><br><span class="line">    easing: Konva.Easings.Linear,</span><br><span class="line">    onFinish: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this === loopTween //true</span></span><br><span class="line">        <span class="keyword">this</span>.reset();<span class="comment">//重置动画</span></span><br><span class="line">        <span class="keyword">this</span>.play(); <span class="comment">//重新播放动画</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">loopTween.play();</span><br></pre></td></tr></table></figure><h3 id="回放且循环播放动画"><a href="#回放且循环播放动画" class="headerlink" title="回放且循环播放动画"></a>回放且循环播放动画</h3><ul><li>yoyo属性可以进行对动画进行播放完后，回放当前动画，并持续循环来回切换播放。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rect</span><span class="selector-class">.to</span>(&#123;</span><br><span class="line">    <span class="attribute">duration</span>: <span class="number">2</span>,</span><br><span class="line">    scale: <span class="number">1.5</span>,</span><br><span class="line">    yoyo: true// 此设置也可以用于 tween</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="进度条案例"><a href="#进度条案例" class="headerlink" title="进度条案例"></a>进度条案例</h3><h3 id="传智官网案例"><a href="#传智官网案例" class="headerlink" title="传智官网案例"></a>传智官网案例</h3><ul><li>三角函数的补充<ul><li>Math.sin(弧度); //夹角对面的边 和 斜边的比值</li><li>Math.cos(弧度); //夹角侧边 与斜边的比值</li></ul></li><li>圆形上面的点的坐标的计算公式<ul><li>x =x0 + Math.cos(rad) * R;//x0和y0是圆心点坐标</li><li>y =y0 + Math.sin(rad) * R;//注意都是弧度<br><img src="/canvas/2019/05/11/canvas/圆形点的坐标计算公式.png" alt="圆形点的坐标计算公式"></li></ul></li><li>group的灵活运用<ul><li>konva的group很灵活，每个group都有自己的坐标系</li><li>group可以包含其他的group，可以对group做整个组的动画</li><li>group可以通过getChidren();//可以拿到直接子级元素。</li></ul></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var<span class="built_in"> group </span>= new Konva.Group(&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">&#125;);</span><br><span class="line">group.<span class="builtin-name">add</span>(rect);</span><br></pre></td></tr></table></figure><h2 id="Konva的事件（重要）"><a href="#Konva的事件（重要）" class="headerlink" title="Konva的事件（重要）"></a>Konva的事件（重要）</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">rect</span> = <span class="keyword">new</span> Konva.Rect(&#123;</span><br><span class="line">    <span class="attribute">x</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attribute">y</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attribute">fill</span>: <span class="string">'red'</span>,</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定事件 Konva支持事件：mouseover, mouseout, mouseenter, mouseleave, mousemove, mousedown, mouseup, mousewheel, click, dblclick, dragstart, dragmove, and dragend</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rect</span>.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//jQuery一模一样！！</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'^_^  ^_^'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定多个事件</span></span><br><span class="line"><span class="built_in">rect</span>.on(<span class="string">'click mousemove'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除绑定事件</span></span><br><span class="line"><span class="built_in">rect</span>.off(<span class="string">'click'</span>);             <span class="comment">//这不是jQuery吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line"><span class="built_in">rect</span>.fire(<span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消事件冒泡</span></span><br><span class="line"><span class="built_in">rect</span>.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'You clicked the circle!'</span>);</span><br><span class="line">  evt.cancelBubble = <span class="literal">true</span>;      <span class="comment">//取消事件冒泡</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Konva的选择器"><a href="#Konva的选择器" class="headerlink" title="Konva的选择器"></a>Konva的选择器</h2><ul><li>选择方法。<ul><li>ID选择法：stage.find(‘#id’); //此方法返回的是一个数组</li><li>name选择法：group.findOne(‘.name’);//返回一个Konva对象</li><li>type选择法： group.find(‘Circle’);//查找所有的圆形Konva对象</li></ul></li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组中查找圆形的Konva对象</span></span><br><span class="line">groupCircle.find(<span class="string">'Circle'</span>).each(<span class="function"><span class="keyword">function</span><span class="params">( circle, <span class="keyword">index</span> )</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    circle.setZIndex( 3 - index );</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br></pre></td></tr></table></figure><h3 id="饼状图案例"><a href="#饼状图案例" class="headerlink" title="饼状图案例"></a>饼状图案例</h3><ul><li>wedge: 楔形</li></ul><h3 id="柱状图案例"><a href="#柱状图案例" class="headerlink" title="柱状图案例"></a>柱状图案例</h3><ul><li>histogram n. [统计] 直方图；柱状图  英 [‘hɪstəgræm]   美 [‘hɪstəɡræm]</li></ul><h1 id="Canvas项目实战"><a href="#Canvas项目实战" class="headerlink" title="Canvas项目实战"></a>Canvas项目实战</h1><h1 id="Canvas优化"><a href="#Canvas优化" class="headerlink" title="Canvas优化"></a>Canvas优化</h1><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;canvas画布，不容小觑的“标签”，得有一定的数学几何底子，虽然目前我还是没用到就是了，但是以后总该会用到的，有想过利用canvas制作小游戏_〆(´Д｀ )&lt;/p&gt;

&lt;blockquote class=&quot;question&quot;&gt;canvas画布，顾名思义即是如图所示绘图的“工具”，然而并不简单(lll￢ω￢)~&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/canvas/2019/05/11/canvas/business-1031754_1280.jpg&quot; alt=&quot;business-1031754_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://jhjhljh.github.io/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://jhjhljh.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>bootstrap开发实例</title>
    <link href="http://jhjhljh.github.io/web%E5%BC%80%E5%8F%91/2019/05/11/web-bootstrap.html"/>
    <id>http://jhjhljh.github.io/web开发/2019/05/11/web-bootstrap.html</id>
    <published>2019-05-11T11:52:45.000Z</published>
    <updated>2019-05-11T15:34:20.009Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">去年参照Bootstrap文档测试尝试的微金所项目实战，搬到博客上来看看</p><blockquote class="question">让我累觉不爱的前端项目之一</blockquote><p><img src="/web开发/2019/05/11/web-bootstrap/mobile-phone-1875813_1280.jpg" alt="mobile-phone-1875813_1280"></p><a id="more"></a><blockquote class="question">代码之余让人有点想玩幻想魔录了</blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=750026&auto=1&height=32"></iframe><h1 id="微金所项目实战"><a href="#微金所项目实战" class="headerlink" title="微金所项目实战"></a>微金所项目实战</h1><h2 id="搭建Bootstrap页面骨架及项目目录结构"><a href="#搭建Bootstrap页面骨架及项目目录结构" class="headerlink" title="搭建Bootstrap页面骨架及项目目录结构"></a>搭建Bootstrap页面骨架及项目目录结构</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├─ /weijinsuo/ ··················· 项目所在目录</span><br><span class="line">└─┬─ /css/ ······················· 我们自己的CSS文件</span><br><span class="line">  ├─ /font/ ······················ 使用到的字体文件</span><br><span class="line">  ├─ /img/ ······················· 使用到的图片文件</span><br><span class="line">  ├─ /js/ ························ 自己写的JS脚步</span><br><span class="line">  ├─ /<span class="class"><span class="keyword">lib</span>/ ······················· 从第三方下载回来的库【只用不改】</span></span><br><span class="line">  ├─ /favicon.ico ················ 站点图标</span><br><span class="line">  └─ /index.html ················· 入口文件</span><br></pre></td></tr></table></figure><h3 id="约定编码规范"><a href="#约定编码规范" class="headerlink" title="约定编码规范"></a>约定编码规范</h3><h4 id="HTML约定"><a href="#HTML约定" class="headerlink" title="HTML约定"></a>HTML约定</h4><ul><li>在head中引入必要的CSS文件，优先引用第三方的CSS，方便我们自己的样式覆盖</li><li>在body末尾引入必要的JS文件，优先引用第三方的JS，注意JS文件之间的依赖关系，比如bootstrap.js依赖jQuery，那就应该先引用jquery.js 然后引用bootstrap.js</li></ul><h4 id="CSS约定"><a href="#CSS约定" class="headerlink" title="CSS约定"></a>CSS约定</h4><ul><li>除了公共级别样式，其余样式全部由 模块前缀</li><li>尽量使用 直接子代选择器， 少用间接子代 避免错杀</li></ul><h3 id="HTML5文档结构"><a href="#HTML5文档结构" class="headerlink" title="HTML5文档结构"></a>HTML5文档结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Viewport设置"><a href="#Viewport设置" class="headerlink" title="Viewport设置"></a>Viewport设置</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>html中插入视口设置，可以通过emmet <strong>meta:vp</strong> 插入</p></blockquote><h3 id="浏览器兼容模式"><a href="#浏览器兼容模式" class="headerlink" title="浏览器兼容模式"></a>浏览器兼容模式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>html中插入兼容模式设置，可以通过emmet <strong>meta:compat</strong> 插入</p></blockquote><h3 id="favicon（站点图标）"><a href="#favicon（站点图标）" class="headerlink" title="favicon（站点图标）"></a>favicon（站点图标）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> <span class="attr">href</span>=<span class="string">"favicon.ico"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>html中插入图标链接，可以通过emmet <strong>link:favicon</strong> 插入</p></blockquote><h3 id="引入相应的第三方文件"><a href="#引入相应的第三方文件" class="headerlink" title="引入相应的第三方文件"></a>引入相应的第三方文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bootstrap.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"my.css"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"my.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在我们默认的样式表中将默认字体设置为："><a href="#在我们默认的样式表中将默认字体设置为：" class="headerlink" title="在我们默认的样式表中将默认字体设置为："></a>在我们默认的样式表中将默认字体设置为：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Helvetica Neue"</span>, </span><br><span class="line">                Helvetica, </span><br><span class="line">                Microsoft Yahei, </span><br><span class="line">                Hiragino Sans GB, </span><br><span class="line">                WenQuanYi Micro Hei, </span><br><span class="line">                sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完成页面空结构"><a href="#完成页面空结构" class="headerlink" title="完成页面空结构"></a>完成页面空结构</h2><blockquote><p>先划分好页面中的大容器，然后在具体看每一个容器中单独的情况</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 头部区域 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /头部区域 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 广告轮播 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /广告轮播 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 特色介绍 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /特色介绍 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 立即预约 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /立即预约 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 产品推荐 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /产品推荐 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 新闻列表 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /新闻列表 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 合作伙伴 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /合作伙伴 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 脚注区域 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /脚注区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="构建顶部通栏"><a href="#构建顶部通栏" class="headerlink" title="构建顶部通栏"></a>构建顶部通栏</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topbar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="container类"><a href="#container类" class="headerlink" title="container类"></a>container类</h3><ul><li>用于定义一个固定宽度且居中的版心</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topbar"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      此处的代码会显示在一个固定宽度且居中的容器中</span></span><br><span class="line"><span class="comment">      该容器的宽度会跟随屏幕的变化而变化</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><ul><li>Bootstrap中定义了一套响应式的网格系统，</li><li>其使用方式就是将一个容器划分成12列，</li><li>然后通过col-xx-xx的类名控制每一列的占比</li></ul><h4 id="row类"><a href="#row类" class="headerlink" title="row类"></a>row类</h4><ul><li>因为每一个列默认有一个15px的左右外边距</li><li>row类的一个作用就是通过左右-15px屏蔽掉这个边距</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="col-类"><a href="#col-类" class="headerlink" title="col-\-*类"></a>col-<em>\</em>-*类</h4><ul><li>col-xs-[列数]：在超小屏幕下展示几份</li><li>col-sm-[列数]：在小屏幕下展示几份</li><li>col-md-[列数]：在中等屏幕下展示几份</li><li>col-lg-[列数]：在大屏幕下展示几份</li><li><strong>xs</strong> : 超小屏幕 手机 (&lt;768px)  </li><li><strong>sm</strong> : 小屏幕 平板 (≥768px) </li><li><strong>md</strong> : 中等屏幕 桌面显示器 (≥992px) </li><li><strong>lg</strong> : 大屏幕 大桌面显示器 (≥1200px)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-2 text-center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-5 text-center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-2 text-center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 text-center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此处顶部通栏已经被划分成四列<br>text-center的作用就是让内部内容居中显示</p></blockquote><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'itcast'</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'../font/MiFie-Web-Font.eot'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>), <span class="built_in">url</span>(<span class="string">'../font/MiFie-Web-Font.svg'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>), <span class="built_in">url</span>(<span class="string">'../font/MiFie-Web-Font.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>), <span class="built_in">url</span>(<span class="string">'../font/MiFie-Web-Font.woff'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[class^="icon-"]</span>,</span><br><span class="line"><span class="selector-attr">[class*=" icon-"]</span> &#123;</span><br><span class="line">  <span class="comment">/*注意上面选择器中间的空格*/</span></span><br><span class="line">  <span class="comment">/*我们使用的名为itcast的字体就是上面的@font-face的方式声明的*/</span></span><br><span class="line">  <span class="attribute">font-family</span>: itcast;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-mobilephone</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'\e908'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-2 text-center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mobile-link"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-mobile"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>手机微金所<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里使用的是bootstrap中的字体图标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-chevron-down"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="字体文件格式"><a href="#字体文件格式" class="headerlink" title="字体文件格式"></a>字体文件格式</h4><ul><li>eot : embedded-opentype</li><li>svg : svg</li><li>ttf : truetype</li><li>woff : woff</li></ul><h3 id="hover图片展示"><a href="#hover图片展示" class="headerlink" title="hover图片展示"></a>hover图片展示</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mobile-link</span><span class="selector-pseudo">:hover</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按钮样式生成"><a href="#按钮样式生成" class="headerlink" title="按钮样式生成"></a>按钮样式生成</h3><ul><li><a href="http://blog.koalite.com/bbg/" target="_blank" rel="noopener">http://blog.koalite.com/bbg/</a></li><li>可以通过界面生成一个新的按钮样式</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-itcast</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#E92322</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#DB3B43</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-pseudo">:focus</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-pseudo">:active</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-class">.active</span>,</span><br><span class="line"><span class="selector-class">.open</span> <span class="selector-class">.dropdown-toggle</span><span class="selector-class">.btn-itcast</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#E92322</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#DB3B43</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-pseudo">:active</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-class">.active</span>,</span><br><span class="line"><span class="selector-class">.open</span> <span class="selector-class">.dropdown-toggle</span><span class="selector-class">.btn-itcast</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-class">.disabled</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-attr">[disabled]</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span><span class="selector-attr">[disabled]</span> <span class="selector-class">.btn-itcast</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-class">.disabled</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-attr">[disabled]</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span><span class="selector-attr">[disabled]</span> <span class="selector-class">.btn-itcast</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-class">.disabled</span><span class="selector-pseudo">:focus</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-attr">[disabled]</span><span class="selector-pseudo">:focus</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span><span class="selector-attr">[disabled]</span> <span class="selector-class">.btn-itcast</span><span class="selector-pseudo">:focus</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-class">.disabled</span><span class="selector-pseudo">:active</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-attr">[disabled]</span><span class="selector-pseudo">:active</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span><span class="selector-attr">[disabled]</span> <span class="selector-class">.btn-itcast</span><span class="selector-pseudo">:active</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-class">.disabled</span><span class="selector-class">.active</span>,</span><br><span class="line"><span class="selector-class">.btn-itcast</span><span class="selector-attr">[disabled]</span><span class="selector-class">.active</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span><span class="selector-attr">[disabled]</span> <span class="selector-class">.btn-itcast</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#E92322</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#DB3B43</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-itcast</span> <span class="selector-class">.badge</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#E92322</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小屏幕隐藏"><a href="#小屏幕隐藏" class="headerlink" title="小屏幕隐藏"></a>小屏幕隐藏</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topbar hidden-xs hidden-sm"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topbar visible-md visible-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>hidden-xx</strong> : 在某种屏幕下隐藏 </li><li><strong>visible-xx</strong> : 在某种屏幕尺寸下显示</li></ul><h2 id="导航通栏"><a href="#导航通栏" class="headerlink" title="导航通栏"></a>导航通栏</h2><ul><li>在使用了boostrap过后，大多数界面元素都是通过bootstrap提供好的界面组件修改得来</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-itcast navbar-static-top"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"navbar-toggle collapsed"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">"#nav_list"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>切换菜单<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav_list"</span> <span class="attr">class</span>=<span class="string">"collapse navbar-collapse"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>我要投资<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>我要借款<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>平台介绍<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>新手专区<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新动态<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>微论坛<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav navbar-right hidden-sm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bootstrap扩展"><a href="#Bootstrap扩展" class="headerlink" title="Bootstrap扩展"></a>Bootstrap扩展</h3><ul><li>通过bootstrap文档对导航条样式的设置发现，其实本身是有一个类似于主题的概念</li><li>navbar-default：默认的外观</li><li>navbar-inverse：暗色背景的样式</li><li>所以我们希望可以通过自定义一套完整的风格：<ul><li>navbar-itcast</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar-itcast</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...具体代码参考<span class="selector-tag">navbar-default</span>实现即可</span><br></pre></td></tr></table></figure><h3 id="品牌logo"><a href="#品牌logo" class="headerlink" title="品牌logo"></a>品牌logo</h3><ul><li>任然使用字体图标</li></ul><h3 id="菜单行高调整"><a href="#菜单行高调整" class="headerlink" title="菜单行高调整"></a>菜单行高调整</h3><ul><li>默认样式中菜单的行高为20px，我们可以调整为自己想要的高度</li><li>一般都是通过自己的样式去覆盖</li></ul><h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><h3 id="Bootstrap-JS插件使用"><a href="#Bootstrap-JS插件使用" class="headerlink" title="Bootstrap JS插件使用"></a>Bootstrap JS插件使用</h3><blockquote><p>对于Bootstrap的JS插件，我们只需要将文档实例中的代码粘到我们自己的代码中<br>让后作出相应的样式调整</p></blockquote><h4 id="Bootstrap中轮播图插件叫作Carousel"><a href="#Bootstrap中轮播图插件叫作Carousel" class="headerlink" title="Bootstrap中轮播图插件叫作Carousel"></a>Bootstrap中轮播图插件叫作Carousel</h4><h4 id="基本的轮播图实现"><a href="#基本的轮播图实现" class="headerlink" title="基本的轮播图实现"></a>基本的轮播图实现</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  以下容器就是整个轮播图组件的整体，</span></span><br><span class="line"><span class="comment">  注意该盒子必须加上 class="carousel slide" data-ride="carousel" 表示当前是一个轮播图</span></span><br><span class="line"><span class="comment">  bootstrap.js会自动为当前元素添加图片轮播的特效</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"轮播图的ID"</span> <span class="attr">class</span>=<span class="string">"carousel slide"</span> <span class="attr">data-ride</span>=<span class="string">"carousel"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ol标签是图片轮播的控制点 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"carousel-indicators"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">      每一个li就是一个单独的控制点</span></span><br><span class="line"><span class="comment">        data-target属性就是指定当前控制点控制的是哪一个轮播图，其目的是如果界面上有多个轮播图，便于区分到底控制哪一个</span></span><br><span class="line"><span class="comment">        data-slide-to属性是指当前的li元素绑定的是第几个轮播项</span></span><br><span class="line"><span class="comment">      注意，默认必须给其中某个li加上active，展示的时候就是焦点项目</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">"#轮播图的ID"</span> <span class="attr">data-slide-to</span>=<span class="string">"0"</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">"#轮播图的ID"</span> <span class="attr">data-slide-to</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ...更多的 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    .carousel-inner是所有轮播项的容器盒子，</span></span><br><span class="line"><span class="comment">    注意role="listbox"代表当前div是一个列表盒子，作用就是给当前div添加一个语义</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"carousel-inner"</span> <span class="attr">role</span>=<span class="string">"listbox"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每一个.item就是单个轮播项目，注意默认要给第一个轮播项目加上active，表示为焦点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item active"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 轮播项目中展示的图片 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.jpg"</span> <span class="attr">alt</span>=<span class="string">"示例图片"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"carousel-caption"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标题或说明性文字，如果不需要，直接删除当前div.carousel-caption --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 图片轮播上左右两个控制按钮，分别点击可以滚动到上一张和下一张 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 此处需要注意的是 该a链接的href属性必须指向需要控制的轮播图ID --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 另外a链接中的data-slide="prev"代表点击该链接会滚到上一张，如果设置为next的话则相反 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"left carousel-control"</span> <span class="attr">href</span>=<span class="string">"#轮播图的ID"</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">data-slide</span>=<span class="string">"prev"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-chevron-left"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>上一张<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"right carousel-control"</span> <span class="attr">href</span>=<span class="string">"#轮播图的ID"</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">data-slide</span>=<span class="string">"next"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-chevron-right"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>下一张<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="由于轮播图片超宽造成的影响"><a href="#由于轮播图片超宽造成的影响" class="headerlink" title="由于轮播图片超宽造成的影响"></a>由于轮播图片超宽造成的影响</h4><ul><li>美工为了在不同屏幕下更好地展示将图片两边做的非常宽，但是我们大多数情况的页面宽度都无法满足这样的图片宽度</li><li>而且Bootstrap的样式中默认将图片的max-width设置为100%；</li><li>造成界面图片缩放</li><li>想在一个较小屏幕下展示一个超宽的图片，并让图片居中显示<ul><li>两种办法：<ul><li>换用背景图的方式，background-position: center center;</li><li>使img元素绝对定位，left:50%，margin-left: -width/2</li></ul></li></ul></li></ul><h3 id="background使用"><a href="#background使用" class="headerlink" title="background使用"></a>background使用</h3><ul><li>将容器的高度固定（410px）</li><li>将轮播图改为背景显示</li><li>由于可能图片的高度不一定是410px</li><li>所以需要设置css3中的background-size</li></ul><h4 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h4><ul><li>length<ul><li>如 background-size: 100px 100px，将背景图固定到多大尺寸</li></ul></li><li>percentage<ul><li>如 background-size: 90% 90%，以百分比的形式设置背景大小</li></ul></li><li>cover<ul><li>1.背景图片等比例缩放</li><li>2.让背景图相对较小边放大到目标容器大小结束<ul><li>如：一张100*200的背景图放到一个300*400的盒子中，最终背景图片的大小是300*600</li><li>因为背景图的较小边为100，将100放大到目标容器300的宽度，放大了3倍，最终结果300*600</li></ul></li></ul></li><li>contain<ul><li>1.背景图片等比例缩放</li><li>2.让背景图相对较大边放大到目标容器大小结束<ul><li>如：一张100*200的背景图放到一个300*400的盒子中，最终背景图片的大小是200*400</li><li>因为背景图的较大边为200，将200放大到目标容器400的高度，放大了2倍，最终结果200*400</li></ul></li></ul></li></ul><h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><h6 id="cover"><a href="#cover" class="headerlink" title="cover"></a>cover</h6><div style="width: 400px;height: 200px;border:1px dashed #c0c0c0;background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMjQyIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDI0MiAyMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjwhLS0KU291cmNlIFVSTDogaG9sZGVyLmpzLzEwMCV4MjAwCkNyZWF0ZWQgd2l0aCBIb2xkZXIuanMgMi42LjAuCkxlYXJuIG1vcmUgYXQgaHR0cDovL2hvbGRlcmpzLmNvbQooYykgMjAxMi0yMDE1IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jbwotLT48ZGVmcz48c3R5bGUgdHlwZT0idGV4dC9jc3MiPjwhW0NEQVRBWyNob2xkZXJfMTUxOWU5ZmNjZDAgdGV4dCB7IGZpbGw6I0FBQUFBQTtmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIE9wZW4gU2Fucywgc2Fucy1zZXJpZiwgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMnB0IH0gXV0+PC9zdHlsZT48L2RlZnM+PGcgaWQ9ImhvbGRlcl8xNTE5ZTlmY2NkMCI+PHJlY3Qgd2lkdGg9IjI0MiIgaGVpZ2h0PSIyMDAiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSI4OS44NTkzNzUiIHk9IjEwNS4xIj4yNDJ4MjAwPC90ZXh0PjwvZz48L2c+PC9zdmc+');background-repeat:no-repeat;background-size: cover;"></div><h6 id="contain"><a href="#contain" class="headerlink" title="contain"></a>contain</h6><div style="width: 400px;height: 200px;border:1px dashed #c0c0c0;background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMjQyIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDI0MiAyMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjwhLS0KU291cmNlIFVSTDogaG9sZGVyLmpzLzEwMCV4MjAwCkNyZWF0ZWQgd2l0aCBIb2xkZXIuanMgMi42LjAuCkxlYXJuIG1vcmUgYXQgaHR0cDovL2hvbGRlcmpzLmNvbQooYykgMjAxMi0yMDE1IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jbwotLT48ZGVmcz48c3R5bGUgdHlwZT0idGV4dC9jc3MiPjwhW0NEQVRBWyNob2xkZXJfMTUxOWU5ZmNjZDAgdGV4dCB7IGZpbGw6I0FBQUFBQTtmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIE9wZW4gU2Fucywgc2Fucy1zZXJpZiwgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMnB0IH0gXV0+PC9zdHlsZT48L2RlZnM+PGcgaWQ9ImhvbGRlcl8xNTE5ZTlmY2NkMCI+PHJlY3Qgd2lkdGg9IjI0MiIgaGVpZ2h0PSIyMDAiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSI4OS44NTkzNzUiIHk9IjEwNS4xIj4yNDJ4MjAwPC90ZXh0PjwvZz48L2c+PC9zdmc+');background-repeat:no-repeat;background-size: contain;"></div><h3 id="图片响应式"><a href="#图片响应式" class="headerlink" title="图片响应式"></a>图片响应式</h3><ul><li>目的<ul><li>各种终端都需要正常显示图片</li><li>移动端应该使用更小（体积）的图片</li></ul></li><li>实现方式<ul><li>将元素中直接设置的图片背景删除，换成两个data-属性（如：data-img-sm=”小图路径”，data-img-lg=”大图路径”）</li><li>通过JS的方式获取屏幕的宽度；</li><li>判断屏幕宽度是否小于一定的值（如：768）</li><li>根据判断情况决定使用具体的大图还是小图</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取屏幕宽度</span></span><br><span class="line"><span class="keyword">var</span> windowWidth = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="comment">// 判断屏幕属于大还是小</span></span><br><span class="line"><span class="keyword">var</span> isSmallScreen = windowWidth &lt; <span class="number">768</span>;</span><br><span class="line"><span class="comment">// 根据大小为界面上的每一张轮播图设置背景</span></span><br><span class="line"><span class="comment">// $('#main_ad &gt; .carousel-inner &gt; .item') // 获取到的是一个DOM数组（多个元素）</span></span><br><span class="line">$(<span class="string">'#main_ad &gt; .carousel-inner &gt; .item'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i, item</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 因为拿到是DOM对象 需要转换</span></span><br><span class="line">  <span class="keyword">var</span> $item = $(item);</span><br><span class="line">  <span class="comment">// var imgSrc = $item.data(isSmallScreen ? 'image-xs' : 'image-lg');</span></span><br><span class="line">  <span class="keyword">var</span> imgSrc =</span><br><span class="line">    isSmallScreen ? $item.data(<span class="string">'image-xs'</span>) : $item.data(<span class="string">'image-lg'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置背景图片</span></span><br><span class="line">  $item.css(<span class="string">'backgroundImage'</span>, <span class="string">'url("'</span> + imgSrc + <span class="string">'")'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="window-resize事件"><a href="#window-resize事件" class="headerlink" title="window resize事件"></a>window resize事件</h3><ul><li>由于上一步我们实现的过程是指在页面加载完成判断一次，</li><li>当用户手动调整页面宽度过后没有及时发生变化，</li><li>所以我们可以通过window的resize事件中重新完成以上操作来解决这个问题</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 窗口变化后执行的函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 具体的操作</span></span><br><span class="line">&#125;</span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, 窗口变化后执行的函数名);</span><br></pre></td></tr></table></figure><ul><li>这个事件只会在窗口尺寸发生变化后执行，但是我们需要一开始时执行一次</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, 窗口变化后执行的函数名).trigger(<span class="string">'resize'</span>);</span><br></pre></td></tr></table></figure><h3 id="小图片不需要使用背景的方式"><a href="#小图片不需要使用背景的方式" class="headerlink" title="小图片不需要使用背景的方式"></a>小图片不需要使用背景的方式</h3><ul><li>小图如果还是使用背景的方式，当屏幕特别小时，效果很差</li><li>所以当使用小图时，改用img的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为我们需要小图时 尺寸等比例变化，所以小图时我们使用img方式</span></span><br><span class="line"><span class="keyword">if</span> (isSmallScreen) &#123;</span><br><span class="line">  $item.html(<span class="string">'&lt;img src="'</span> + imgSrc + <span class="string">'" alt="" /&gt;'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  $item.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按照目前的情况，如果是小图展示则不需要给容器加上410px的固定高度</li><li>所以我们可以通过CSS媒体查询的方式解决</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main_ad</span> &gt; <span class="selector-class">.carousel-inner</span> &gt; <span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-id">#main_ad</span> &gt; <span class="selector-class">.carousel-inner</span> &gt; <span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">410px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main_ad</span> &gt; <span class="selector-class">.carousel-inner</span> &gt; <span class="selector-class">.item</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网站特性"><a href="#网站特性" class="headerlink" title="网站特性"></a>网站特性</h2><h3 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a>网格系统</h3><ul><li>该板块当屏幕为中等尺寸时分为3列，较小屏幕是分为2列</li><li>所以使用网格系统划分</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6 col-md-4"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="媒体对象样式"><a href="#媒体对象样式" class="headerlink" title="媒体对象样式"></a>媒体对象样式</h3><ul><li>每一个小块的样式可以通过Bootstrap中的媒体对象样式实现</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"media"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"media-left"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-uniE907"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"media-body"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"media-heading"</span>&gt;</span>支付交易保障<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>银联支付全称保证支付安全<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="响应式辅助类型"><a href="#响应式辅助类型" class="headerlink" title="响应式辅助类型"></a>响应式辅助类型</h3><ul><li>整个板块在超小屏幕下是隐藏起来的<ul><li>只需要给当前板块加上hidden-xs的class</li></ul></li></ul><h2 id="预约投标"><a href="#预约投标" class="headerlink" title="预约投标"></a>预约投标</h2><h3 id="pull-left"><a href="#pull-left" class="headerlink" title="pull-left"></a>pull-left</h3><ul><li>左边文字段落</li></ul><h3 id="pull-right"><a href="#pull-right" class="headerlink" title="pull-right"></a>pull-right</h3><ul><li>右边文字段落</li></ul><h2 id="投资产品"><a href="#投资产品" class="headerlink" title="投资产品"></a>投资产品</h2><h3 id="Tab选项卡"><a href="#Tab选项卡" class="headerlink" title="Tab选项卡"></a>Tab选项卡</h3><blockquote><p>选项卡功能可以通过Bootstrap中提供的相应组件实现<br><a href="http://v3.bootcss.com/javascript/#tabs" target="_blank" rel="noopener">http://v3.bootcss.com/javascript/#tabs</a></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 所有的选项卡标签，每个标签点击分别对应面板展示出来 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav nav-tabs"</span> <span class="attr">role</span>=<span class="string">"tablist"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">      下面的li定义了一个选项卡的标签，其中a标签的href属性指向的就是对应要展开的面板ID</span></span><br><span class="line"><span class="comment">      aria-controls属性是说当前a链接控制的是哪个元素（注意此属性和功能无关，只是语义）</span></span><br><span class="line"><span class="comment">      注意一定要给a标签加上data-toggle="tab"，如果不加则boostrap无法知道这是一个选项卡标签，也就不会有相应的效果</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">role</span>=<span class="string">"presentation"</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#第一个标签的ID"</span> <span class="attr">aria-controls</span>=<span class="string">"第一个标签的ID"</span> <span class="attr">role</span>=<span class="string">"tab"</span> <span class="attr">data-toggle</span>=<span class="string">"tab"</span>&gt;</span>标签页1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">role</span>=<span class="string">"presentation"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#第二个标签的ID"</span> <span class="attr">aria-controls</span>=<span class="string">"第二个标签的ID"</span> <span class="attr">role</span>=<span class="string">"tab"</span> <span class="attr">data-toggle</span>=<span class="string">"tab"</span>&gt;</span>标签页2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Tab panes --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-content"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- .tab-pane定义当前是一个tab面板，通过id和选项卡标签关联起来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">"tabpanel"</span> <span class="attr">class</span>=<span class="string">"tab-pane active"</span> <span class="attr">id</span>=<span class="string">"第一个标签的ID"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 标签展开后的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">"tabpanel"</span> <span class="attr">class</span>=<span class="string">"tab-pane"</span> <span class="attr">id</span>=<span class="string">"第二个标签的ID"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="网格系统-1"><a href="#网格系统-1" class="headerlink" title="网格系统"></a>网格系统</h3><ul><li>和网站特色板块的网格系统定义一样</li></ul><h3 id="before-after"><a href="#before-after" class="headerlink" title="::before ::after"></a>::before ::after</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel-czbk</span> &gt; <span class="selector-class">.panel-heading</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.panel-czbk</span> &gt; <span class="selector-class">.panel-heading</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel-czbk</span> &gt; <span class="selector-class">.panel-heading</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel-czbk</span> &gt; <span class="selector-class">.panel-heading</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">1px</span> <span class="number">#ccc</span> inset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tooltip插件"><a href="#tooltip插件" class="headerlink" title="tooltip插件"></a>tooltip插件</h3><ul><li>注意，bootstrap中的tooltip插件必须通过js方式初始化</li></ul><h3 id="选项卡标签横向滚动"><a href="#选项卡标签横向滚动" class="headerlink" title="选项卡标签横向滚动"></a>选项卡标签横向滚动</h3><ol><li>要给ul加一个容器，这个容器有横向滚动条</li><li>动态设置ul的宽度，宽度是根据内容大小决定的<br>width= sum (li.width)</li></ol><h2 id="新闻资讯"><a href="#新闻资讯" class="headerlink" title="新闻资讯"></a>新闻资讯</h2><h3 id="Tab选项卡-1"><a href="#Tab选项卡-1" class="headerlink" title="Tab选项卡"></a>Tab选项卡</h3><h3 id="响应式偏移"><a href="#响应式偏移" class="headerlink" title="响应式偏移"></a>响应式偏移</h3><h2 id="合作伙伴"><a href="#合作伙伴" class="headerlink" title="合作伙伴"></a>合作伙伴</h2><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><h2 id="登录对话框"><a href="#登录对话框" class="headerlink" title="登录对话框"></a>登录对话框</h2><h3 id="模态框"><a href="#模态框" class="headerlink" title="模态框"></a>模态框</h3><h3 id="表单样式"><a href="#表单样式" class="headerlink" title="表单样式"></a>表单样式</h3><h2 id="导航吸顶"><a href="#导航吸顶" class="headerlink" title="导航吸顶"></a>导航吸顶</h2><h3 id="affix组件"><a href="#affix组件" class="headerlink" title="affix组件"></a>affix组件</h3><h2 id="深度自定义"><a href="#深度自定义" class="headerlink" title="深度自定义"></a>深度自定义</h2><h3 id="http-v3-bootcss-com-customize"><a href="#http-v3-bootcss-com-customize" class="headerlink" title="http://v3.bootcss.com/customize"></a><a href="http://v3.bootcss.com/customize" target="_blank" rel="noopener">http://v3.bootcss.com/customize</a></h3><h3 id="通过-Less-文件修改"><a href="#通过-Less-文件修改" class="headerlink" title="通过 Less 文件修改"></a>通过 Less 文件修改</h3><h2 id="version-4"><a href="#version-4" class="headerlink" title="version 4"></a>version 4</h2><p><a href="http://www.cnblogs.com/micua/p/bootstrap-version4-alpha.html" target="_blank" rel="noopener">http://www.cnblogs.com/micua/p/bootstrap-version4-alpha.html</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;去年参照Bootstrap文档测试尝试的微金所项目实战，搬到博客上来看看&lt;/p&gt;

&lt;blockquote class=&quot;question&quot;&gt;让我累觉不爱的前端项目之一&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/web开发/2019/05/11/web-bootstrap/mobile-phone-1875813_1280.jpg&quot; alt=&quot;mobile-phone-1875813_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web开发" scheme="http://jhjhljh.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="bootstrap" scheme="http://jhjhljh.github.io/tags/bootstrap/"/>
    
      <category term="web开发" scheme="http://jhjhljh.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>VueJs学习笔记-Day6</title>
    <link href="http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day6.html"/>
    <id>http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day6.html</id>
    <published>2019-05-11T03:50:05.000Z</published>
    <updated>2019-05-11T04:09:39.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">继续介绍webpack以及Element饿了么组件</p><p><img src="/Vue-js/2019/05/11/Vue-Day6/wordpress-265132_1280.jpg" alt="wordpress-265132_1280"></p><a id="more"></a><h1 id="Vue-js-day6"><a href="#Vue-js-day6" class="headerlink" title="Vue.js - day6"></a>Vue.js - day6</h1><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>有时候使用<code>npm i node-sass -D</code>装不上，这时候，就必须使用 <code>cnpm i node-sass -D</code></p><h2 id="在普通页面中使用render函数渲染组件"><a href="#在普通页面中使用render函数渲染组件" class="headerlink" title="在普通页面中使用render函数渲染组件"></a>在普通页面中使用render函数渲染组件</h2><h2 id="在webpack中配置-vue组件页面的解析"><a href="#在webpack中配置-vue组件页面的解析" class="headerlink" title="在webpack中配置.vue组件页面的解析"></a>在webpack中配置.vue组件页面的解析</h2><ol><li><p>运行<code>cnpm i vue -S</code>将vue安装为运行依赖；</p></li><li><p>运行<code>cnpm i vue-loader vue-template-compiler -D</code>将解析转换vue的包安装为开发依赖；</p></li><li><p>运行<code>cnpm i style-loader css-loader -D</code>将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式；</p></li><li><p>在<code>webpack.config.js</code>中，添加如下<code>module</code>规则：</p></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">module</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">rules</span>: [</span><br><span class="line"></span><br><span class="line">      &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;,</span><br><span class="line"></span><br><span class="line">      &#123; test: /\.vue$/, use: 'vue-loader' &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建<code>App.js</code>组件页面：</li></ol><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是APP组件 - </span><span class="template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  data() &#123;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    return &#123;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      msg: 'OK'</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">h1 &#123;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  color: red;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="6"><li>创建<code>main.js</code>入口文件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 导入 Vue 组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 App组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App.vue'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Vue 实例，使用 render 函数，渲染指定的组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"></span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="params">c</span> =&gt;</span> c(App)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="在使用webpack构建的Vue项目中使用模板对象？"><a href="#在使用webpack构建的Vue项目中使用模板对象？" class="headerlink" title="在使用webpack构建的Vue项目中使用模板对象？"></a>在使用webpack构建的Vue项目中使用模板对象？</h2><ol><li>在<code>webpack.config.js</code>中添加<code>resolve</code>属性：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">resolve</span>: &#123;</span><br><span class="line">    <span class="attribute">alias</span>: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="ES6中语法使用总结"><a href="#ES6中语法使用总结" class="headerlink" title="ES6中语法使用总结"></a>ES6中语法使用总结</h2><ol><li><p>使用 <code>export default</code> 和 <code>export</code> 导出模块中的成员; 对应ES5中的 <code>module.exports</code> 和 <code>export</code></p></li><li><p>使用 <code>import ** from **</code> 和 <code>import &#39;路径&#39;</code> 还有 <code>import {a, b} from &#39;模块标识&#39;</code> 导入其他模块</p></li><li><p>使用箭头函数：<code>(a, b)=&gt; { return a-b; }</code></p></li></ol><h2 id="在vue组件页面中，集成vue-router路由模块"><a href="#在vue组件页面中，集成vue-router路由模块" class="headerlink" title="在vue组件页面中，集成vue-router路由模块"></a>在vue组件页面中，集成vue-router路由模块</h2><p><a href="https://router.vuejs.org/" target="_blank" rel="noopener">vue-router官网</a></p><ol><li>导入路由模块：</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装路由模块：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.use(VueRouter)<span class="comment">;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>导入需要展示的组件:</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">'./components/account/login.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> register <span class="keyword">from</span> <span class="string">'./components/account/register.vue'</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建路由对象:</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"></span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/'</span>, <span class="string">redirect:</span> <span class="string">'/login'</span> &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">component:</span> login &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/register'</span>, <span class="string">component:</span> register &#125;</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>将路由对象，挂载到 Vue 实例上:</li></ol><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line"></span><br><span class="line">  el: '#app',</span><br><span class="line"></span><br><span class="line">  // render: c =&gt; &#123; return c(<span class="name">App</span>) &#125;</span><br><span class="line"></span><br><span class="line">  render(<span class="name">c</span>) &#123;</span><br><span class="line"></span><br><span class="line">    return c(<span class="name">App</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  router // 将路由对象，挂载到 Vue 实例上</span><br><span class="line"></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>改造App.vue组件，在 template 中，添加<code>router-link</code>和<code>router-view</code>：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件中的css作用域问题"><a href="#组件中的css作用域问题" class="headerlink" title="组件中的css作用域问题"></a>组件中的css作用域问题</h2><h2 id="抽离路由为单独的模块"><a href="#抽离路由为单独的模块" class="headerlink" title="抽离路由为单独的模块"></a>抽离路由为单独的模块</h2><h2 id="使用-饿了么的-MintUI-组件"><a href="#使用-饿了么的-MintUI-组件" class="headerlink" title="使用 饿了么的 MintUI 组件"></a>使用 饿了么的 MintUI 组件</h2><p><a href="https://github.com/ElemeFE/mint-ui" target="_blank" rel="noopener">Github 仓储地址</a></p><p><a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">Mint-UI官方文档</a></p><ol><li>导入所有MintUI组件：</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> MintUI <span class="keyword">from</span> <span class="string">'mint-ui'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>导入样式表：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'mint-ui/lib/style.css'</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 vue 中使用 MintUI：</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.<span class="keyword">use</span>(MintUI)</span><br></pre></td></tr></table></figure><ol start="4"><li>使用的例子：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;mt-button <span class="attribute">type</span>=<span class="string">"primary"</span> <span class="attribute">size</span>=<span class="string">"large"</span>&gt;primary&lt;/mt-button&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-MUI-组件"><a href="#使用-MUI-组件" class="headerlink" title="使用 MUI 组件"></a>使用 MUI 组件</h2><p><a href="http://dev.dcloud.net.cn/mui/" target="_blank" rel="noopener">官网首页</a></p><p><a href="http://dev.dcloud.net.cn/mui/ui/" target="_blank" rel="noopener">文档地址</a></p><ol><li>导入 MUI 的样式表：</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">import</span></span> <span class="string">'../lib/mui/css/mui.min.css'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>webpack.config.js</code>中添加新的loader规则：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; <span class="attribute">test</span>: /\.(png|jpg|gif|ttf)$/, use: <span class="string">'url-loader'</span> &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>根据官方提供的文档和example，尝试使用相关的组件</li></ol><h2 id="将项目源码托管到oschina中"><a href="#将项目源码托管到oschina中" class="headerlink" title="将项目源码托管到oschina中"></a>将项目源码托管到oschina中</h2><ol><li><p>点击头像 -&gt; 修改资料 -&gt; SSH公钥 <a href="http://git.mydoc.io/?t=154712" target="_blank" rel="noopener">如何生成SSH公钥</a></p></li><li><p>创建自己的空仓储，使用 <code>git config --global user.name &quot;用户名&quot;</code> 和 <code>git config --global user.email ***@**.com</code> 来全局配置提交时用户的名称和邮箱</p></li><li><p>使用 <code>git init</code> 在本地初始化项目</p></li><li><p>使用 <code>touch README.md</code> 和 <code>touch .gitignore</code> 来创建项目的说明文件和忽略文件；</p></li><li><p>使用 <code>git add .</code> 将所有文件托管到 git 中</p></li><li><p>使用 <code>git commit -m &quot;init project&quot;</code> 将项目进行本地提交</p></li><li><p>使用 <code>git remote add origin 仓储地址</code>将本地项目和远程仓储连接，并使用origin最为远程仓储的别名</p></li><li><p>使用 <code>git push -u origin master</code> 将本地代码push到仓储中</p></li></ol><h2 id="App-vue-组件的基本设置"><a href="#App-vue-组件的基本设置" class="headerlink" title="App.vue 组件的基本设置"></a>App.vue 组件的基本设置</h2><ol><li><p>头部的固定导航栏使用 <code>Mint-UI</code> 的 <code>Header</code> 组件；</p></li><li><p>底部的页签使用 <code>mui</code> 的 <code>tabbar</code>;</p></li><li><p>购物车的图标，使用 <code>icons-extra</code> 中的 <code>mui-icon-extra mui-icon-extra-cart</code>，同时，应该把其依赖的字体图标文件 <code>mui-icons-extra.ttf</code>，复制到 <code>fonts</code> 目录下！</p></li><li><p>将底部的页签，改造成 <code>router-link</code> 来实现单页面的切换；</p></li><li><p>Tab Bar 路由激活时候设置高亮的两种方式：</p><ul><li>全局设置样式如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.router-link-active</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#007aff</span> <span class="meta">!important</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>或者在 <code>new VueRouter</code> 的时候，通过 <code>linkActiveClass</code> 来指定高亮的类：</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"></span><br><span class="line">  var router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"></span><br><span class="line"><span class="symbol">    routes:</span> [</span><br><span class="line"></span><br><span class="line">      &#123; <span class="string">path:</span> <span class="string">'/'</span>, <span class="string">redirect:</span> <span class="string">'/home'</span> &#125;</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line"><span class="symbol">    linkActiveClass:</span> <span class="string">'mui-active'</span></span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现-tabbar-页签不同组件页面的切换"><a href="#实现-tabbar-页签不同组件页面的切换" class="headerlink" title="实现 tabbar 页签不同组件页面的切换"></a>实现 tabbar 页签不同组件页面的切换</h2><ol><li><p>将 tabbar 改造成 <code>router-link</code> 形式，并指定每个连接的 <code>to</code> 属性；</p></li><li><p>在入口文件中导入需要展示的组件，并创建路由对象：</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 导入需要展示的组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home from <span class="string">'./components/home/home.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Member from <span class="string">'./components/member/member.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Shopcar from <span class="string">'./components/shopcar/shopcar.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Search from <span class="string">'./components/search/search.vue'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"></span><br><span class="line">var router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"></span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/'</span>, <span class="string">redirect:</span> <span class="string">'/home'</span> &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/home'</span>, <span class="string">component:</span> Home &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/member'</span>, <span class="string">component:</span> Member &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/shopcar'</span>, <span class="string">component:</span> Shopcar &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/search'</span>, <span class="string">component:</span> Search &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line"><span class="symbol">  linkActiveClass:</span> <span class="string">'mui-active'</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="使用-mt-swipe-轮播图组件"><a href="#使用-mt-swipe-轮播图组件" class="headerlink" title="使用 mt-swipe 轮播图组件"></a>使用 mt-swipe 轮播图组件</h2><ol><li>假数据：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">lunbo</span>: [</span><br><span class="line"></span><br><span class="line">        'http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg',</span><br><span class="line"></span><br><span class="line">        'http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg',</span><br><span class="line"></span><br><span class="line">        'http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg'</span><br><span class="line"></span><br><span class="line">      ]</span><br></pre></td></tr></table></figure><ol start="2"><li>引入轮播图组件：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Mint-UI 轮播图组件 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"home-swipe"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">mt-swipe</span> <span class="attr">:auto</span>=<span class="string">"4000"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mt-swipe-item</span> <span class="attr">v-for</span>=<span class="string">"(item, i) in lunbo"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"item"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mt-swipe-item</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mt-swipe</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在-vue组件中使用vue-resource获取数据"><a href="#在-vue组件中使用vue-resource获取数据" class="headerlink" title="在.vue组件中使用vue-resource获取数据"></a>在<code>.vue</code>组件中使用<code>vue-resource</code>获取数据</h2><ol><li><p>运行<code>cnpm i vue-resource -S</code>安装模块</p></li><li><p>导入 vue-resource 组件</p></li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueResource <span class="keyword">from</span> <span class="string">'vue-resource'</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在vue中使用 vue-resource 组件</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.use(VueResource)<span class="comment">;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;继续介绍webpack以及Element饿了么组件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Vue-js/2019/05/11/Vue-Day6/wordpress-265132_1280.jpg&quot; alt=&quot;wordpress-265132_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>VueJs学习笔记-Day5</title>
    <link href="http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day5.html"/>
    <id>http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day5.html</id>
    <published>2019-05-11T03:49:56.000Z</published>
    <updated>2019-05-11T04:07:55.606Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">本文介绍babel以及Webpack的使用方式，之后会补上具体操作</p><blockquote class="question">Webpack以及babel的配置</blockquote><p><img src="/Vue-js/2019/05/11/Vue-Day5/blonde-801985_1280.jpg" alt="blonde-801985_1280"></p><a id="more"></a><h1 id="Vue-js-Day5-Webpack"><a href="#Vue-js-Day5-Webpack" class="headerlink" title="Vue.js - Day5 - Webpack"></a>Vue.js - Day5 - Webpack</h1><h2 id="在网页中会引用哪些常见的静态资源？"><a href="#在网页中会引用哪些常见的静态资源？" class="headerlink" title="在网页中会引用哪些常见的静态资源？"></a>在网页中会引用哪些常见的静态资源？</h2><ul><li>JS<ul><li>.js  .jsx  .coffee  .ts（TypeScript  类 C# 语言）</li></ul></li><li>CSS<ul><li>.css  .less   .sass  .scss</li></ul></li><li>Images<ul><li>.jpg   .png   .gif   .bmp   .svg</li></ul></li><li>字体文件（Fonts）<ul><li>.svg   .ttf   .eot   .woff   .woff2</li></ul></li><li>模板文件<ul><li>.ejs   .jade  .vue【这是在webpack中定义组件的方式，推荐这么用】</li></ul></li></ul><h2 id="网页中引入的静态资源多了以后有什么问题？？？"><a href="#网页中引入的静态资源多了以后有什么问题？？？" class="headerlink" title="网页中引入的静态资源多了以后有什么问题？？？"></a>网页中引入的静态资源多了以后有什么问题？？？</h2><ol><li>网页加载速度慢， 因为 我们要发起很多的二次请求；</li><li>要处理错综复杂的依赖关系</li></ol><h2 id="如何解决上述两个问题"><a href="#如何解决上述两个问题" class="headerlink" title="如何解决上述两个问题"></a>如何解决上述两个问题</h2><ol><li>合并、压缩、精灵图、图片的Base64编码</li><li>可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；</li></ol><h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack?"></a>什么是webpack?</h2><p>webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；</p><h2 id="如何完美实现上述的2种解决方案"><a href="#如何完美实现上述的2种解决方案" class="headerlink" title="如何完美实现上述的2种解决方案"></a>如何完美实现上述的2种解决方案</h2><ol><li>使用Gulp， 是基于 task 任务的；</li><li>使用Webpack， 是基于整个项目进行构建的；</li></ol><ul><li>借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。</li><li>根据官网的图片介绍webpack打包的过程</li><li><a href="http://webpack.github.io/" target="_blank" rel="noopener">webpack官网</a></li></ul><h2 id="webpack安装的两种方式"><a href="#webpack安装的两种方式" class="headerlink" title="webpack安装的两种方式"></a>webpack安装的两种方式</h2><ol><li>运行<code>npm i webpack -g</code>全局安装webpack，这样就能在全局使用webpack的命令</li><li>在项目根目录中运行<code>npm i webpack --save-dev</code>安装到项目依赖中</li></ol><h2 id="初步使用webpack打包构建列表隔行变色案例"><a href="#初步使用webpack打包构建列表隔行变色案例" class="headerlink" title="初步使用webpack打包构建列表隔行变色案例"></a>初步使用webpack打包构建列表隔行变色案例</h2><ol><li>运行<code>npm init</code>初始化项目，使用npm管理项目中的依赖包</li><li>创建项目基本的目录结构</li><li>使用<code>cnpm i jquery --save</code>安装jquery类库</li><li><p>创建<code>main.js</code>并书写各行变色的代码逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入jquery类库</span></span><br><span class="line">   <span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置偶数行背景色，索引从0开始，0是偶数</span></span><br><span class="line">   $(<span class="string">'#list li:even'</span>).css(<span class="string">'backgroundColor'</span>,<span class="string">'lightblue'</span>);</span><br><span class="line">   <span class="comment">// 设置奇数行背景色</span></span><br><span class="line">   $(<span class="string">'#list li:odd'</span>).css(<span class="string">'backgroundColor'</span>,<span class="string">'pink'</span>);</span><br></pre></td></tr></table></figure></li><li><p>直接在页面上引用<code>main.js</code>会报错，因为浏览器不认识<code>import</code>这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；</p></li><li>运行<code>webpack 入口文件路径 输出文件路径</code>对<code>main.js</code>进行处理：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack src/js/main<span class="selector-class">.js</span> dist/bundle.js</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用webpack的配置文件简化打包时候的命令"><a href="#使用webpack的配置文件简化打包时候的命令" class="headerlink" title="使用webpack的配置文件简化打包时候的命令"></a>使用webpack的配置文件简化打包时候的命令</h2><ol><li>在项目根目录中创建<code>webpack.config.js</code></li><li>由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在<code>webpack.config.js</code>中配置这两个路径：<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入处理路径的模块</span></span><br><span class="line">var <span class="built_in">path</span> = require(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'src/js/main.js'</span>), <span class="comment">// 项目入口文件</span></span><br><span class="line">    output: &#123; <span class="comment">// 配置输出选项</span></span><br><span class="line">        <span class="built_in">path</span>: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 配置输出的路径</span></span><br><span class="line">        filename: <span class="string">'bundle.js'</span> <span class="comment">// 配置输出的文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现webpack的实时打包构建"><a href="#实现webpack的实时打包构建" class="headerlink" title="实现webpack的实时打包构建"></a>实现webpack的实时打包构建</h2><ol><li>由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用<code>webpack-dev-server</code>来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。</li><li>运行<code>cnpm i webpack-dev-server --save-dev</code>安装到开发依赖</li><li><p>安装完成之后，在命令行直接运行<code>webpack-dev-server</code>来进行打包，发现报错，此时需要借助于<code>package.json</code>文件中的指令，来进行运行<code>webpack-dev-server</code>命令，在<code>scripts</code>节点下新增<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>指令，发现可以进行实时打包，但是dist目录下并没有生成<code>bundle.js</code>文件，这是因为<code>webpack-dev-server</code>将打包好的文件放在了内存中</p><ul><li>把<code>bundle.js</code>放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快</li><li>这个时候访问webpack-dev-server启动的<code>http://localhost:8080/</code>网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:<code>&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;</code></li><li>为了能在访问<code>http://localhost:8080/</code>的时候直接访问到index首页，可以使用<code>--contentBase src</code>指令来修改dev指令，指定启动的根目录：<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server --contentBase src"</span></span><br></pre></td></tr></table></figure></li></ul><p>同时修改index页面中script的src属性为<code>&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</code></p></li></ol><h2 id="使用html-webpack-plugin插件配置启动页面"><a href="#使用html-webpack-plugin插件配置启动页面" class="headerlink" title="使用html-webpack-plugin插件配置启动页面"></a>使用<code>html-webpack-plugin</code>插件配置启动页面</h2><p>由于使用<code>--contentBase</code>指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用<code>html-webpack-plugin</code>插件配置启动页面.</p><ol><li>运行<code>cnpm i html-webpack-plugin --save-dev</code>安装到开发依赖</li><li><p>修改<code>webpack.config.js</code>配置文件如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入处理路径的模块</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 导入自动生成HTMl文件的插件</span></span><br><span class="line"><span class="keyword">var</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">'src/js/main.js'</span>), <span class="comment">// 项目入口文件</span></span><br><span class="line">    output: &#123; <span class="comment">// 配置输出选项</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 配置输出的路径</span></span><br><span class="line">        filename: <span class="string">'bundle.js'</span> <span class="comment">// 配置输出的文件名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[ <span class="comment">// 添加plugins节点配置插件</span></span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.resolve(__dirname, <span class="string">'src/index.html'</span>),<span class="comment">//模板路径</span></span><br><span class="line">            filename:<span class="string">'index.html'</span><span class="comment">//自动生成的HTML文件的名称</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改<code>package.json</code>中<code>script</code>节点中的dev指令如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span></span><br></pre></td></tr></table></figure></li><li><p>将index.html中script标签注释掉，因为<code>html-webpack-plugin</code>插件会自动把bundle.js注入到index.html页面中！</p></li></ol><h2 id="实现自动打开浏览器、热更新和配置浏览器的默认端口号"><a href="#实现自动打开浏览器、热更新和配置浏览器的默认端口号" class="headerlink" title="实现自动打开浏览器、热更新和配置浏览器的默认端口号"></a>实现自动打开浏览器、热更新和配置浏览器的默认端口号</h2><p><strong>注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！</strong></p><h3 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h3><ul><li>修改<code>package.json</code>的script节点如下，其中<code>--open</code>表示自动打开浏览器，<code>--port 4321</code>表示打开的端口号为4321，<code>--hot</code>表示启用浏览器热更新：<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">"dev":</span> <span class="comment">"webpack</span><span class="literal">-</span><span class="comment">dev</span><span class="literal">-</span><span class="comment">server</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">hot</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">4321</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">open"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h3><ol><li><p>修改<code>webpack.config.js</code>文件，新增<code>devServer</code>节点如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer:</span><span class="string">&#123;</span></span><br><span class="line"><span class="attr">        hot:</span><span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">        open:</span><span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">        port:</span><span class="number">4321</span></span><br><span class="line">    <span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在头部引入<code>webpack</code>模块：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var webpack</span> = require(<span class="string">'webpack'</span>);</span><br></pre></td></tr></table></figure></li><li><p>在<code>plugins</code>节点下新增：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">webpack</span>.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用webpack打包css文件"><a href="#使用webpack打包css文件" class="headerlink" title="使用webpack打包css文件"></a>使用webpack打包css文件</h2><ol><li>运行<code>cnpm i style-loader css-loader --save-dev</code></li><li><p>修改<code>webpack.config.js</code>这个配置文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">module:</span> &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line"><span class="symbol">        rules:</span> [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">            &#123; <span class="string">test:</span> <span class="regexp">/\.css$/</span>, <span class="string">use:</span> [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;<span class="comment">//处理css文件的规则</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：<code>use</code>表示使用哪些模块来处理<code>test</code>所匹配到的文件；<code>use</code>中相关loader模块的调用顺序是从后向前调用的；</p></li></ol><h2 id="使用webpack打包less文件"><a href="#使用webpack打包less文件" class="headerlink" title="使用webpack打包less文件"></a>使用webpack打包less文件</h2><ol><li>运行<code>cnpm i less-loader less -D</code></li><li>修改<code>webpack.config.js</code>这个配置文件：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">test</span>: /\.less$/, use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用webpack打包sass文件"><a href="#使用webpack打包sass文件" class="headerlink" title="使用webpack打包sass文件"></a>使用webpack打包sass文件</h2><ol><li>运行<code>cnpm i sass-loader node-sass --save-dev</code></li><li>在<code>webpack.config.js</code>中添加处理sass文件的loader模块：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">test</span>: /\.scss$/, use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用webpack处理css中的路径"><a href="#使用webpack处理css中的路径" class="headerlink" title="使用webpack处理css中的路径"></a>使用webpack处理css中的路径</h2><ol><li>运行<code>cnpm i url-loader file-loader --save-dev</code></li><li><p>在<code>webpack.config.js</code>中添加处理url路径的loader模块：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">test</span>: /\.(png|jpg|gif)$/, use: <span class="string">'url-loader'</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>可以通过<code>limit</code>指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">test</span>: /\.(png|jpg|gif)$/, use: <span class="string">'url-loader?limit=43960'</span> &#125;,</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用babel处理高级JS语法"><a href="#使用babel处理高级JS语法" class="headerlink" title="使用babel处理高级JS语法"></a>使用babel处理高级JS语法</h2><ol><li>运行<code>cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev</code>安装babel的相关loader包</li><li>运行<code>cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev</code>安装babel转换的语法</li><li><p>在<code>webpack.config.js</code>中添加相关loader模块，其中需要注意的是，一定要把<code>node_modules</code>文件夹添加到排除项：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">test:</span> <span class="regexp">/\.js$/</span>, <span class="string">use:</span> <span class="string">'babel-loader'</span>, <span class="string">exclude:</span> <span class="regexp">/node_modules/</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录中添加<code>.babelrc</code>文件，并修改这个配置文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>:[<span class="string">"es2015"</span>, <span class="string">"stage-0"</span>],</span><br><span class="line">    <span class="attr">"plugins"</span>:[<span class="string">"transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意：语法插件<code>babel-preset-es2015</code>可以更新为<code>babel-preset-env</code>，它包含了所有的ES相关的语法；</strong></p></li></ol><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://segmentfault.com/p/1210000008466178" target="_blank" rel="noopener">babel-preset-env：你需要的唯一Babel插件</a><br><a href="https://segmentfault.com/a/1190000009065987" target="_blank" rel="noopener">Runtime transform 运行时编译es6</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;本文介绍babel以及Webpack的使用方式，之后会补上具体操作&lt;/p&gt;

&lt;blockquote class=&quot;question&quot;&gt;Webpack以及babel的配置&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/Vue-js/2019/05/11/Vue-Day5/blonde-801985_1280.jpg&quot; alt=&quot;blonde-801985_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>VueJs学习笔记-Day4</title>
    <link href="http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day4.html"/>
    <id>http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day4.html</id>
    <published>2019-05-11T03:49:48.000Z</published>
    <updated>2019-05-11T04:04:53.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">本文主要介绍父子组件的调用方式，以及Vue.js中重要的路由思想</p><p><img src="/Vue-js/2019/05/11/Vue-Day4/sparkler-677774_1280.jpg" alt="sparkler-677774_1280"></p><a id="more"></a><h1 id="Vue-js-Day4"><a href="#Vue-js-Day4" class="headerlink" title="Vue.js - Day4"></a>Vue.js - Day4</h1><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol><li><p>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="actionscript">        msg: <span class="string">'这是父组件中的消息'</span></span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      components: &#123;</span></span><br><span class="line"><span class="undefined">        son: &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">          template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是子组件 --- </span><span class="template-variable">&#123;&#123;finfo&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>',</span></span></span><br><span class="line"><span class="actionscript">          props: [<span class="string">'finfo'</span>]</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;son <span class="symbol">:finfo=<span class="string">"msg"</span>&gt;&lt;/son&gt;</span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><ol><li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li><li><p>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">son</span> @<span class="attr">func</span>=<span class="string">"getMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用父组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span> @<span class="attr">func</span>=<span class="string">"getMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 组件模板定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"x-template"</span> <span class="attr">id</span>=<span class="string">"son"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"向父组件传值"</span> @<span class="attr">click</span>=<span class="string">"sendMsg"</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 子组件的定义方式</span></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">'son'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">      template: <span class="string">'#son'</span>, <span class="comment">// 组件模板Id</span></span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="actionscript">        sendMsg() &#123; <span class="comment">// 按钮的点击事件</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$emit(<span class="string">'func'</span>, <span class="string">'OK'</span>); <span class="comment">// 调用父组件传递过来的方法，同时把数据传递出去</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="actionscript">        getMsg(val)&#123; <span class="comment">// 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span></span></span><br><span class="line"><span class="undefined">          alert(val);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="组件中data和props的区别"><a href="#组件中data和props的区别" class="headerlink" title="组件中data和props的区别"></a>组件中data和props的区别</h2><h2 id="评论列表案例"><a href="#评论列表案例" class="headerlink" title="评论列表案例"></a>评论列表案例</h2><p>目标：主要练习父子组件之间传值</p><h2 id="使用-this-refs-来获取元素和组件"><a href="#使用-this-refs-来获取元素和组件" class="headerlink" title="使用 this.$refs 来获取元素和组件"></a>使用 <code>this.$refs</code> 来获取元素和组件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"获取元素内容"</span> @<span class="attr">click</span>=<span class="string">"getElement"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 ref 获取元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">"myh1"</span>&gt;</span>这是一个大大的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 ref 获取子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-com</span> <span class="attr">ref</span>=<span class="string">"mycom"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-com</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  Vue.component(<span class="string">'my-com'</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: '<span class="tag">&lt;<span class="name">h5</span>&gt;</span>这是一个子组件<span class="tag">&lt;/<span class="name">h5</span>&gt;</span>',</span></span></span><br><span class="line"><span class="undefined">    data() &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        name: <span class="string">'子组件'</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      getElement() &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过 this.$refs 来获取元素</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.myh1.innerText);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过 this.$refs 来获取组件</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.mycom.name);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><ol><li><p><strong>后端路由：</strong>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p></li><li><p><strong>前端路由：</strong>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p></li><li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p></li></ol><h2 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h2><ol><li><p>导入 vue-router 组件类库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 导入 vue-router 组件类库 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./lib/vue-router-2.7.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 router-link 组件来导航</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 router-view 组件来显示匹配到的组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建使用<code>Vue.extend</code>创建组件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.1 使用 Vue.extend 来创建登录组件</span></span><br><span class="line">var login = Vue.extend(&#123;</span><br><span class="line">  <span class="keyword">template</span>: <span class="string">'&lt;h1&gt;登录组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.2 使用 Vue.extend 来创建注册组件</span></span><br><span class="line">var <span class="keyword">register</span> = Vue.extend(&#123;</span><br><span class="line">  <span class="keyword">template</span>: <span class="string">'&lt;h1&gt;注册组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</span></span><br><span class="line">    var router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">      routes:</span> [</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">component:</span> login &#125;,</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">'/register'</span>, <span class="string">component:</span> register &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用 router 属性来使用路由规则</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,</span><br><span class="line">      router: router <span class="comment">// 使用 router 属性来使用路由规则</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用tag属性指定router-link渲染的标签类型"><a href="#使用tag属性指定router-link渲染的标签类型" class="headerlink" title="使用tag属性指定router-link渲染的标签类型"></a>使用tag属性指定router-link渲染的标签类型</h2><h2 id="设置路由重定向"><a href="#设置路由重定向" class="headerlink" title="设置路由重定向"></a>设置路由重定向</h2><h2 id="设置路由高亮"><a href="#设置路由高亮" class="headerlink" title="设置路由高亮"></a>设置路由高亮</h2><h2 id="设置路由切换动效"><a href="#设置路由切换动效" class="headerlink" title="设置路由切换动效"></a>设置路由切换动效</h2><h2 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h2><ol><li><p>在规则中定义参数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">path</span>: <span class="string">'/register/:id'</span>, component: register &#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>this.$route.params</code>来获取路由中的参数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">register</span> = Vue.extend(&#123;</span><br><span class="line">      <span class="keyword">template</span>: <span class="string">'&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;'</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account"</span>&gt;</span>Account<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">  // 父路由中的组件</span></span><br><span class="line"><span class="xml">  const account = Vue.extend(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    template: `<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">      这是account组件</span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account/login"</span>&gt;</span>login<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span> | </span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account/register"</span>&gt;</span>register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">    &lt;/div&gt;`</span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 子路由中的 login 组件</span></span><br><span class="line"><span class="xml">  const login = Vue.extend(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    template: <span class="string">'&lt;div&gt;登录组件&lt;/div&gt;'</span></span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 子路由中的 register 组件</span></span><br><span class="line"><span class="xml">  const register = Vue.extend(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    template: <span class="string">'&lt;div&gt;注册组件&lt;/div&gt;'</span></span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 路由实例</span></span><br><span class="line"><span class="xml">  var router = new VueRouter(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    routes: [</span></span><br><span class="line"><span class="xquery">      &#123;<span class="built_in"> path</span>: <span class="string">'/'</span>, redirect: <span class="string">'/account/login'</span> &#125;</span><span class="xml">, // 使用 redirect 实现路由重定向</span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> path</span>: <span class="string">'/account'</span>,</span></span><br><span class="line"><span class="xquery">        component: account,</span></span><br><span class="line"><span class="xquery">        children: [ // 通过 children 数组属性，来实现路由的嵌套</span></span><br><span class="line"><span class="xquery">          &#123;<span class="built_in"> path</span>: <span class="string">'login'</span>, component: login &#125;</span><span class="xml">, // 注意，子路由的开头位置，不要加 / 路径符</span></span><br><span class="line"><span class="xml">          </span><span class="xquery">&#123;<span class="built_in"> path</span>: <span class="string">'register'</span>, component: register &#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        ]</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    ]</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">  var vm = new Vue(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="xquery">    data: &#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    methods: </span><span class="xquery">&#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    components: </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">      account</span></span><br><span class="line"><span class="xquery">    &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    router: router</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="命名视图实现经典布局"><a href="#命名视图实现经典布局" class="headerlink" title="命名视图实现经典布局"></a>命名视图实现经典布局</h2><ol><li><p>标签代码结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>JS代码：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    var header = Vue.component('header', </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      template: '&lt;div class="header"&gt;header&lt;/div&gt;'</span></span><br><span class="line"><span class="template-variable">    &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    var sidebar = Vue.component('sidebar', </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;'</span></span><br><span class="line"><span class="template-variable">    &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    var mainbox = Vue.component('mainbox', </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;'</span></span><br><span class="line"><span class="template-variable">    &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // 创建路由对象</span></span><br><span class="line"><span class="xml">    var router = new VueRouter(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      routes: [</span></span><br><span class="line"><span class="template-variable">        &#123;</span></span><br><span class="line"><span class="template-variable">          path: '/', components: &#123;</span></span><br><span class="line"><span class="template-variable">            <span class="keyword">default</span>: header,</span></span><br><span class="line"><span class="template-variable">            a: sidebar,</span></span><br><span class="line"><span class="template-variable">            b: mainbox</span></span><br><span class="line"><span class="template-variable">          &#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      ]</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      el: '#app',</span></span><br><span class="line"><span class="template-variable">      data: &#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      methods: </span><span class="template-variable">&#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      router</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>CSS 样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="undefined">    border: 1px solid red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="undefined">    display: flex;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.sidebar</span> &#123;</span></span><br><span class="line"><span class="undefined">    flex: 2;</span></span><br><span class="line"><span class="undefined">    border: 1px solid green;</span></span><br><span class="line"><span class="undefined">    height: 500px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.mainbox</span>&#123;</span></span><br><span class="line"><span class="undefined">    flex: 8;</span></span><br><span class="line"><span class="undefined">    border: 1px solid blue;</span></span><br><span class="line"><span class="undefined">    height: 500px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="watch属性的使用"><a href="#watch属性的使用" class="headerlink" title="watch属性的使用"></a><code>watch</code>属性的使用</h2><p>考虑一个问题：想要实现 <code>名</code> 和 <code>姓</code> 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）</p><ol><li><p>监听<code>data</code>中属性的改变：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span> +</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span> =</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;fullName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el: '#app',</span></span><br><span class="line"><span class="xml">      data: &#123;</span></span><br><span class="line"><span class="xml">        firstName: 'jack',</span></span><br><span class="line"><span class="xml">        lastName: 'chen',</span></span><br><span class="line"><span class="xml">        fullName: 'jack - chen'</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      methods: &#123;&#125;,</span></span><br><span class="line"><span class="xml">      watch: &#123;</span></span><br><span class="line"><span class="xml">        'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据</span></span><br><span class="line"><span class="xml">          this.fullName = newVal + ' - ' + this.lastName;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        'lastName': function (newVal, oldVal) &#123;</span></span><br><span class="line"><span class="xml">          this.fullName = this.firstName + ' - ' + newVal;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>监听路由对象的改变：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> login = Vue.extend(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> register = Vue.extend(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line"><span class="undefined">      routes: [</span></span><br><span class="line"><span class="actionscript">        &#123; path: <span class="string">"/login"</span>, component: login &#125;,</span></span><br><span class="line"><span class="actionscript">        &#123; path: <span class="string">"/register"</span>, component: register &#125;</span></span><br><span class="line"><span class="undefined">      ]</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">      router: router,</span></span><br><span class="line"><span class="undefined">      watch: &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">'$route'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(newVal, oldVal)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (newVal.path === <span class="string">'/login'</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'这是登录组件'</span>);</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="computed计算属性的使用"><a href="#computed计算属性的使用" class="headerlink" title="computed计算属性的使用"></a><code>computed</code>计算属性的使用</h2><ol><li><p>默认只有<code>getter</code>的计算属性：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span> +</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span> =</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;fullName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el: '#app',</span></span><br><span class="line"><span class="xml">      data: &#123;</span></span><br><span class="line"><span class="xml">        firstName: 'jack',</span></span><br><span class="line"><span class="xml">        lastName: 'chen'</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      methods: &#123;&#125;,</span></span><br><span class="line"><span class="xml">      computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值</span></span><br><span class="line"><span class="xml">        fullName() &#123;</span></span><br><span class="line"><span class="xml">          return this.firstName + ' - ' + this.lastName;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>定义有<code>getter</code>和<code>setter</code>的计算属性：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"修改fullName"</span> @<span class="attr">click</span>=<span class="string">"changeName"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;fullName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el: '#app',</span></span><br><span class="line"><span class="xml">      data: &#123;</span></span><br><span class="line"><span class="xml">        firstName: 'jack',</span></span><br><span class="line"><span class="xml">        lastName: 'chen'</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      methods: &#123;</span></span><br><span class="line"><span class="xml">        changeName() &#123;</span></span><br><span class="line"><span class="xml">          this.fullName = 'TOM - chen2';</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      computed: &#123;</span></span><br><span class="line"><span class="xml">        fullName: &#123;</span></span><br><span class="line"><span class="xml">          get: function () &#123;</span></span><br><span class="line"><span class="xml">            return this.firstName + ' - ' + this.lastName;</span></span><br><span class="line"><span class="xml">          &#125;,</span></span><br><span class="line"><span class="xml">          set: function (newVal) &#123;</span></span><br><span class="line"><span class="xml">            var parts = newVal.split(' - ');</span></span><br><span class="line"><span class="xml">            this.firstName = parts[0];</span></span><br><span class="line"><span class="xml">            this.lastName = parts[1];</span></span><br><span class="line"><span class="xml">          &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="watch、computed和methods之间的对比"><a href="#watch、computed和methods之间的对比" class="headerlink" title="watch、computed和methods之间的对比"></a><code>watch</code>、<code>computed</code>和<code>methods</code>之间的对比</h2><ol><li><code>computed</code>属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li><li><code>methods</code>方法表示一个具体的操作，主要书写业务逻辑；</li><li><code>watch</code>一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是<code>computed</code>和<code>methods</code>的结合体；</li></ol><h2 id="nrm的安装使用"><a href="#nrm的安装使用" class="headerlink" title="nrm的安装使用"></a><code>nrm</code>的安装使用</h2><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；<br>什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；</p><ol><li>运行<code>npm i nrm -g</code>全局安装<code>nrm</code>包；</li><li>使用<code>nrm ls</code>查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</li><li>使用<code>nrm use npm</code>或<code>nrm use taobao</code>切换不同的镜像源地址；</li></ol><blockquote><p>注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是  npm</p></blockquote><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ol><li><a href="http://www.cnblogs.com/joyho/articles/4430148.html" target="_blank" rel="noopener">URL中的hash（井号）</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;本文主要介绍父子组件的调用方式，以及Vue.js中重要的路由思想&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Vue-js/2019/05/11/Vue-Day4/sparkler-677774_1280.jpg&quot; alt=&quot;sparkler-677774_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>VueJs学习笔记-Day3</title>
    <link href="http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day3.html"/>
    <id>http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day3.html</id>
    <published>2019-05-11T03:49:38.000Z</published>
    <updated>2019-05-11T04:02:47.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">主要介绍组件化，组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；</p><p><img src="/Vue-js/2019/05/11/Vue-Day3/security-265130_1280.jpg" alt="security-265130_1280"></p><a id="more"></a><h1 id="Vue-js-Day3"><a href="#Vue-js-Day3" class="headerlink" title="Vue.js - Day3"></a>Vue.js - Day3</h1><h2 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h2><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul><li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li><li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；<h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><ol><li>使用 Vue.extend 配合 Vue.component 方法：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> login = Vue.extend(&#123;</span><br><span class="line">      template: <span class="string">'&lt;h1&gt;登录&lt;/h1&gt;'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    Vue.component(<span class="string">'login'</span>, login);</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>直接使用 Vue.component 方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'register'</span>, &#123;</span><br><span class="line">      <span class="keyword">template</span>: <span class="string">'&lt;h1&gt;注册&lt;/h1&gt;'</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>将模板字符串，定义到script标签种：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"tmpl"</span> <span class="attr">type</span>=<span class="string">"x-template"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span> | <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>同时，需要使用 Vue.component 来定义组件：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'account'</span>, &#123;</span><br><span class="line">      <span class="keyword">template</span>: <span class="string">'#tmpl'</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p></blockquote><h3 id="组件中展示数据和响应事件"><a href="#组件中展示数据和响应事件" class="headerlink" title="组件中展示数据和响应事件"></a>组件中展示数据和响应事件</h3><ol><li><p>在组件中，<code>data</code>需要被定义为一个方法，例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'account'</span>, &#123;</span><br><span class="line">      <span class="attribute">template</span>: <span class="string">'#tmpl'</span>,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          <span class="attribute">msg</span>: <span class="string">'大家好！'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attribute">methods</span>:&#123;</span><br><span class="line">        <span class="selector-tag">login</span>()&#123;</span><br><span class="line">          <span class="selector-tag">alert</span>(<span class="string">'点击了登录按钮'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</p></li></ol><h3 id="【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象"><a href="#【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象" class="headerlink" title="【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象"></a>【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象</h3><ol><li>通过计数器案例演示</li></ol><h3 id="使用components属性定义局部子组件"><a href="#使用components属性定义局部子组件" class="headerlink" title="使用components属性定义局部子组件"></a>使用<code>components</code>属性定义局部子组件</h3><ol><li><p>组件实例定义方式：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el: '#app',</span></span><br><span class="line"><span class="xml">      data: &#123;&#125;,</span></span><br><span class="line"><span class="xml">      methods: &#123;&#125;,</span></span><br><span class="line"><span class="xml">      components: &#123; // 定义子组件</span></span><br><span class="line"><span class="xml">        account: &#123; // account 组件</span></span><br><span class="line"><span class="xml">          template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是Account组件</span><span class="template-variable">&#123;&#123;name&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">login</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>', // 在这里使用定义的子组件</span></span><br><span class="line"><span class="xml">          components: &#123; // 定义子组件的子组件</span></span><br><span class="line"><span class="xml">            login: &#123; // login 组件</span></span><br><span class="line"><span class="xml">              template: "<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是登录组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>"</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">          &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>引用组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">account</span>&gt;</span><span class="tag">&lt;/<span class="name">account</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="使用flag标识符结合v-if和v-else切换组件"><a href="#使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="使用flag标识符结合v-if和v-else切换组件"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h2><ol><li><p>页面结构：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"toggle"</span> @click=<span class="string">"flag=!flag"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">my</span>-com1 v-<span class="keyword">if</span>=<span class="string">"flag"</span>&gt;&lt;/<span class="keyword">my</span>-com1&gt;</span><br><span class="line">    &lt;<span class="keyword">my</span>-com2 v-<span class="keyword">else</span>=<span class="string">"flag"</span>&gt;&lt;/<span class="keyword">my</span>-com2&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>Vue实例定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">'myCom1'</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: '<span class="tag">&lt;<span class="name">h3</span>&gt;</span>奔波霸<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>'</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">'myCom2'</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: '<span class="tag">&lt;<span class="name">h3</span>&gt;</span>霸波奔<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>'</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="actionscript">        flag: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;&#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="使用-is属性来切换不同的子组件-并添加切换动画"><a href="#使用-is属性来切换不同的子组件-并添加切换动画" class="headerlink" title="使用:is属性来切换不同的子组件,并添加切换动画"></a>使用<code>:is</code>属性来切换不同的子组件,并添加切换动画</h2><ol><li><p>组件实例定义方式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录组件</span></span><br><span class="line">  <span class="keyword">const</span> login = Vue.extend(&#123;</span><br><span class="line">    <span class="keyword">template</span>: `&lt;div&gt;</span><br><span class="line">      &lt;h3&gt;登录组件&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">  &#125;);</span><br><span class="line">  Vue.component(<span class="string">'login'</span>, login);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册组件</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">register</span> = Vue.extend(&#123;</span><br><span class="line">    <span class="keyword">template</span>: `&lt;div&gt;</span><br><span class="line">      &lt;h3&gt;注册组件&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">  &#125;);</span><br><span class="line">  Vue.component(<span class="string">'register'</span>, <span class="keyword">register</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line">  var vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123; comName: <span class="string">'login'</span> &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>component</code>标签，来引用组件，并通过<code>:is</code>属性来指定要加载的组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='login'"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='register'"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"comName"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加切换样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-to</span> &#123;</span></span><br><span class="line"><span class="undefined">    opacity: 0;</span></span><br><span class="line"><span class="undefined">    transform: translateX(30px);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter-active</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-active</span> &#123;</span></span><br><span class="line"><span class="undefined">    position: absolute;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> 0<span class="selector-class">.3s</span> <span class="selector-tag">ease</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  h3&#123;</span></span><br><span class="line"><span class="undefined">    margin: 0;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol><li><p>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="actionscript">        msg: <span class="string">'这是父组件中的消息'</span></span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      components: &#123;</span></span><br><span class="line"><span class="undefined">        son: &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">          template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是子组件 --- </span><span class="template-variable">&#123;&#123;finfo&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>',</span></span></span><br><span class="line"><span class="actionscript">          props: [<span class="string">'finfo'</span>]</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;son <span class="symbol">:finfo=<span class="string">"msg"</span>&gt;&lt;/son&gt;</span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><ol><li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li><li><p>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">son</span> @<span class="attr">func</span>=<span class="string">"getMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用父组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span> @<span class="attr">func</span>=<span class="string">"getMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 组件模板定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"x-template"</span> <span class="attr">id</span>=<span class="string">"son"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"向父组件传值"</span> @<span class="attr">click</span>=<span class="string">"sendMsg"</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 子组件的定义方式</span></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">'son'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">      template: <span class="string">'#son'</span>, <span class="comment">// 组件模板Id</span></span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="actionscript">        sendMsg() &#123; <span class="comment">// 按钮的点击事件</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$emit(<span class="string">'func'</span>, <span class="string">'OK'</span>); <span class="comment">// 调用父组件传递过来的方法，同时把数据传递出去</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="actionscript">        getMsg(val)&#123; <span class="comment">// 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span></span></span><br><span class="line"><span class="undefined">          alert(val);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="评论列表案例"><a href="#评论列表案例" class="headerlink" title="评论列表案例"></a>评论列表案例</h2><p>目标：主要练习父子组件之间传值</p><h2 id="使用-this-refs-来获取元素和组件"><a href="#使用-this-refs-来获取元素和组件" class="headerlink" title="使用 this.$refs 来获取元素和组件"></a>使用 <code>this.$refs</code> 来获取元素和组件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"获取元素内容"</span> @<span class="attr">click</span>=<span class="string">"getElement"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 ref 获取元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">"myh1"</span>&gt;</span>这是一个大大的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 ref 获取子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-com</span> <span class="attr">ref</span>=<span class="string">"mycom"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-com</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  Vue.component(<span class="string">'my-com'</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: '<span class="tag">&lt;<span class="name">h5</span>&gt;</span>这是一个子组件<span class="tag">&lt;/<span class="name">h5</span>&gt;</span>',</span></span></span><br><span class="line"><span class="undefined">    data() &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        name: <span class="string">'子组件'</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      getElement() &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过 this.$refs 来获取元素</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.myh1.innerText);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过 this.$refs 来获取组件</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.mycom.name);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><ol><li><p>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p></li><li><p>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p></li><li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p></li></ol><h2 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h2><ol><li><p>导入 vue-router 组件类库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 导入 vue-router 组件类库 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./lib/vue-router-2.7.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 router-link 组件来导航</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 router-view 组件来显示匹配到的组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建使用<code>Vue.extend</code>创建组件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.1 使用 Vue.extend 来创建登录组件</span></span><br><span class="line">var login = Vue.extend(&#123;</span><br><span class="line">  <span class="keyword">template</span>: <span class="string">'&lt;h1&gt;登录组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.2 使用 Vue.extend 来创建注册组件</span></span><br><span class="line">var <span class="keyword">register</span> = Vue.extend(&#123;</span><br><span class="line">  <span class="keyword">template</span>: <span class="string">'&lt;h1&gt;注册组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</span></span><br><span class="line">    var router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">      routes:</span> [</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">component:</span> login &#125;,</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">'/register'</span>, <span class="string">component:</span> register &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用 router 属性来使用路由规则</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,</span><br><span class="line">      router: router <span class="comment">// 使用 router 属性来使用路由规则</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置路由高亮"><a href="#设置路由高亮" class="headerlink" title="设置路由高亮"></a>设置路由高亮</h2><h2 id="设置路由切换动效"><a href="#设置路由切换动效" class="headerlink" title="设置路由切换动效"></a>设置路由切换动效</h2><h2 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h2><ol><li><p>在规则中定义参数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">path</span>: <span class="string">'/register/:id'</span>, component: register &#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>this.$route.params</code>来获取路由中的参数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">register</span> = Vue.extend(&#123;</span><br><span class="line">      <span class="keyword">template</span>: <span class="string">'&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;'</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account"</span>&gt;</span>Account<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">  // 父路由中的组件</span></span><br><span class="line"><span class="xml">  const account = Vue.extend(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    template: `<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">      这是account组件</span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account/login"</span>&gt;</span>login<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span> | </span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account/register"</span>&gt;</span>register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">    &lt;/div&gt;`</span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 子路由中的 login 组件</span></span><br><span class="line"><span class="xml">  const login = Vue.extend(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    template: <span class="string">'&lt;div&gt;登录组件&lt;/div&gt;'</span></span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 子路由中的 register 组件</span></span><br><span class="line"><span class="xml">  const register = Vue.extend(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    template: <span class="string">'&lt;div&gt;注册组件&lt;/div&gt;'</span></span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 路由实例</span></span><br><span class="line"><span class="xml">  var router = new VueRouter(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    routes: [</span></span><br><span class="line"><span class="xquery">      &#123;<span class="built_in"> path</span>: <span class="string">'/'</span>, redirect: <span class="string">'/account/login'</span> &#125;</span><span class="xml">, // 使用 redirect 实现路由重定向</span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> path</span>: <span class="string">'/account'</span>,</span></span><br><span class="line"><span class="xquery">        component: account,</span></span><br><span class="line"><span class="xquery">        children: [ // 通过 children 数组属性，来实现路由的嵌套</span></span><br><span class="line"><span class="xquery">          &#123;<span class="built_in"> path</span>: <span class="string">'login'</span>, component: login &#125;</span><span class="xml">, // 注意，子路由的开头位置，不要加 / 路径符</span></span><br><span class="line"><span class="xml">          </span><span class="xquery">&#123;<span class="built_in"> path</span>: <span class="string">'register'</span>, component: register &#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        ]</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    ]</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">  var vm = new Vue(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="xquery">    data: &#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    methods: </span><span class="xquery">&#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    components: </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">      account</span></span><br><span class="line"><span class="xquery">    &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    router: router</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="命名视图实现经典布局"><a href="#命名视图实现经典布局" class="headerlink" title="命名视图实现经典布局"></a>命名视图实现经典布局</h2><ol><li><p>标签代码结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>JS代码：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    var header = Vue.component('header', </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      template: '&lt;div class="header"&gt;header&lt;/div&gt;'</span></span><br><span class="line"><span class="template-variable">    &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    var sidebar = Vue.component('sidebar', </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;'</span></span><br><span class="line"><span class="template-variable">    &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    var mainbox = Vue.component('mainbox', </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;'</span></span><br><span class="line"><span class="template-variable">    &#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // 创建路由对象</span></span><br><span class="line"><span class="xml">    var router = new VueRouter(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      routes: [</span></span><br><span class="line"><span class="template-variable">        &#123;</span></span><br><span class="line"><span class="template-variable">          path: '/', components: &#123;</span></span><br><span class="line"><span class="template-variable">            <span class="keyword">default</span>: header,</span></span><br><span class="line"><span class="template-variable">            a: sidebar,</span></span><br><span class="line"><span class="template-variable">            b: mainbox</span></span><br><span class="line"><span class="template-variable">          &#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      ]</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      el: '#app',</span></span><br><span class="line"><span class="template-variable">      data: &#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      methods: </span><span class="template-variable">&#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      router</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>CSS 样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="undefined">    border: 1px solid red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="undefined">    display: flex;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.sidebar</span> &#123;</span></span><br><span class="line"><span class="undefined">    flex: 2;</span></span><br><span class="line"><span class="undefined">    border: 1px solid green;</span></span><br><span class="line"><span class="undefined">    height: 500px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.mainbox</span>&#123;</span></span><br><span class="line"><span class="undefined">    flex: 8;</span></span><br><span class="line"><span class="undefined">    border: 1px solid blue;</span></span><br><span class="line"><span class="undefined">    height: 500px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="watch属性的使用"><a href="#watch属性的使用" class="headerlink" title="watch属性的使用"></a><code>watch</code>属性的使用</h2><p>考虑一个问题：想要实现 <code>名</code> 和 <code>姓</code> 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）</p><ol><li><p>监听<code>data</code>中属性的改变：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span> +</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span> =</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;fullName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el: '#app',</span></span><br><span class="line"><span class="xml">      data: &#123;</span></span><br><span class="line"><span class="xml">        firstName: 'jack',</span></span><br><span class="line"><span class="xml">        lastName: 'chen',</span></span><br><span class="line"><span class="xml">        fullName: 'jack - chen'</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      methods: &#123;&#125;,</span></span><br><span class="line"><span class="xml">      watch: &#123;</span></span><br><span class="line"><span class="xml">        'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据</span></span><br><span class="line"><span class="xml">          this.fullName = newVal + ' - ' + this.lastName;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        'lastName': function (newVal, oldVal) &#123;</span></span><br><span class="line"><span class="xml">          this.fullName = this.firstName + ' - ' + newVal;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>监听路由对象的改变：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> login = Vue.extend(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> register = Vue.extend(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line"><span class="undefined">      routes: [</span></span><br><span class="line"><span class="actionscript">        &#123; path: <span class="string">"/login"</span>, component: login &#125;,</span></span><br><span class="line"><span class="actionscript">        &#123; path: <span class="string">"/register"</span>, component: register &#125;</span></span><br><span class="line"><span class="undefined">      ]</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">      router: router,</span></span><br><span class="line"><span class="undefined">      watch: &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">'$route'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(newVal, oldVal)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (newVal.path === <span class="string">'/login'</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'这是登录组件'</span>);</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="computed计算属性的使用"><a href="#computed计算属性的使用" class="headerlink" title="computed计算属性的使用"></a><code>computed</code>计算属性的使用</h2><ol><li><p>默认只有<code>getter</code>的计算属性：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span> +</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span> =</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;fullName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el: '#app',</span></span><br><span class="line"><span class="xml">      data: &#123;</span></span><br><span class="line"><span class="xml">        firstName: 'jack',</span></span><br><span class="line"><span class="xml">        lastName: 'chen'</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      methods: &#123;&#125;,</span></span><br><span class="line"><span class="xml">      computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值</span></span><br><span class="line"><span class="xml">        fullName() &#123;</span></span><br><span class="line"><span class="xml">          return this.firstName + ' - ' + this.lastName;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>定义有<code>getter</code>和<code>setter</code>的计算属性：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"修改fullName"</span> @<span class="attr">click</span>=<span class="string">"changeName"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;fullName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    // 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el: '#app',</span></span><br><span class="line"><span class="xml">      data: &#123;</span></span><br><span class="line"><span class="xml">        firstName: 'jack',</span></span><br><span class="line"><span class="xml">        lastName: 'chen'</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      methods: &#123;</span></span><br><span class="line"><span class="xml">        changeName() &#123;</span></span><br><span class="line"><span class="xml">          this.fullName = 'TOM - chen2';</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      computed: &#123;</span></span><br><span class="line"><span class="xml">        fullName: &#123;</span></span><br><span class="line"><span class="xml">          get: function () &#123;</span></span><br><span class="line"><span class="xml">            return this.firstName + ' - ' + this.lastName;</span></span><br><span class="line"><span class="xml">          &#125;,</span></span><br><span class="line"><span class="xml">          set: function (newVal) &#123;</span></span><br><span class="line"><span class="xml">            var parts = newVal.split(' - ');</span></span><br><span class="line"><span class="xml">            this.firstName = parts[0];</span></span><br><span class="line"><span class="xml">            this.lastName = parts[1];</span></span><br><span class="line"><span class="xml">          &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="watch、computed和methods之间的对比"><a href="#watch、computed和methods之间的对比" class="headerlink" title="watch、computed和methods之间的对比"></a><code>watch</code>、<code>computed</code>和<code>methods</code>之间的对比</h2><ol><li><code>computed</code>属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li><li><code>methods</code>方法表示一个具体的操作，主要书写业务逻辑；</li><li><code>watch</code>一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是<code>computed</code>和<code>methods</code>的结合体；</li></ol><h2 id="nrm的安装使用"><a href="#nrm的安装使用" class="headerlink" title="nrm的安装使用"></a><code>nrm</code>的安装使用</h2><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；<br>什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；</p><ol><li>运行<code>npm i nrm -g</code>全局安装<code>nrm</code>包；</li><li>使用<code>nrm ls</code>查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</li><li>使用<code>nrm use npm</code>或<code>nrm use taobao</code>切换不同的镜像源地址；</li></ol><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ol><li><a href="http://www.cnblogs.com/joyho/articles/4430148.html" target="_blank" rel="noopener">URL中的hash（井号）</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;主要介绍组件化，组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Vue-js/2019/05/11/Vue-Day3/security-265130_1280.jpg&quot; alt=&quot;security-265130_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>VueJs学习笔记-Day2</title>
    <link href="http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day2.html"/>
    <id>http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day2.html</id>
    <published>2019-05-11T03:49:29.000Z</published>
    <updated>2019-05-11T09:22:26.228Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</p><p><img src="/Vue-js/2019/05/11/Vue-Day2/umbrella-801918_1280.jpg" alt="umbrella-801918_1280"></p><a id="more"></a><h1 id="Vue-js-Day2"><a href="#Vue-js-Day2" class="headerlink" title="Vue.js - Day2"></a>Vue.js - Day2</h1><h2 id="品牌管理案例"><a href="#品牌管理案例" class="headerlink" title="品牌管理案例"></a>品牌管理案例</h2><h3 id="添加新品牌"><a href="#添加新品牌" class="headerlink" title="添加新品牌"></a>添加新品牌</h3><h3 id="删除品牌"><a href="#删除品牌" class="headerlink" title="删除品牌"></a>删除品牌</h3><h3 id="根据条件筛选品牌"><a href="#根据条件筛选品牌" class="headerlink" title="根据条件筛选品牌"></a>根据条件筛选品牌</h3><ol><li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li></ol><p><a href="https://v1-cn.vuejs.org/api/#filterBy" target="_blank" rel="noopener">filterBy - 指令</a></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"item in list | filterBy searchName in 'name'"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.id</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span>.ctime&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"del(item.id)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>在2.x版本中<a href="https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果" target="_blank" rel="noopener">手动实现筛选的方式</a>：</li></ol><ul><li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;hr&gt; 输入筛选名称：</span><br><span class="line"></span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">v-model</span>=<span class="string">"searchName"</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"item in search(searchName)"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.id</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span>.ctime&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">          </span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"del(item.id)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">search(name) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.list.filter(x =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x.name.indexOf(name) != -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue调试工具vue-devtools的安装步骤和使用"><a href="#Vue调试工具vue-devtools的安装步骤和使用" class="headerlink" title="Vue调试工具vue-devtools的安装步骤和使用"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h2><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p><h3 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h3><ol><li>HTML元素：</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span>.ctime | dataFormat(<span class="string">'yyyy-mm-dd'</span>)&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>私有 <code>filters</code> 定义方式：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">filters</span>: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用</span><br><span class="line"></span><br><span class="line">    dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错</span><br><span class="line"></span><br><span class="line">      var dt = new Date(input);</span><br><span class="line"></span><br><span class="line">      // 获取年月日</span><br><span class="line"></span><br><span class="line">      var y = dt.getFullYear();</span><br><span class="line"></span><br><span class="line">      var m = (dt.getMonth() + 1).toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line">      var d = dt.getDate().toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class="line"></span><br><span class="line">      // 否则，就返回  年-月-日 时：分：秒</span><br><span class="line"></span><br><span class="line">      if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123;</span><br><span class="line"></span><br><span class="line">        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 获取时分秒</span><br><span class="line"></span><br><span class="line">        var hh = dt.getHours().toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line">        var mm = dt.getMinutes().toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line">        var ss = dt.getSeconds().toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p></blockquote><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局过滤器</span></span><br><span class="line"></span><br><span class="line">Vue.filter(<span class="string">'dataFormat'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">input, pattern = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(input);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取年月日</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> y = dt.getFullYear();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> m = (dt.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> d = dt.getDate().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则，就返回  年-月-日 时：分：秒</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pattern.toLowerCase() === <span class="string">'yyyy-mm-dd'</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时分秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hh = dt.getHours().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mm = dt.getMinutes().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ss = dt.getSeconds().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p></blockquote><h2 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id="1-x中自定义键盘修饰符【了解即可】"><a href="#1-x中自定义键盘修饰符【了解即可】" class="headerlink" title="1.x中自定义键盘修饰符【了解即可】"></a>1.x中自定义键盘修饰符【了解即可】</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.directive('<span class="keyword">on</span>').keyCodes.f2 = <span class="number">113</span>;</span><br></pre></td></tr></table></figure><h3 id="2-x中自定义键盘修饰符"><a href="#2-x中自定义键盘修饰符" class="headerlink" title="2.x中自定义键盘修饰符"></a><a href="https://cn.vuejs.org/v2/guide/events.html#键值修饰符" target="_blank" rel="noopener">2.x中自定义键盘修饰符</a></h3><ol><li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">Vue.config.keyCodes.f2</span> = <span class="number">113</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用自定义的按键修饰符：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">v-model</span>=<span class="string">"name"</span> @keyup.<span class="attribute">f2</span>=<span class="string">"add"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></h2><ol><li>自定义全局和局部的 自定义指令：</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：</span></span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line"></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> </span>&#123; <span class="comment">// inserted 表示被绑定元素插入父节点时调用</span></span><br><span class="line"></span><br><span class="line">    el.focus();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：</span></span><br><span class="line"></span><br><span class="line">  directives: &#123;</span><br><span class="line"></span><br><span class="line">    color: &#123; <span class="comment">// 为元素设置指定的字体颜色</span></span><br><span class="line"></span><br><span class="line">      bind(el, binding) &#123;</span><br><span class="line"></span><br><span class="line">        el.style.color = binding.value;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'font-weight'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(el, binding2)</span> </span>&#123; <span class="comment">// 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数</span></span><br><span class="line"></span><br><span class="line">      el.style.fontWeight = binding2.value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义指令的使用方式：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">v-model</span>=<span class="string">"searchName"</span> v-focus <span class="attribute">v-color</span>=<span class="string">"'red'"</span> <span class="attribute">v-font-weight</span>=<span class="string">"900"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue-1-x-中-自定义元素指令【已废弃-了解即可】"><a href="#Vue-1-x-中-自定义元素指令【已废弃-了解即可】" class="headerlink" title="Vue 1.x 中 自定义元素指令【已废弃,了解即可】"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.elementDirective(<span class="string">'red-color'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.el.style.color = <span class="string">'red'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用方式：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">red</span>-<span class="built_in">color</span>&gt;<span class="number">1232</span>&lt;/<span class="built_in">red</span>-<span class="built_in">color</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="vue实例的生命周期"><a href="#vue实例的生命周期" class="headerlink" title="vue实例的生命周期"></a><a href="https://cn.vuejs.org/v2/guide/instance.html#实例生命周期" target="_blank" rel="noopener">vue实例的生命周期</a></h2><ul><li>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</li><li><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</li><li>生命周期钩子 = 生命周期函数 = 生命周期事件</li><li>主要的生命周期函数分类：<ul><li>创建期间的生命周期函数：<ul><li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li><li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li><li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li><li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li></ul></li><li>运行期间的生命周期函数：<ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul></li><li>销毁期间的生命周期函数：<ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></li></ul></li></ul><h2 id="vue-resource-实现-get-post-jsonp请求"><a href="#vue-resource-实现-get-post-jsonp请求" class="headerlink" title="vue-resource 实现 get, post, jsonp请求"></a><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">vue-resource 实现 get, post, jsonp请求</a></h2><p>除了 vue-resource 之外，还可以使用 <code>axios</code> 的第三方包实现实现数据的请求</p><ol><li>之前的学习中，如何发起数据请求？</li><li>常见的数据请求类型？  get  post jsonp</li><li>测试的URL请求资源地址：<ul><li>get请求地址： <a href="http://vue.studyit.io/api/getlunbo" target="_blank" rel="noopener">http://vue.studyit.io/api/getlunbo</a></li><li>post请求地址：<a href="http://vue.studyit.io/api/post" target="_blank" rel="noopener">http://vue.studyit.io/api/post</a></li><li>jsonp请求地址：<a href="http://vue.studyit.io/api/jsonp" target="_blank" rel="noopener">http://vue.studyit.io/api/jsonp</a></li></ul></li><li><p>JSONP的实现原理</p><ul><li>由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；</li><li>可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；</li><li>具体实现过程：<ul><li>先在客户端定义一个回调方法，预定义对数据的操作；</li><li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；</li><li>服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；</li><li>客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；</li></ul></li><li>带大家通过 Node.js ，来手动实现一个JSONP的请求例子；<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">// 导入解析 URL 地址的核心模块</span></span><br><span class="line"><span class="keyword">const</span> urlModule = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"><span class="comment">// 监听 服务器的 request 请求事件，处理每个请求</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析客户端请求的URL地址</span></span><br><span class="line">  <span class="keyword">var</span> info = urlModule.parse(url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据</span></span><br><span class="line">  <span class="keyword">if</span> (info.pathname === <span class="string">'/getjsonp'</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取客户端指定的回调函数的名称</span></span><br><span class="line">    <span class="keyword">var</span> cbName = info.query.callback;</span><br><span class="line">    <span class="comment">// 手动拼接要返回给客户端的数据对象</span></span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      name: <span class="string">'zs'</span>,</span><br><span class="line">      age: <span class="number">22</span>,</span><br><span class="line">      gender: <span class="string">'男'</span>,</span><br><span class="line">      hobby: [<span class="string">'吃饭'</span>, <span class="string">'睡觉'</span>, <span class="string">'运动'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">`<span class="subst">$&#123;cbName&#125;</span>(<span class="subst">$&#123;JSON.stringify(data)&#125;</span>)`</span>;</span><br><span class="line">    <span class="comment">// 将拼接好的方法的调用，返回给客户端去解析执行</span></span><br><span class="line">    res.end(result);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'404'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server running at http://127.0.0.1:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>vue-resource 的配置步骤：</p><ul><li>直接在页面中，通过<code>script</code>标签，引入 <code>vue-resource</code> 的脚本文件；</li><li>注意：引用的先后顺序是：先引用 <code>Vue</code> 的脚本文件，再引用 <code>vue-resource</code> 的脚本文件；</li></ul></li><li><p>发送get请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getInfo() &#123; <span class="comment">// get 方式获取数据</span></span><br><span class="line">  <span class="keyword">this</span>.$http.get(<span class="string">'http://127.0.0.1:8899/api/getlunbo'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.body);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送post请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postInfo() &#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'http://127.0.0.1:8899/api/post'</span>;</span><br><span class="line">  <span class="comment">// post 方法接收三个参数：</span></span><br><span class="line">  <span class="comment">// 参数1： 要请求的URL地址</span></span><br><span class="line">  <span class="comment">// 参数2： 要发送的数据对象</span></span><br><span class="line">  <span class="comment">// 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded</span></span><br><span class="line">  <span class="keyword">this</span>.$http.post(url, &#123; <span class="attr">name</span>: <span class="string">'zs'</span> &#125;, &#123; <span class="attr">emulateJSON</span>: <span class="literal">true</span> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.body);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送JSONP请求获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jsonpInfo() &#123; <span class="comment">// JSONP形式从服务器获取数据</span></span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'http://127.0.0.1:8899/api/jsonp'</span>;</span><br><span class="line">  <span class="keyword">this</span>.$http.jsonp(url).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.body);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置本地数据库和数据接口API"><a href="#配置本地数据库和数据接口API" class="headerlink" title="配置本地数据库和数据接口API"></a>配置本地数据库和数据接口API</h2><ol><li>先解压安装 <code>PHPStudy</code>;</li><li>解压安装 <code>Navicat</code> 这个数据库可视化工具，并激活；</li><li>打开 <code>Navicat</code> 工具，新建空白数据库，名为 <code>dtcmsdb4</code>;</li><li>双击新建的数据库，连接上这个空白数据库，在新建的数据库上<code>右键</code> -&gt; <code>运行SQL文件</code>，选择并执行 <code>dtcmsdb4.sql</code> 这个数据库脚本文件；如果执行不报错，则数据库导入完成；</li><li>进入文件夹 <code>vuecms3_nodejsapi</code> 内部，执行 <code>npm i</code> 安装所有的依赖项；</li><li>先确保本机安装了 <code>nodemon</code>, 没有安装，则运行 <code>npm i nodemon -g</code> 进行全局安装，安装完毕后，进入到 <code>vuecms3_nodejsapi</code>目录 -&gt; <code>src</code>目录 -&gt; 双击运行 <code>start.bat</code></li><li>如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 <code>app.js</code> 中第 <code>14行</code> 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root</li></ol><h2 id="品牌管理改造"><a href="#品牌管理改造" class="headerlink" title="品牌管理改造"></a>品牌管理改造</h2><h3 id="展示品牌列表"><a href="#展示品牌列表" class="headerlink" title="展示品牌列表"></a>展示品牌列表</h3><h3 id="添加品牌数据"><a href="#添加品牌数据" class="headerlink" title="添加品牌数据"></a>添加品牌数据</h3><h3 id="删除品牌数据"><a href="#删除品牌数据" class="headerlink" title="删除品牌数据"></a>删除品牌数据</h3><h2 id="Vue中的动画"><a href="#Vue中的动画" class="headerlink" title="Vue中的动画"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Vue中的动画</a></h2><p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p><h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><ol><li><p>HTML结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"动起来"</span> @<span class="attr">click</span>=<span class="string">"myAnimate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"isshow"</span>&gt;</span>动画哦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>VM 实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="keyword">var</span> vm = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="keyword">data</span>: &#123;</span><br><span class="line">    isshow: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myAnimate() &#123;</span><br><span class="line">      <span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>定义两组类样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义进入和离开时候的过渡状态 */</span></span><br><span class="line">    <span class="selector-class">.fade-enter-active</span>,</span><br><span class="line">    <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="number">0.2s</span> ease;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义进入过渡的开始状态 和 离开过渡的结束状态 */</span></span><br><span class="line">    <span class="selector-class">.fade-enter</span>,</span><br><span class="line">    <span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">      <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(100px);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用第三方-CSS-动画库"><a href="#使用第三方-CSS-动画库" class="headerlink" title="使用第三方 CSS 动画库"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名" target="_blank" rel="noopener">使用第三方 CSS 动画库</a></h3><ol><li><p>导入动画类库：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">type</span>=<span class="string">"text/css"</span> <span class="attribute">href</span>=<span class="string">"./lib/animate.css"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义 transition 及属性：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">enter-active-<span class="keyword">class</span>=<span class="string">"fadeInRight"</span></span><br><span class="line">    leave-active-<span class="keyword">class</span>=<span class="string">"fadeOutRight"</span></span><br><span class="line">    :duration=<span class="string">"&#123; enter: 500, leave: 800 &#125;"</span>&gt;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">"animated"</span> v-show=<span class="string">"isshow"</span>&gt;动画哦&lt;/div&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><ol><li><p>定义 transition 组件以及三个钩子函数：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"切换动画"</span> @click=<span class="string">"isshow = !isshow"</span>&gt;</span><br><span class="line">    &lt;transition</span><br><span class="line">    @<span class="keyword">before</span>-enter=<span class="string">"beforeEnter"</span></span><br><span class="line">    @enter=<span class="string">"enter"</span></span><br><span class="line">    @<span class="keyword">after</span>-enter=<span class="string">"afterEnter"</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> v-<span class="keyword">if</span>=<span class="string">"isshow"</span> <span class="built_in">class</span>=<span class="string">"show"</span>&gt;OK&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义三个 methods 钩子方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        beforeEnter(el) &#123; <span class="comment">// 动画进入之前的回调</span></span><br><span class="line">          el.style.transform = <span class="string">'translateX(500px)'</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        enter(el, done) &#123; <span class="comment">// 动画进入完成时候的回调</span></span><br><span class="line">          el.offsetWidth;</span><br><span class="line">          el.style.transform = <span class="string">'translateX(0px)'</span>;</span><br><span class="line">          done();</span><br><span class="line">        &#125;,</span><br><span class="line">        afterEnter(el) &#123; <span class="comment">// 动画进入完成之后的回调</span></span><br><span class="line">          <span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>定义动画过渡时长和样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.show</span>&#123;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="number">0.4s</span> ease;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="v-for-的列表过渡"><a href="#v-for-的列表过渡" class="headerlink" title="v-for 的列表过渡"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡" target="_blank" rel="noopener">v-for 的列表过渡</a></h3><ol><li><p>定义过渡样式：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">style&gt;</span></span><br><span class="line">    .<span class="built_in">list-enter,</span></span><br><span class="line"><span class="built_in"></span>    .<span class="built_in">list-leave-to</span> &#123;</span><br><span class="line">      <span class="string">opacity:</span> 0;</span><br><span class="line">      <span class="string">transform:</span> <span class="string">translateY(</span><span class="string">10px)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="built_in">list-enter-active,</span></span><br><span class="line"><span class="built_in"></span>    .<span class="built_in">list-leave-active</span> &#123;</span><br><span class="line">      <span class="string">transition:</span> <span class="string">all </span>0.<span class="string">3s </span><span class="string">ease;</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="string">style&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> v-model=<span class="string">"txt"</span> @keyup.enter=<span class="string">"add"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;<span class="attribute">transition</span>-group tag=<span class="string">"ul"</span> name=<span class="string">"list"</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">li</span> v-<span class="keyword">for</span>=<span class="string">"(item, i) in list"</span> :key=<span class="string">"i"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/<span class="attribute">transition</span>-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义 VM中的结构：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="keyword">var</span> vm = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="keyword">data</span>: &#123;</span><br><span class="line">    txt: <span class="string">''</span>,</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.txt);</span><br><span class="line">      <span class="keyword">this</span>.txt = <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p><ul><li><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-move</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.8s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave-active</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol><li><a href="https://v1-cn.vuejs.org/" target="_blank" rel="noopener">vue.js 1.x 文档</a></li><li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js 2.x 文档</a></li><li><a href="http://www.css88.com/archives/7715" target="_blank" rel="noopener">String.prototype.padStart(maxLength, fillString)</a></li><li><a href="http://www.cnblogs.com/wuhua1/p/6686237.html" target="_blank" rel="noopener">js 里面的键盘事件对应的键码</a></li><li><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">pagekit/vue-resource</a></li><li><a href="https://jingyan.baidu.com/article/a65957f4976aad24e67f9b9b.html" target="_blank" rel="noopener">navicat如何导入sql文件和导出sql文件</a></li><li><a href="http://cubic-bezier.com/#.4,-0.3,1,.33" target="_blank" rel="noopener">贝塞尔在线生成器</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Vue-js/2019/05/11/Vue-Day2/umbrella-801918_1280.jpg&quot; alt=&quot;umbrella-801918_1280&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>VueJs学习笔记-Day1</title>
    <link href="http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day1.html"/>
    <id>http://jhjhljh.github.io/Vue-js/2019/05/11/Vue-Day1.html</id>
    <published>2019-05-11T03:49:20.000Z</published>
    <updated>2019-05-11T03:58:01.507Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架,本文主要讨论Vue基本的语法和概念</p><p><img src="/Vue-js/2019/05/11/Vue-Day1/laptop.jpg" alt="laptop"></p><a id="more"></a><h1 id="Vue-js-Day1"><a href="#Vue-js-Day1" class="headerlink" title="Vue.js - Day1"></a>Vue.js - Day1</h1><h3 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h3><ul><li><p>Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</p></li><li><p>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</p></li><li><p>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</p></li><li><p>前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；</p></li></ul><h2 id="为什么要学习流行框架"><a href="#为什么要学习流行框架" class="headerlink" title="为什么要学习流行框架"></a>为什么要学习流行框架</h2><ul><li>企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；<ul><li>企业中，使用框架，能够提高开发的效率；</li></ul></li></ul><ul><li>提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）</li><li>在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；</li></ul><ul><li>增强自己就业时候的竞争力<ul><li>人无我有，人有我优</li><li>你平时不忙的时候，都在干嘛？</li></ul></li></ul><h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><ul><li><p>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</p><ul><li>node 中的 express；</li></ul></li></ul><ul><li>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。<ul><li><ol><li>从Jquery 切换到 Zepto</li></ol></li><li><ol start="2"><li>从 EJS 切换到 art-template</li></ol></li></ul></li></ul><h2 id="Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别"><a href="#Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别" class="headerlink" title="Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别"></a>Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别</h2><ul><li>MVC 是后端的分层开发概念；</li><li><p>MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</p></li><li><p>为什么有了MVC还要有MVVM</p></li></ul><h2 id="Vue-js-基本代码-和-MVVM-之间的对应关系"><a href="#Vue-js-基本代码-和-MVVM-之间的对应关系" class="headerlink" title="Vue.js 基本代码 和 MVVM 之间的对应关系"></a>Vue.js 基本代码 和 MVVM 之间的对应关系</h2><h2 id="Vue之-基本的代码结构和插值表达式、v-cloak"><a href="#Vue之-基本的代码结构和插值表达式、v-cloak" class="headerlink" title="Vue之 - 基本的代码结构和插值表达式、v-cloak"></a>Vue之 - <code>基本的代码结构</code>和<code>插值表达式</code>、<code>v-cloak</code></h2><h2 id="Vue指令之v-text和v-html"><a href="#Vue指令之v-text和v-html" class="headerlink" title="Vue指令之v-text和v-html"></a>Vue指令之<code>v-text</code>和<code>v-html</code></h2><h2 id="Vue指令之v-bind的三种用法"><a href="#Vue指令之v-bind的三种用法" class="headerlink" title="Vue指令之v-bind的三种用法"></a>Vue指令之<code>v-bind</code>的三种用法</h2><ol><li><p>直接使用指令<code>v-bind</code></p></li><li><p>使用简化指令<code>:</code></p></li><li><p>在绑定的时候，拼接绑定内容：<code>:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot;</code></p></li></ol><h2 id="Vue指令之v-on和跑马灯效果"><a href="#Vue指令之v-on和跑马灯效果" class="headerlink" title="Vue指令之v-on和跑马灯效果"></a>Vue指令之<code>v-on</code>和<code>跑马灯效果</code></h2><h3 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h3><ol><li>HTML结构：</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"开启"</span> v-<span class="keyword">on</span>:click=<span class="string">"go"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"停止"</span> v-<span class="keyword">on</span>:click=<span class="string">"stop"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>Vue实例：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> vm = new Vue(&#123;</span><br><span class="line"></span><br><span class="line">     el: <span class="string">'#app'</span>,</span><br><span class="line"></span><br><span class="line">     <span class="keyword">data</span>: &#123;</span><br><span class="line"></span><br><span class="line">       info: <span class="string">'猥琐发育，别浪~！'</span>,</span><br><span class="line"></span><br><span class="line">       intervalId: <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     methods: &#123;</span><br><span class="line"></span><br><span class="line">       go() &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果当前有定时器在运行，则直接return</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.intervalId != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 开始定时器</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">this</span>.intervalId = setInterval(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.info = <span class="keyword">this</span>.info.substring(<span class="number">1</span>) + <span class="keyword">this</span>.info.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">         &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       stop() &#123;</span><br><span class="line"></span><br><span class="line">         clearInterval(<span class="keyword">this</span>.intervalId);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h2 id="Vue指令之v-on的缩写和事件修饰符"><a href="#Vue指令之v-on的缩写和事件修饰符" class="headerlink" title="Vue指令之v-on的缩写和事件修饰符"></a>Vue指令之<code>v-on的缩写</code>和<code>事件修饰符</code></h2><h3 id="事件修饰符："><a href="#事件修饰符：" class="headerlink" title="事件修饰符："></a>事件修饰符：</h3><ul><li><p>.stop       阻止冒泡</p></li><li><p>.prevent    阻止默认事件</p></li><li><p>.capture    添加事件侦听器时使用事件捕获模式</p></li><li><p>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</p></li><li><p>.once       事件只触发一次</p></li></ul><h2 id="Vue指令之v-model和双向数据绑定"><a href="#Vue指令之v-model和双向数据绑定" class="headerlink" title="Vue指令之v-model和双向数据绑定"></a>Vue指令之<code>v-model</code>和<code>双向数据绑定</code></h2><h2 id="简易计算器案例"><a href="#简易计算器案例" class="headerlink" title="简易计算器案例"></a>简易计算器案例</h2><ol><li>HTML 代码结构</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"n1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"opt"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>*<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span>÷<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"n2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"="</span> <span class="attr">v-on:click</span>=<span class="string">"getResult"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"result"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Vue实例代码：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> vm = new Vue(&#123;</span><br><span class="line"></span><br><span class="line">     el: <span class="string">'#app'</span>,</span><br><span class="line"></span><br><span class="line">     <span class="keyword">data</span>: &#123;</span><br><span class="line"></span><br><span class="line">       n1: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       n2: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       result: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       opt: <span class="string">'0'</span></span><br><span class="line"></span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     methods: &#123;</span><br><span class="line"></span><br><span class="line">       getResult() &#123;</span><br><span class="line"></span><br><span class="line">         switch (<span class="keyword">this</span>.opt) &#123;</span><br><span class="line"></span><br><span class="line">           case <span class="string">'0'</span>:</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.result = parseInt(<span class="keyword">this</span>.n1) + parseInt(<span class="keyword">this</span>.n2);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           case <span class="string">'1'</span>:</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.result = parseInt(<span class="keyword">this</span>.n1) - parseInt(<span class="keyword">this</span>.n2);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           case <span class="string">'2'</span>:</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.result = parseInt(<span class="keyword">this</span>.n1) * parseInt(<span class="keyword">this</span>.n2);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           case <span class="string">'3'</span>:</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.result = parseInt(<span class="keyword">this</span>.n1) / parseInt(<span class="keyword">this</span>.n2);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h2 id="在Vue中使用样式"><a href="#在Vue中使用样式" class="headerlink" title="在Vue中使用样式"></a>在Vue中使用样式</h2><h3 id="使用class样式"><a href="#使用class样式" class="headerlink" title="使用class样式"></a>使用class样式</h3><ol><li><p>数组</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"['red', 'thin']"</span>&gt;</span>这是一个邪恶的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>数组中使用三元表达式</p><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class="[<span class="string">'red'</span>, <span class="string">'thin'</span>, isactive?<span class="string">'active'</span>:<span class="string">''</span>]"&gt;这是一个邪恶的H1&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>数组中嵌套对象</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"['red', 'thin', </span></span></span><span class="template-variable">&#123;'active': isactive&#125;</span><span class="xml"><span class="tag"><span class="string">]"</span>&gt;</span>这是一个邪恶的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>直接使用对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">h1 :</span><span class="class"><span class="keyword">class</span>="&#123;</span><span class="string">red:</span><span class="literal">true</span>, <span class="string">italic:</span><span class="literal">true</span>, <span class="string">active:</span><span class="literal">true</span>, <span class="string">thin:</span><span class="literal">true</span>&#125;<span class="string">"&gt;这是一个邪恶的H1&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h3><ol><li><p>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;color: 'red', 'font-size': '40px'&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>这是一个善良的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</p><ul><li><p>在data上定义样式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">data</span>: &#123;</span><br><span class="line">        <span class="attribute">h1StyleObj</span>: &#123; <span class="attribute">color</span>: <span class="string">'red'</span>, <span class="string">'font-size'</span>: <span class="string">'40px'</span>, <span class="string">'font-weight'</span>: <span class="string">'200'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"h1StyleObj"</span>&gt;</span>这是一个善良的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</p><ul><li><p>在data上定义样式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">data</span>: &#123;</span><br><span class="line">        <span class="attribute">h1StyleObj</span>: &#123; <span class="attribute">color</span>: <span class="string">'red'</span>, <span class="string">'font-size'</span>: <span class="string">'40px'</span>, <span class="string">'font-weight'</span>: <span class="string">'200'</span> &#125;,</span><br><span class="line">        <span class="attribute">h1StyleObj2</span>: &#123; <span class="attribute">fontStyle</span>: <span class="string">'italic'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"[h1StyleObj, h1StyleObj2]"</span>&gt;</span>这是一个善良的H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Vue指令之v-for和key属性"><a href="#Vue指令之v-for和key属性" class="headerlink" title="Vue指令之v-for和key属性"></a>Vue指令之<code>v-for</code>和<code>key</code>属性</h2><ol><li>迭代数组</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line">  <span class="string">&lt;li</span> <span class="string">v-for="(item,</span> <span class="string">i)</span> <span class="string">in</span> <span class="string">list"&gt;索引：&#123;&#123;i&#125;&#125;</span> <span class="meta">---</span> <span class="string">姓名：&#123;&#123;item.name&#125;&#125;</span> <span class="meta">---</span> <span class="string">年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>迭代对象中的属性</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">循环遍历对象身上的属性</span> <span class="bullet">--&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="string">&lt;div</span> <span class="string">v-for="(val,</span> <span class="string">key,</span> <span class="string">i)</span> <span class="string">in</span> <span class="string">userInfo"&gt;&#123;&#123;val&#125;&#125;</span> <span class="meta">---</span> <span class="string">&#123;&#123;key&#125;&#125;</span> <span class="meta">---</span> <span class="string">&#123;&#123;i&#125;&#125;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>迭代数字</li></ol><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"i in 10"</span>&gt;</span>这是第 </span><span class="template-variable">&#123;&#123;i&#125;&#125;</span><span class="xml"> 个P标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.2.0+ 的版本里，<strong>当在组件中使用</strong> v-for 时，key 现在是必须的。</p></blockquote><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p><h2 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h2><blockquote><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p></blockquote><h2 id="品牌管理案例"><a href="#品牌管理案例" class="headerlink" title="品牌管理案例"></a>品牌管理案例</h2><h3 id="添加新品牌"><a href="#添加新品牌" class="headerlink" title="添加新品牌"></a>添加新品牌</h3><h3 id="删除品牌"><a href="#删除品牌" class="headerlink" title="删除品牌"></a>删除品牌</h3><h3 id="根据条件筛选品牌"><a href="#根据条件筛选品牌" class="headerlink" title="根据条件筛选品牌"></a>根据条件筛选品牌</h3><ol><li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li></ol><p><a href="https://v1-cn.vuejs.org/api/#filterBy" target="_blank" rel="noopener">filterBy - 指令</a></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"item in list | filterBy searchName in 'name'"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.id</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span>.ctime&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"del(item.id)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>在2.x版本中<a href="https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果" target="_blank" rel="noopener">手动实现筛选的方式</a>：</li></ol><ul><li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;hr&gt; 输入筛选名称：</span><br><span class="line"></span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">v-model</span>=<span class="string">"searchName"</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"item in search(searchName)"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.id</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span>.ctime&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">          </span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"del(item.id)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">search(name) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.list.filter(x =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x.name.indexOf(name) != -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue调试工具vue-devtools的安装步骤和使用"><a href="#Vue调试工具vue-devtools的安装步骤和使用" class="headerlink" title="Vue调试工具vue-devtools的安装步骤和使用"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h2><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p><h3 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h3><ol><li>HTML元素：</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span>.ctime | dataFormat(<span class="string">'yyyy-mm-dd'</span>)&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>私有 <code>filters</code> 定义方式：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">filters</span>: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用</span><br><span class="line"></span><br><span class="line">    dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错</span><br><span class="line"></span><br><span class="line">      var dt = new Date(input);</span><br><span class="line"></span><br><span class="line">      // 获取年月日</span><br><span class="line"></span><br><span class="line">      var y = dt.getFullYear();</span><br><span class="line"></span><br><span class="line">      var m = (dt.getMonth() + 1).toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line">      var d = dt.getDate().toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class="line"></span><br><span class="line">      // 否则，就返回  年-月-日 时：分：秒</span><br><span class="line"></span><br><span class="line">      if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123;</span><br><span class="line"></span><br><span class="line">        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 获取时分秒</span><br><span class="line"></span><br><span class="line">        var hh = dt.getHours().toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line">        var mm = dt.getMinutes().toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line">        var ss = dt.getSeconds().toString().padStart(2, '0');</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p></blockquote><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局过滤器</span></span><br><span class="line"></span><br><span class="line">Vue.filter(<span class="string">'dataFormat'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">input, pattern = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(input);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取年月日</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> y = dt.getFullYear();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> m = (dt.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> d = dt.getDate().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则，就返回  年-月-日 时：分：秒</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pattern.toLowerCase() === <span class="string">'yyyy-mm-dd'</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时分秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hh = dt.getHours().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mm = dt.getMinutes().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ss = dt.getSeconds().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p></blockquote><h2 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id="1-x中自定义键盘修饰符【了解即可】"><a href="#1-x中自定义键盘修饰符【了解即可】" class="headerlink" title="1.x中自定义键盘修饰符【了解即可】"></a>1.x中自定义键盘修饰符【了解即可】</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.directive('<span class="keyword">on</span>').keyCodes.f2 = <span class="number">113</span>;</span><br></pre></td></tr></table></figure><h3 id="2-x中自定义键盘修饰符"><a href="#2-x中自定义键盘修饰符" class="headerlink" title="2.x中自定义键盘修饰符"></a><a href="https://cn.vuejs.org/v2/guide/events.html#键值修饰符" target="_blank" rel="noopener">2.x中自定义键盘修饰符</a></h3><ol><li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">Vue.config.keyCodes.f2</span> = <span class="number">113</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用自定义的按键修饰符：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">v-model</span>=<span class="string">"name"</span> @keyup.<span class="attribute">f2</span>=<span class="string">"add"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></h2><ol><li>自定义全局和局部的 自定义指令：</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：</span></span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line"></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> </span>&#123; <span class="comment">// inserted 表示被绑定元素插入父节点时调用</span></span><br><span class="line"></span><br><span class="line">    el.focus();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：</span></span><br><span class="line"></span><br><span class="line">  directives: &#123;</span><br><span class="line"></span><br><span class="line">    color: &#123; <span class="comment">// 为元素设置指定的字体颜色</span></span><br><span class="line"></span><br><span class="line">      bind(el, binding) &#123;</span><br><span class="line"></span><br><span class="line">        el.style.color = binding.value;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'font-weight'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(el, binding2)</span> </span>&#123; <span class="comment">// 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数</span></span><br><span class="line"></span><br><span class="line">      el.style.fontWeight = binding2.value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义指令的使用方式：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">v-model</span>=<span class="string">"searchName"</span> v-focus <span class="attribute">v-color</span>=<span class="string">"'red'"</span> <span class="attribute">v-font-weight</span>=<span class="string">"900"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue-1-x-中-自定义元素指令【已废弃-了解即可】"><a href="#Vue-1-x-中-自定义元素指令【已废弃-了解即可】" class="headerlink" title="Vue 1.x 中 自定义元素指令【已废弃,了解即可】"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.elementDirective(<span class="string">'red-color'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.el.style.color = <span class="string">'red'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用方式：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">red</span>-<span class="built_in">color</span>&gt;<span class="number">1232</span>&lt;/<span class="built_in">red</span>-<span class="built_in">color</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol><li><a href="https://v1-cn.vuejs.org/" target="_blank" rel="noopener">vue.js 1.x 文档</a></li><li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js 2.x 文档</a></li><li><a href="http://www.css88.com/archives/7715" target="_blank" rel="noopener">String.prototype.padStart(maxLength, fillString)</a></li><li><a href="http://www.cnblogs.com/wuhua1/p/6686237.html" target="_blank" rel="noopener">js 里面的键盘事件对应的键码</a></li><li><a href="http://www.cnblogs.com/kidney/p/6052935.html" target="_blank" rel="noopener">Vue.js双向绑定的实现原理</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架,本文主要讨论Vue基本的语法和概念&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Vue-js/2019/05/11/Vue-Day1/laptop.jpg&quot; alt=&quot;laptop&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://jhjhljh.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-07.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-07.html</id>
    <published>2019-05-11T03:08:23.000Z</published>
    <updated>2019-05-11T15:35:42.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">提到排序，鸡皮疙瘩都起来了，排序思想固然是好玩的，但是代码的实现也是无比蛋疼，记忆起来噩梦级别，之后会在这里补充一些排序算法相关的练习题</p><blockquote class="question">排序习题</blockquote><p><img src="/DataStructure/2019/05/11/DataStructure-07/ipe-yellow.jpg" alt="ipe-yellow"></p><a id="more"></a><blockquote class="question">听首歌先，缓解接下来乏味的过程，Lantern是我很喜欢的挪威剧中的配乐</blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=29844475&auto=1&height=32"></iframe><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们根据待排序记录是否全部被放置在内存中，将排序分为内排序和外排序两种，外排序需要在内外存之间多次交换数据才能进行。我们本章主要讲的是内排序的算法</p><ul><li>我们根据排序过程中借助的主要操作，将内排序分为：</li></ul><ol><li>插入排序类<blockquote><p>包括直接插入排序跟希尔排序</p></blockquote></li><li>选择排序类<blockquote><p>包括简单选择排序和堆排序</p></blockquote></li><li>交换排序类<blockquote><p>包括冒泡排序跟快速排序</p></blockquote></li><li>归并排序类<blockquote><p>包括归并排序</p></blockquote></li></ol><hr><h2 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h2><ul><li>内排序与外排序</li></ul><p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行</p><ul><li>对于内排序来说，排序算法的性能主要是受3个方面影响</li></ul><ol><li>时间性能</li><li>辅助空间</li><li>算法的复杂度</li></ol><ul><li>我们根据排序过程中借助的主要操作，将内排序分为：插入排序，交换排序，选择排序，归并排序<h3 id="排序用到的结构与函数"><a href="#排序用到的结构与函数" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10  <span class="comment">/*用于要排序数组个数的最大值，可根据需要修改*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];  <span class="comment">/*用于存储要排序数组，r[0]用于哨兵或临时变量*/</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">/*用于记录顺序表的长度*/</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure></li></ul><p>另外，由于排序最常用的操作是数组两元素的交换，我们将它写成函数<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*交换<span class="type">L</span>中数组r的下标为i和j的值*/</span><br><span class="line">void swap(<span class="type">SqList</span> *<span class="type">L</span>,<span class="built_in">int</span> i,<span class="built_in">int</span> j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> temp = <span class="type">L</span>-&gt;r[i];</span><br><span class="line">    <span class="type">L</span>-&gt;r[i]=<span class="type">L</span>-&gt;[j];</span><br><span class="line">    <span class="type">L</span>-&gt;r[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h3><ul><li>冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止<blockquote><p>冒泡实现在细节上可以有多种变化，我们将分别就3种不同的冒泡实现代码。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表L作交换排序(冒泡排序初级版)*/</span></span><br><span class="line">void BubbleSort0(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    <span class="function"><span class="title">for</span>(i=1;i&lt;L-&gt;</span>length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(j=i+1;i&lt;L-&gt;</span>length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(L-&gt;</span><span class="function"><span class="title">r</span>[i] &gt; L-&gt;</span>r[j])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(L,i,j);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>这段代码严格意义上，不算是标准的冒泡排序算法，因为它不满足两两比较相邻记录的冒泡排序思想，它更应该是最最简单的交换排序而已，而且效率很低</p></blockquote><p>以下是正宗的冒泡排序<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    <span class="function"><span class="title">for</span>(i=1;i&lt;L-&gt;</span>length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(j=L-&gt;</span>length-<span class="number">1</span>;j&gt;=i;j--)  <span class="comment">/*注意j是从后往前循环*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(L-&gt;</span><span class="function"><span class="title">r</span>[j] &gt; L-&gt;</span>r[j+<span class="number">1</span>])  <span class="comment">/*若前者大于后者(注意与前者的差异)*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(L,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表L作改进冒泡算法*/</span></span><br><span class="line">void BubbleSort2(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    Status flag=<span class="keyword">TRUE</span>;  <span class="comment">/*flag用来作为标记*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag;i++)  <span class="comment">/*若flag为false则退出循环*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="keyword">FALSE</span>;  <span class="comment">/*初始为false*/</span></span><br><span class="line">        <span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[j] &gt; L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(L,j,j+<span class="number">1</span>);</span><br><span class="line">                flag=<span class="keyword">TRUE</span>;  <span class="comment">/*若有数据交换，则flag为true*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>冒泡排序法复杂度分析，总时间复杂度为O(n^2^)</p></blockquote><hr><h3 id="简单选择排序-Simple-Selection-Sort"><a href="#简单选择排序-Simple-Selection-Sort" class="headerlink" title="简单选择排序(Simple Selection Sort)"></a>简单选择排序(Simple Selection Sort)</h3><ul><li>简单选择排序法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和i个记录交换之<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> SelectSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;<span class="built_in">length</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = i;  <span class="comment">/*将当前下标定义为最小值下标*/</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=L-&gt;<span class="built_in">length</span>;j++)  <span class="comment">/*循环之后的数据*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[<span class="built_in">min</span>]&gt;L-&gt;r[j])  <span class="comment">/*如果有小于当前最小值的关键字*/</span></span><br><span class="line">                <span class="built_in">min</span>=j;  <span class="comment">/*将此关键字的下标赋值给min*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="built_in">min</span>)  <span class="comment">/*若min不等于i，说明找到最小值，交换*/</span></span><br><span class="line">            swap(L,i,<span class="built_in">min</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>简单选择排序复杂度仍然为O(n^2^)，尽管如此，但是性能上还是要略优于冒泡排序</p></blockquote><hr><h3 id="直接插入排序-Straight-Insertion-Sort"><a href="#直接插入排序-Straight-Insertion-Sort" class="headerlink" title="直接插入排序(Straight Insertion Sort)"></a>直接插入排序(Straight Insertion Sort)</h3><ul><li>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    <span class="function"><span class="title">for</span>(i=2;i&lt;=L-&gt;</span>length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(L-&gt;</span><span class="function"><span class="title">r</span>[i] &lt; L-&gt;</span><span class="function"><span class="title">r</span>[i-1])  /*需将L-&gt;</span>r[i]插入有序子表*/</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;<span class="function"><span class="title">r</span>[0]=L-&gt;</span>r[i];  <span class="comment">/*设置哨兵*/</span></span><br><span class="line">            <span class="function"><span class="title">for</span>(j=i-1;L-&gt;</span><span class="function"><span class="title">r</span>[j] &gt; L-&gt;</span>r[<span class="number">0</span>];j--)</span><br><span class="line">                L-&gt;<span class="function"><span class="title">r</span>[j+1]=L-&gt;</span>r[j];  <span class="comment">/*记录后移*/</span></span><br><span class="line">            L-&gt;<span class="function"><span class="title">r</span>[j+1]=L-&gt;</span>r[<span class="number">0</span>];  <span class="comment">/*插入到正确位置*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>直接插入排序法的时间复杂度还是O(n^2^)，但是直接插入排序法比冒泡和简单选择排序的性能更好一些.</p></blockquote><hr><h3 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    <span class="function"><span class="title">int</span> increment=L-&gt;</span>length;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        increment=increment/<span class="number">3</span> + <span class="number">1</span>;  <span class="comment">/*增量序列*/</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(i=increment+1;i&lt;=L-&gt;</span>length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(L-&gt;</span><span class="function"><span class="title">r</span>[i] &lt; L-&gt;</span>r[i-increment])</span><br><span class="line">            &#123;  <span class="comment">/*需将L-&gt;r[i]插入有序增量子表*/</span></span><br><span class="line">                L-&gt;<span class="function"><span class="title">r</span>[0]=L-&gt;</span><span class="function"><span class="title">r</span>[i];  /*暂存在L-&gt;</span>r[<span class="number">0</span>]*/</span><br><span class="line">                <span class="function"><span class="title">for</span>(j=i-increment;j&gt;0 &amp;&amp; L-&gt;</span><span class="function"><span class="title">r</span>[0] &lt; L-&gt;</span>r[j];j-=increment)</span><br><span class="line">                    L-&gt;<span class="function"><span class="title">r</span>[j+increment]=L-&gt;</span>r[j];  <span class="comment">/*记录后移，查找插入位置*/</span></span><br><span class="line">                L-&gt;<span class="function"><span class="title">r</span>[j+increment]=L-&gt;</span>r[<span class="number">0</span>]  <span class="comment">/*插入*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“增量”的选取非常关键，需要注意增量序列的最后一个增量必须等于1才行</p><blockquote><p>希尔排序的时间复杂度为O(n^3/2^)，终于突破了慢速排序的时代(超越了时间复杂度为O(n^2^)</p></blockquote></blockquote><hr><h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h3><ul><li>堆是具有下列性质的完全二叉树</li></ul><ol><li>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆</li><li>或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆<blockquote><p>故根结点一定是堆中所有的结点的最大(小)者</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表L进行堆排序*/</span></span><br><span class="line"><span class="type">void</span> HeapSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;<span class="built_in">length</span>/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)  <span class="comment">/*把L中的r构建成一个大顶堆*/</span></span><br><span class="line">        HeapAdjust(L,i,L-&gt;<span class="built_in">length</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;<span class="built_in">length</span>;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(L,<span class="number">1</span>,i);  <span class="comment">/*将堆顶记录和当前未经排序子序列的最后一个记录交换*/</span></span><br><span class="line">        HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);  <span class="comment">/*将L-&gt;r[1..i-1]重新调整未大顶堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>弄清楚i的变化是在调整哪些元素后，可以看关键的HeapAdjust(堆调整)函数是如何实现的<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义*/</span></span><br><span class="line"><span class="comment">/*本函数调整L-&gt;r[s]的关键字，使L-&gt;r[s..m]成为一个大顶堆*/</span></span><br><span class="line">void HeapAdjust(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,j;</span><br><span class="line">    temp=L-&gt;r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>)  <span class="comment">/*沿关键字较大的孩子结点向下筛选*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">            ++j;  <span class="comment">/*j为关键字中较大的记录的下标*/</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=L-&gt;r[j])</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">/*rc应插入在位置s上*/</span></span><br><span class="line">        L-&gt;r[s]=L-&gt;r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[s]=temp; <span class="comment">/*插入*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">    swap(L,<span class="number">1</span>,i);  <span class="comment">/*将堆顶记录和当前未经排序子序列的最后一个记录交换*/</span></span><br><span class="line">    HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);  <span class="comment">/*将L-&gt;r[1..i-1]重新调整为大顶堆*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>堆排序的时间复杂度为O(nlogn)，这在性能上显然要远远好过于冒泡，简单选择，直接插入的时间复杂度了</p></blockquote><hr><h3 id="归并排序-Merging-Sort"><a href="#归并排序-Merging-Sort" class="headerlink" title="归并排序(Merging Sort)"></a>归并排序(Merging Sort)</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MergeSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    MS<span class="function"><span class="title">ort</span>(L-&gt;</span><span class="function"><span class="title">r</span>,L-&gt;</span><span class="function"><span class="title">r</span>,1,L-&gt;</span>length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*将SR<span class="string">[s..t]</span>归并排序为TR1<span class="string">[s..t]</span>*/</span><br><span class="line">void MSort(int SR<span class="string">[]</span>,int TR1<span class="string">[]</span>,int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    int TR2<span class="string">[MAXSIZE+1]</span>;</span><br><span class="line">    if(s==t)</span><br><span class="line">        TR1<span class="string">[s]</span>=SR<span class="string">[s]</span>;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        m=(s+t)/<span class="number">2</span>;  /*将SR<span class="string">[s..t]</span>平分为SR<span class="string">[s..m]</span>和SR<span class="string">[m+1..t]</span>*/</span><br><span class="line">        MSort(SR,TR2,s,m);  /*递归将SR<span class="string">[s..m]</span>归并为有序的TR2<span class="string">[s..m]</span>*/</span><br><span class="line">        MSort(SR,TR2,m+<span class="number">1</span>,t);  /*递归将SR<span class="string">[m+1..t]</span>归并为有序TR2<span class="string">[m+1..t]</span>*/</span><br><span class="line">        Merge(TR2,TR1,s,m,t);  /*将TR2<span class="string">[s..m]</span>和TR2<span class="string">[m+1..t]</span>归并到TR1<span class="string">[s..]</span>*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]*/</span></span><br><span class="line">void Merge(int <span class="built_in">SR</span>[],int TR[],int i,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">j,k,l;</span></span><br><span class="line"><span class="keyword"> </span>   for(<span class="keyword">j=m+1,k=1;i&lt;=m </span>&amp;&amp; <span class="keyword">j&lt;=n;k++) </span> <span class="comment">/*将SR中记录由小到大归并入TR*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        if(<span class="built_in">SR</span>[i]&lt;<span class="built_in">SR</span>[<span class="keyword">j])</span></span><br><span class="line"><span class="keyword"> </span>           TR[k]=<span class="built_in">SR</span>[i++]<span class="comment">;</span></span><br><span class="line">        else</span><br><span class="line">            TR[k]=<span class="built_in">SR</span>[<span class="keyword">j++];</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    if(i&lt;=m)</span><br><span class="line">    &#123;</span><br><span class="line">        for(l=<span class="number">0</span><span class="comment">;l&lt;=m-i;l++)</span></span><br><span class="line">            TR[k+<span class="number">1</span>]=<span class="built_in">SR</span>[i+<span class="number">1</span>]  <span class="comment">/*将剩余的SR[i..m]复制到TR*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    if(<span class="keyword">j&lt;=n)</span></span><br><span class="line"><span class="keyword"> </span>   &#123;</span><br><span class="line">        for(l=<span class="number">0</span><span class="comment">;l&lt;=n-j;l++)</span></span><br><span class="line">            TR[k+<span class="number">1</span>]=<span class="built_in">SR</span>[<span class="keyword">j+1]; </span> <span class="comment">/*将剩余的SR[j..n]复制到TR*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：一趟归并需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行(log2n)次，因此，总的时间复杂度为O(nlogn)，空间复杂度为O(n+logn)</p></blockquote><h4 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表L作归并非递归排序*/</span></span><br><span class="line">void MergeSort2(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">int</span>* TR=(int*)malloc(L-&gt;</span>length*sizeof(int));  <span class="comment">/*申请额外空间*/</span></span><br><span class="line">    int k=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">while</span>(k&lt;L-&gt;</span>length)</span><br><span class="line">    &#123;</span><br><span class="line">        M<span class="function"><span class="title">ergePass</span>(L-&gt;</span><span class="function"><span class="title">r</span>,TR,k,L-&gt;</span>length);</span><br><span class="line">        k=<span class="number">2</span>*k;  <span class="comment">/*子序列长度加倍*/</span></span><br><span class="line">        M<span class="function"><span class="title">ergePass</span>(TR,L-&gt;</span><span class="function"><span class="title">r</span>,k,L-&gt;</span>length);</span><br><span class="line">        k=<span class="number">2</span>*k;  <span class="comment">/*子序列长度加倍*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们能感受到，非递归的迭代做法更加直接了当，从最小的序列开始归并直至完成，不需要像归并的递归算法一样，需要先拆分递归，再归并退出递归<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将SR[]中相邻长度为s的子序列两两归并到TR[]*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Merge(SR,TR,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);  <span class="comment">/*两两归并*/</span></span><br><span class="line">        i=i+<span class="number">2</span>*s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n-s+<span class="number">1</span>)  <span class="comment">/*归并最后两个序列*/</span></span><br><span class="line">        Merge(SR,TR,i,i+s<span class="number">-1</span>,n);</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/*若最后只剩下单个子序列*/</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            TR[j]=SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>非递归的迭代方法，避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O(n)，而且避免递归也在时间性能上有一定的提升，应该说，使用归并排序时，尽量考虑非递归方法。</p></blockquote><hr><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSort(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表L中的子序列L-&gt;r[low..high]作快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        pivot=Partition(L,low,high);  <span class="comment">/*将L-&gt;r[low..high]一分为二，算出枢轴值pivot*/</span></span><br><span class="line">        QSort(L,low,pivot<span class="number">-1</span>);  <span class="comment">/*对低子表递归排序*/</span></span><br><span class="line">        QSort(L,pivot+<span class="number">1</span>,high);  <span class="comment">/*对高子表递归排序*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Partition函数要做的，就是先选取当中一个关键字，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边值都比它大，我们将这样的关键字称为枢轴(pivot)<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置*/</span></span><br><span class="line"><span class="comment">/*此时在它之前(后)的记录均不大(小)与它*/</span></span><br><span class="line"><span class="keyword">int</span> Partition(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotkey;</span><br><span class="line">    pivotkey=L-&gt;r[low];  <span class="comment">/*用子表的第一个记录作枢轴记录*/</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)  <span class="comment">/*从表的两端交替向中间扫描*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)</span><br><span class="line">            high--;</span><br><span class="line">        swap(L,low,high);  <span class="comment">/*将比枢轴记录小的记录交换到低端*/</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class="line">            low++;</span><br><span class="line">        swap(L,low,high);  <span class="comment">/*将比枢轴记录大的记录交换到高端*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">/*返回枢轴所在位置*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在最优的情况下，快速排序算法的时间复杂度为O(nlogn)</p><blockquote><p>证明过程了解一下</p></blockquote></blockquote><h4 id="快速排序优化"><a href="#快速排序优化" class="headerlink" title="快速排序优化"></a>快速排序优化</h4><ol><li>优化选取枢轴</li></ol><ul><li>三数取中(median-of-three)法，即选取三个关键字先进行排序，将中间数作为枢纽，一般是取左端，右端，中间三个数，也可以随机选取。这样至少这个中间数不会是最小或最大的数。<blockquote><p>故在Partition函数代码的第3行与第4行之间增加这样一段代码</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int pivotkey;</span><br><span class="line">int m = low + (high - low)/<span class="number">2</span>;  <span class="comment">/*计算数组中间的元素下标*/</span></span><br><span class="line"><span class="function"><span class="title">if</span>(L-&gt;</span><span class="function"><span class="title">r</span>[low] &gt; L-&gt;</span>r[high])</span><br><span class="line">    swap(L,low,high);  <span class="comment">/*交换左端与右端数据，保证左端较小*/</span></span><br><span class="line"><span class="function"><span class="title">if</span>(L-&gt;</span><span class="function"><span class="title">r</span>[m] &gt; L-&gt;</span>r[high])</span><br><span class="line">    swap(L,high,m);  <span class="comment">/*交换中间与右端数据，保证中间较小*/</span></span><br><span class="line"><span class="function"><span class="title">if</span>(L-&gt;</span><span class="function"><span class="title">r</span>[m] &gt; L-&gt;</span>r[low])</span><br><span class="line">    swap[L,m,low];  <span class="comment">/*交换中间与左端数据，保证左端较小*/</span></span><br><span class="line"><span class="comment">/*此时L，r[low]已经为整个序列左中右三个关键字的中间值*/</span></span><br><span class="line"><span class="function"><span class="title">pivotkey</span> = L-&gt;</span>[low];  <span class="comment">/*用子表的第一个记录作为枢轴记录*/</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><p>当然三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey，但是对于非常大的待排序的序列来说还是不足以保证能够选出一个好的pivotkey，因此还有个方法叫<strong>九数取中(median-of-nine)</strong></p><blockquote><p>三次三数取中，然后再进行一次三数取中</p></blockquote><p>2.优化不必要的交换<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*快速排序优化算法*/</span></span><br><span class="line"><span class="keyword">int</span> Partition1(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotkey;  <span class="comment">//这里省略三数取中代码</span></span><br><span class="line">    pivotkey = L-&gt;r[low];  <span class="comment">/*用于表的第一个记录作枢纽记录*/</span></span><br><span class="line">    L-&gt;r[<span class="number">0</span>]=pivotkey;  /将枢纽关键字备份到L-&gt;r[<span class="number">0</span>]/</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)  <span class="comment">/*从表的两端交替向中间扫描*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)</span><br><span class="line">            high--</span><br><span class="line">        L-&gt;r[low]=L-&gt;r[high];  /采用替换而不是交换的方式进行操作/</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class="line">            low++;</span><br><span class="line">        L-&gt;r[high]=L-&gt;r[low];  /采用替换而不是交换的方式进行操作/</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[low]=L-&gt;r[<span class="number">0</span>];  /将枢纽数值替换回L.r[low]/</span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">/*返回枢轴所在位置*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.优化小数组时的排序方案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LENGTH_INSERT_SORT 7 <span class="comment">/*数组长度阀值*/</span></span></span><br><span class="line"><span class="comment">/*对顺序表L中的子序列L.r[low..high]作快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</span><br><span class="line">    &#123;<span class="comment">/*当high-low大于常数时用快速排序*/</span></span><br><span class="line">        pivot=Partition(L,low,high);  <span class="comment">/*将L.r[low..high]一分为二，并算出枢轴值pivot*/</span></span><br><span class="line">        QSort(L,low,pivot<span class="number">-1</span>);  <span class="comment">/*第低子表递归排序*/</span></span><br><span class="line">        QSort(L,pivot+<span class="number">1</span>,high);  <span class="comment">/*对高子表递归排序*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/*当high-low小于等于常数时用直接插入排序*/</span></span><br><span class="line">        InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果数组小还不如直接插入排序来得更快(直接插入是简单排序中性能最好的)</p><ol start="4"><li>优化递归操作</li></ol><p>我们对QSort实施<strong>尾递归</strong>优化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            pivot=Partition1(L,low,high);  <span class="comment">/*L.r[low..high]一分为二，算出枢轴值*/</span></span><br><span class="line">            QSort1(L,low,pivot<span class="number">-1</span>);  <span class="comment">/*对低子表递归排序*/</span></span><br><span class="line">            low=pivot+<span class="number">1</span>;  <span class="comment">/*尾递归*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>从算法的简单性来看，我们将7种算法分为两类：</p><ol><li>简单算法：冒泡，简单选择，直接插入</li><li>改进算法：希尔，堆，归并，快速</li></ol><ul><li>从平均情况来看，最后3种改进算法要胜过希尔算法，并远远胜于前3种简单算法</li><li>从最好情况来看，反而冒泡和直接插入排序更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法。</li><li>从最坏情况来看，堆排序和归并排序又强过快速排序以及其他简单排序。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;提到排序，鸡皮疙瘩都起来了，排序思想固然是好玩的，但是代码的实现也是无比蛋疼，记忆起来噩梦级别，之后会在这里补充一些排序算法相关的练习题&lt;/p&gt;

&lt;blockquote class=&quot;question&quot;&gt;排序习题&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/DataStructure/2019/05/11/DataStructure-07/ipe-yellow.jpg&quot; alt=&quot;ipe-yellow&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="排序" scheme="http://jhjhljh.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-查找</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-06.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-06.html</id>
    <published>2019-05-11T03:08:15.000Z</published>
    <updated>2019-05-11T07:35:02.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">查找，说到底也是排序思想的基础，主要是针对树的查找</p><p><img src="/DataStructure/2019/05/11/DataStructure-06/hoodie.jpg" alt="hoodie"></p><a id="more"></a><p>前言：查找(Searching)就是根据给定的某个值，在查找表中确定一个其关键字等于定值的数据元素(或记录)</p><ul><li>查找表(Search Table)是由同一类型的数据元素(或记录)构成的集合</li><li>关键字(Key)是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项(字段)，我们称为关键码</li></ul><ol><li>若此关键字可以唯一地标识一个记录，则称此关键字为主关键字(Primary Key)，注意这意味着，对不同的记录，其主关键字均不相同，主关键字所在的数据项称为主关键码</li><li>那么对于那些可以识别多个数据元素(或记录)的关键字，我们称为次关键字(Secondary Key)，次关键字可以理解为是不以唯一标识一个数据元素(或记录)的关键字，它对应的数据项就是次关键码</li></ol><p>查找表按照操作方式分两大种：</p><ol><li>静态查找表(Static Search Table)：只作查找操作的操作表</li><li>动态操作表(Dynamic Search Table):在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</li></ol><hr><h2 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h2><ul><li>顺序查找(Sequential Search)又叫线性查找，是最基本的查找技术。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字*/</span></span><br><span class="line"><span class="built_in">int</span> Sequential_Search(<span class="built_in">int</span> *a,<span class="built_in">int</span> n,<span class="built_in">int</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="built_in">key</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里并非足够完美，因为每次循环时都需要对i是否越界，即是否小于等于n进行判断，我们不妨设置一个哨兵</p></blockquote><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序表查找优化：有哨兵顺序查找*/</span></span><br><span class="line"><span class="built_in">int</span> Sequential_Search2(<span class="built_in">int</span> *a,<span class="built_in">int</span> n, <span class="built_in">int</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="built_in">key</span>;  <span class="comment">/*设置a[0]为关键字值，我们称之为“哨兵”*/</span></span><br><span class="line">    i=n;  <span class="comment">/*循环从数组尾部开始*/</span></span><br><span class="line">    <span class="keyword">while</span>(a[i]!=<span class="built_in">key</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">/*返回0则说明查找失败*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于这种顺序查找算法来说，查找成功最好的情况就是第一个位置就找到了，算法时间复杂度为O(1)，最坏的情况是最后一个位置才找到，需要n次比较，时间复杂度为O(n)，当查找不成功时，需要n+1次比较，时间复杂度为O(n)</p><blockquote><p>我们推导过，关键字在任何一位置的概率是相同的，所以平均查找次数为(n+1)/2，所以最终时间复杂度为O(n)</p></blockquote></blockquote><hr><h2 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h2><h3 id="折半查找-Binary-Search"><a href="#折半查找-Binary-Search" class="headerlink" title="折半查找(Binary Search)"></a>折半查找(Binary Search)</h3><p> 又称为二分查找，它的前提是线性表中的记录必须是关键码有序(通常从小到大有序)，线性表必须采用顺序存储。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*折半查找*/</span></span><br><span class="line"><span class="built_in">int</span> Binary_Search(<span class="built_in">int</span> *a,<span class="built_in">int</span> n,<span class="built_in">int</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> low,high,mid;</span><br><span class="line">    low=<span class="number">1</span>;  <span class="comment">/*定义最低下标为记录首位*/</span></span><br><span class="line">    high=n;  <span class="comment">/*定义最高下标为记录末位*/</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">       mid=(low+high)/<span class="number">2</span>;  <span class="comment">/*折半*/</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">key</span>&lt;a[mid])  <span class="comment">/*若查找值比中值小*/</span></span><br><span class="line">           high=mid<span class="number">-1</span>; <span class="comment">/*最高下标调整到中位下标小一位*/</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">key</span>&gt;a[mid])  <span class="comment">/*若查找值比中值大*/</span></span><br><span class="line">           low=mid+<span class="number">1</span>;  <span class="comment">/*最低下标调整到中位下标大一位*/</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> mid;  <span class="comment">/*若相等则说明mid即为查到的位置*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因此最终折半算法的时间复杂度为O(logn)，它显然远远好于顺序查找的O(n)时间复杂度</p></blockquote><hr><h3 id="插值查找-Interpolation-Search"><a href="#插值查找-Interpolation-Search" class="headerlink" title="插值查找(Interpolation Search)"></a>插值查找(Interpolation Search)</h3><blockquote><p>换句话说，我们只需要在折半查找算法的代码中更改一下第8行的代码</p><blockquote><p>如下</p></blockquote></blockquote><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid = low + <span class="comment">(high-low)</span> * <span class="comment">(key-a[low])</span>/<span class="comment">(a[high]-a[low])</span>;  <span class="comment">/*插值*/</span></span><br></pre></td></tr></table></figure><ul><li>我们得到了另一种有序表查找算法，差值查找法，插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法。</li></ul><blockquote><p>其核心就在于插值的计算公式，应该说，从时间复杂度来看，也是O(logn)，但是对于表长较大的，关键字分布又比较均匀的查找表来说，插值查找算法的平均性能要比折半查找好很多</p></blockquote><hr><h3 id="斐波那契额查找-Fibonacci-Search"><a href="#斐波那契额查找-Fibonacci-Search" class="headerlink" title="斐波那契额查找(Fibonacci Search)"></a>斐波那契额查找(Fibonacci Search)</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*斐波那契查找*/</span></span><br><span class="line">int <span class="built_in">Fibonacci_Search</span>(int *a,int n,int <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int low,high,mid,i,k;</span><br><span class="line">    low=<span class="number">1</span>;  <span class="comment">/*定义最低下标为记录首位*/</span></span><br><span class="line">    high=n;  <span class="comment">/*定义最高下标为记录末位*/</span></span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)  <span class="comment">/*计算n位于斐波那契数列的位置*/</span></span><br><span class="line">        k++;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;F[k]<span class="number">-1</span>;i++)  <span class="comment">/*将不满的数值补全*/</span></span><br><span class="line">        a[i]=a[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;  <span class="comment">/*计算当前分割的下标*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">key</span>&lt;a[mid])  <span class="comment">/*若查找记录小于当前分隔记录*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;  <span class="comment">/*最高下标调整到分隔下标mid-1处*/</span></span><br><span class="line">            k=k<span class="number">-1</span>;  <span class="comment">/*斐波那契数列下标减一位*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">key</span>&gt;a[mid])  <span class="comment">/*若查找记录大于当前分隔记录*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;  <span class="comment">/*最低下标调整到分隔下标mid+1处*/</span></span><br><span class="line">            k=k<span class="number">-2</span>;  <span class="comment">/*斐波那契数列下标减两位*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;=n)</span><br><span class="line">                <span class="keyword">return</span> mid;  <span class="comment">/*若相等则说明mid即为查找到的位置*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> n;  <span class="comment">/*若mid&gt;n说明是补全数值，返回n*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线索索引查找"><a href="#线索索引查找" class="headerlink" title="线索索引查找"></a>线索索引查找</h3><ul><li>索引就是把一个关键字与它对应的记录相关联的过程，所以线性索引就是将索引项集合组织为线性结构，也称为索引表，我们重点介绍三种线性索引：稠密索引，分块索引和倒排索引</li></ul><hr><h2 id="二叉排序树-Binary-Sort-Tree"><a href="#二叉排序树-Binary-Sort-Tree" class="headerlink" title="二叉排序树(Binary Sort Tree)"></a>二叉排序树(Binary Sort Tree)</h2><blockquote><p>又称为二叉寻找树。它或者是一棵空树，或者是具有下列性质的二叉树</p></blockquote><ol><li>若它的左子树不空，则左子树上所有结点的值均小于它 的根结构的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值；</li><li>它的左，右子树也分别为二叉排序树</li></ol><ul><li>二叉排序树查找操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>  /*结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">/*左右孩子指针*/</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*递归查找二叉排序树T中是否存在key*/</span></span><br><span class="line"><span class="comment">/*指针f指向T的双亲，其初始调用值为NULL*/</span></span><br><span class="line"><span class="comment">/*若查找成功，则指针p指向该数据元素结点，并返回TRUE*/</span></span><br><span class="line"><span class="comment">/*否则指针p指向查找路径上访问的最后一个结点并返回FALSE*/</span></span><br><span class="line">Status <span class="built_in">SearchBST</span>(BiTree T,int <span class="built_in">key</span>,BiTree f,BiTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)  <span class="comment">/*查找不成功*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">key</span> == T-&gt;data)  <span class="comment">/*查找成功*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p = T;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">key</span>&lt;T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild,<span class="built_in">key</span>,T,p);  <span class="comment">/*在左子树继续查找*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild,<span class="built_in">key</span>,T,p);  <span class="comment">/*在右子树继续查找*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二叉排列树插入操作</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当二叉排序树T中不存在关键字等于key的数据元素时*/</span></span><br><span class="line"><span class="comment">/*插入key并返回TRUE,否则返回FALSE*/</span></span><br><span class="line">Status InsertBST(BiTree *T,int key)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree p,s;</span><br><span class="line">    <span class="keyword">if</span>(!SearchBST(*T,key,NULL,&amp;p))  <span class="comment">/*查找不成功*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        <span class="function"><span class="title">s</span>-&gt;</span><span class="keyword">data</span> = key;</span><br><span class="line">        <span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">lchild</span> = s-&gt;</span>rchild = NULL;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            *T = s;  <span class="comment">/*输入s为新的根节点*/</span></span><br><span class="line">        <span class="function"><span class="title">else</span> <span class="keyword">if</span>(key&lt;p-&gt;</span><span class="keyword">data</span>)</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>lchild = s;  <span class="comment">/*插入s为左孩子*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>rchild = s;  <span class="comment">/*插入s为右孩子*/</span></span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        return FALSE;  <span class="comment">/*树中已经有关键字相同的结点，不再输入*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了二叉排序树的插入代码，我们要实现二叉排序树的构建就非常容易了，比如</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">int a[<span class="number">10</span>] = &#123;<span class="number">62</span>,<span class="number">22</span>,<span class="number">41</span>,<span class="number">53</span>,<span class="number">76</span>,<span class="number">33</span>,<span class="number">77</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">75</span>&#125;</span><br><span class="line">BiTree T = NULL;</span><br><span class="line">for(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    InsertBST(&amp;T,a[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二叉排序树删除操作(三种情况)</li></ul><ol><li>叶子结点</li><li>仅有左或右子树的结点</li><li>左右子树都有的结点，我们来看代码，下面这个算法是递归方式对二叉排序树T查找key，查到是删除</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点*/</span></span><br><span class="line">Status <span class="built_in">DeleteBST</span>(BiTree *T,int <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!*T)  <span class="comment">/*不存在关键字等于key的数据元素*/</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">key</span> == (*T)-&gt;data)  <span class="comment">/*找到关键字等于key的数据元素*/</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">Delete</span>(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">key</span>&lt;(*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(&amp;(*T)-&gt;lchild,<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(&amp;(*T)-&gt;rchild,<span class="built_in">key</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s delete !</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**/</span></span><br><span class="line">Status Delete(BiTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree q,s;</span><br><span class="line">    <span class="function"><span class="title">if</span>((*p)-&gt;</span>rchild=NULL)  <span class="comment">/*右子树空则只需重接它的左子树*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">q</span>=*p;*p=(*p)-&gt;</span>lchild;free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>((*p)-&gt;</span>lchild==NULL)  <span class="comment">/*只需重接它的右子树*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">q</span>=*p;*p=(*p)-&gt;</span>rchild;free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/*左右子树均不空*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">q</span>=*p;s=(*p)-&gt;</span>lchild;</span><br><span class="line">        <span class="function"><span class="title">while</span>(s-&gt;</span>rchild)  <span class="comment">/*转左，然后向右到尽头(找待删结点的前驱)*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">q</span>=s;s=s-&gt;</span>rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*<span class="function"><span class="title">p</span>)-&gt;</span><span class="function"><span class="title">data</span>=s-&gt;</span><span class="keyword">data</span>;  <span class="comment">/*s指向被删结点的直接前驱*/</span></span><br><span class="line">        <span class="keyword">if</span>(q!=*p)</span><br><span class="line">            <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">rchild</span>=s-&gt;</span>lchild;  <span class="comment">/*重接q的右子树*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">lchild</span>=s-&gt;</span>lchild;  <span class="comment">/*重接q的左子树*/</span></span><br><span class="line">        free(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉排序树总结"><a href="#二叉排序树总结" class="headerlink" title="二叉排序树总结"></a>二叉排序树总结</h3><ul><li>二叉排序树是以链接的方式存储，保存了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。</li><li>二叉排序树的查找性能取决于二叉排序树的形状，也就是说我们希望二叉排序树是平衡的，即深度与完全二叉树相同，均为[log2n]+1，那么查找的时间复杂度也就为O(logn)，类似于折半查找，不平衡的最坏情况就是斜树，查找时间复杂度为O(n)，这等同于顺序查找</li></ul><hr><h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h2><ul><li>平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree),是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多为1.</li><li>顾名思义，这是一种高度平衡的二叉排序树，我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor)</li><li>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树</li></ul><h3 id="平衡二叉树实现原理"><a href="#平衡二叉树实现原理" class="headerlink" title="平衡二叉树实现原理"></a>平衡二叉树实现原理</h3><ul><li>当最小不平衡树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋。插入结点后，最小不平衡树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作</li></ul><h3 id="平衡二叉树实现算法"><a href="#平衡二叉树实现算法" class="headerlink" title="平衡二叉树实现算法"></a>平衡二叉树实现算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>  /*结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="keyword">int</span> bf;  <span class="comment">/*结点的平衡因子*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">/*左右孩子指针*/</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p>右旋操作</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对以p为根的二叉排序树作右旋处理*/</span></span><br><span class="line"><span class="comment">/*处理之后p指向新的树根结点，即旋转处理之前的左子树的根节点*/</span></span><br><span class="line"><span class="literal">void</span> R_Rotate(BiTree *P)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree L;</span><br><span class="line">    <span class="function"><span class="title">L</span>=<span class="params">(*P)</span>-&gt;</span>lchild;  <span class="comment">/*L指向P的左子树根结点*/</span></span><br><span class="line">    <span class="function"><span class="params">(*P)</span>-&gt;</span>lchild=L-&gt;rchild;  <span class="comment">/*L的右子树挂接为P的左子树*/</span></span><br><span class="line">    L-&gt;rchild=(*P);</span><br><span class="line">    *P=L;  <span class="comment">/*P指向新的根结点*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>左旋操作与右旋代码是对称的，不做解释</p></blockquote><p>以下是左平衡旋转处理的函数代码</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define LH +1  /*左高*/</span></span><br><span class="line"><span class="comment">#define EH 0  /*等高*/</span></span><br><span class="line"><span class="comment">#define RH -1  /*右高*/</span></span><br><span class="line"><span class="comment">/*对以指针T所指结点为根的二叉树作左平衡旋转处理*/</span></span><br><span class="line"><span class="comment">/*本算法结束时，指针T指向新的根结点*/</span></span><br><span class="line"><span class="literal">void</span> LeftBalance(BiTree *T)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree L,Lr;</span><br><span class="line">    <span class="function"><span class="title">L</span>=<span class="params">(*T)</span>-&gt;</span>lchild;  <span class="comment">/*L指向T的左子树根结点*/</span></span><br><span class="line">    <span class="keyword">switch</span>(L-&gt;bf)</span><br><span class="line">    &#123;<span class="comment">/*检查T的左子树的平衡度，并作相应平衡处理*/</span></span><br><span class="line">       <span class="keyword">case</span> LH:  <span class="comment">/*新结点插入在T的左孩子的左子树上，要作单右旋处理*/</span></span><br><span class="line">        <span class="function"><span class="params">(*T)</span>-&gt;</span>bf=L-&gt;bf=EH;</span><br><span class="line">        R_Rotate(T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> RH:  <span class="comment">/*新结点插在T的左孩子的右子树商，要作双旋处理*/</span></span><br><span class="line">        Lr=L-&gt;rchild <span class="comment">/*Lr指向T的左孩子的右子树根*/</span></span><br><span class="line">        <span class="keyword">switch</span>(Lr-&gt;bf)  <span class="comment">/*修改T及其左孩子的平衡因子*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> LH:<span class="function"><span class="params">(*T)</span>-&gt;</span>bf=RH;</span><br><span class="line">                    L-&gt;bf=EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EH:<span class="function"><span class="params">(*T)</span>-&gt;</span>bf=L-&gt;bf=EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RH: <span class="function"><span class="params">(*T)</span>-&gt;</span>bf=EH;</span><br><span class="line">                    L-&gt;bf=LH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Lr-&gt;bf=EH;</span><br><span class="line">        L_Rotate<span class="function"><span class="params">(&amp;(*T)-&gt;lchild;  /*对T的左子树作左旋平衡处理*/</span></span></span><br><span class="line"><span class="function"><span class="params">        R_Rotate(T);  /*对T作右旋处理*/</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>同样的，右平衡旋转处理的函数代码非常类似，有了这些准备，我们的主函数正式登场</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个数据元素为e的新结点并返回1，否则返回0*/</span></span><br><span class="line"><span class="comment">/*若因插入而使二叉排序树失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否*/</span></span><br><span class="line">Status InsertAVL(BiTree *T,<span class="keyword">int</span> e,Status *taller)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!*T)</span><br><span class="line">    &#123;  <span class="comment">/*输入新结点，树“长高”，置taller为TRUE*/</span></span><br><span class="line">        *T=(BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        (*T)-&gt;data=e;</span><br><span class="line">        (*T)-&gt;lchild=(*T)-&gt;rchild=<span class="keyword">NULL</span>;</span><br><span class="line">        (*T)-&gt;bf=EN;</span><br><span class="line">        *taller=<span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e==(*T)-&gt;data)</span><br><span class="line">        &#123;  <span class="comment">/*树中已存在和e有相同关键字的结点则不再输入*/</span></span><br><span class="line">            *taller=<span class="keyword">FALSE</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(e&lt;(*T)-&gt;data)</span><br><span class="line">        &#123;  <span class="comment">/*应继续在T的左子树中进行搜索*/</span></span><br><span class="line">            <span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller))  <span class="comment">/*未插入*/</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">            <span class="keyword">if</span>(taller)  <span class="comment">/*已插入到T的左子树且左子树“长高”*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>((*T)-&gt;bf)  <span class="comment">/*检查T的平衡度*/</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> LH:  <span class="comment">/*原本左子树比右子树高，需要作左平衡处理*/</span></span><br><span class="line">                        LeftBalance(T);</span><br><span class="line">                        *taller=<span class="keyword">FALSE</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EH:  <span class="comment">/*原本左右子树等高，现因左子树增高而树增高*/</span></span><br><span class="line">                        (*T)-&gt;bf=LH;</span><br><span class="line">                        *taller=<span class="keyword">TRUE</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH:  <span class="comment">/*原本右子树比左子树高，现左右子树等高*/</span></span><br><span class="line">                        (*T)-&gt;bf=EH;</span><br><span class="line">                        *taller=<span class="keyword">FALSE</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  <span class="comment">/*应继续在T的右子树中进行搜索*/</span></span><br><span class="line">            <span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller))  <span class="comment">/*未插入*/</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">            <span class="keyword">if</span>(*taller)  <span class="comment">/*已插入到T的右子树且右子树“长高”*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>((*T)-&gt;bf)  <span class="comment">/*检查T的平衡度*/</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> LH:  <span class="comment">/*原本左子树比右子树高，现左，右子树等高*/</span></span><br><span class="line">                        (*T)-&gt;bf=EH;</span><br><span class="line">                        *taller=<span class="keyword">FALSE</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EH:  <span class="comment">/*原本左右子树等高，现因右子树增高而树增高*/</span></span><br><span class="line">                        (*T)-&gt;bf=RH;</span><br><span class="line">                        *taller=<span class="keyword">TRUE</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH:  <span class="comment">/*原本右子树比左子树高，需要作右平衡处理*/</span></span><br><span class="line">                        RightBalance(T);</span><br><span class="line">                        *taller=<span class="keyword">FALSE</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：生成平衡二叉树</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">int a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">BiTree T=NULL;</span><br><span class="line">Status taller;</span><br><span class="line">for(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    InsertAVL(&amp;T,a[i],&amp;taller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不平衡的二叉排序树查找效率是非常低的，由此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们的查找时间复杂度就为O(logn)，而插入和删除也为O(logn)，这显然是比较理想的一种动态查找表算法</p></blockquote><hr><h2 id="多路查找树-B树"><a href="#多路查找树-B树" class="headerlink" title="多路查找树(B树)"></a>多路查找树(B树)</h2><ul><li>多路查找树(multl-way search tree)：其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。</li><li>2-3树：其中每一个结点都具有两个孩子(我们称它为2结点)或三个孩子(我们称它为3结点)</li></ul><ol><li>一个2结点包含一个元素和两个孩子(或没有孩子)</li></ol><blockquote><p>与二叉排序树类似，左子树包含的元素小于该元素，右子树同理</p><blockquote><p>不过，这个2结点要么没有孩子，要么就有两个，不能只有一个孩子</p></blockquote></blockquote><ol start="2"><li>一个3结点包含一小一大两个元素和三个孩子(或没有孩子)</li></ol><blockquote><p>一个3结点要么没有孩子，要么具有三个孩子，左最小，中介于，右最大</p></blockquote><ol start="3"><li>2-3树中所有叶子都在同一层次上</li></ol><blockquote><p>了解一下2-3树的插入实现与删除实现</p></blockquote><ul><li>2-3-4树：其实就是2-3树的概念拓展，包括了4结点的使用，一个4结点包括小中大三个元素和四个孩子(或没有孩子)</li><li>B树(B-tree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order)，因此2-3树是3阶B树，2-3-4是4阶B树</li></ul><blockquote><p>对于n个关键字的m阶B树，最坏情况是要查找几次呢？</p><blockquote><p>第一层至少有1个结点，第二层至少有2个结点，由于除根结点外每个分支结点至少有(m/2)棵子树，则第三层至少有2X(m/2)个结点，….这样第k+1层至少有2X(m/2)^k-1^</p></blockquote></blockquote><ul><li>B+树</li></ul><hr><h2 id="散列表查找-哈希表-概述"><a href="#散列表查找-哈希表-概述" class="headerlink" title="散列表查找(哈希表)概述"></a>散列表查找(哈希表)概述</h2><ul><li>散列技术是在记录的存储位置和它的关键字之间建立一个确立的对应关系f，使得每个关键字key对应一个存储位置f(key)</li></ul><blockquote><p>查找时，根据这个确定的对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上</p></blockquote><ul><li>这里我们把这种对应关系f称为散列函数，又称哈希(Hash)函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)，那么关键字对应的记录存储位置我们称为散列地址</li></ul><blockquote><p>散列技术既是一种存储方法，也是一种查找方法,散列技术最合适的求解问题是查找与给定值相等的记录.</p></blockquote><ul><li><h2 id="我们通常会碰到两个关键字key1≠key2，但是却有f-key1-f-key2-，这种现象我们称为冲突-collision-，并把key1和key2称为这个散列函数的同义词-synonym"><a href="#我们通常会碰到两个关键字key1≠key2，但是却有f-key1-f-key2-，这种现象我们称为冲突-collision-，并把key1和key2称为这个散列函数的同义词-synonym" class="headerlink" title="我们通常会碰到两个关键字key1≠key2，但是却有f(key1)=f(key2)，这种现象我们称为冲突(collision)，并把key1和key2称为这个散列函数的同义词(synonym)"></a>我们通常会碰到两个关键字key1≠key2，但是却有f(key1)=f(key2)，这种现象我们称为冲突(collision)，并把key1和key2称为这个散列函数的同义词(synonym)</h2></li></ul><hr><h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><ul><li>直接定址法</li></ul><blockquote><p>也就是说，我们可以取关键字的某个线性函数值为散列地址，即f(key)=a x key+b (a，b为常数)</p></blockquote><ul><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>除留余数法</li><li>随机数法</li></ul><h3 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h3><ol><li>开放地址法</li></ol><blockquote><p>所谓的开放地址，就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p><blockquote><p>f1(key) = (f(key)+di) MOD m (di=1,2,3,….,m-1)</p><blockquote><p>我们把这种解决冲突的开放地址法称为线性探测法</p></blockquote></blockquote></blockquote><ul><li>在解决冲突的时候，我们会碰到这种本来都不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。</li></ul><blockquote><p>另外增加平方运算的目的是为了不让关键字都聚集在某一刻区域，我们称这种方法为二次探测法</p><blockquote><p>即改进di=1^2^，-1^2^，2^2^，-2^2^,…</p></blockquote></blockquote><ul><li>还有一种方法是，在冲突时，对于位移量di采用随机函数计算得到，我们称之为随机探测法</li></ul><blockquote><p>这里的随机其实是伪随机数，伪随机数就是说，如果我们设置随机种子相同，则不断调用随机函数生成不会重复的数列，我们在查找时，用同样的随机种子，它每次得到的数列是相同的，相同的di也会得到相同的数列地址</p><blockquote><p>随机种子了解一波？</p></blockquote></blockquote><p>总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的方法</p><ol start="2"><li>再散列函数法(事先准备多个散列函数)</li><li>链地址法</li></ol><h3 id="公共溢出区法-溢出表"><a href="#公共溢出区法-溢出表" class="headerlink" title="公共溢出区法(溢出表)"></a>公共溢出区法(溢出表)</h3><hr><h2 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h2><p>首先是需要定义一个散列表的结构以及一些相关的常数，其中HashTable就是散列表结构，机构当中的elem为一个动态数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12  <span class="comment">/*定义散列表长为数组的长度*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem;  <span class="comment">/*数据元素存储基址，动态分配数组*/</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">/*当前数据元素个数*/</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>;  <span class="comment">/*散列表表长，全局变量*/</span></span><br></pre></td></tr></table></figure><p>有了结构的定义，我们可以对散列表进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化散列表*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m=HASHSIZE;</span><br><span class="line">    H-&gt;count=m;</span><br><span class="line">    H-&gt;elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        H-&gt;elem[i]=NULLKEY;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了插入时计算地址，我们需要定义散列函数，散列函数可以根据不同情况更改算法。</p><hr><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*散列函数*/</span></span><br><span class="line"><span class="built_in">int</span> Hash(<span class="built_in">int</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ruturn <span class="built_in">key</span> % m;  <span class="comment">/*除留余数法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成后，我们可以对散列表进行插入操作。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入关键字进散列表*/</span></span><br><span class="line"><span class="keyword">void</span> InsertHash(HashTable *H,<span class="built_in">int</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> addr = Hash(<span class="built_in">key</span>);  <span class="comment">/*求散列地址*/</span></span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[addr] != NULLKEY)  <span class="comment">/*如果不为空，则冲突*/</span></span><br><span class="line">        addr = (addr+<span class="number">1</span>) % m;  <span class="comment">/*开放地址法的线性探测*/</span></span><br><span class="line">    H-&gt;elem[addr] = <span class="built_in">key</span>;  <span class="comment">/*直到有空位后插入关键字*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>散列表存在后，我们在需要时就可以通过散列表查找要的记录</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*散列表查找关键字*/</span></span><br><span class="line">Status <span class="built_in">SearchHash</span>(HashTable H,int <span class="built_in">key</span>,int *addr)</span><br><span class="line">&#123;</span><br><span class="line">    *addr = <span class="built_in">Hash</span>(<span class="built_in">key</span>);  <span class="comment">/*求散列地址*/</span></span><br><span class="line">    <span class="keyword">while</span>(H.elem[*addr] != <span class="built_in">key</span>)  <span class="comment">/*如果不为空，则冲突*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr+<span class="number">1</span>) % m;  <span class="comment">/*开放定址法的线性探测*/</span></span><br><span class="line">        <span class="keyword">if</span>(H.elem[*addr]  == NULLKEY || *addr == <span class="built_in">Hash</span>(<span class="built_in">key</span>))</span><br><span class="line">        &#123;  <span class="comment">/*如果循环回到原点*/</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;  <span class="comment">/*则说明关键字不存在*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找的代码和插入的代码非常类似，只需做一个不存在关键字的判断而已</p><hr><h3 id="散列表查找性能分析"><a href="#散列表查找性能分析" class="headerlink" title="散列表查找性能分析"></a>散列表查找性能分析</h3><p>如果没有冲突，散列查找是本章所有查找效率最高的，因为它的时间复杂度为O(1)</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;查找，说到底也是排序思想的基础，主要是针对树的查找&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/DataStructure/2019/05/11/DataStructure-06/hoodie.jpg&quot; alt=&quot;hoodie&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="查找" scheme="http://jhjhljh.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-05.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-05.html</id>
    <published>2019-05-10T17:22:48.000Z</published>
    <updated>2019-05-11T07:08:57.415Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">图，让我想起被离散数学图论支配的恐惧，但是数据结构涉及到的属于图的抽象数据结构，简直比离散数学还要致命</p><p><img src="/DataStructure/2019/05/11/DataStructure-05/art.jpg" alt="art"></p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>前言: 图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合</li><li>图的定义与术语</li></ul><ol><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)</li><li>线性表中可以没有数据元素，称为空表；树中可以没有结点，称为空树；而在图结构，不允许没有顶点，在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。</li><li>线性表中，相邻的数据元素之间有线性关系；树结构中，相邻两层的结点具有层次关系；而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的.</li><li>无向边(Edge)，用无序偶对(vi,vj)来表示</li><li>无向图(Undirected graphs)</li><li>有向边，也称为为弧(Arc)</li><li>有向图(Directed graphs)，用有序偶&lt;vi,vj&gt;来表示<blockquote><p>连接顶点A到D的有向边就是弧，A是弧尾，D是弧头</p></blockquote></li><li>简单图：图中若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</li><li>无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</li><li>有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</li><li>稀疏图与稠密图：有很少条边或弧的图称为稀疏图，反之称为稠密图</li><li>权(Weight)：与图的边或弧相关的数叫做权</li><li>网(Network)：这种带权的图通常称为网</li><li>子图(Subgraph)</li><li>邻接点(Adjacent)</li><li>依附(incident)</li><li>度(Degree)</li><li>入度(InDegree)ID与出度(OutDegree)OD</li><li>路径(Path)<blockquote><p>路径的长度是路径上边或弧的数目</p></blockquote></li><li>回路或环(Cycle)</li><li>简单路径：序列中顶点不重复出现的路径称为简单路径</li><li>简单回路或简单环：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路</li><li>连通图(Connected Graph)：无向图中</li><li>连通分量：无向图中的极大连通子图</li><li>强连通图：有向图中，任意两点都有路径</li><li>强连通分量：有向图中的极大强连通子图</li><li>连通图的生成树：一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边<blockquote><p>如果一个图有n个顶点和小于n-1条边，则是非连通图；如果它多于n-1条边，必定构成一个环</p><blockquote><p>但是有n-1条边并不一定是生成树</p></blockquote></blockquote></li><li>有向树：如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树</li><li><p>生成森林：由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2></li><li><p>邻接矩阵</p></li></ol><p>图的邻接矩阵存储的结构<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">/*顶点类型应由用户定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;  <span class="comment">/*边上的权值类型应全由用户定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100  <span class="comment">/*最大顶点数，由用户定义*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535  <span class="comment">/*用65535表示∞*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType vexs[MAXVEX];  <span class="comment">/*顶点表*/</span></span><br><span class="line">    EdgeType arc[MAXVEX][MAXVEX];  <span class="comment">/*邻接矩阵，可看作边表*/</span></span><br><span class="line">    <span class="keyword">int</span> numVertexes,numEdges;  <span class="comment">/*图中当前的顶点和边数*/</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure></p><p>有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*建立无向网图的邻接矩阵表示*/</span></span><br><span class="line">void CreateMGraph(MGraph *G)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,w;</span><br><span class="line">    printf(<span class="string">"输入顶点数和边数:\n"</span>)；</span><br><span class="line">    scanf(<span class="string">"%d,%d"</span>,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);  <span class="comment">/*输入顶点数和边数*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G-&gt;numVertexes;i++)  <span class="comment">/*读入顶点信息，建立顶点表*/</span></span><br><span class="line">        scanf(&amp;G-&gt;vexs[i]);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G-&gt;numVertexes;i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt;G-&gt;numVertexes;j++)</span><br><span class="line">            G-&gt;arc[i][j] = INFINITY;  <span class="comment">/*邻接矩阵初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>;k &lt;G-&gt;numEdges;k++)  <span class="comment">/*读入numEdges条边，建立邻接矩阵*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"输入边(vi,vj)上的下标i，下标j和权w:\n"</span>);</span><br><span class="line">        scanf(<span class="string">"%d,%d,%d"</span>,&amp;i,&amp;j,&amp;w);  <span class="comment">/*输入边(vi,vj)上的权*/</span></span><br><span class="line">        G-&gt;arc[i][j]=w;</span><br><span class="line">        G-&gt;arc[j][i]=G-&gt;arc[i][j];  <span class="comment">/*因为是无向图，矩阵对称*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中可以得到n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n^2^+e)，其中对邻接矩阵Garc的初始化耗费了O(n^2^)的时间</p><ol start="2"><li>邻接表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">/*顶点类型应由用户定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;  <span class="comment">/*边上的权值类型应由用户定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>  /*边表结点*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;  <span class="comment">/*邻接点域，存储该顶点对应的下标*/</span></span><br><span class="line">    EdgeType weight;  <span class="comment">/*用于存储权值，对于非网图可以不需要*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span>  <span class="comment">/*链域，指向下一个临接点*/</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>  /*顶点表结点*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList adjList;  <span class="comment">/*顶点域，存储顶点信息*/</span></span><br><span class="line">    <span class="keyword">int</span> numVertexes,numEdges;  <span class="comment">/*边表头指针*/</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*建立无向图的邻接表结构*/</span></span><br><span class="line">void CreateALGraph(GraphAdjList *G)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    printf(<span class="string">"输入顶点数和边数:\n"</span>);</span><br><span class="line">    <span class="function"><span class="title">scanf</span>("%d,%d",&amp;G-&gt;</span><span class="function"><span class="title">numVertexes</span>,&amp;G-&gt;</span>numEdges);  <span class="comment">/*输入顶点数和边数*/</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(i = 0;i &lt; G-&gt;</span>numVertexes;i++)  <span class="comment">/*读入顶点信息，建立顶点表*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">scanf</span>(&amp;G-&gt;</span>adjList[i].<span class="keyword">data</span>);  <span class="comment">/*输入顶点信息*/</span></span><br><span class="line">        G-&gt;adjList[i].firstedge=NULL;  <span class="comment">/*将边表置为空表*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">for</span>(k = 0;k &lt; G-&gt;</span>numEdges;k++)  <span class="comment">/*建立边表*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"输入边(vi,vj)上的顶点序号:\n"</span>);</span><br><span class="line">        scanf(<span class="string">"%d,%d"</span>,&amp;i,&amp;j);  <span class="comment">/*输入边上的顶点序号*/</span></span><br><span class="line">        e =(EdgeNode*)malloc(sizeof(EdgeNode));  <span class="comment">/*向内存申请空间，生成边表结点*/</span></span><br><span class="line">        <span class="function"><span class="title">e</span>-&gt;</span>adjvex=j;  <span class="comment">/*邻接序号为j*/</span></span><br><span class="line">        <span class="function"><span class="title">e</span>-&gt;</span><span class="function"><span class="title">next</span>=G-&gt;</span>adjList[i].firstedge;  <span class="comment">/*将e指针指向当前顶点指向的结点*/</span></span><br><span class="line">        G-&gt;adjList[i].firstedge=e;  <span class="comment">/*将当前顶点的指针指向e*/</span></span><br><span class="line">        e=(EdgeNode*)malloc(sizeof(EdgeNode));  <span class="comment">/*向内存申请空间，生成边表结点*/</span></span><br><span class="line">        <span class="function"><span class="title">e</span>-&gt;</span>adjvex=i;  <span class="comment">/*邻接序号为i*/</span></span><br><span class="line">        <span class="function"><span class="title">e</span>-&gt;</span><span class="function"><span class="title">next</span>=G-&gt;</span>adjList[j].firstedge;  <span class="comment">/*将e指针指向当前顶点指向的结点*/</span></span><br><span class="line">        G-&gt;adjList[j].firstedge=e;  <span class="comment">/*将当前顶点的指针指向e*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*后边代码用了前面讲到的单链表头插法*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>边集数组</li><li>十字链表</li><li>邻接多重表</li></ol><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h4 id="深度优先遍历-Depth-First-Search"><a href="#深度优先遍历-Depth-First-Search" class="headerlink" title="深度优先遍历(Depth_First_Search)"></a>深度优先遍历(Depth_First_Search)</h4><p>又称为深度优先搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Boolean;  <span class="comment">/*Boolean是布尔类型，其值是TRUE或FALSE*/</span></span><br><span class="line">Boolean visited[MAX];  <span class="comment">/*访问标志的数组*/</span></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优化递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    visited[i] = TRUE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vexs[i]);  <span class="comment">/*打印顶点，也可以其他操作*/</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt;G.numVertexes;j++)</span><br><span class="line">        <span class="keyword">if</span>(G.arc[i][j]) == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line">            DFS(G,j);  <span class="comment">/*对为访问的邻接顶点递归调用*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*邻接矩阵的深度遍历操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.numVertexes;i++)</span><br><span class="line">        visited[i] = FALSE;  <span class="comment">/*初始所有顶点状态都是未访问过状态*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.numVertexes;i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])  <span class="comment">/*对未访问过的顶点调用DFS，若是连通图，只会执行一次*/</span></span><br><span class="line">            DFS(G,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接表的深度优先递归算法*/</span></span><br><span class="line">void DFS(GraphAdjList GL, int i)</span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    visited[i]=TRUE;</span><br><span class="line">    <span class="function"><span class="title">printf</span>("%c",GL-&gt;</span>adjList[i].<span class="keyword">data</span>);  <span class="comment">/*打印顶点，也可以其他操作*/</span></span><br><span class="line">    <span class="function"><span class="title">p</span> = GL-&gt;</span>adjList[i].firstedge;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!visited[p-&gt;</span>adjvex])</span><br><span class="line">            DFS(GL,<span class="function"><span class="title">p</span>-&gt;</span>adjvex);  <span class="comment">/*对为访问的邻接顶点递归调用*/</span></span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*邻接表的深度遍历操作*/</span></span><br><span class="line">void DFSTraverse(GraphAdjList GL)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="function"><span class="title">for</span>(i = 0;i &lt; GL-&gt;</span>numVertexes;i++)</span><br><span class="line">        visited[i] = FALSE; <span class="comment">/*初始所有顶点状态都是未访问过状态*/</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(i = 0;i &lt; GL-&gt;</span>numVertexes;i++)</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])  <span class="comment">/*对未访问过的顶点调用DFS，若是连通图，只会执行一次*/</span></span><br><span class="line">        DFS(GL,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于n个顶点e条边的图，邻接矩阵是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此需要O(n^2^)的时间；而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O(n+e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高</p></blockquote><h4 id="广度优先遍历-Breadth-First-Search"><a href="#广度优先遍历-Breadth-First-Search" class="headerlink" title="广度优先遍历(Breadth_First_Search)"></a>广度优先遍历(Breadth_First_Search)</h4><p>又称为广度优先搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵的广度遍历算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.numVertexes;i++)</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    InitQueue(&amp;Q);  <span class="comment">/*初始化一辅助用的队列*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.numVertexes;i++)  <span class="comment">/*对每一个顶点做循环*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])  <span class="comment">/*若是未访问过就处理*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            visited[i]=TRUE;  <span class="comment">/*设置当前顶点访问过*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vexs[i]);  <span class="comment">/*打印顶点，也可以其他操作*/</span></span><br><span class="line">            EnQueue(&amp;Q,i);  <span class="comment">/*将此顶点入队列*/</span></span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))  <span class="comment">/*若当前队列不为空*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q,&amp;i);  <span class="comment">/*将队中元素出队列，赋值给i*/</span></span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*判断其他顶点若与当前顶点存在边且未访问过*/</span></span><br><span class="line">                    <span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[j]=TRUE;  <span class="comment">/*将找到的此顶点标记为已访问*/</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vexs[j]);  <span class="comment">/*打印顶点*/</span></span><br><span class="line">                        EnQueue(&amp;Q,j);  <span class="comment">/*将找到的此顶点入队列*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接表的广度遍历算法*/</span></span><br><span class="line">void BFSTraverse(GraphAdjList GL)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="function"><span class="title">for</span>(i = 0; i &lt; GL-&gt;</span>numVertexes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i]=TRUE;</span><br><span class="line">            <span class="function"><span class="title">printf</span>("%c",GL-&gt;</span>adjList[i].<span class="keyword">data</span>);  <span class="comment">/*打印顶点，也可以其他操作*/</span></span><br><span class="line">            EnQueue(&amp;Q,i);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q,&amp;i);</span><br><span class="line">                <span class="function"><span class="title">p</span> =GL-&gt;</span>adjList[i].firstedge;  <span class="comment">/*找到当前顶点边表链表头指针*/</span></span><br><span class="line">                <span class="keyword">while</span>(p)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function"><span class="title">if</span>(!visited[p-&gt;</span>adjvex])  <span class="comment">/*若此顶点未被访问*/</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="function"><span class="title">visited</span>[p-&gt;</span>adjvex] = TRUE;</span><br><span class="line">                        <span class="function"><span class="title">printf</span>("%c",GL-&gt;</span><span class="function"><span class="title">adjList</span>[p-&gt;</span>adjvex].<span class="keyword">data</span>);</span><br><span class="line">                        E<span class="function"><span class="title">nQueue</span>(&amp;Q,p-&gt;</span>adjvex);  <span class="comment">/*将此顶点入队列*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="title">p</span> = p-&gt;</span>next;  <span class="comment">/*指针指向下一个邻接点*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对比图的深度优先遍历与广度优先遍历算法，它们在时间复杂度上是一样的，不同之处仅仅在对顶点访问的顺序不同，可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。</p></blockquote><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><ol><li>普里姆算法(Prim)<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Prim算法生成最小生成树*/</span></span><br><span class="line">void <span class="symbol">MiniSpanTree_Prim</span>(<span class="symbol">MGraph</span> <span class="symbol">G</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int min,i,j,k;</span><br><span class="line">    int adjvex[<span class="symbol">MAXVEX</span>];  <span class="comment">/*保存相关顶点下标*/</span></span><br><span class="line">    int lowcost[<span class="symbol">MAXVEX</span>];  <span class="comment">/*保存相关顶点间边的权值*/</span></span><br><span class="line">    lowcost[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">/*初始化第一个权值为0，即v0加入生成树*/</span></span><br><span class="line">    <span class="comment">/*lowcost的值为0，在这里就是此下标的顶点已经加入生成树*/</span></span><br><span class="line">    adjvex[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">/*初始化第一个顶点下标为0*/</span></span><br><span class="line">    for(i = <span class="number">1</span>; i &lt; <span class="symbol">G</span>.numVertexes;i++)  <span class="comment">/*循环除下标为0外的全部顶点*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        lowcost[i] = <span class="symbol">G</span>.arc[<span class="number">0</span>][i];  <span class="comment">/*将v0顶点与之有边的权值存入数组*/</span></span><br><span class="line">        adjvex[i] = <span class="number">0</span>;  <span class="comment">/*初始化都为v0的下标*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    for(i = <span class="number">1</span>; i &lt; <span class="symbol">G</span>.numVertexes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = <span class="symbol">INFINITY</span>; <span class="comment">/*初始化最小权值为∞，通常设置为不可能的大数字如32767,65535*/</span></span><br><span class="line">        j = <span class="number">1</span>;k = <span class="number">0</span>;</span><br><span class="line">        while(j &lt;<span class="symbol">G</span>.numVertexes)  <span class="comment">/*循环全部顶点*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            if(lowcost[j]! = <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min)</span><br><span class="line">            &#123;  <span class="comment">/*如果权值不为0且权值小于min*/</span></span><br><span class="line">                min = lowcost[j];  <span class="comment">/*则让当前权值成为最小值*/</span></span><br><span class="line">                k = j;  <span class="comment">/*将当且最小值的下标存入k*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">"(%d,%d)"</span>,adjvex[k],k);  <span class="comment">/*打印当前顶点边中权值最小边*/</span></span><br><span class="line">        lowcost[k] = <span class="number">0</span>;  <span class="comment">/*将当前顶点的权值设置为0，表示此顶点已经完成任务*/</span></span><br><span class="line">        for(j = <span class="number">1</span>;j &lt;<span class="symbol">G</span>.numVertexes;j++)  <span class="comment">/*循环所有顶点*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            if(lowcost[j]!= <span class="number">0</span> &amp;&amp; <span class="symbol">G</span>.arc[k][j] &lt; lowcost[j])</span><br><span class="line">            &#123;  <span class="comment">/*若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值*/</span></span><br><span class="line">                lowcost[j] = <span class="symbol">G</span>.arc[k][j];  <span class="comment">/*将较小权值存入lowcost*/</span></span><br><span class="line">                adjvex[j] = k;  <span class="comment">/*将下标为k的顶点存入adjvex*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>由此算法代码中的循环嵌套可得此算法的时间复杂度为O(n^2^)</p><ol start="2"><li>克鲁斯卡尔算法(Kruskal)<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对边集数组Edge结构的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">begin</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;Edge;</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Kruskal算法生成最小生成树*/</span></span><br><span class="line"><span class="keyword">void</span> MiniSpanTree_Kruskal(MGraph G)  <span class="comment">/*生成最小生成树*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i,n,m;</span><br><span class="line">    Edge edges[MAXEDGE];  <span class="comment">/*定义边集数组*/</span></span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">parent</span>[MAXVEX];  <span class="comment">/*定义一数组用来判断边与边是否形成环路*/</span></span><br><span class="line">    <span class="comment">/*此处省略将邻接表矩阵G转化为边集数组edges并按权从小到大排序的代码*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;G.numVertexes; i++)</span><br><span class="line">        <span class="built_in">parent</span>[i] = <span class="number">0</span>;  <span class="comment">/*初始化数组值为0*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;G.numEdges;i++)  <span class="comment">/*循环每一条边*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = Find(<span class="built_in">parent</span>,edges[i].begin);</span><br><span class="line">        m = Find(<span class="built_in">parent</span>,edges[i].end);</span><br><span class="line">        <span class="keyword">if</span>(n!=m)  <span class="comment">/*假设n与m不等，说明此边没有与现有生成树形成环路*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">parent</span>[n] = m;  <span class="comment">/*将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中*/</span></span><br><span class="line">            printf(<span class="string">"(%d,%d) %d"</span>,edges[i].begin,edges[i].end,edges[i].weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> Find(<span class="built_in">int</span> *<span class="built_in">parent</span>,<span class="built_in">int</span> f)  <span class="comment">/*查找连线顶点的尾部下标*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">parent</span>[f]&gt;<span class="number">0</span>)</span><br><span class="line">        f = <span class="built_in">parent</span>[f];</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此算法的Find函数由边数e决定，时间复杂度为O(loge)，而外面有一个for循环e次，所以克鲁斯卡尔算法的时间复杂度为O(eloge)</p><blockquote><p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，对于稀疏图有很大优势，而普里姆算法对于稠密图，即边数非常多的情况会更好一点。</p></blockquote></blockquote><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ol><li>迪杰斯特拉(Dijkstra)<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Pathmatrix[MAXVEX];  <span class="comment">/*用于存储最短路径下标的数组*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ShortPathTable[MAXVEX];  <span class="comment">/*用于存储到各点最短路径的权值和*/</span></span><br><span class="line"><span class="comment">/*Dijkstra算法，求有向网G的v0顶点到其余顶点v最短路径P[v]及带权长度D[v]*/</span></span><br><span class="line"><span class="comment">/*P[v]的值为前驱顶点下标，D[v]表示v0到v的最短路径长度和*/</span></span><br><span class="line"><span class="keyword">void</span> shortestPath_Dijkstra(MGraph G,<span class="keyword">int</span> v0,Pathmatirx *p,ShortPathTable *D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w,k,<span class="built_in">min</span>;</span><br><span class="line">    <span class="keyword">int</span> final[MAXVEX];  <span class="comment">/*final[w]=1表示求得顶点V0至Vw的最短路径*/</span></span><br><span class="line">    <span class="built_in">for</span>(v=<span class="number">0</span>;v&lt;G.numVertexes;v++)  <span class="comment">/*初始化数据*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        final[v] = <span class="number">0</span>;  <span class="comment">/*全部顶点初始化为未知最短路径状态*/</span></span><br><span class="line">        (*D)[v] = G.matirx[v0][v];  <span class="comment">/*将与v0点有连线的顶点加上权值*/</span></span><br><span class="line">        (*P)[v] = <span class="number">0</span>;  <span class="comment">/*初始化路径数组为0*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    (*D)[v0] = <span class="number">0</span>;  <span class="comment">/*v0至v0路径为0*/</span></span><br><span class="line">    final[v0] = <span class="number">1</span>;  <span class="comment">/*v0至v0不需要求路径*/</span></span><br><span class="line">    <span class="comment">/*开始主循环，每次求得v0到某个v顶点的最短路径*/</span></span><br><span class="line">    <span class="built_in">for</span>(v=<span class="number">1</span>;v&lt;G.numVertexes;w++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span>=INFINITY;  <span class="comment">/*当前所知离v0顶点的最近距离*/</span></span><br><span class="line">        <span class="built_in">for</span>(w=<span class="number">0</span>;w&lt;G.numVertexes;w++)  <span class="comment">/*寻找离v0最近的顶点*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">if</span>(!final[w] &amp;&amp; (*D)[w]&lt;<span class="built_in">min</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k=w;</span><br><span class="line">                <span class="built_in">min</span> = (*D)[w];  <span class="comment">/*w顶点离v0顶点更近*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        final[k] = <span class="number">1</span>;  <span class="comment">/*将目前找到的最近的顶点置为1*/</span></span><br><span class="line">        <span class="built_in">for</span>(w=<span class="number">0</span>;w&lt;G.numVertexes;w++)  <span class="comment">/*修正当前最短路径及距离*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*如果结果v顶点的路径比现在这条路径的长度短的话*/</span></span><br><span class="line">            <span class="built_in">if</span>(!final[w] &amp;&amp; (<span class="built_in">min</span> + G.matirx[k][w] &lt; (*D)[w]))</span><br><span class="line">            &#123;  <span class="comment">/*说明找到了更短的路径，修改D[w]和P[w]*/</span></span><br><span class="line">                (*D)[w] = <span class="built_in">min</span> + G.matirx[k][w];  <span class="comment">/**/</span></span><br><span class="line">                (*P)[w] = k;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>我们通过迪杰斯特拉(Dijkstra)算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为O(n^2^)，如果我们还需要知道其它顶点到其余所有顶点的最短路径，我们则需要再一次循环，此时整个算法的复杂度变成了O(n^3^)</p><ol start="2"><li>弗洛伊德算法(Floyd)<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef int Pathmatirx<span class="string">[MAXVEX]</span><span class="string">[MAXVEX]</span>;</span><br><span class="line">typedef int ShortPathTable<span class="string">[MAXVEX]</span><span class="string">[MAXVEX]</span>;</span><br><span class="line">/*Floyd算法，求网图G中各顶点v到其余顶点w最短路径P<span class="string">[v]</span><span class="string">[w]</span>及带权长度D<span class="string">[v]</span><span class="string">[w]</span>*/</span><br><span class="line">void ShortestPath_Floyd(MGraph G,Pathmatirx *P,ShortPathTable *D)</span><br><span class="line">&#123;</span><br><span class="line">    int v,w,k;</span><br><span class="line">    for(v=<span class="number">0</span>;v&lt;G.numVertexes;++v)  /*初始化D与P*/</span><br><span class="line">    &#123;</span><br><span class="line">        for(w=<span class="number">0</span>;w&lt;G.numVertexes;++w)</span><br><span class="line">        &#123;</span><br><span class="line">            (*D)<span class="string">[v]</span><span class="string">[w]</span>=G.matirx<span class="string">[v]</span><span class="string">[w]</span>;  /*D<span class="string">[v]</span><span class="string">[w]</span>值即为对应点间的权值*/</span><br><span class="line">            (*P)<span class="string">[v]</span><span class="string">[w]</span>=w;  /*初始化P*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=<span class="number">0</span>;k&lt;G.numVertexes;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        for(v=<span class="number">0</span>;v&lt;G.numVertexes;++v)</span><br><span class="line">        &#123;</span><br><span class="line">            for(w=<span class="number">0</span>;w&lt;G.numVertexes;++w)</span><br><span class="line">            &#123;</span><br><span class="line">                if((*D)<span class="string">[v]</span><span class="string">[w]</span>&gt;(*D)<span class="string">[v]</span><span class="string">[k]</span>+(*D)<span class="string">[k]</span><span class="string">[w]</span>)</span><br><span class="line">                &#123;  /*如果经过下标为k顶点路径比原两点间路径更短，将当前两点间权值设为更小的一个*/</span><br><span class="line">                    (*D)<span class="string">[v]</span><span class="string">[w]</span>=(*D)<span class="string">[v]</span><span class="string">[k]</span>+(*D)<span class="string">[k]</span><span class="string">[w]</span>;</span><br><span class="line">                    (*P)<span class="string">[v]</span><span class="string">[w]</span>=(*P)<span class="string">[v]</span><span class="string">[k]</span>;  /*路径设置经过下标为k的顶点*/</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>求最短路径的显示代码可以这么写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.numVertexes;++v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(w=v+<span class="number">1</span>;w&lt;G.numVertexes;w++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"v%d-v%d weight: %d"</span>,v,w,D[v][w]);</span><br><span class="line">        k=P[v][w];  <span class="comment">/*获得第一个路径顶点下标*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"path:%d"</span>,v);  <span class="comment">/*打印源点*/</span></span><br><span class="line">        <span class="keyword">while</span>(k!=w)  <span class="comment">/*如果路径顶点下标不是终点*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-&gt;%d"</span>,k);  <span class="comment">/*打印路径顶点*/</span></span><br><span class="line">            k=P[k][w];  <span class="comment">/*获得下一个路径顶点下标*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%d\n"</span>,w);  <span class="comment">/*打印终点*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>拓扑排序</li></ul><p>有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程是否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析除一个有向图是否存在环，如果不存在，那它的拓扑序列是？</p><blockquote><p>在拓扑排序算法中，涉及的结构代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>  /**/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;  <span class="comment">/*邻接点域，存储该顶点对应的下标*/</span></span><br><span class="line">    <span class="keyword">int</span> weight;  <span class="comment">/*用于存储权值，对于非网图可以不需要*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span>  <span class="comment">/*链域，指向下一个邻接点*/</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>  /*顶点表结点*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> in;  <span class="comment">/*顶点入度*/</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">/*顶点域，存储顶点信息*/</span></span><br><span class="line">    EdgeNode *firstedge;  <span class="comment">/*边表头指针*/</span></span><br><span class="line">&#125;VertexNode,AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList adjList;</span><br><span class="line">    <span class="keyword">int</span> numVertexes,numEdges;  <span class="comment">/*图中当前顶点数和边数*/</span></span><br><span class="line">&#125;graphAdjList,*GraphAdjList;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在算法中，我们还需要辅助的数据结构——栈，用来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*拓扑排序，若GL无回路，则输出拓扑排序序列并返回OK，若有回路返回ERROR*/</span></span><br><span class="line">Status TopologicalSort(GraphAdList <span class="keyword">GL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *<span class="keyword">e</span>;</span><br><span class="line">    int i,k,gettop;</span><br><span class="line">    int top=0;  <span class="comment">/*用于栈指针下标*/</span></span><br><span class="line">    int <span class="keyword">count</span>=0;  <span class="comment">/*用于统计输出顶点的个数*/</span></span><br><span class="line">    int *<span class="keyword">stack</span>;  <span class="comment">/*建栈存储入度为0的顶点*/</span></span><br><span class="line">    <span class="keyword">stack</span>=(int*)malloc(<span class="keyword">GL</span>-numVertexes*sizeof(int));</span><br><span class="line">    <span class="keyword">for</span>(i = 0;i&lt;<span class="keyword">GL</span>-&gt;numVertexes;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">GL</span>-&gt;adjList[<span class="keyword">in</span>].<span class="keyword">in</span> == 0)</span><br><span class="line">            <span class="keyword">stack</span>[++top]=i;  <span class="comment">/*将入度为0的顶点入栈*/</span></span><br><span class="line">    <span class="keyword">while</span>(top!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        gettop=<span class="keyword">stack</span>[top--];  <span class="comment">/*出栈*/</span></span><br><span class="line">        printf(<span class="string">"%d-&gt;"</span>,<span class="keyword">GL</span>-&gt;adjList[gettop].data);  <span class="comment">/*打印此顶点*/</span></span><br><span class="line">        <span class="keyword">count</span>++;  <span class="comment">/*统计输出顶点数*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">e</span>=<span class="keyword">GL</span>-&gt;adjList[gettop].firstedge;<span class="keyword">e</span>;<span class="keyword">e</span>-&gt;next)</span><br><span class="line">        &#123;<span class="comment">/*对此顶点弧表遍历*/</span></span><br><span class="line">            k=<span class="keyword">e</span>-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--<span class="keyword">GL</span>-&gt;adjList[k].<span class="keyword">in</span>))  <span class="comment">/*将k号顶点邻接点的入度减一*/</span></span><br><span class="line">                <span class="keyword">stack</span>[++top]=k;  <span class="comment">/*若为0则入栈，以便于下次循环输出*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">count</span>&lt;<span class="keyword">GL</span>-&gt;numVertexes)  <span class="comment">/*如果count小于顶点数，说明存在环*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ERROR</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>分析整个算法，对一个具有n个顶点e条弧的AOV网来说，将入度为0的顶点入栈的时间复杂为O(n)，而之后的while循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为O(n+e)</p><blockquote><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex Network)</p><ul><li>关键路径</li></ul></blockquote></blockquote><p>另一方面关心的是整个工程的完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。</p><blockquote><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网(Activity On Edge Network)</p><blockquote><p>我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点3具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动</p><ol><li>事件的最早发生时间etv(earliest time of vertex)</li><li>事件的最晚发生时间ltv(latest time of vertex)</li><li>活动的最早开工时间ete(earliest time of edge)</li><li>活动的最晚开工时间lte(latest time of edge)<br>我们由1和2求得3跟4，然后再根据ete[k]是否等于lte[k]来判断ak是否是关键活动</li></ol></blockquote></blockquote><p>求etv的过程就是从头到尾找拓扑序列的过程，因此在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列表，为此，我们先在程序开始出声明几个全局变量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *etv,*ltv; <span class="keyword">if</span> <span class="comment">/*事件最早发生时间和最迟发生时间数组*/</span></span><br><span class="line"><span class="keyword">int</span> stack2;  <span class="comment">/*用于存储拓扑序列的栈*/</span></span><br><span class="line"><span class="keyword">int</span> top2;  <span class="comment">/*用于stack2的指针*/</span></span><br></pre></td></tr></table></figure></p><p>以下是改进过的拓扑序列算法<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*拓扑排序，用于关键路径计算*/</span></span><br><span class="line">Status TopologicalSort(GraphAdjList GL)</span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    <span class="keyword">int</span> i,k,gettop;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;  <span class="comment">/*用于栈指针下标*/</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;  <span class="comment">/*用于统计输出顶点的个数*/</span></span><br><span class="line">    <span class="keyword">int</span> *stack;  <span class="comment">/*建栈将入度为0的顶点入栈*/</span></span><br><span class="line">    stack=(<span class="keyword">int</span> *)malloc(GL-&gt;numVertexes *sizeof(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; GL-&gt;numVertexes; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == GL-&gt;adjList[i].in)</span><br><span class="line">            stack[++top]=i;</span><br><span class="line">    top2=<span class="number">0</span>;  /初始化为<span class="number">0</span>/</span><br><span class="line">    etv=(<span class="keyword">int</span>*)malloc(GL-&gt;numVertexes *sizeof(<span class="keyword">int</span>));  /事件最早发生时间/</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; GL-&gt;numVertexes; i++)</span><br><span class="line">        etv[i]=<span class="number">0</span>;  /初始化为<span class="number">0</span>/</span><br><span class="line">    stack2 = (<span class="keyword">int</span> *)malloc(GL-&gt;numVertexes*sizeof(<span class="keyword">int</span>))  /初始化/</span><br><span class="line">    <span class="keyword">while</span>(top!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gettop=stack[top--];</span><br><span class="line">        count++;</span><br><span class="line">        stack2[++top2]=gettop;  <span class="comment">/*将弹出的顶点序号压入拓扑序列的栈*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(e = GL-&gt;adjList[gettop].firstedge;e;e = e-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            k=e-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--GL-&gt;adjList[k].in))</span><br><span class="line">                stack[++top]=k;</span><br><span class="line">            <span class="keyword">if</span>((etv[gettop]+e-&gt;weight)&gt;etv[k])  /求各顶点事件最早发生时间值/</span><br><span class="line">                etv[k] = etv[gettop]+e-&gt;weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; GL-&gt;numVertexes)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键路径的算法<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求关键路径，GL为有向网，输出GL的各项关键活动*/</span></span><br><span class="line">void CriticalPath(GraphAdjList GL)</span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    int i,gettop,k,j;</span><br><span class="line">    int ete,lte;  <span class="comment">/*声明活动最早发生时间和最迟发生时间变量*/</span></span><br><span class="line">    TopologicalSort(GL);  <span class="comment">/*求拓扑序列，计算数组etv和stack2的值*/</span></span><br><span class="line">    <span class="function"><span class="title">ltv</span>=(int*)malloc(GL-&gt;</span>numVertexes*sizeof(int));  <span class="comment">/*事件最晚发生时间*/</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;GL-&gt;</span>numVertexes;i++)</span><br><span class="line">        <span class="function"><span class="title">ltv</span>[i]=etv[GL-&gt;</span>numVertexes-<span class="number">1</span>];  <span class="comment">/*初始化ltv*/</span></span><br><span class="line">    <span class="keyword">while</span>(top2!=<span class="number">0</span>)  <span class="comment">/*计算ltv*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        gettop=stack2[top--];  <span class="comment">/*将拓扑序列出栈，后进先出*/</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(e=GL-&gt;</span><span class="function"><span class="title">adjList</span>[gettop].firstedge;e;e=e-&gt;</span>next)</span><br><span class="line">        &#123;  <span class="comment">/*求各顶点事件的最迟发生时间ltv值*/</span></span><br><span class="line">            <span class="function"><span class="title">k</span>=e-&gt;</span>adjvex;</span><br><span class="line">            <span class="function"><span class="title">if</span>(ltv[k]-e-&gt;</span>weight&lt;ltv[gettop])  <span class="comment">/*求各顶点事件最晚发生时间ltv*/</span></span><br><span class="line">                <span class="function"><span class="title">ltv</span>[gettop]=ltv[k]-e-&gt;</span>weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">for</span>(j=0;j&lt;GL-&gt;</span>numVertexes;j++)  <span class="comment">/*求ete，lte和关键活动*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(e=GL-&gt;</span><span class="function"><span class="title">adjList</span>[j].firstedge;e;e=e-&gt;</span>next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">k</span>=e-&gt;</span>adjvex;</span><br><span class="line">            ete=etv[j];  <span class="comment">/*活动最早发生时间*/</span></span><br><span class="line">            <span class="function"><span class="title">lte</span>=ltv[k]-e-&gt;</span>weight;  <span class="comment">/*活动最迟发生时间*/</span></span><br><span class="line">            <span class="keyword">if</span>(ete == lte)  <span class="comment">/*两者相等即在关键路径上*/</span></span><br><span class="line">                <span class="function"><span class="title">printf</span>("&lt;v%d,v%d&gt; length: %d,",GL-&gt;</span><span class="function"><span class="title">adjList</span>[j].<span class="keyword">data</span>,GL-&gt;</span><span class="function"><span class="title">adjList</span>[k].<span class="keyword">data</span>,e-&gt;</span>weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>整个关键路径的算法，拓扑排序O(n+e)，初始化lte为O(n)…根据我们对时间复杂度的定义，所有的常数系数可以忽略，所以最终求得关键路径算法的时间复杂度仍然是O(n+e)</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;图，让我想起被离散数学图论支配的恐惧，但是数据结构涉及到的属于图的抽象数据结构，简直比离散数学还要致命&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/DataStructure/2019/05/11/DataStructure-05/art.jpg&quot; alt=&quot;art&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="图" scheme="http://jhjhljh.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-树</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-04.html</id>
    <published>2019-05-10T17:22:40.000Z</published>
    <updated>2019-05-12T10:56:06.121Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">众所周知，树一直是数据结构的重点，此处摘要不做多介绍</p><p><img src="/DataStructure/2019/05/11/DataStructure-04/coldplay.jpg" alt="coldplay"></p><a id="more"></a><blockquote class="question">最近一直在循环coldplay的歌，分享一波</blockquote>        <div id="aplayer-QWRxrzBH" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-QWRxrzBH"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Viva la Vida",              author: "Coldplay",              url: "http://prc4nro7n.bkt.clouddn.com/Viva%20la%20Vida.mp3",              pic: "http://prc4nro7n.bkt.clouddn.com/Viva.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>前言:树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：</li></ul><ol><li>有且仅有一个特定的称为根(Root)的结点</li><li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2…..Tm，其中每一个集合本身又是一棵树，并且称为根的子数(SubTree)<h5 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h5></li></ol><ul><li>树的结点包含一个数据元素以及若干指向其子树的分支。结点拥有的字树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。</li><li>树的度是树内各结点的度的最大值<h5 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h5></li><li>结点的子树的根称为该结点的孩子(Child)，相应的，该结点称为孩子的双亲(Parent)<blockquote><p>对于结点来说其父母同体，唯一的一个，所以称为双亲</p></blockquote></li><li>同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所近分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙.<h5 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h5></li><li>结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。<blockquote><p>若某结点在第I层，则其子树的根就在第I+1层。</p></blockquote></li><li>其双亲在同一层的结点互为堂兄弟。</li><li>树中结点的最大层次称为树的深度(Depth)或高度<blockquote><p>如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</p></blockquote></li><li>森林(Forest)是m(m≥0)棵互不相交的树的集合<blockquote><p>对树种的每个结点而言，其子树的集合即为森林。</p></blockquote></li><li>对比线性表与树的结构，它们有很大的不同</li></ul><ol><li>线性结构：①第一个数据元素：无前驱；②最后一个数据元素：无后继；③中间元素：一个前驱一个后继</li><li>树结构：①根节点：无双亲，唯一；②叶节点：无孩子，可以多个；③中间结点：一个双亲多个孩子</li></ol><hr><h4 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h4><p>对于线性结构，树的操作就完全不同了<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT 树(Tree)</span><br><span class="line">Data 树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系.</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line">    InitTree(*<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    DestroyTree(*<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    CreateTree(*<span class="built_in">T</span>,definition)<span class="symbol">:</span></span><br><span class="line">    ClearTree(*<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    TreeEmpty(<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    TreeDepth(<span class="built_in">T</span>)<span class="symbol">:</span></span><br><span class="line">    Root(<span class="built_in">T</span>)<span class="symbol">:</span>返回树的根节点</span><br><span class="line">    <span class="built_in">Value</span>(<span class="built_in">T</span>,cur_e)<span class="symbol">:cu</span>r_e是树<span class="built_in">T</span>中的一个结点，返回此结点的值</span><br><span class="line">    Assign(<span class="built_in">T</span>,cur_e,<span class="built_in">value</span>)<span class="symbol">:</span>给树<span class="built_in">T</span>的结点cur_e赋值为<span class="built_in">value</span></span><br><span class="line">    Parent(<span class="built_in">T</span>,cur_e)<span class="symbol">:</span>若cur_e是树<span class="built_in">T</span>的非根结点，则返回它的双亲，否则返回空</span><br><span class="line">    LeftChild(<span class="built_in">T</span>,cur_e)<span class="symbol">:</span>若cur_e是树<span class="built_in">T</span>的非叶节点，则返回它的最左孩子，否则返回空</span><br><span class="line">    RightSibling(<span class="built_in">T</span>,cur_e)<span class="symbol">:</span>若cur_e有右兄弟，则返回它的右兄弟，否则返回空</span><br><span class="line">    InsertChild(*<span class="built_in">T</span>,&amp;p,i,c)<span class="symbol">:</span>其中p指向树<span class="built_in">T</span>的某个结点，i为所指结点p的度加上<span class="number">1</span>，非空树c与<span class="built_in">T</span>不相交，操作结果为插入c为树<span class="built_in">T</span>中p指结点的第i棵子树</span><br><span class="line">    DeleteChild(*<span class="built_in">T</span>,*p,i)<span class="symbol">:</span>其中p指向树<span class="built_in">T</span>的某个结点，i为所指结点p的度，操作结果为删除<span class="built_in">T</span>中p所指结点的第i棵子树</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure></p><hr><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul><li>双亲表示法(在每个结点中，附设一个指示器指示其双亲结点到链表中的位置)<blockquote><p>每个结点除了知道自己是谁之外，还知道它的双亲在哪里,结点结构分为data(数据域，存储结点的数据信息)跟parent(指针域，存储该结点的双亲在数组的下标)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*树的双亲表示法结点结构定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TElemType;  <span class="comment">/*树结点的数据类型，目前暂定为整型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>  /*结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;  <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="keyword">int</span> parent;  <span class="comment">/*双亲位置*/</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  /*树结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];  <span class="comment">/*结点数组*/</span></span><br><span class="line">    <span class="keyword">int</span> r,n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>双亲域，长子域，右兄弟域</p><blockquote><p>根节点的双亲域，长子域，右兄弟域都是-1</p><ul><li>孩子表示法<br>每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法，不过树的每个结点的度，也就是它的孩子个数是不同的，所以我们可以设计两种反案来解决</li></ul><ol><li>一种是指针域的个数等于树的度(树的度是树各个结点度的最大值<br>这种方法在树中各结点的度相差很大时，显然是浪费空间的</li><li>第二种是每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数(degree)<br>这种方法克服了空间的浪费，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗<br>思考：能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同？<blockquote><p>我们把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系.<br>这就是所谓的孩子表示法</p></blockquote></li></ol><ul><li>孩子表示法:把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*树的孩子表示法结构定义*/</span></span><br><span class="line"><span class="meta">#define MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CTNode</span> <span class="comment">/*孩子结点*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">CTNode</span> *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="comment">/*表头结构*/</span></span><br><span class="line">&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;<span class="built_in">CTbox</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="comment">/*树结构*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CTBox</span> nodes[MAX_TREE_SIZE];  <span class="comment">/*结点数组*/</span></span><br><span class="line">    <span class="keyword">int</span> r,n;</span><br><span class="line">&#125;<span class="built_in">CTree</span>;</span><br></pre></td></tr></table></figure></li></ul></blockquote></blockquote><ul><li>双亲孩子表示法<blockquote><p>算是孩子表示法的改进，略过</p></blockquote></li><li>孩子兄弟表示法<blockquote><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*树的孩子兄弟表示法结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightsib</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>其实这个表达法最大好处就是把一棵复杂的树变成了一棵二叉树</p></blockquote><hr><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul><li>二叉树的五种基本形态：</li></ul><ol><li>空二叉树</li><li>只有一个根节点</li><li>根节点只有左子树</li><li>根节点只有右子树</li><li>根节点既有左子树又有右子树<blockquote><p>注意：三个结点的树有两种情况，而三个结点的二叉树有五种形态</p></blockquote></li></ol><ul><li>特殊二叉树</li></ul><ol><li>斜树(左斜树跟右斜树)</li><li>满二叉树<blockquote><p>注意满二叉树的叶子只能出现在最下一层，单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有叶子都在同一层上</p></blockquote></li><li>完全二叉树</li></ol><ul><li>二叉树的性质</li></ul><ol><li>在二叉树的第i层上至多有2^i-1^个结点</li><li>深度为k的二叉树至多有2^k^-1个结点<blockquote><p>这里要看清楚，很容易把性质1跟性质2弄混</p></blockquote></li><li>对任意一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</li><li>具有n个结点的完全二叉树的深度为(log2n)+1</li><li>如果对一棵有n个结点的完全二叉树(其深度为(log2n)+1)的结点按层序编号，对任一节点i(1≤i≤n)有：</li></ol><ul><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]</li><li>如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i</li><li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1</li></ul><hr><h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul><li>顺序存储:二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，还原成完全二叉树的方法<blockquote><p>考虑一种极端的情况，比如一棵深度为k的右斜树，它只有k个结点，却要分配2^k^-1个存储单元空间，这显然是对存储空间的浪费，所以顺序存储结构一般只用于完全二叉树.</p></blockquote></li><li>二叉链表：二叉树的每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表为二叉链表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>  /*结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;  <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">/*左右孩子指针*/</span></span><br><span class="line">&#125;BiTNode,*BiTree</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><ul><li>二叉树的遍历(traversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问一次且仅被访问一次.</li></ul><ol><li><p>前序遍历</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*二叉树的前序遍历递归算法*/</span><br><span class="line">void PreOrderTraverse(BiTree <span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    printf(<span class="string">"c%"</span>,<span class="literal">T</span>-&gt;data); </span><br><span class="line">    PreOrderTraverse(<span class="literal">T</span>-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(<span class="literal">T</span>-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*二叉树的中序遍历递归算法*/</span><br><span class="line">void InOrderTraverse(BiTree <span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(<span class="literal">T</span>-&gt;lchild);</span><br><span class="line">    printf(<span class="string">"c%"</span>,<span class="literal">T</span>-&gt;data); </span><br><span class="line">    InOrderTraverse(<span class="literal">T</span>-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*二叉树的后序遍历递归算法*/</span><br><span class="line">void PostOrderTraverse(BiTree <span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(<span class="literal">T</span>-&gt;lchild);</span><br><span class="line">    PostOrderTraverse(<span class="literal">T</span>-&gt;rchild);</span><br><span class="line">    printf(<span class="string">"c%"</span>,<span class="literal">T</span>-&gt;data); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>层序遍历</p></li></ol><ul><li>推导遍历结果</li></ul><ol><li>已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，求这棵二叉树的后序遍历结果?<blockquote><p>CBEFDA</p></blockquote></li><li>已知一棵二叉树的中序序列是ABCDEFG，后序序列是BDCAFGE,求前序序列?<blockquote><p>EACBDGF 重要</p></blockquote></li></ol><p>从这里我们可以得到两个二叉树遍历的性质</p><ol><li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树<blockquote><p>已知前序和后序遍历，是不能确定一棵二叉树的，例如已知前序序列ABC和后序序列CBA，我们可以确定A一定是根节点，但接下来我们无法知道哪个结点是左结点和右结点，所以有4种情况</p></blockquote></li></ol><hr><h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><ul><li>利用扩展二叉树，比如假设二叉树的结点均为一个字符，我们把刚才前序遍历序列AB#D##C##用键盘挨个输入<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/*按前序输入二叉树中结点的值(一个字符)*/</span></span><br><span class="line"><span class="regexp">/* #表示空树，构造二叉链表示二叉树T */</span></span><br><span class="line">void CreateBiTree(BiTree *T)</span><br><span class="line">&#123;</span><br><span class="line">    TElemType ch;</span><br><span class="line">    scanf(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'#'</span>)</span><br><span class="line">        *T=NULL;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T=(BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        <span class="keyword">if</span>(!*T)</span><br><span class="line">            <span class="keyword">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;data=ch; <span class="regexp">/*生成根节点*/</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild); <span class="regexp">/*构造左子树*/</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild); <span class="regexp">/*构造右子树*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>其实建立二叉树，也是利用了递归的原理，只不过在原来应该打印结点的地方改成了生成结点，给结点赋值的操作而已，所以如果换成中序和后序遍历的方式，只要调整一下生成结点和构造左右子树的代码顺序即可</p></blockquote><hr><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><blockquote><p>我们考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址</p><ul><li>我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)</li><li>对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化，我们将这棵二叉树中所有空指针域中的lchild改为指向当前结点的前驱，rchild改为指向当前结点的后继<br>但是问题没有彻底解决，我们如何知道某一结点的lchild是指它的左孩子还是指向前驱？rchild是指向右孩子还是指向后继？<blockquote><p>这里我们引入两个标志域ltag和rtag，注意ltag和rtag只是存放0或1数字的布尔型变量</p><blockquote><p>tag为0时指向结点的孩子，为1时指向该结点的前驱/后继</p></blockquote></blockquote></li></ul></blockquote><hr><h4 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉线索存储结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Link,Thread&#125; PointerTag;  <span class="comment">/*Link == 0表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>  /*二叉线索存储结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;  <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">/*左右孩子指针*/</span></span><br><span class="line">    PointerTag LTag;</span><br><span class="line">    PointerTag RTag;</span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure><blockquote><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索，由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。</p></blockquote><p>中序遍历线索化的递归函数代码如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre;  <span class="comment">/*全局变量，始终指向刚刚访问过的结点*/</span></span><br><span class="line"><span class="comment">/*中序遍历进行中序线索化*/</span></span><br><span class="line">void InThreading(BiThrTree p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>lchild);  <span class="comment">/*递归左子树线索化*/</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(!p-&gt;</span>lchild)  <span class="comment">/*没有左孩子*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>LTag=Thread;  <span class="comment">/*前驱线索*/</span></span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>lchild=pre;  <span class="comment">/*左孩子指针指向前驱*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!pre-&gt;</span>rchild)  <span class="comment">/*前驱没有右孩子*/</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>Tag=Thread;  <span class="comment">/*后继线索*/</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rchild=p;   <span class="comment">/*前驱右孩子指针指向后继(当前结点p)*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre=p;  <span class="comment">/*保持pre指向p的前驱*/</span></span><br><span class="line">    I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>rchild);  <span class="comment">/*递归右子树线索化*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这段代码和二叉树中序遍历的递归代码几乎一样，只不过是将打印结点的功能改成了线索化的功能</p><blockquote><p>有了线索二叉树后，我们对它进行遍历时发现，其实就等于操作一个双向链表结构</p></blockquote></blockquote><p>遍历的代码如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*T指向头结点，头结点左链lchild指向根节点，头结点右链rchild指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T*/</span></span><br><span class="line">Status InOrderTraverse_Thr(BiThrTree T)</span><br><span class="line">&#123;</span><br><span class="line">    BiThrTree p;</span><br><span class="line">    <span class="function"><span class="title">p</span> = T-&gt;</span>lchild;  <span class="comment">/*p指向根节点*/</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)  <span class="comment">/*空树或遍历结束时，p==T*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>LTag==Link)  <span class="comment">/*当LTag==0时循环到中序序列第一个结点*/</span></span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>lchild；</span><br><span class="line">        <span class="function"><span class="title">printf</span>("c%",p-&gt;</span><span class="keyword">data</span>);  <span class="comment">/*显示结点数据，可以更改为其他对结点操作*/</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>RT<span class="function"><span class="title">ag</span>==Thread &amp;&amp; p-&gt;</span>rchild! =T)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;</span><br><span class="line">            <span class="function"><span class="title">printf</span>("%c",p-&gt;</span><span class="keyword">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;  <span class="comment">/*p进至其右子树根*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择.</li></ul><hr><h4 id="树，森林与二叉树的转换"><a href="#树，森林与二叉树的转换" class="headerlink" title="树，森林与二叉树的转换"></a>树，森林与二叉树的转换</h4><ul><li>转换</li><li>树与森林的遍历</li></ul><p>树的遍历分为两种形式</p><ol><li>先根遍历</li><li>后根遍历</li></ol><p>森林的遍历也分两种</p><ol><li>前序遍历</li><li>后序遍历<blockquote><p>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同</p></blockquote></li></ol><hr><h4 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h4><ul><li>赫夫曼树定义及原理</li></ul><ol><li>从树中的一个结点到另一个结点之间的分支构成的两个结点之间的路径，路径上的分支数目称为路径长度</li><li>树的路径长度就是从树根到每个结点的路径长度之和。</li><li>其中带权路径长度WPL最小的二叉树称为赫夫曼树，也称为最优二叉树.</li></ol><ul><li>赫夫曼编码</li><li>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码</li></ul><blockquote><p>线索二叉树记得回顾理解一下</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;众所周知，树一直是数据结构的重点，此处摘要不做多介绍&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/DataStructure/2019/05/11/DataStructure-04/coldplay.jpg&quot; alt=&quot;coldplay&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="树" scheme="http://jhjhljh.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-串</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-03.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/11/DataStructure-03.html</id>
    <published>2019-05-10T17:22:26.000Z</published>
    <updated>2019-05-12T16:10:27.446Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description">虽然课本已经不把串的抽象数据类型作为重点，但是毕竟有所提及，这里还是把串的相关笔记提交上来</p><p><img src="/DataStructure/2019/05/11/DataStructure-03/startup.jpg" alt="startup"></p><a id="more"></a><blockquote class="question">“你将不再是道具，而是人如其名的人”</blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=534064298&auto=1&height=66"></iframe><ul><li>前言<blockquote><p>串(string)是由零个或多个字符组成的有限序列，又名叫字符串,一般记为s=”a1a2a3….an”(n≥0),其中s是串的名称，用双引号括起来的字符序列是串的值，注意单引号不属于串中的内容。</p><blockquote><p>串中的字符数目n称为串的长度</p><blockquote><p>零个字符的串称为空串(null string)，它的长度为0，可以直接用两双引号“”表示，也可以用希腊字母Ø表示</p><blockquote><p>空格串，是只包含空格的串，注意它与空串的区别，空格串是有长度的，而且可以不止一个空格</p></blockquote></blockquote></blockquote></blockquote></li><li>字串和主串：串中容易个数的连续字符组成的子序列称为该串的字串，相应地，包含字串的串称为主串<blockquote><p>字串在主串中的位置就是字串的第一个字符在主串中的符号</p></blockquote></li></ul><hr><h4 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h4><p>串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</p><blockquote><p>ASCII——扩展——Unicode——UTF-8的关系了解一波?</p><blockquote><p>如果我们要在c语言中比较两个串是否相等，必须是它们串的长度以及它们各自对应位置的字符都相等时，才算是相等,而对于两个不相等的串，怎么判定它们的大小呢?</p><blockquote><p>给定两个串：s=“a1a2….an”，t=“b1b2b3…bn”，当满足以下条件之一时，s&lt;t.</p><ol><li>n&lt;m，且ai=bi(i=1，2…..,n) 例如当s=”hap”,t=”happy”就有s&lt;t</li><li>存在某个k≤min(m,n),使得ai=bi(i=1,2….k-1), ak&lt;bk 例如当s=”happen”,t=”happy”因为两串的前4个字母均相同，而两串第五个字母(k)值e&lt;y，所以s&lt;t</li></ol></blockquote></blockquote></blockquote><hr><h4 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串(string)</span><br><span class="line">Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line">    StrAssign(<span class="built_in">T</span>,*chars)：生成一个其值等于字符串常量chars的串<span class="built_in">T</span></span><br><span class="line">    StrCopy(<span class="built_in">T</span>,S)<span class="symbol">:</span>串S存在，由串S复制得串<span class="built_in">T</span></span><br><span class="line">    ClearStrng(S)<span class="symbol">:</span>串S存在，将串清空</span><br><span class="line">    StringEmpty(S)<span class="symbol">:</span>若串S为空，则返回<span class="built_in">true</span>，否则返回<span class="built_in">false</span></span><br><span class="line">    StrLength(S)<span class="symbol">:</span>返回串S的元素个数，即串的长度</span><br><span class="line">    StrCompare(S,<span class="built_in">T</span>)<span class="symbol">:</span>若S&gt;<span class="built_in">T</span>,返回值&gt;<span class="number">0</span>，若S=<span class="built_in">T</span>,返回<span class="number">0</span>，若S&lt;<span class="built_in">T</span>,返回值&lt;<span class="number">0</span></span><br><span class="line">    <span class="built_in">Concat</span>(<span class="built_in">T</span>,<span class="symbol">S1</span>,<span class="symbol">S2</span>)<span class="symbol">:</span>用<span class="built_in">T</span>返回由<span class="symbol">S1</span>和<span class="symbol">S2</span>连接而成的新串</span><br><span class="line">    SubString(Sub,S,pos,<span class="built_in">len</span>)<span class="symbol">:</span>串S存在，<span class="number">1</span>≤pos≤StrLength(S)。若主串S中存在和串<span class="built_in">T</span>值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回<span class="number">0</span></span><br><span class="line">    <span class="built_in">Index</span>(S,<span class="built_in">T</span>,pos)<span class="symbol">:</span>串S和<span class="built_in">T</span>存在，<span class="built_in">T</span>是非空串，<span class="number">1</span>≤pos≤StrLength(S)。若主串S中存在和串<span class="built_in">T</span>值相同的字串，则返回它在主串中第pos个字符之后第一次出现的位置，否则返回<span class="number">0</span></span><br><span class="line">    <span class="built_in">Replace</span>(S,<span class="built_in">T</span>,V)<span class="symbol">:</span>串S,<span class="built_in">T</span>和V存在，<span class="built_in">T</span>是非空串。用V代替主串S中出现的所有与<span class="built_in">T</span>相等的不重叠字串</span><br><span class="line">    StrInsert(S,pos,<span class="built_in">T</span>)<span class="symbol">:</span>串S，<span class="built_in">T</span>存在，<span class="number">1</span>≤pos≤StrLength(S)+<span class="number">1</span>,在串S的第pos个字符之前插入串<span class="built_in">T</span></span><br><span class="line">    StrDelete(S,pos,<span class="built_in">len</span>)<span class="symbol">:</span>串S存在，<span class="number">1</span>≤pos≤StrLength(S)-<span class="built_in">len</span>+<span class="number">1</span>。从串S中删除第pos个字符起长度为<span class="built_in">len</span>的子串</span><br><span class="line">endADTs</span><br></pre></td></tr></table></figure><p>我们来看一个操作Index的实现算法<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*T为非空串。若主串S中第pos个字符之后存在与T相等的子串则返回第一个这样的字串在S中的位置，否则返回0*/</span></span><br><span class="line"><span class="keyword">int</span> Index(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i;</span><br><span class="line">    <span class="keyword">String</span> sub;</span><br><span class="line">    <span class="built_in">if</span>(pos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n = StrLength(S);</span><br><span class="line">        m = StrLength(T);</span><br><span class="line">        i = pos;</span><br><span class="line">        <span class="built_in">while</span>(i &lt;= n-m+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            SubString(sub,S,i,m);<span class="comment">/*取主串第i个位置，长度与T相等子串给sub*/</span></span><br><span class="line">            <span class="built_in">if</span>(StrCompare(sub,T) != <span class="number">0</span>) <span class="comment">/*如果两串不相等*/</span></span><br><span class="line">                ++i;</span><br><span class="line">            <span class="built_in">else</span></span><br><span class="line">                <span class="built_in">return</span> i;<span class="comment">/*如果两串相等，则返回i值*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;<span class="comment">/*若无子串与T相等，返回0*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义</p><blockquote><p>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书也会定义存储在数组的最后一个下标位置</p><blockquote><p>有些是规定在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结，这个时候你要想知道串长度，遍历计算一下即可</p></blockquote></blockquote></blockquote><h4 id="朴素的模式匹配算法-BF算法-Brute-Force"><a href="#朴素的模式匹配算法-BF算法-Brute-Force" class="headerlink" title="朴素的模式匹配算法(BF算法)(Brute Force)"></a>朴素的模式匹配算法(BF算法)(Brute Force)</h4><blockquote><p>子串的的定位操作通常称为串的模糊匹配，应该算是串中最重要的操作之一<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*返回子串在主串S中第pos个字符之后的位置，若不存在则返回值为0。T非空，1≤pos≤StrLength(S)*/</span></span><br><span class="line"><span class="keyword">int</span> Index(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos;   <span class="comment">/*i用于主串S中当前位置下标，若pos不为1则从pos位置开始匹配*/</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">/*j用于子串T中当前位置下标值*/</span></span><br><span class="line">    <span class="built_in">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j&lt;= T[<span class="number">0</span>])  <span class="comment">/*若i小于S长度且j小于T的长度时循环*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">if</span>(S[i] == T[j])  <span class="comment">/*两字母相等则继续*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">else</span>    <span class="comment">/*指针后退重新开始匹配*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i-j+<span class="number">2</span>;  <span class="comment">/*i退回到上次匹配首位的下一位*/</span></span><br><span class="line">            j = <span class="number">1</span>;  <span class="comment">/*j退回到子串T的首位*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">return</span> i-T[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">else</span></span><br><span class="line">        <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h4 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h4><p>三位前辈发表一个模式匹配算法，可以大大避免重复遍历的情况，我们称之为克努特-莫里斯-普拉特算法，简称KMP算法</p><blockquote><p>此处省略原理简介以及next数组的引入，自己看书，简述几个例子</p><ol><li>abcdex———011111</li><li>abcabx———011123</li><li>ababaaaba———011234223</li><li>aaaaaaaab———012345678</li></ol><ul><li>KMP模式匹配算法实现<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*通过计算返回子串<span class="literal">T</span>的<span class="keyword">next</span>数组*/</span><br><span class="line">void get_next(String <span class="literal">T</span>,int *<span class="keyword">next</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="literal">T</span>[<span class="number">0</span>])  /*此处<span class="literal">T</span>[<span class="number">0</span>]表示串<span class="literal">T</span>的长度*/</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || <span class="literal">T</span>[i]==<span class="literal">T</span>[j])  /*<span class="literal">T</span>[i]表示后缀的单个字符，<span class="literal">T</span>[j]表示前缀的单个字符*/</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">next</span>[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = <span class="keyword">next</span>[j];      /*若字符不相同，则j值回溯*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0.。T非空，1≤pos≤StrLength(S)*/</span></span><br><span class="line"><span class="keyword">int</span> Index_KMP(String S, String T,<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos;  <span class="comment">/*i用于主串S当前位置下标值，若pos不为1，则从pos位置开始匹配*/</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">/*j用于子串T中当前位置下标值*/</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">next</span>[<span class="number">255</span>]; <span class="regexp">/定义一next数组/</span></span><br><span class="line">    get_next(T,<span class="keyword">next</span>);<span class="regexp">/对串T作分析，得到next数组/</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; k &lt;= T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S[i] == T[j])  <span class="regexp">/两字母相等则继续，与朴素算法增加了j=0判断/</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="keyword">next</span>[j];  <span class="regexp">/j退回合适的位置，i值不变/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>绿色注释部分为相对于朴素匹配算法增加的代码，改动不算大，关键就是去掉了i值回溯的部分。</p><blockquote><p>对于get_next函数来说，若T的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得index_KMP算法效率得到了提高</p><blockquote><p>while循环的时间复杂度为O(n),因此，整个算法的时间复杂度为O(n+m)，相较于朴素算法的O((n-m+1)*m)l来说，是要好一些。</p><blockquote><p>KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显</p></blockquote></blockquote></blockquote></blockquote><hr><h4 id="KMP模式匹配算法改进"><a href="#KMP模式匹配算法改进" class="headerlink" title="KMP模式匹配算法改进"></a>KMP模式匹配算法改进</h4><blockquote><p>对next函数进行了改良,假设取代的数组为nextval(String T,int *nextval),注意观察两者区别<br> <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求模式串T的next函数修正值并存入数组nextval*/</span></span><br><span class="line">void get_nextval(String T,int *nextval)</span><br><span class="line">&#123;</span><br><span class="line">    int i,<span class="keyword">j;</span></span><br><span class="line"><span class="keyword"> </span>   i = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">j </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    nextval[<span class="number">1</span>]=<span class="number">0</span><span class="comment">;</span></span><br><span class="line">    while(i &lt;T[<span class="number">0</span>])  <span class="comment">/*此处T[0]表示串T的长度*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        if(<span class="keyword">j==0 </span><span class="title">||</span> T[i] == T[<span class="keyword">j]) </span><span class="comment">/*T[i]表示后缀的单个字符，T[j]表示前缀的单个字符*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i<span class="comment">;</span></span><br><span class="line">            ++<span class="keyword">j;</span></span><br><span class="line"><span class="keyword"> </span>           <span class="comment">/*以下则是区别之处*/</span></span><br><span class="line">            if(T[i] != T[<span class="keyword">j]) </span> <span class="comment">/*若当前字符与前缀字符不同*/</span></span><br><span class="line">               nextval[i] = <span class="keyword">j; </span> <span class="comment">/*则当前的j为nextval在i位置的值*/</span></span><br><span class="line">            else</span><br><span class="line">               nextval[i] = nextval[<span class="keyword">j]; </span> <span class="comment">/*如果与前缀字符相同，则将前缀字符的nextval值赋值给nextval在i位置的值*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">           <span class="keyword">j </span>= nextval[<span class="keyword">j]; </span><span class="comment">/*若字符不相同，则j值回溯*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>实际匹配算法，只需要将”get_next(T,next);”改为”get_nextval(t,next);”j即可，这里不再重复</p><ul><li>nextval数组值推导</li></ul><ol><li>ababaaaba——011234223——010104210</li><li>aaaaaaaab——012345678——000000008</li></ol></blockquote><blockquote><p>总结改进过的KMP算法，它是在计算出next值的同时,如果a位字符与它next值指向的b位字符相等，则a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己的a位的next的值。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;虽然课本已经不把串的抽象数据类型作为重点，但是毕竟有所提及，这里还是把串的相关笔记提交上来&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/DataStructure/2019/05/11/DataStructure-03/startup.jpg&quot; alt=&quot;startup&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="串" scheme="http://jhjhljh.github.io/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://jhjhljh.github.io/git/2019/05/11/git.html"/>
    <id>http://jhjhljh.github.io/git/2019/05/11/git.html</id>
    <published>2019-05-10T17:21:48.000Z</published>
    <updated>2019-05-12T16:12:09.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="description"></p><p><img src="/git/2019/05/11/git/tie.jpg" alt="tie"></p><a id="more"></a><blockquote class="question">Taylor Swift is back from reputation, and there is no snake but only butterflies now </blockquote>        <div id="aplayer-NBmSUnyo" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-NBmSUnyo"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Me!!!",              author: "Taylor Swift",              url: "http://prc4nro7n.bkt.clouddn.com/Me.mp3",              pic: "http://prc4nro7n.bkt.clouddn.com/me.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><div class="note primary"><p>内容之后补充，还在整理,先听歌Σ(っ °Д °;)っ</p></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/git/2019/05/11/git/tie.jpg&quot; alt=&quot;tie&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://jhjhljh.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://jhjhljh.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈与队列</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-02.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-02.html</id>
    <published>2019-05-10T11:51:38.000Z</published>
    <updated>2019-05-12T16:02:11.869Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p></p><p class="description"><br>    数据结构与算法-栈与队列部分,栈与队列是数据结构重要思想之一，之后的抽象数据类型中诸多算法与方法会利用其特点<br></p><br><img src="/DataStructure/2019/05/10/DataStructure-02/faded.jpg" alt="fade"><p></p><a id="more"></a><hr><blockquote class="question">“花也好。星星也好。世间所有美丽的事物，都是为了比喻你而存在。”</blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=462688887&auto=1&height=32"></iframe><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>前言：<blockquote><p>栈(stack)是限定仅在表尾进行插入和删除操作的线性表</p><blockquote><p>队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表</p></blockquote></blockquote></li><li>我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIFO结构。<blockquote><p>首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底</p></blockquote></li><li>栈的插入操作，叫作进栈，也称压栈,入栈</li><li>栈的删除操作，叫作出栈<blockquote><p>最先进栈的元素，是不是就只能是最后出栈呢？</p><blockquote><p>举例:3个整型数字元素1，2，3依次进栈，会有哪些出栈次序呢？？？</p><blockquote><p>321，123，213，132，231</p><blockquote><p>没有312</p></blockquote></blockquote></blockquote></blockquote></li></ul><hr><h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><blockquote><p>对于栈来讲，理论上线性表的操作特性它都具备，由于它的特殊性，特别是插入和删除操作，我们改名为push和pop,英文直译的话是压和弹,我们一般叫进栈和出栈<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ADT</span> 栈(stack)</span><br><span class="line"><span class="selector-tag">Data</span></span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="selector-tag">Operation</span></span><br><span class="line">    <span class="selector-tag">InitStack</span>(*S):初始化操作，建立一个空栈<span class="selector-tag">S</span></span><br><span class="line">    <span class="selector-tag">DestroyStack</span>(*S):若栈存在，则销毁它</span><br><span class="line">    <span class="selector-tag">ClearStack</span>(*S):将栈清空</span><br><span class="line">    <span class="selector-tag">StackEmpty</span>(S):若栈为空，返回<span class="selector-tag">true</span>，否则返回<span class="selector-tag">false</span></span><br><span class="line">    <span class="selector-tag">GetTop</span>(S,*e):若栈存在且非空，用<span class="selector-tag">e</span>返回<span class="selector-tag">S</span>的栈顶元素</span><br><span class="line">    <span class="selector-tag">Push</span>(*S,e):若栈存在，插入新元素<span class="selector-tag">e</span>到栈<span class="selector-tag">S</span>中并成为栈顶元素</span><br><span class="line">    <span class="selector-tag">Pop</span>(*S,*e):删除栈<span class="selector-tag">S</span>中栈顶元素，并用<span class="selector-tag">e</span>返回其值</span><br><span class="line">    <span class="selector-tag">StackLength</span>(S):返回栈<span class="selector-tag">S</span>的元素个数</span><br><span class="line"><span class="selector-tag">endADT</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>同理：思考一下何时用S，<em>S，e，</em>e</p></blockquote><hr><h4 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h4><blockquote><p>若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。若栈存在一个元素时，top等于0，因此通常把空栈的判定条件定位top等于-1</p><blockquote><p>栈的结构定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;<span class="comment">/*SElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">/*用于栈顶指针*/</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><ul><li><p>进栈操作(push)</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line">Status <span class="keyword">Push</span>(SqStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top == MAXSIZE - <span class="number">1</span>) <span class="comment">/*栈满*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top++;<span class="comment">/*栈顶指针增加一*/</span></span><br><span class="line">    S-&gt;data[S-&gt;top]=e;<span class="comment">/*将新插入元素赋值给栈顶空闲*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出栈操作(pop)</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line">Status Pop(SqStack *S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(S-&gt;</span>top == -<span class="number">1</span>)</span><br><span class="line">        return ERROR;</span><br><span class="line">    *<span class="function"><span class="title">e</span> = S-&gt;</span><span class="function"><span class="title">data</span>[S-&gt;</span>top];<span class="comment">/*将要删除的栈顶元素赋值给e*/</span></span><br><span class="line">    <span class="function"><span class="title">s</span>-&gt;</span>top--;<span class="comment">/*栈顶指针减一*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>两者没有涉及到任何循环语句，由此时间复杂度均是O(1)</p></blockquote><hr><h4 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h4><blockquote><p>栈的顺序存储缺陷：必须事先确定数组存储空间大小</p><blockquote><p>不理解：栈1为空时，就是top1等于-1时，而当top2等于n时，即是栈2为空时；若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。</p><blockquote><p>两个栈相遇之时，就是两个指针相差1之时，即top1 + 1== top2为栈满<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">/*栈1栈顶指针*/</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">/*栈2栈顶指针*/</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><blockquote><p>对于两栈共享空间的push，除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line">Status Push(SqDoubleStack *S,SElemType e, <span class="keyword">int</span> stackNumber)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top1+<span class="number">1</span>==S-&gt;top2)<span class="comment">/*栈已满，不能再push新元素了*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber==<span class="number">1</span>)<span class="comment">/*栈1有元素进栈*/</span></span><br><span class="line">        S-&gt;data[++S-&gt;top1]=e;<span class="comment">/*若栈1则先top1+1后给数组元素赋值*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber==<span class="number">2</span>)<span class="comment">/*栈2有元素进栈*/</span></span><br><span class="line">        S-&gt;data[--S-&gt;top2]=e;<span class="comment">/*若栈2则先top2-1后给数组元素赋值*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line">Status <span class="keyword">Pop</span>(SqDoubleStack *S,SElemType *e,int stackNumber)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top1==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">        *e=S-&gt;data[S-&gt;top1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top2==MAXSIZE)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">        *e=S-&gt;data[S-&gt;top2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意前提条件:两个具有相同数据类型的栈</p></blockquote><hr><h4 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h4><blockquote><p>栈的链式存储结构简称为链栈</p><blockquote><p>有栈顶在头部，那对于链栈来说，是不需要头结点的</p><blockquote><p>对于链栈，基本不存在栈满的情况，除非内存已经没有可以使用的空间，对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*链栈的结构代码*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;<span class="comment">/*ptr指pointer,即指针*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><ul><li><p>栈的链表存储结构——进栈操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line">Status Push(LinkStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr s = (LinkStackPtr)malloc(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=S-&gt;top;<span class="comment">/*把当前的栈顶元素赋值给新结点的直接后继*/</span></span><br><span class="line">    S-&gt;top=s;<span class="comment">/*将新的结点s赋值给栈顶指针*/</span></span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>栈的链式存储结构——出栈操作</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR；*/</span></span><br><span class="line">Status Pop(LinkStack *S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">        return ERROR;</span><br><span class="line">    *<span class="function"><span class="title">e</span>=S-&gt;</span><span class="function"><span class="title">top</span>-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">    <span class="function"><span class="title">p</span>=S-&gt;</span>top;<span class="comment">/*将栈顶结点赋值给p*/</span></span><br><span class="line">    S-&gt;<span class="function"><span class="title">top</span>=S-&gt;</span><span class="function"><span class="title">top</span>-&gt;</span>next;<span class="comment">/*使得栈顶指针下移一位，指向后一结点*/</span></span><br><span class="line">    free(p);</span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1)</p></blockquote><hr><p>栈的应用</p><ul><li>递归之斐波那契数列(Fibonacci)<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*迭代法实现*/</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int a[<span class="number">40</span>];</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    printf(<span class="string">"%d"</span>,a[<span class="number">0</span>]);</span><br><span class="line">    printf(<span class="string">"%d"</span>,a[<span class="number">1</span>]);</span><br><span class="line">    for(i=<span class="number">2</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">        printf(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*斐波那契的递归函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fbi(i<span class="number">-1</span>)+Fbi(i<span class="number">-2</span>);<span class="comment">/*这里Fbi就是函数自己，它在调用自己*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,Fbi(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们把一个直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称作递归函数，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p><ul><li>栈的应用之四则运算表达式求值<br>逆波兰(Reverse Polish Notation,RPN):一种不需要括号的后缀表达法，这种后缀表示法，巧妙解决了程序实现四则运算的难题</li><li>例子：对于”9+(3-1)X3+10/2”如果用后缀表示法应该是”9 3 1 - 3 * + 10 2 / +”</li><li>计算规则:从左到右遍历表达式的每个数字和符号，遇到是数字就出栈，遇到是符号，就将处以栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最后获得最终结果</li><li>中缀表达式转后缀表达式规则:从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止</li></ul></blockquote><hr><h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><ul><li>定义：队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表<blockquote><p>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头.</p></blockquote></li></ul><hr><h4 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ADT</span> 队列(Queue)</span><br><span class="line"><span class="selector-tag">Data</span></span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="selector-tag">Operation</span></span><br><span class="line">    <span class="selector-tag">InitQueue</span>(*Q):初始化操作，建立一个空队列<span class="selector-tag">Q</span></span><br><span class="line">    <span class="selector-tag">DestroyQueue</span>(*Q):若队列<span class="selector-tag">Q</span>存在，则销毁它</span><br><span class="line">    <span class="selector-tag">ClearQueue</span>(*Q):将队列<span class="selector-tag">Q</span>清空</span><br><span class="line">    <span class="selector-tag">QueueEmpty</span>(Q):若队列<span class="selector-tag">Q</span>为空，返回<span class="selector-tag">true</span>，否则返回<span class="selector-tag">false</span></span><br><span class="line">    <span class="selector-tag">GetHead</span>(Q,*e):若队列<span class="selector-tag">Q</span>存在且非空，用<span class="selector-tag">e</span>返回队列<span class="selector-tag">Q</span>的队头元素</span><br><span class="line">    <span class="selector-tag">EnQueue</span>(*Q,e):若队列<span class="selector-tag">Q</span>存在，插入新元素<span class="selector-tag">e</span>到队列<span class="selector-tag">Q</span>中并成为队尾元素</span><br><span class="line">    <span class="selector-tag">DeQueue</span>(*Q,*e):删除队列<span class="selector-tag">Q</span>中队头元素，并用<span class="selector-tag">e</span>返回其值</span><br><span class="line">    <span class="selector-tag">QueueLength</span>(Q):返回队列<span class="selector-tag">Q</span>的元素个数</span><br><span class="line"><span class="selector-tag">endADT</span></span><br></pre></td></tr></table></figure><hr><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ul><li>队列顺序存储的不足<blockquote><p>假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，数组下标为0的一端即是队头</p><blockquote><p>所谓的入队列操作，就是在队尾插入一个元素，不需要移动任何元素，时间复杂度为O(1)</p><blockquote><p>与栈不同的是，队列元素的出列在队头，即下标为0的地方，队列所有元素都得前移，那时间复杂度为O(n)，之后利用指针改善</p><blockquote><p>这里的实现和线性表的顺序存储结构完全相同，不再详述</p></blockquote></blockquote></blockquote></blockquote></li></ul><blockquote><p>为了避免当只有一个元素时，队头跟队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个元素，这样当front等于rear时，此队列不是还剩一个元素，而是空队列</p><ul><li>定义：我们把队列的这种头尾相接的顺序存储结构称为循环队列。<br>我们刚才说，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？<blockquote><p>法一是设置一个标志变量flag,当front == rear，且flag=0时队列空，当flag=1时为队列满</p><blockquote><p>法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。</p></blockquote></blockquote></li><li>重点讨论法二:由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，也可能相差整整一圈。若队列的最大尺寸为QueueSize，那么队列满的条件是:(rear+1)%QueueSize == front</li><li>队列长度: 当rear &gt; front时，队列长度就是rear-front。但当rear &lt; front时，队列长度分为两段，一段是Queue-front，另一段是0+rear，加在一起就是rear-front+Queue，由此通用的计算队列长度公式为: (rear-front+Queue)%Queue<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;<span class="comment">/*QElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="comment">/*循环队列的顺序存储结构代码*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">/*头指针*/</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">/*尾指针，若队列不空，指向队列尾元素的下一个位置*/</span></span><br><span class="line">&#125;SqQueue</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>循环队列的初始化代码如下<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化一个空队列Q*/</span></span><br><span class="line">Status InitQueue(SqQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;front = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    Q-&gt;rear = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    return OK<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环队列求队列长度代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*返回Q的元素个数，也就是队列的当前长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环队列的入队列操作代码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若队列未满，则插入元素e为Q新的队尾元素*/</span></span><br><span class="line">Status EnQueue(SqQueue *Q,QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)<span class="comment">/*队列满的判断*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=e;<span class="comment">/*将元素e赋值给队尾*/</span></span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/*rear指针向后移一位置,若到最后则转到数组头部*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环队列的出队列操作代码<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若队列不空，则删除Q中队头元素，用e返回其值*/</span></span><br><span class="line">Status DeQueue(SqQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(Q-&gt;</span><span class="function"><span class="title">front</span> = Q-&gt;</span>rear)<span class="comment">/*队列空的判断*/</span></span><br><span class="line">        return ERROR;</span><br><span class="line">    *<span class="function"><span class="title">e</span>=Q-&gt;</span><span class="function"><span class="title">data</span>[Q-&gt;</span>front];</span><br><span class="line">    Q-&gt;<span class="function"><span class="title">front</span>=(Q-&gt;</span>front+<span class="number">1</span>)%MAXSIZE;<span class="comment">/*front指针向后移一个位置，若到最后则转到数组头部*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以发现，单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临数组可能溢出的问题，所以我们需要研究一下不需要担心队列长度的链式存储结构。</p></blockquote><hr><h4 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h4><ul><li>定义：队列的链式存储结构，其实就是线性表的单链表,只不过它只能尾进头出而已，我们把它简称为链队列。<blockquote><p>重点：为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点</p></blockquote></li><li><p>链队列的结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;<span class="comment">/*QElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> /*结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /*队列的链表结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front,rear;<span class="comment">/*队头，队尾指针*/</span></span><br><span class="line">&#125;LinkQueue</span><br></pre></td></tr></table></figure></li><li><p>队列的链式存储结构——入队操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/*插入元素e为Q的新的队尾元素*/</span></span><br><span class="line">Status EnQueue(LinkQueue *Q,QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="regexp">/*存储分配失败*/</span></span><br><span class="line">        <span class="keyword">exit</span>(OVERFLOW);</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;<span class="keyword">next</span>=NULL;</span><br><span class="line">    Q-&gt;rear-&gt;<span class="keyword">next</span>=s;<span class="regexp">/*把拥有元素e新结点s赋值给原队尾结点的后继，把当前的s设置为队尾结点，rear指向s*/</span></span><br><span class="line">    Q-&gt;rear=s;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>队列的链式存储结构——出队操作</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR*/</span></span><br><span class="line">Status DeQueue(LinkQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    <span class="function"><span class="title">if</span>(Q-&gt;</span><span class="function"><span class="title">front</span> == Q-&gt;</span>rear)</span><br><span class="line">        return ERROR;</span><br><span class="line">    <span class="function"><span class="title">p</span>=Q-&gt;</span><span class="function"><span class="title">front</span>-&gt;</span>next;<span class="comment">/*将欲删除的队头结点暂存给p*/</span></span><br><span class="line">    *<span class="function"><span class="title">e</span>=p-&gt;</span><span class="keyword">data</span>;<span class="comment">/*将欲删除的队头结点的值赋值给e*/</span></span><br><span class="line">    Q-&gt;<span class="function"><span class="title">front</span>-&gt;</span><span class="function"><span class="title">next</span>=p-&gt;</span><span class="function"><span class="title">next</span>;/*将原队头结点后继p-&gt;</span>next赋值给头结点后继*/</span><br><span class="line">    <span class="function"><span class="title">if</span>(Q-&gt;</span>rear==p)<span class="comment">/*若队头是队尾，则删除后将rear指向头结点*/</span></span><br><span class="line">        Q-&gt;<span class="function"><span class="title">rear</span>=Q-&gt;</span>front;</span><br><span class="line">    free(p);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>对于循环队列与链队列的比较，可以从两方面考虑</p><blockquote><p>时间上，它们的基本操作都是常数时间，即O(1)，不过循环队列是事先申请好空间，使用期间不释放，而链队列每次申请和释放结点会存在一些时间开销，如果入队出队频繁，还是有细微差异的</p><blockquote><p>空间上，循环队列必须有一个固定长度，所以就有存储元素个数和空间浪费的问题,空间上链队列更灵活</p><blockquote><p>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列长度，则用链队列.</p></blockquote></blockquote></blockquote></blockquote><hr><h4 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h4><p>stack跟queue均可以用线性表的顺序存储结构来实现，但是都存在着顺序存储的一些弊端,由此它们各自有各自的技巧解决问题</p><ul><li>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化利用数组的空间。</li><li>对于队列来说，未来避免数组插入和删除时需要移动数据，则引入了循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)<br>它们也可以通过链式存储结构来实现，实现原则跟线性表差不多。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;br&gt;    数据结构与算法-栈与队列部分,栈与队列是数据结构重要思想之一，之后的抽象数据类型中诸多算法与方法会利用其特点&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;/DataStructure/2019/05/10/DataStructure-02/faded.jpg&quot; alt=&quot;fade&quot;&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="线性表" scheme="http://jhjhljh.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-线性表</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01.html</id>
    <published>2019-05-10T11:21:38.000Z</published>
    <updated>2019-05-12T16:10:01.941Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p></p><p class="description"><br>    数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习<br></p><p></p><blockquote class="question">链表练习</blockquote><p><img src="/DataStructure/2019/05/10/DataStructure-01/fade.jpg" alt="fade"></p><a id="more"></a><hr><blockquote class="question">“即使只有一条路，也没有什么好困扰的，重要的是该怎么走那条路，对吧？”</blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=489970551&auto=1&height=32"></iframe><h4 id="线性表-List-：零个或多个数据元素的有限序列"><a href="#线性表-List-：零个或多个数据元素的有限序列" class="headerlink" title="线性表 (List)：零个或多个数据元素的有限序列"></a>线性表 (List)：零个或多个数据元素的有限序列</h4><ul><li>线性表元素的个数n（n≥0）定义为线性表的长度，当n=0时，称为空表。</li><li>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</li></ul><hr><h4 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data 线性表的数据对象集合为&#123;a1，a2，....an&#125;每个元素类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an之外，每一个元素有且只有一个直接后继元素。数据元素之间是一对一的关系</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line"><span class="function"><span class="title">InitList</span><span class="params">(*L)</span></span>:初始化操作，建立一个空的线性表L</span><br><span class="line"><span class="function"><span class="title">ListEmpty</span><span class="params">(L)</span></span>:判断线性表是否为空表，若线性表为空，返回True，否则返回false</span><br><span class="line"><span class="function"><span class="title">ClearList</span><span class="params">(*L)</span></span>:将线性表清空</span><br><span class="line"><span class="function"><span class="title">GetElem</span><span class="params">(L,I,*e)</span></span>:将线性表L中的第i个位置元素返回给e</span><br><span class="line"><span class="function"><span class="title">LocateElem</span><span class="params">(L,e)</span></span>:在线性表L中查找与给定值e相等的元素如果查找成功，返回该元素在表中序号，表示成功，否则返回<span class="number">0</span>，表示失败。</span><br><span class="line"><span class="function"><span class="title">ListInsert</span><span class="params">(*L,i,e)</span></span>:在线性表L的第i个位置插入新元素e</span><br><span class="line"><span class="function"><span class="title">ListDelete</span><span class="params">(*L,i,*e)</span></span>:删除线性表L中第i个位置元素，并用e返回其值</span><br><span class="line"><span class="function"><span class="title">ListLength</span><span class="params">(L)</span></span>:返回线性表L的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>实现两个线性表集合A跟B的并集操作！<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将所有的在线性表Lb但不在La的数据元素插入到La中*/</span></span><br><span class="line">void union(<span class="keyword">List</span> *<span class="keyword">La</span>,<span class="keyword">List</span> Lb)</span><br><span class="line">&#123;</span><br><span class="line">    int La_len,Lb_len,i;</span><br><span class="line">    ElemType <span class="keyword">e</span>; <span class="comment">/*声明与La和Lb相同的数据元素e*/</span></span><br><span class="line">    La_len = ListLength(<span class="keyword">La</span>); <span class="comment">/*求线性表的长度*/</span></span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span>(i = 1;i &lt;= Lb_len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(Lb,i,<span class="keyword">e</span>);<span class="comment">/*取Lb中第i个数据元素赋给e*/</span></span><br><span class="line">        <span class="keyword">if</span>(!LocateElem(<span class="keyword">La</span>,<span class="keyword">e</span>,equal)) <span class="comment">/*La中不存在和e相同数据元素*/</span></span><br><span class="line">        ListInsert(<span class="keyword">La</span>, ++La_len, <span class="keyword">e</span>); <span class="comment">/*插入*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h4><ul><li><p>定义:指的是用一段地址连续的存储单元以此存储线性表的数据元素。</p><blockquote><p>以下是线性表的顺序存储的结构代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/*存储空间的初始分配量 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType； <span class="comment">/*ElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]； <span class="comment">/*数组存储数据元素，最大值为MAXSIZE*/</span></span><br><span class="line">    <span class="keyword">int</span> length； <span class="comment">/*线性表当前长度*/</span></span><br><span class="line">&#125;SqList； <span class="comment">/*Sequence List*/</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>数组长度和线性表长度的区别：</p></li></ul><ol><li>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的</li><li>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是会变化的</li><li>在任意时刻，线性表的长度应该小于等于数组的长度。</li></ol><ul><li>地址计算方法</li></ul><ol><li>线性表的第i个元素是要存储在数组下标为i-1的位置，即线性表从1开始</li><li>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，由此分配的数组空间要大于等于当前线性表的长度</li><li>存储器中的每个存储单元都有自己的编号，这个编号称为地址</li></ol><blockquote><p> LOC(a(i+1))=LOC(ai)+c</p></blockquote><blockquote><p> LOC(ai)=LOC(a1)+(i-1)*c</p></blockquote><hr><h4 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h4><ul><li>GetElem:将线性表L中的第i个位置元素值返回，就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="comment">/*Status（状态，身份，地位）是函数的类型，其值是函数结果状态代码，如OK*/</span></span><br><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:用e返回L中第i个数据元素的值*/</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(L.length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">   <span class="keyword">return</span> ERROR;</span><br><span class="line">   *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>==疑问：为什么是*e？==</p><ul><li>ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e</li><li>插入算法的思路：</li></ul><ol><li>如果插入位置不合理，抛出异常</li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li><li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置</li><li>将要插入元素填入位置i处</li><li>表长加一<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在,1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/</span></span><br><span class="line">Status ListInsert(SqList *L,<span class="keyword">int</span> i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length==MAXSIZE) <span class="comment">/*顺序线性表已经满*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>) <span class="comment">/*当i不在范围内时*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length) <span class="comment">/*若插入数据位置不在表尾*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) <span class="comment">/*将要插入位置后数据元素向后移一位*/</span></span><br><span class="line">            L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=e;<span class="comment">/*将新元素插入*/</span></span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><ul><li>ListDelete</li><li>删除算法的思路:</li></ul><ol><li>如果删除位置不合理，抛出异常</li><li>取出删除元素</li><li>从删除元素位置开始遍历到最后一个元素，分别将它们都往前移动一个位置</li><li>表长减1<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete(SqList *L,<span class="type">int</span> i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;<span class="built_in">length</span> == <span class="number">0</span>) <span class="comment">/*线性表为空*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;<span class="built_in">length</span>) <span class="comment">/*删除位置不正确*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-<span class="built_in">length</span>) <span class="comment">/*如果删除不是最后位置*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;L-<span class="built_in">length</span>;k++) <span class="comment">/*将删除位置后继元素前移*/</span></span><br><span class="line">            L-data[k<span class="number">-1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;<span class="built_in">length</span>--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>-线性表顺序存储结构的优缺点</p><ol><li>优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间，可以快速地存取表中任一位置的元素</li><li>缺点：插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量，造成存储空间的“碎片”</li></ol><hr><h4 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h4><ul><li>为了表示每个数据元素a1与其直接后继元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置).我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)</li><li>n个结点(ai的存储映像)链结成一个链表，即为线性表(a1，a2，…an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做==单链表==</li><li>我们把链表中第一个结点的存储位置叫做头指针，规定最后一个结点指针为“空”(通常用NULL或^符号表)；有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，头结点的指针域存储指向第一个结点的指针。<h5 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h5></li><li>头指针</li></ul><ol><li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li><li>头指针具有标识作用，所以常用头指针冠以链表的名字</li><li>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</li></ol><ul><li>头结点</li></ul><ol><li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度)</li><li>有了头结点，对在第一元素结点前插入节点和删除第一结点，其操作与其它节点的操作就==统一==了</li><li>头结点不一定是链表必要元素</li></ol><ul><li>线性表链式存储结构代码描述</li></ul><ol><li>若线性表为空表，则头结点的指针域为“空”<blockquote><p>单链表中，我们在C语言可用结构指针来描述</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*线性表的单链表存储结构*/</span><br><span class="line">typedef struct <span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    ElemType</span> data;</span><br><span class="line">    struct <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125; <span class="keyword">Node</span><span class="title">;</span></span><br><span class="line"><span class="title">typedef</span> struct <span class="keyword">Node</span> <span class="title">*LinkList</span>;/*定义LinkList*/</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>这波操作事后==了解==一下,翻一下结构体</p><ol start="2"><li>结点由存放数据元素的数据域,存放后继结点地址的指针域组成</li></ol></blockquote><hr><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><ul><li>获得链表第i个数据的算法思路：</li></ul><ol><li>声明一个结点p指向链表第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，返回结点p的数据<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:用e返回L中的第i个数据元素的值*/</span></span><br><span class="line">Status GetElem(LinkList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p; <span class="comment">/*声明一结点p*/</span></span><br><span class="line">    <span class="function"><span class="title">p</span> = L-&gt;</span>next; <span class="comment">/*让p指向链表L的第一个结点*/</span></span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">/*j为计数器*/</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i) <span class="comment">/*p不为空或者计数器j还没有等于i时，循环继续*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next; <span class="comment">/*让p指向下一个结点*/</span></span><br><span class="line">        ++j；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( !p || j&gt;i )</span><br><span class="line">        return ERROR; <span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    *<span class="function"><span class="title">e</span> = p-&gt;</span><span class="keyword">data</span>; <span class="comment">/*取第i个元素的数据*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h4><blockquote><p>s-&gt;next=p-&gt;next; p-&gt;next=s<br>这两句的顺序==不可交换==，自己想</p><ul><li>单链表第i个数据插入结点的算法思路：</li></ul><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，在系列中生成一个空结点s</li><li>将数据元素e赋值给s-&gt;data</li><li>单链表的插入标准语句s-&gt;next=p-&gt;next; p-&gt;next=s</li><li>返回成功<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/</span></span><br><span class="line">Status ListInsert(LinkList *L,int i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p,s;</span><br><span class="line">    p = *L;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j &lt; i) <span class="comment">/*寻找第i个结点*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">        return ERROR; <span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    s =(LinkList)malloc(sizeof(Node));<span class="comment">/*生成新结点(C标准函数)*/</span></span><br><span class="line">    <span class="function"><span class="title">s</span>-&gt;</span><span class="keyword">data</span> = e;</span><br><span class="line">    <span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;<span class="comment">/*将p的后继结点赋值给s的后继*/</span></span><br><span class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next = s; <span class="comment">/*将s赋值给p的后继*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>单链表的删除实质：p-&gt;next=p-&gt;next-&gt;next</p><blockquote><p>用q来取代p-&gt;next,就是q=p-&gt;next;p-&gt;next=q-&gt;next;</p><ul><li>单链表第i个数据删除结点的算法思路:</li></ul><ol><li>声明一结点p指向链表的第一个节点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，将欲删除的结点p-&gt;next赋值给q</li><li>单链表的标准删除语句p-&gt;next=q-&gt;next</li><li>将q结点中的数据赋值给e，作为返回</li><li>释放q结点</li><li>返回成功<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:删除L的第i个数据元素，并用e返回其值，L的长度减1*/</span></span><br><span class="line">Status ListDelete(LinkList *L,int i, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = *L;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">while</span>(p-&gt;</span>next &amp;&amp; j &lt; i) <span class="comment">/*遍历寻找第i个元素*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span>(!(p-&gt;</span>next) || j&gt;i)</span><br><span class="line">        return ERROR;<span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    <span class="function"><span class="title">q</span> = p-&gt;</span>next;</span><br><span class="line">    p</span><br><span class="line">    -&gt;<span class="function"><span class="title">next</span> = q-&gt;</span>next;<span class="comment">/*将q的后继赋值给p的后继*/</span></span><br><span class="line">    *<span class="function"><span class="title">e</span>=q-&gt;</span><span class="keyword">data</span>;<span class="comment">/*将q结点中的数据给e*/</span></span><br><span class="line">    free(q);<span class="comment">/*让系统回收此结点，释放内存*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote></blockquote><hr><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><ul><li>创建单链表的过程就是一个动态生成链表的过程，即从”空表”的初始状态起，依次建立各元素结点，并逐个插入链表</li><li>单链表整表创建的算法思路:</li></ul><ol><li>声明一结点p和计数器变量i</li><li>初始化一空链表L</li><li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表</li><li>循环:<br>生成一新结点赋值给p；随机生成一数字赋值给p的数据域p-&gt;data;将p插入到头结点与前一新结点之间<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*随机生成n个元素的值，建立带表头结点的单链线性表L(头插法)*/</span></span><br><span class="line"><span class="literal">void</span> CreateListHead(LinkList *L,int n)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    int i;</span><br><span class="line">    srand(time(<span class="number">0</span>)); <span class="comment">/*初始化随机数种子*/</span></span><br><span class="line">    *L = ( LinkList)malloc(sizeof(Node));</span><br><span class="line">    <span class="function"><span class="params">(*L)</span>-&gt;</span>next = NULL; <span class="comment">/*先建立一个带头结点的单链表*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (LinkList)malloc(sizeof(Node));<span class="comment">/*生成新结点*/</span></span><br><span class="line">        p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>; <span class="comment">/*随机生成100以内的数字*/</span></span><br><span class="line">        p-&gt;<span class="function"><span class="title">next</span> = <span class="params">(*L)</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="params">(*L)</span>-&gt;</span>next = p; <span class="comment">/*插入到表头*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>求问L,<em>L,(</em>L)的区别？ 如果要改变变量的值就用指针，不改变就用变量本身<br>LinkList等同于Node <em>，所以L要加 </em></p><blockquote><p>函数rand()跟srand()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*随机生成n个元素的值，建立带表头结点的单链线性表L(尾插法)*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList *L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p,r;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    srand(time(<span class="number">0</span>));<span class="comment">/*初始化随机数种子*/</span></span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))；<span class="comment">/*为整个线性表*/</span></span><br><span class="line">    r=*L;<span class="comment">/*r为指向尾部的结点*/</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">/*生成新结点*/</span></span><br><span class="line">        p-&gt;data=rand()%<span class="number">100</span>+<span class="number">1</span>;<span class="comment">/*随机生成100以内的数字*/</span></span><br><span class="line">        r-&gt;next = p;<span class="comment">/*将表尾终端结点的指针指向新结点*/</span></span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;<span class="comment">/*表示当前链表结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><hr><h4 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h4><ul><li>单链表整表删除的算法思路如下:</li></ul><ol><li>声明一结点p和q；</li><li>将第一个结点赋值给p</li><li>循环：将下一结点赋值给q；释放p；将q赋值给p。<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件：顺序线性表L已存在，操作结果：将L重置为空表*/</span></span><br><span class="line">Status ClearList(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    <span class="function"><span class="title">p</span>=<span class="params">(*L)</span>-&gt;</span>next; <span class="comment">/*p指向第一个结点*/</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        free(p);</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="params">(*L)</span>-&gt;</span>next=NULL;<span class="comment">/*头结点指针域为空*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><blockquote><p>简单地对单链表结构和顺序存储结构做对比：</p><ul><li>存储分配方式</li></ul><ol><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li></ol><ul><li>时间性能</li></ul><ol><li>查找：①顺序存储结构O(1)；②单链表O(n)</li><li>插入与删除：①顺序存储结构需要平均移动表长一半的元素，时间为O(n)； ②单链表在线出某位置的指针后，插入和删除时间仅为O(1)</li></ol><ul><li>空间性能</li></ul><ol><li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制<br>通过上面对比，我们可以得出一些经验性的结论</li><li>若线性表需要频繁查找，很少进行插入或删除时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。比如游戏开发，对于用户注册的个人信息，出来注册时插入数据外，绝大多数情况都是读取，所以应该考虑顺序存储结构。而游戏装备道具就用单链表结构。</li><li>当线性表元素个数变化很大或者不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，则用顺序存储结构效率会高很多。</li></ol></blockquote><hr><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><ul><li>背景:数组代替指针描述单链表，首先让数组的元素由两个数据域组成，data和cur，也就是说，数组的每一个下标都对应一个data和一个cur.数据域data，用来存放数据元素，也就是通常我们要处理的数据，而游标cur相当于单链表的next指针，用于存放该元素后继在数组中的下标。我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<blockquote><p>为了方便插入数据，通常会把数组建立得大一些，以便有一些空闲空间插入不至于溢出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的静态链表存储结构*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">/*假设链表的最大长度是1000*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur; <span class="comment">/*游标(cursor),为0</span></span><br><span class="line"><span class="comment">    时表示无指向*/</span></span><br><span class="line">&#125;Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据，把未被使用的数组元素称为备用链表。</p><blockquote><p>数组第一个元素，即下标为0的元素的cur存放备用链表的第一个结点的下标;而数组的最后一个元素的cur则存放第一个有数值的元素的下表，相当于单链表中的头结点，当整个链表为空时，则为0<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*将一维数组<span class="literal">space</span>中各分量链成一备用链表*/</span><br><span class="line">/*<span class="literal">space</span>[<span class="number">0</span>].cur为头指针，<span class="string">"0"</span>表示空指针*/</span><br><span class="line">Status InitList(StaticLinkList <span class="literal">space</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXSIZE<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="literal">space</span>[i].cur = i+<span class="number">1</span>;</span><br><span class="line">    <span class="literal">space</span>[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>/*目前静态链表为空，最后一个元素的cur为<span class="number">0</span>*/</span><br><span class="line"><span class="built_in">    return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><ul><li>静态链表的插入操作<blockquote><p>静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放</p><blockquote><p>动态链表，结点的申请和释放分别借用malloc()和free()两个函数来实现，而静态链表操作的是数组，我们需要自己实现这两个函数</p><blockquote><p>为了辨明数组中哪些分量未被使用，解决方法是将所有未被使用过的及被删除的分量用游标链成一个备用的链表，每当插入时，可以从备用链表上取得第一个结点作为待插入的新结点</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若备用空间链表为空，则返回分配的结点下标，否则为0*/</span></span><br><span class="line">int Malloc_SLL(StaticLinkList <span class="built_in">space</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="built_in">space</span>[<span class="number">0</span>].cur;<span class="comment">/*当前数组第一个元素的cur存的值就是要返回的第一个备用空闲的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">space</span>[<span class="number">0</span>].cur)</span><br><span class="line">        <span class="built_in">space</span>[<span class="number">0</span>].cur = <span class="built_in">space</span>[i].cur<span class="comment">/*由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用*/</span></span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote></li></ul><blockquote><p>需要找到接替者才能继续分配新的空闲分量</p><blockquote><p>现在我们如果需要在乙丁之间插入丙，我们只需要让丙在7号备用位待着，把乙的cur改为7，再让丙的cur改为3即可<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="built_in">ListInsert</span>(StaticLinkList L,int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int j,k,l;</span><br><span class="line">    k = MAX_SIZE - <span class="number">1</span>;<span class="comment">/*注意k首先是最后一个元素的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; <span class="built_in">ListLength</span>(L) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">    j = <span class="built_in">Malloc_SSL</span>(L);<span class="comment">/*获得空闲分量的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(j)</span><br><span class="line">    &#123;</span><br><span class="line">        L[j].data = e; <span class="comment">/*将数据赋值给此分量的data*/</span></span><br><span class="line">        <span class="keyword">for</span>(l = <span class="number">1</span>;l &lt;= i<span class="number">-1</span>;l++) <span class="comment">/*找到第i个元素之前的位置*/</span></span><br><span class="line">        k = L[k].cur;</span><br><span class="line">        L[j].cur = L[k].cur;<span class="comment">/*把第i个元素之前的cur赋值给新元素的cur*/</span></span><br><span class="line">        L[k].cur = j;<span class="comment">/*把新元素的下标赋值给第i个元素之前元素的cur*/</span></span><br><span class="line">        <span class="keyword">return</span> OK；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ERROR</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><ul><li>静态链表的删除操作<blockquote><p>和前面一样，删除元素时，原来是需要释放结点的函数free().现在我们也得自己实现它:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除在L中第i个数据元素e*/</span></span><br><span class="line">Status ListDelete(StaticLinkList L,int i)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">j,k;</span></span><br><span class="line"><span class="keyword"> </span>   if(i &lt; <span class="number">1</span> <span class="title">||</span> i &gt; LIstLength(L))</span><br><span class="line">        return ERROR<span class="comment">;</span></span><br><span class="line">    k = MAX_SIZE - <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">j </span>= <span class="number">1</span><span class="comment">;j &lt;= i-1;j++)</span></span><br><span class="line">        k = L[k].cur<span class="comment">;</span></span><br><span class="line">    <span class="keyword">j </span>= L[k].cur<span class="comment">;</span></span><br><span class="line">    L[k].cur = L[<span class="keyword">j].cur;</span></span><br><span class="line"><span class="keyword"> </span>   Free_SSL(L,<span class="keyword">j);</span></span><br><span class="line"><span class="keyword"> </span>   return OK<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>而关于Free_SSL(L,j)<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将下列为k的空闲结点回收到备用链表*/</span></span><br><span class="line">void Free_SSL(StaticLinkList <span class="built_in">space</span>,int k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">space</span>[k].cur = <span class="built_in">space</span>[<span class="number">0</span>].cur;<span class="comment">/*把第一个元素cur赋值给要删除的分量cur*/</span></span><br><span class="line">    <span class="built_in">space</span>[<span class="number">0</span>].cur = k;<span class="comment">/*把要删除的分量下标赋值给第一个元素的cur*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当然，静态链表也有相应的其他操作的相关实现，比如代码中的ListLength<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件：静态链表L已存在，操作结果：返回L中的数据个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        i = L[i].cur;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>回顾：sizeof()和strlen</p></blockquote><hr><h4 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h4><ul><li>优点</li></ul><ol><li>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点</li></ol><ul><li>缺点</li></ul><ol><li>没有解决连续存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性<blockquote><p>总的来说，静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法。</p></blockquote></li></ol><hr><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ul><li>定义:将单链表中终端结点的指针端由空指针改为指向头结点就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)</li><li>循环链表和单链表的主要差异在判断条件上：原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束<blockquote><p>在单链表中，我们有了头结点，可以用O(1)的时间访问第一个结点，但对于要访问到最后一个结点，却需要O(n)时间，因为我们需要将单链表全部扫描一遍</p><blockquote><p>如用O(1)的时间由链表指针访问到最后一个结点,则需改造一下循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便</p><blockquote><p>终端结点用尾指针rear指示，则查找终端结点是O(1),而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂也为O(1)</p></blockquote></blockquote></blockquote></li><li>举个程序的例子，要将两个循环链表合成一个表时，有了尾指针就非常简单<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span> = rearA-&gt;</span>next;<span class="comment">/*保存A表的头结点*/</span></span><br><span class="line"><span class="function"><span class="title">rearA</span>-&gt;</span><span class="function"><span class="title">next</span>=rearB-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>;/*将本是指向B表的第一个结点(不是头结点)赋值给rearA-&gt;</span>next*/</span><br><span class="line"><span class="function"><span class="title">rearB</span>-&gt;</span><span class="function"><span class="title">next</span>=p;/*将原A表的头结点赋值给rearB-&gt;</span>next*/</span><br><span class="line">free(p);<span class="comment">/*释放p*/</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul><li>定义：双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的双向链表存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span><span class="comment">/*直接前驱指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span><span class="comment">/*直接后继指针*/</span></span><br><span class="line">&#125;DulNode,*DuLinkList;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>既然单链表有循环链表，那么双向链表也可以是循环链表</p><blockquote><p>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</p><ul><li>双向链表的插入<br>将结点s插入到结点p和p-&gt;next之间</li></ul></blockquote><blockquote><p>顺序很重要，不能写反<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span>-&gt;</span>prior = p;<span class="comment">/*将p赋值给s的前驱*/</span></span><br><span class="line"><span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span><span class="function"><span class="title">next</span>;/*把p-&gt;</span>next赋值给s的后继*/</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">prior</span> = s;/*把s赋值给p-&gt;</span>next的前驱*/</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>next = s;<span class="comment">/*把s赋值给p的后继*/</span></span><br></pre></td></tr></table></figure></p></blockquote></blockquote><blockquote><p>顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继</p><ul><li>双向链表的删除<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">prior</span>-&gt;</span><span class="function"><span class="title">next</span>=p-&gt;</span>next;</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">prior</span>=p-&gt;</span>prior;</span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>多结合图形记忆</p></blockquote><hr><h4 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h4><ul><li>线性表</li></ul><ol><li>顺序存储结构</li><li>链式存储结构</li></ol><ul><li>单链表</li><li>静态链表</li><li>循环链表</li><li>双向链表</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;br&gt;    数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote class=&quot;question&quot;&gt;链表练习&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/DataStructure/2019/05/10/DataStructure-01/fade.jpg&quot; alt=&quot;fade&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="线性表" scheme="http://jhjhljh.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构概论</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-introduction.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-introduction.html</id>
    <published>2019-05-10T06:31:56.000Z</published>
    <updated>2019-05-11T15:19:00.692Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p></p><p class="description"><br>    数据结构与算法绪论,打算将当初的数据结构笔记搬上博客，主要参照《大话数据结构》，此处强烈推荐<br></p><br><img src="/DataStructure/2019/05/10/DataStructure-introduction/fade.jpg" alt="fade"><p></p><a id="more"></a><hr><blockquote class="question">摘要图存粹是为了美观，其次是为了推荐这首faded的remix，同一首歌不一样的感觉，在我看来，多了一种空灵的美感，强烈推荐，之后的摘要图估计也会是图文关系不大（￣︶￣）↗　</blockquote>        <div id="aplayer-TfvXlgOH" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-TfvXlgOH"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "Faded (Restrung)",              author: "Alan Walker",              url: "http://prc4nro7n.bkt.clouddn.com/faded.mp3",              pic: "http://prc4nro7n.bkt.clouddn.com/faded.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h4 id="数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。"><a href="#数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。" class="headerlink" title="数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。"></a>数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。</h4><ul><li>逻辑结构：数据对象中数据元素之间的相互关系<ol><li>集合结构（平等）</li><li>线性结构（一对一）</li><li>树形结构（一对多）</li><li>图形结构（多对多）</li></ol></li><li>物理结构：数据的逻辑结构在计算机中的存储方式</li></ul><ol><li>顺序结构</li><li>链式结构</li></ol><hr><h4 id="算法（Algorithm）：对数据结构的运用"><a href="#算法（Algorithm）：对数据结构的运用" class="headerlink" title="算法（Algorithm）：对数据结构的运用"></a>算法（Algorithm）：对数据结构的运用</h4><ul><li>算法的特性</li></ul><ol><li>输入：算法具有零个或多个输入</li><li>输出：算法至少有一个或多个输出</li><li>有穷性：自动结束不会死循环</li><li>确定性：不会出现二义性</li><li>可行性：每一步都是可行的</li></ol><ul><li>算法设计要求</li></ul><ol><li>正确性<blockquote><ol><li>算法程序没有语法错误</li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果</li><li>算法程序对于非法的输入数据能够算得出满足规格说明的结果</li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果</li></ol></blockquote></li><li>可读性</li><li>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或者莫名其妙的结果</li><li>时间效率搞和存储量低</li></ol><hr><h4 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h4><ol><li>事后统计方法</li><li>事前分析估算方法</li></ol><hr><h4 id="函数的渐近增长与时间复杂度"><a href="#函数的渐近增长与时间复杂度" class="headerlink" title="函数的渐近增长与时间复杂度"></a>函数的渐近增长与时间复杂度</h4><ul><li>大O阶方法</li></ul><ol><li>用常数1取代运行时间中所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数，得到的结果就是大O阶。</li></ol><ul><li>常数阶<blockquote><p>无论n为多少，这个常数为多少，我们都记作O（1），而不能是O（3）、O（12）等任何数字，这是初学者常常犯的错。可以理解为常数项为最高项，然后去除系数，则为1</p></blockquote></li><li><p>线性阶</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">/*时间复杂度为O（1）的程序步骤序列*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对数阶</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">count</span> &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">count</span> = <span class="keyword">count</span> * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/*时间复杂度为O（1）的程序步骤序列*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>由2^x^=n得x=log(2)n，所以这个循环的时间复杂度为O（logn）</p><ul><li>平方阶<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i,<span class="keyword">j;</span></span><br><span class="line"><span class="keyword">for(i </span>= <span class="number">0</span><span class="comment">; i &lt; n;i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    for(<span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j &lt; n;j++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 时间复杂度为O（1）的程序步骤序列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = i;j &lt; n;j++) <span class="comment">/*注意j = i而不是0*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*时间复杂度为O（1）的程序步骤序列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总执行次数为：n+(n-1)+(n-2)+…+1= n^2^/2+n/2,因此这段代码的时间负责度为O(n^2^)</p><ul><li>最坏情况与平均情况</li></ul><ol><li>通常，除非特殊指定，我们提到的运行时间都是最坏情况的运行时间</li><li>平均运行时间是所有情况中最有意义的，因为它是期望的云习惯时间，但是平均运行时间和难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。</li><li>一般在没有特殊说明的情况下，都是指最坏时间复杂度</li></ol></blockquote><hr><h4 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;br&gt;    数据结构与算法绪论,打算将当初的数据结构笔记搬上博客，主要参照《大话数据结构》，此处强烈推荐&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;/DataStructure/2019/05/10/DataStructure-introduction/fade.jpg&quot; alt=&quot;fade&quot;&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="introduction" scheme="http://jhjhljh.github.io/tags/introduction/"/>
    
  </entry>
  
  <entry>
    <title>article</title>
    <link href="http://jhjhljh.github.io/%E7%BB%83%E4%B9%A0/2019/05/08/article.html"/>
    <id>http://jhjhljh.github.io/练习/2019/05/08/article.html</id>
    <published>2019-05-08T08:31:34.000Z</published>
    <updated>2019-05-11T15:16:42.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote class="question">内容</blockquote><p><blockquote class="blockquote-center"><br>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！<br></blockquote><br><blockquote class="blockquote-center"><p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p></blockquote></p><!-- 简单示例 (id, server, type)  -->    <div id="aplayer-OLzOGRgl" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="60198" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="练习" scheme="http://jhjhljh.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="jQuery" scheme="http://jhjhljh.github.io/tags/jQuery/"/>
    
      <category term="表格" scheme="http://jhjhljh.github.io/tags/%E8%A1%A8%E6%A0%BC/"/>
    
      <category term="表单验证" scheme="http://jhjhljh.github.io/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jhjhljh.github.io/uncategorized/2019/05/08/hello-world.html"/>
    <id>http://jhjhljh.github.io/uncategorized/2019/05/08/hello-world.html</id>
    <published>2019-05-08T08:02:01.327Z</published>
    <updated>2019-05-08T08:02:01.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>
