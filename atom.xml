<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abo</title>
  
  <subtitle>阿波同学</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jhjhljh.github.io/"/>
  <updated>2019-05-10T12:07:27.560Z</updated>
  <id>http://jhjhljh.github.io/</id>
  
  <author>
    <name>林加鸿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-栈与队列</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-02.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-02.html</id>
    <published>2019-05-10T11:51:38.000Z</published>
    <updated>2019-05-10T12:07:27.560Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"><br>    数据结构与算法-栈与队列部分,栈与队列是数据结构重要思想之一，之后的抽象数据类型中诸多算法与方法会利用其特点<br></p><br><img src="/DataStructure/2019/05/10/DataStructure-02/faded.jpg" alt="fade"><p></p><a id="more"></a><hr><ul><li>前言：<blockquote><p>栈(stack)是限定仅在表尾进行插入和删除操作的线性表</p><blockquote><p>队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表</p></blockquote></blockquote></li><li>我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIFO结构。<blockquote><p>首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底</p></blockquote></li><li>栈的插入操作，叫作进栈，也称压栈,入栈</li><li>栈的删除操作，叫作出栈<blockquote><p>最先进栈的元素，是不是就只能是最后出栈呢？</p><blockquote><p>举例:3个整型数字元素1，2，3依次进栈，会有哪些出栈次序呢？？？</p><blockquote><p>321，123，213，132，231</p><blockquote><p>没有312</p></blockquote></blockquote></blockquote></blockquote></li></ul><hr><h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><blockquote><p>对于栈来讲，理论上线性表的操作特性它都具备，由于它的特殊性，特别是插入和删除操作，我们改名为push和pop,英文直译的话是压和弹,我们一般叫进栈和出栈<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ADT</span> 栈(stack)</span><br><span class="line"><span class="selector-tag">Data</span></span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="selector-tag">Operation</span></span><br><span class="line">    <span class="selector-tag">InitStack</span>(*S):初始化操作，建立一个空栈<span class="selector-tag">S</span></span><br><span class="line">    <span class="selector-tag">DestroyStack</span>(*S):若栈存在，则销毁它</span><br><span class="line">    <span class="selector-tag">ClearStack</span>(*S):将栈清空</span><br><span class="line">    <span class="selector-tag">StackEmpty</span>(S):若栈为空，返回<span class="selector-tag">true</span>，否则返回<span class="selector-tag">false</span></span><br><span class="line">    <span class="selector-tag">GetTop</span>(S,*e):若栈存在且非空，用<span class="selector-tag">e</span>返回<span class="selector-tag">S</span>的栈顶元素</span><br><span class="line">    <span class="selector-tag">Push</span>(*S,e):若栈存在，插入新元素<span class="selector-tag">e</span>到栈<span class="selector-tag">S</span>中并成为栈顶元素</span><br><span class="line">    <span class="selector-tag">Pop</span>(*S,*e):删除栈<span class="selector-tag">S</span>中栈顶元素，并用<span class="selector-tag">e</span>返回其值</span><br><span class="line">    <span class="selector-tag">StackLength</span>(S):返回栈<span class="selector-tag">S</span>的元素个数</span><br><span class="line"><span class="selector-tag">endADT</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>同理：思考一下何时用S，<em>S，e，</em>e</p></blockquote><hr><h4 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h4><blockquote><p>若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。若栈存在一个元素时，top等于0，因此通常把空栈的判定条件定位top等于-1</p><blockquote><p>栈的结构定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;<span class="comment">/*SElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">/*用于栈顶指针*/</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><ul><li><p>进栈操作(push)</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line">Status <span class="keyword">Push</span>(SqStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top == MAXSIZE - <span class="number">1</span>) <span class="comment">/*栈满*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top++;<span class="comment">/*栈顶指针增加一*/</span></span><br><span class="line">    S-&gt;data[S-&gt;top]=e;<span class="comment">/*将新插入元素赋值给栈顶空闲*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出栈操作(pop)</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line">Status Pop(SqStack *S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(S-&gt;</span>top == -<span class="number">1</span>)</span><br><span class="line">        return ERROR;</span><br><span class="line">    *<span class="function"><span class="title">e</span> = S-&gt;</span><span class="function"><span class="title">data</span>[S-&gt;</span>top];<span class="comment">/*将要删除的栈顶元素赋值给e*/</span></span><br><span class="line">    <span class="function"><span class="title">s</span>-&gt;</span>top--;<span class="comment">/*栈顶指针减一*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>两者没有涉及到任何循环语句，由此时间复杂度均是O(1)</p></blockquote><hr><h4 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h4><blockquote><p>栈的顺序存储缺陷：必须事先确定数组存储空间大小</p><blockquote><p>不理解：栈1为空时，就是top1等于-1时，而当top2等于n时，即是栈2为空时；若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。</p><blockquote><p>两个栈相遇之时，就是两个指针相差1之时，即top1 + 1== top2为栈满<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">/*栈1栈顶指针*/</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">/*栈2栈顶指针*/</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><blockquote><p>对于两栈共享空间的push，除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line">Status Push(SqDoubleStack *S,SElemType e, <span class="keyword">int</span> stackNumber)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top1+<span class="number">1</span>==S-&gt;top2)<span class="comment">/*栈已满，不能再push新元素了*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber==<span class="number">1</span>)<span class="comment">/*栈1有元素进栈*/</span></span><br><span class="line">        S-&gt;data[++S-&gt;top1]=e;<span class="comment">/*若栈1则先top1+1后给数组元素赋值*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber==<span class="number">2</span>)<span class="comment">/*栈2有元素进栈*/</span></span><br><span class="line">        S-&gt;data[--S-&gt;top2]=e;<span class="comment">/*若栈2则先top2-1后给数组元素赋值*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line">Status <span class="keyword">Pop</span>(SqDoubleStack *S,SElemType *e,int stackNumber)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top1==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">        *e=S-&gt;data[S-&gt;top1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top2==MAXSIZE)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">        *e=S-&gt;data[S-&gt;top2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意前提条件:两个具有相同数据类型的栈</p></blockquote><hr><h4 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h4><blockquote><p>栈的链式存储结构简称为链栈</p><blockquote><p>有栈顶在头部，那对于链栈来说，是不需要头结点的</p><blockquote><p>对于链栈，基本不存在栈满的情况，除非内存已经没有可以使用的空间，对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*链栈的结构代码*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;<span class="comment">/*ptr指pointer,即指针*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><ul><li><p>栈的链表存储结构——进栈操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line">Status Push(LinkStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr s = (LinkStackPtr)malloc(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=S-&gt;top;<span class="comment">/*把当前的栈顶元素赋值给新结点的直接后继*/</span></span><br><span class="line">    S-&gt;top=s;<span class="comment">/*将新的结点s赋值给栈顶指针*/</span></span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>栈的链式存储结构——出栈操作</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR；*/</span></span><br><span class="line">Status Pop(LinkStack *S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">        return ERROR;</span><br><span class="line">    *<span class="function"><span class="title">e</span>=S-&gt;</span><span class="function"><span class="title">top</span>-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">    <span class="function"><span class="title">p</span>=S-&gt;</span>top;<span class="comment">/*将栈顶结点赋值给p*/</span></span><br><span class="line">    S-&gt;<span class="function"><span class="title">top</span>=S-&gt;</span><span class="function"><span class="title">top</span>-&gt;</span>next;<span class="comment">/*使得栈顶指针下移一位，指向后一结点*/</span></span><br><span class="line">    free(p);</span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1)</p></blockquote><hr><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><ul><li>递归之斐波那契数列(Fibonacci)<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*迭代法实现*/</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int a[<span class="number">40</span>];</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    printf(<span class="string">"%d"</span>,a[<span class="number">0</span>]);</span><br><span class="line">    printf(<span class="string">"%d"</span>,a[<span class="number">1</span>]);</span><br><span class="line">    for(i=<span class="number">2</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">        printf(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*斐波那契的递归函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fbi(i<span class="number">-1</span>)+Fbi(i<span class="number">-2</span>);<span class="comment">/*这里Fbi就是函数自己，它在调用自己*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,Fbi(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们把一个直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称作递归函数，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p><ul><li>栈的应用之四则运算表达式求值<br>逆波兰(Reverse Polish Notation,RPN):一种不需要括号的后缀表达法，这种后缀表示法，巧妙解决了程序实现四则运算的难题</li><li>例子：对于”9+(3-1)X3+10/2”如果用后缀表示法应该是”9 3 1 - 3 * + 10 2 / +”</li><li>计算规则:从左到右遍历表达式的每个数字和符号，遇到是数字就出栈，遇到是符号，就将处以栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最后获得最终结果</li><li>中缀表达式转后缀表达式规则:从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止</li></ul></blockquote><hr><h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><ul><li>定义：队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表<blockquote><p>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头.</p></blockquote></li></ul><hr><h4 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ADT</span> 队列(Queue)</span><br><span class="line"><span class="selector-tag">Data</span></span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="selector-tag">Operation</span></span><br><span class="line">    <span class="selector-tag">InitQueue</span>(*Q):初始化操作，建立一个空队列<span class="selector-tag">Q</span></span><br><span class="line">    <span class="selector-tag">DestroyQueue</span>(*Q):若队列<span class="selector-tag">Q</span>存在，则销毁它</span><br><span class="line">    <span class="selector-tag">ClearQueue</span>(*Q):将队列<span class="selector-tag">Q</span>清空</span><br><span class="line">    <span class="selector-tag">QueueEmpty</span>(Q):若队列<span class="selector-tag">Q</span>为空，返回<span class="selector-tag">true</span>，否则返回<span class="selector-tag">false</span></span><br><span class="line">    <span class="selector-tag">GetHead</span>(Q,*e):若队列<span class="selector-tag">Q</span>存在且非空，用<span class="selector-tag">e</span>返回队列<span class="selector-tag">Q</span>的队头元素</span><br><span class="line">    <span class="selector-tag">EnQueue</span>(*Q,e):若队列<span class="selector-tag">Q</span>存在，插入新元素<span class="selector-tag">e</span>到队列<span class="selector-tag">Q</span>中并成为队尾元素</span><br><span class="line">    <span class="selector-tag">DeQueue</span>(*Q,*e):删除队列<span class="selector-tag">Q</span>中队头元素，并用<span class="selector-tag">e</span>返回其值</span><br><span class="line">    <span class="selector-tag">QueueLength</span>(Q):返回队列<span class="selector-tag">Q</span>的元素个数</span><br><span class="line"><span class="selector-tag">endADT</span></span><br></pre></td></tr></table></figure><hr><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ul><li>队列顺序存储的不足<blockquote><p>假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，数组下标为0的一端即是队头</p><blockquote><p>所谓的入队列操作，就是在队尾插入一个元素，不需要移动任何元素，时间复杂度为O(1)</p><blockquote><p>与栈不同的是，队列元素的出列在队头，即下标为0的地方，队列所有元素都得前移，那时间复杂度为O(n)，之后利用指针改善</p><blockquote><p>这里的实现和线性表的顺序存储结构完全相同，不再详述</p></blockquote></blockquote></blockquote></blockquote></li></ul><blockquote><p>为了避免当只有一个元素时，队头跟队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个元素，这样当front等于rear时，此队列不是还剩一个元素，而是空队列</p><ul><li>定义：我们把队列的这种头尾相接的顺序存储结构称为循环队列。<br>我们刚才说，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？<blockquote><p>法一是设置一个标志变量flag,当front == rear，且flag=0时队列空，当flag=1时为队列满</p><blockquote><p>法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。</p></blockquote></blockquote></li><li>重点讨论法二:由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，也可能相差整整一圈。若队列的最大尺寸为QueueSize，那么队列满的条件是:(rear+1)%QueueSize == front</li><li>队列长度: 当rear &gt; front时，队列长度就是rear-front。但当rear &lt; front时，队列长度分为两段，一段是Queue-front，另一段是0+rear，加在一起就是rear-front+Queue，由此通用的计算队列长度公式为: (rear-front+Queue)%Queue<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;<span class="comment">/*QElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="comment">/*循环队列的顺序存储结构代码*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">/*头指针*/</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">/*尾指针，若队列不空，指向队列尾元素的下一个位置*/</span></span><br><span class="line">&#125;SqQueue</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>循环队列的初始化代码如下<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化一个空队列Q*/</span></span><br><span class="line">Status InitQueue(SqQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;front = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    Q-&gt;rear = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    return OK<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环队列求队列长度代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*返回Q的元素个数，也就是队列的当前长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环队列的入队列操作代码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若队列未满，则插入元素e为Q新的队尾元素*/</span></span><br><span class="line">Status EnQueue(SqQueue *Q,QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)<span class="comment">/*队列满的判断*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=e;<span class="comment">/*将元素e赋值给队尾*/</span></span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/*rear指针向后移一位置,若到最后则转到数组头部*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环队列的出队列操作代码<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若队列不空，则删除Q中队头元素，用e返回其值*/</span></span><br><span class="line">Status DeQueue(SqQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(Q-&gt;</span><span class="function"><span class="title">front</span> = Q-&gt;</span>rear)<span class="comment">/*队列空的判断*/</span></span><br><span class="line">        return ERROR;</span><br><span class="line">    *<span class="function"><span class="title">e</span>=Q-&gt;</span><span class="function"><span class="title">data</span>[Q-&gt;</span>front];</span><br><span class="line">    Q-&gt;<span class="function"><span class="title">front</span>=(Q-&gt;</span>front+<span class="number">1</span>)%MAXSIZE;<span class="comment">/*front指针向后移一个位置，若到最后则转到数组头部*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以发现，单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临数组可能溢出的问题，所以我们需要研究一下不需要担心队列长度的链式存储结构。</p></blockquote><hr><h4 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h4><ul><li>定义：队列的链式存储结构，其实就是线性表的单链表,只不过它只能尾进头出而已，我们把它简称为链队列。<blockquote><p>重点：为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点</p></blockquote></li><li><p>链队列的结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;<span class="comment">/*QElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> /*结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /*队列的链表结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front,rear;<span class="comment">/*队头，队尾指针*/</span></span><br><span class="line">&#125;LinkQueue</span><br></pre></td></tr></table></figure></li><li><p>队列的链式存储结构——入队操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/*插入元素e为Q的新的队尾元素*/</span></span><br><span class="line">Status EnQueue(LinkQueue *Q,QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="regexp">/*存储分配失败*/</span></span><br><span class="line">        <span class="keyword">exit</span>(OVERFLOW);</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;<span class="keyword">next</span>=NULL;</span><br><span class="line">    Q-&gt;rear-&gt;<span class="keyword">next</span>=s;<span class="regexp">/*把拥有元素e新结点s赋值给原队尾结点的后继，把当前的s设置为队尾结点，rear指向s*/</span></span><br><span class="line">    Q-&gt;rear=s;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>队列的链式存储结构——出队操作</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR*/</span></span><br><span class="line">Status DeQueue(LinkQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    <span class="function"><span class="title">if</span>(Q-&gt;</span><span class="function"><span class="title">front</span> == Q-&gt;</span>rear)</span><br><span class="line">        return ERROR;</span><br><span class="line">    <span class="function"><span class="title">p</span>=Q-&gt;</span><span class="function"><span class="title">front</span>-&gt;</span>next;<span class="comment">/*将欲删除的队头结点暂存给p*/</span></span><br><span class="line">    *<span class="function"><span class="title">e</span>=p-&gt;</span><span class="keyword">data</span>;<span class="comment">/*将欲删除的队头结点的值赋值给e*/</span></span><br><span class="line">    Q-&gt;<span class="function"><span class="title">front</span>-&gt;</span><span class="function"><span class="title">next</span>=p-&gt;</span><span class="function"><span class="title">next</span>;/*将原队头结点后继p-&gt;</span>next赋值给头结点后继*/</span><br><span class="line">    <span class="function"><span class="title">if</span>(Q-&gt;</span>rear==p)<span class="comment">/*若队头是队尾，则删除后将rear指向头结点*/</span></span><br><span class="line">        Q-&gt;<span class="function"><span class="title">rear</span>=Q-&gt;</span>front;</span><br><span class="line">    free(p);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>对于循环队列与链队列的比较，可以从两方面考虑</p><blockquote><p>时间上，它们的基本操作都是常数时间，即O(1)，不过循环队列是事先申请好空间，使用期间不释放，而链队列每次申请和释放结点会存在一些时间开销，如果入队出队频繁，还是有细微差异的</p><blockquote><p>空间上，循环队列必须有一个固定长度，所以就有存储元素个数和空间浪费的问题,空间上链队列更灵活</p><blockquote><p>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列长度，则用链队列.</p></blockquote></blockquote></blockquote></blockquote><hr><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>stack跟queue均可以用线性表的顺序存储结构来实现，但是都存在着顺序存储的一些弊端,由此它们各自有各自的技巧解决问题</p><ul><li>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化利用数组的空间。</li><li>对于队列来说，未来避免数组插入和删除时需要移动数据，则引入了循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)<br>它们也可以通过链式存储结构来实现，实现原则跟线性表差不多。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;br&gt;    数据结构与算法-栈与队列部分,栈与队列是数据结构重要思想之一，之后的抽象数据类型中诸多算法与方法会利用其特点&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;/DataStructure/2019/05/10/DataStructure-02/faded.jpg&quot; alt=&quot;fade&quot;&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="线性表" scheme="http://jhjhljh.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-线性表</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-01.html</id>
    <published>2019-05-10T11:21:38.000Z</published>
    <updated>2019-05-10T12:01:18.283Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"><br>    数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习<br></p><p></p><blockquote class="question">链表练习</blockquote><p><img src="/DataStructure/2019/05/10/DataStructure-01/fade.jpg" alt="fade"></p><a id="more"></a><hr><h4 id="线性表-List-：零个或多个数据元素的有限序列"><a href="#线性表-List-：零个或多个数据元素的有限序列" class="headerlink" title="线性表 (List)：零个或多个数据元素的有限序列"></a>线性表 (List)：零个或多个数据元素的有限序列</h4><ul><li>线性表元素的个数n（n≥0）定义为线性表的长度，当n=0时，称为空表。</li><li>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</li></ul><hr><h4 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data 线性表的数据对象集合为&#123;a1，a2，....an&#125;每个元素类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an之外，每一个元素有且只有一个直接后继元素。数据元素之间是一对一的关系</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line"><span class="function"><span class="title">InitList</span><span class="params">(*L)</span></span>:初始化操作，建立一个空的线性表L</span><br><span class="line"><span class="function"><span class="title">ListEmpty</span><span class="params">(L)</span></span>:判断线性表是否为空表，若线性表为空，返回True，否则返回false</span><br><span class="line"><span class="function"><span class="title">ClearList</span><span class="params">(*L)</span></span>:将线性表清空</span><br><span class="line"><span class="function"><span class="title">GetElem</span><span class="params">(L,I,*e)</span></span>:将线性表L中的第i个位置元素返回给e</span><br><span class="line"><span class="function"><span class="title">LocateElem</span><span class="params">(L,e)</span></span>:在线性表L中查找与给定值e相等的元素如果查找成功，返回该元素在表中序号，表示成功，否则返回<span class="number">0</span>，表示失败。</span><br><span class="line"><span class="function"><span class="title">ListInsert</span><span class="params">(*L,i,e)</span></span>:在线性表L的第i个位置插入新元素e</span><br><span class="line"><span class="function"><span class="title">ListDelete</span><span class="params">(*L,i,*e)</span></span>:删除线性表L中第i个位置元素，并用e返回其值</span><br><span class="line"><span class="function"><span class="title">ListLength</span><span class="params">(L)</span></span>:返回线性表L的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>实现两个线性表集合A跟B的并集操作！<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将所有的在线性表Lb但不在La的数据元素插入到La中*/</span></span><br><span class="line">void union(<span class="keyword">List</span> *<span class="keyword">La</span>,<span class="keyword">List</span> Lb)</span><br><span class="line">&#123;</span><br><span class="line">    int La_len,Lb_len,i;</span><br><span class="line">    ElemType <span class="keyword">e</span>; <span class="comment">/*声明与La和Lb相同的数据元素e*/</span></span><br><span class="line">    La_len = ListLength(<span class="keyword">La</span>); <span class="comment">/*求线性表的长度*/</span></span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span>(i = 1;i &lt;= Lb_len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(Lb,i,<span class="keyword">e</span>);<span class="comment">/*取Lb中第i个数据元素赋给e*/</span></span><br><span class="line">        <span class="keyword">if</span>(!LocateElem(<span class="keyword">La</span>,<span class="keyword">e</span>,equal)) <span class="comment">/*La中不存在和e相同数据元素*/</span></span><br><span class="line">        ListInsert(<span class="keyword">La</span>, ++La_len, <span class="keyword">e</span>); <span class="comment">/*插入*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h4><ul><li><p>定义:指的是用一段地址连续的存储单元以此存储线性表的数据元素。</p><blockquote><p>以下是线性表的顺序存储的结构代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/*存储空间的初始分配量 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType； <span class="comment">/*ElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]； <span class="comment">/*数组存储数据元素，最大值为MAXSIZE*/</span></span><br><span class="line">    <span class="keyword">int</span> length； <span class="comment">/*线性表当前长度*/</span></span><br><span class="line">&#125;SqList； <span class="comment">/*Sequence List*/</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>数组长度和线性表长度的区别：</p></li></ul><ol><li>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的</li><li>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是会变化的</li><li>在任意时刻，线性表的长度应该小于等于数组的长度。</li></ol><ul><li>地址计算方法</li></ul><ol><li>线性表的第i个元素是要存储在数组下标为i-1的位置，即线性表从1开始</li><li>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，由此分配的数组空间要大于等于当前线性表的长度</li><li>存储器中的每个存储单元都有自己的编号，这个编号称为地址</li></ol><blockquote><p> LOC(a(i+1))=LOC(ai)+c</p></blockquote><blockquote><p> LOC(ai)=LOC(a1)+(i-1)*c</p></blockquote><hr><h4 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h4><ul><li>GetElem:将线性表L中的第i个位置元素值返回，就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="comment">/*Status（状态，身份，地位）是函数的类型，其值是函数结果状态代码，如OK*/</span></span><br><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:用e返回L中第i个数据元素的值*/</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(L.length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">   <span class="keyword">return</span> ERROR;</span><br><span class="line">   *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>==疑问：为什么是*e？==</p><ul><li>ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e</li><li>插入算法的思路：</li></ul><ol><li>如果插入位置不合理，抛出异常</li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li><li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置</li><li>将要插入元素填入位置i处</li><li>表长加一<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在,1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/</span></span><br><span class="line">Status ListInsert(SqList *L,<span class="keyword">int</span> i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length==MAXSIZE) <span class="comment">/*顺序线性表已经满*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>) <span class="comment">/*当i不在范围内时*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length) <span class="comment">/*若插入数据位置不在表尾*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) <span class="comment">/*将要插入位置后数据元素向后移一位*/</span></span><br><span class="line">            L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=e;<span class="comment">/*将新元素插入*/</span></span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><ul><li>ListDelete</li><li>删除算法的思路:</li></ul><ol><li>如果删除位置不合理，抛出异常</li><li>取出删除元素</li><li>从删除元素位置开始遍历到最后一个元素，分别将它们都往前移动一个位置</li><li>表长减1<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete(SqList *L,<span class="type">int</span> i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;<span class="built_in">length</span> == <span class="number">0</span>) <span class="comment">/*线性表为空*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;<span class="built_in">length</span>) <span class="comment">/*删除位置不正确*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-<span class="built_in">length</span>) <span class="comment">/*如果删除不是最后位置*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;L-<span class="built_in">length</span>;k++) <span class="comment">/*将删除位置后继元素前移*/</span></span><br><span class="line">            L-data[k<span class="number">-1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;<span class="built_in">length</span>--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>-线性表顺序存储结构的优缺点</p><ol><li>优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间，可以快速地存取表中任一位置的元素</li><li>缺点：插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量，造成存储空间的“碎片”</li></ol><hr><h4 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h4><ul><li>为了表示每个数据元素a1与其直接后继元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置).我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)</li><li>n个结点(ai的存储映像)链结成一个链表，即为线性表(a1，a2，…an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做==单链表==</li><li>我们把链表中第一个结点的存储位置叫做头指针，规定最后一个结点指针为“空”(通常用NULL或^符号表)；有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，头结点的指针域存储指向第一个结点的指针。<h5 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h5></li><li>头指针</li></ul><ol><li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li><li>头指针具有标识作用，所以常用头指针冠以链表的名字</li><li>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</li></ol><ul><li>头结点</li></ul><ol><li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度)</li><li>有了头结点，对在第一元素结点前插入节点和删除第一结点，其操作与其它节点的操作就==统一==了</li><li>头结点不一定是链表必要元素</li></ol><ul><li>线性表链式存储结构代码描述</li></ul><ol><li>若线性表为空表，则头结点的指针域为“空”<blockquote><p>单链表中，我们在C语言可用结构指针来描述</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*线性表的单链表存储结构*/</span><br><span class="line">typedef struct <span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    ElemType</span> data;</span><br><span class="line">    struct <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125; <span class="keyword">Node</span><span class="title">;</span></span><br><span class="line"><span class="title">typedef</span> struct <span class="keyword">Node</span> <span class="title">*LinkList</span>;/*定义LinkList*/</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>这波操作事后==了解==一下,翻一下结构体</p><ol start="2"><li>结点由存放数据元素的数据域,存放后继结点地址的指针域组成</li></ol></blockquote><hr><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><ul><li>获得链表第i个数据的算法思路：</li></ul><ol><li>声明一个结点p指向链表第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，返回结点p的数据<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:用e返回L中的第i个数据元素的值*/</span></span><br><span class="line">Status GetElem(LinkList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p; <span class="comment">/*声明一结点p*/</span></span><br><span class="line">    <span class="function"><span class="title">p</span> = L-&gt;</span>next; <span class="comment">/*让p指向链表L的第一个结点*/</span></span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">/*j为计数器*/</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i) <span class="comment">/*p不为空或者计数器j还没有等于i时，循环继续*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next; <span class="comment">/*让p指向下一个结点*/</span></span><br><span class="line">        ++j；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( !p || j&gt;i )</span><br><span class="line">        return ERROR; <span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    *<span class="function"><span class="title">e</span> = p-&gt;</span><span class="keyword">data</span>; <span class="comment">/*取第i个元素的数据*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h4><blockquote><p>s-&gt;next=p-&gt;next; p-&gt;next=s<br>这两句的顺序==不可交换==，自己想</p><ul><li>单链表第i个数据插入结点的算法思路：</li></ul><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，在系列中生成一个空结点s</li><li>将数据元素e赋值给s-&gt;data</li><li>单链表的插入标准语句s-&gt;next=p-&gt;next; p-&gt;next=s</li><li>返回成功<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/</span></span><br><span class="line">Status ListInsert(LinkList *L,int i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p,s;</span><br><span class="line">    p = *L;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j &lt; i) <span class="comment">/*寻找第i个结点*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">        return ERROR; <span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    s =(LinkList)malloc(sizeof(Node));<span class="comment">/*生成新结点(C标准函数)*/</span></span><br><span class="line">    <span class="function"><span class="title">s</span>-&gt;</span><span class="keyword">data</span> = e;</span><br><span class="line">    <span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;<span class="comment">/*将p的后继结点赋值给s的后继*/</span></span><br><span class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next = s; <span class="comment">/*将s赋值给p的后继*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>单链表的删除实质：p-&gt;next=p-&gt;next-&gt;next</p><blockquote><p>用q来取代p-&gt;next,就是q=p-&gt;next;p-&gt;next=q-&gt;next;</p><ul><li>单链表第i个数据删除结点的算法思路:</li></ul><ol><li>声明一结点p指向链表的第一个节点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，将欲删除的结点p-&gt;next赋值给q</li><li>单链表的标准删除语句p-&gt;next=q-&gt;next</li><li>将q结点中的数据赋值给e，作为返回</li><li>释放q结点</li><li>返回成功<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果:删除L的第i个数据元素，并用e返回其值，L的长度减1*/</span></span><br><span class="line">Status ListDelete(LinkList *L,int i, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = *L;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">while</span>(p-&gt;</span>next &amp;&amp; j &lt; i) <span class="comment">/*遍历寻找第i个元素*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span>(!(p-&gt;</span>next) || j&gt;i)</span><br><span class="line">        return ERROR;<span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">    <span class="function"><span class="title">q</span> = p-&gt;</span>next;</span><br><span class="line">    p</span><br><span class="line">    -&gt;<span class="function"><span class="title">next</span> = q-&gt;</span>next;<span class="comment">/*将q的后继赋值给p的后继*/</span></span><br><span class="line">    *<span class="function"><span class="title">e</span>=q-&gt;</span><span class="keyword">data</span>;<span class="comment">/*将q结点中的数据给e*/</span></span><br><span class="line">    free(q);<span class="comment">/*让系统回收此结点，释放内存*/</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote></blockquote><hr><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><ul><li>创建单链表的过程就是一个动态生成链表的过程，即从”空表”的初始状态起，依次建立各元素结点，并逐个插入链表</li><li>单链表整表创建的算法思路:</li></ul><ol><li>声明一结点p和计数器变量i</li><li>初始化一空链表L</li><li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表</li><li>循环:<br>生成一新结点赋值给p；随机生成一数字赋值给p的数据域p-&gt;data;将p插入到头结点与前一新结点之间<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*随机生成n个元素的值，建立带表头结点的单链线性表L(头插法)*/</span></span><br><span class="line"><span class="literal">void</span> CreateListHead(LinkList *L,int n)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    int i;</span><br><span class="line">    srand(time(<span class="number">0</span>)); <span class="comment">/*初始化随机数种子*/</span></span><br><span class="line">    *L = ( LinkList)malloc(sizeof(Node));</span><br><span class="line">    <span class="function"><span class="params">(*L)</span>-&gt;</span>next = NULL; <span class="comment">/*先建立一个带头结点的单链表*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (LinkList)malloc(sizeof(Node));<span class="comment">/*生成新结点*/</span></span><br><span class="line">        p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>; <span class="comment">/*随机生成100以内的数字*/</span></span><br><span class="line">        p-&gt;<span class="function"><span class="title">next</span> = <span class="params">(*L)</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="params">(*L)</span>-&gt;</span>next = p; <span class="comment">/*插入到表头*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>求问L,<em>L,(</em>L)的区别？ 如果要改变变量的值就用指针，不改变就用变量本身<br>LinkList等同于Node <em>，所以L要加 </em></p><blockquote><p>函数rand()跟srand()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*随机生成n个元素的值，建立带表头结点的单链线性表L(尾插法)*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList *L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p,r;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    srand(time(<span class="number">0</span>));<span class="comment">/*初始化随机数种子*/</span></span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))；<span class="comment">/*为整个线性表*/</span></span><br><span class="line">    r=*L;<span class="comment">/*r为指向尾部的结点*/</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">/*生成新结点*/</span></span><br><span class="line">        p-&gt;data=rand()%<span class="number">100</span>+<span class="number">1</span>;<span class="comment">/*随机生成100以内的数字*/</span></span><br><span class="line">        r-&gt;next = p;<span class="comment">/*将表尾终端结点的指针指向新结点*/</span></span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;<span class="comment">/*表示当前链表结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><hr><h4 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h4><ul><li>单链表整表删除的算法思路如下:</li></ul><ol><li>声明一结点p和q；</li><li>将第一个结点赋值给p</li><li>循环：将下一结点赋值给q；释放p；将q赋值给p。<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件：顺序线性表L已存在，操作结果：将L重置为空表*/</span></span><br><span class="line">Status ClearList(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    <span class="function"><span class="title">p</span>=<span class="params">(*L)</span>-&gt;</span>next; <span class="comment">/*p指向第一个结点*/</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        free(p);</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="params">(*L)</span>-&gt;</span>next=NULL;<span class="comment">/*头结点指针域为空*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><blockquote><p>简单地对单链表结构和顺序存储结构做对比：</p><ul><li>存储分配方式</li></ul><ol><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li></ol><ul><li>时间性能</li></ul><ol><li>查找：①顺序存储结构O(1)；②单链表O(n)</li><li>插入与删除：①顺序存储结构需要平均移动表长一半的元素，时间为O(n)； ②单链表在线出某位置的指针后，插入和删除时间仅为O(1)</li></ol><ul><li>空间性能</li></ul><ol><li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制<br>通过上面对比，我们可以得出一些经验性的结论</li><li>若线性表需要频繁查找，很少进行插入或删除时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。比如游戏开发，对于用户注册的个人信息，出来注册时插入数据外，绝大多数情况都是读取，所以应该考虑顺序存储结构。而游戏装备道具就用单链表结构。</li><li>当线性表元素个数变化很大或者不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，则用顺序存储结构效率会高很多。</li></ol></blockquote><hr><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><ul><li>背景:数组代替指针描述单链表，首先让数组的元素由两个数据域组成，data和cur，也就是说，数组的每一个下标都对应一个data和一个cur.数据域data，用来存放数据元素，也就是通常我们要处理的数据，而游标cur相当于单链表的next指针，用于存放该元素后继在数组中的下标。我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<blockquote><p>为了方便插入数据，通常会把数组建立得大一些，以便有一些空闲空间插入不至于溢出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的静态链表存储结构*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">/*假设链表的最大长度是1000*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur; <span class="comment">/*游标(cursor),为0</span></span><br><span class="line"><span class="comment">    时表示无指向*/</span></span><br><span class="line">&#125;Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据，把未被使用的数组元素称为备用链表。</p><blockquote><p>数组第一个元素，即下标为0的元素的cur存放备用链表的第一个结点的下标;而数组的最后一个元素的cur则存放第一个有数值的元素的下表，相当于单链表中的头结点，当整个链表为空时，则为0<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*将一维数组<span class="literal">space</span>中各分量链成一备用链表*/</span><br><span class="line">/*<span class="literal">space</span>[<span class="number">0</span>].cur为头指针，<span class="string">"0"</span>表示空指针*/</span><br><span class="line">Status InitList(StaticLinkList <span class="literal">space</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXSIZE<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="literal">space</span>[i].cur = i+<span class="number">1</span>;</span><br><span class="line">    <span class="literal">space</span>[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>/*目前静态链表为空，最后一个元素的cur为<span class="number">0</span>*/</span><br><span class="line"><span class="built_in">    return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><ul><li>静态链表的插入操作<blockquote><p>静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放</p><blockquote><p>动态链表，结点的申请和释放分别借用malloc()和free()两个函数来实现，而静态链表操作的是数组，我们需要自己实现这两个函数</p><blockquote><p>为了辨明数组中哪些分量未被使用，解决方法是将所有未被使用过的及被删除的分量用游标链成一个备用的链表，每当插入时，可以从备用链表上取得第一个结点作为待插入的新结点</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若备用空间链表为空，则返回分配的结点下标，否则为0*/</span></span><br><span class="line">int Malloc_SLL(StaticLinkList <span class="built_in">space</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="built_in">space</span>[<span class="number">0</span>].cur;<span class="comment">/*当前数组第一个元素的cur存的值就是要返回的第一个备用空闲的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">space</span>[<span class="number">0</span>].cur)</span><br><span class="line">        <span class="built_in">space</span>[<span class="number">0</span>].cur = <span class="built_in">space</span>[i].cur<span class="comment">/*由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用*/</span></span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote></li></ul><blockquote><p>需要找到接替者才能继续分配新的空闲分量</p><blockquote><p>现在我们如果需要在乙丁之间插入丙，我们只需要让丙在7号备用位待着，把乙的cur改为7，再让丙的cur改为3即可<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="built_in">ListInsert</span>(StaticLinkList L,int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int j,k,l;</span><br><span class="line">    k = MAX_SIZE - <span class="number">1</span>;<span class="comment">/*注意k首先是最后一个元素的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; <span class="built_in">ListLength</span>(L) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERROR</span>;</span><br><span class="line">    j = <span class="built_in">Malloc_SSL</span>(L);<span class="comment">/*获得空闲分量的下标*/</span></span><br><span class="line">    <span class="keyword">if</span>(j)</span><br><span class="line">    &#123;</span><br><span class="line">        L[j].data = e; <span class="comment">/*将数据赋值给此分量的data*/</span></span><br><span class="line">        <span class="keyword">for</span>(l = <span class="number">1</span>;l &lt;= i<span class="number">-1</span>;l++) <span class="comment">/*找到第i个元素之前的位置*/</span></span><br><span class="line">        k = L[k].cur;</span><br><span class="line">        L[j].cur = L[k].cur;<span class="comment">/*把第i个元素之前的cur赋值给新元素的cur*/</span></span><br><span class="line">        L[k].cur = j;<span class="comment">/*把新元素的下标赋值给第i个元素之前元素的cur*/</span></span><br><span class="line">        <span class="keyword">return</span> OK；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ERROR</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><ul><li>静态链表的删除操作<blockquote><p>和前面一样，删除元素时，原来是需要释放结点的函数free().现在我们也得自己实现它:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除在L中第i个数据元素e*/</span></span><br><span class="line">Status ListDelete(StaticLinkList L,int i)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">j,k;</span></span><br><span class="line"><span class="keyword"> </span>   if(i &lt; <span class="number">1</span> <span class="title">||</span> i &gt; LIstLength(L))</span><br><span class="line">        return ERROR<span class="comment">;</span></span><br><span class="line">    k = MAX_SIZE - <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">j </span>= <span class="number">1</span><span class="comment">;j &lt;= i-1;j++)</span></span><br><span class="line">        k = L[k].cur<span class="comment">;</span></span><br><span class="line">    <span class="keyword">j </span>= L[k].cur<span class="comment">;</span></span><br><span class="line">    L[k].cur = L[<span class="keyword">j].cur;</span></span><br><span class="line"><span class="keyword"> </span>   Free_SSL(L,<span class="keyword">j);</span></span><br><span class="line"><span class="keyword"> </span>   return OK<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>而关于Free_SSL(L,j)<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将下列为k的空闲结点回收到备用链表*/</span></span><br><span class="line">void Free_SSL(StaticLinkList <span class="built_in">space</span>,int k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">space</span>[k].cur = <span class="built_in">space</span>[<span class="number">0</span>].cur;<span class="comment">/*把第一个元素cur赋值给要删除的分量cur*/</span></span><br><span class="line">    <span class="built_in">space</span>[<span class="number">0</span>].cur = k;<span class="comment">/*把要删除的分量下标赋值给第一个元素的cur*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当然，静态链表也有相应的其他操作的相关实现，比如代码中的ListLength<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件：静态链表L已存在，操作结果：返回L中的数据个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        i = L[i].cur;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>回顾：sizeof()和strlen</p></blockquote><hr><h4 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h4><ul><li>优点</li></ul><ol><li>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点</li></ol><ul><li>缺点</li></ul><ol><li>没有解决连续存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性<blockquote><p>总的来说，静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法。</p></blockquote></li></ol><hr><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ul><li>定义:将单链表中终端结点的指针端由空指针改为指向头结点就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)</li><li>循环链表和单链表的主要差异在判断条件上：原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束<blockquote><p>在单链表中，我们有了头结点，可以用O(1)的时间访问第一个结点，但对于要访问到最后一个结点，却需要O(n)时间，因为我们需要将单链表全部扫描一遍</p><blockquote><p>如用O(1)的时间由链表指针访问到最后一个结点,则需改造一下循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便</p><blockquote><p>终端结点用尾指针rear指示，则查找终端结点是O(1),而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂也为O(1)</p></blockquote></blockquote></blockquote></li><li>举个程序的例子，要将两个循环链表合成一个表时，有了尾指针就非常简单<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span> = rearA-&gt;</span>next;<span class="comment">/*保存A表的头结点*/</span></span><br><span class="line"><span class="function"><span class="title">rearA</span>-&gt;</span><span class="function"><span class="title">next</span>=rearB-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>;/*将本是指向B表的第一个结点(不是头结点)赋值给rearA-&gt;</span>next*/</span><br><span class="line"><span class="function"><span class="title">rearB</span>-&gt;</span><span class="function"><span class="title">next</span>=p;/*将原A表的头结点赋值给rearB-&gt;</span>next*/</span><br><span class="line">free(p);<span class="comment">/*释放p*/</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul><li>定义：双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的双向链表存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span><span class="comment">/*直接前驱指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span><span class="comment">/*直接后继指针*/</span></span><br><span class="line">&#125;DulNode,*DuLinkList;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>既然单链表有循环链表，那么双向链表也可以是循环链表</p><blockquote><p>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</p><ul><li>双向链表的插入<br>将结点s插入到结点p和p-&gt;next之间</li></ul></blockquote><blockquote><p>顺序很重要，不能写反<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span>-&gt;</span>prior = p;<span class="comment">/*将p赋值给s的前驱*/</span></span><br><span class="line"><span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span><span class="function"><span class="title">next</span>;/*把p-&gt;</span>next赋值给s的后继*/</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">prior</span> = s;/*把s赋值给p-&gt;</span>next的前驱*/</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>next = s;<span class="comment">/*把s赋值给p的后继*/</span></span><br></pre></td></tr></table></figure></p></blockquote></blockquote><blockquote><p>顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继</p><ul><li>双向链表的删除<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">prior</span>-&gt;</span><span class="function"><span class="title">next</span>=p-&gt;</span>next;</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">prior</span>=p-&gt;</span>prior;</span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>多结合图形记忆</p></blockquote><hr><h4 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h4><ul><li>线性表</li></ul><ol><li>顺序存储结构</li><li>链式存储结构</li></ol><ul><li>单链表</li><li>静态链表</li><li>循环链表</li><li>双向链表</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;br&gt;    数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote class=&quot;question&quot;&gt;链表练习&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/DataStructure/2019/05/10/DataStructure-01/fade.jpg&quot; alt=&quot;fade&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="线性表" scheme="http://jhjhljh.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构概论</title>
    <link href="http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-introduction.html"/>
    <id>http://jhjhljh.github.io/DataStructure/2019/05/10/DataStructure-introduction.html</id>
    <published>2019-05-10T06:31:56.000Z</published>
    <updated>2019-05-10T11:45:52.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"><br>    数据结构与算法绪论,打算将当初的数据结构笔记搬上博客，主要参照《大话数据结构》，此处强烈推荐<br></p><br><img src="/DataStructure/2019/05/10/DataStructure-introduction/fade.jpg" alt="fade"><p></p><a id="more"></a><hr><h4 id="数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。"><a href="#数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。" class="headerlink" title="数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。"></a>数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。</h4><ul><li>逻辑结构：数据对象中数据元素之间的相互关系<ol><li>集合结构（平等）</li><li>线性结构（一对一）</li><li>树形结构（一对多）</li><li>图形结构（多对多）</li></ol></li><li>物理结构：数据的逻辑结构在计算机中的存储方式</li></ul><ol><li>顺序结构</li><li>链式结构</li></ol><hr><h4 id="算法（Algorithm）：对数据结构的运用"><a href="#算法（Algorithm）：对数据结构的运用" class="headerlink" title="算法（Algorithm）：对数据结构的运用"></a>算法（Algorithm）：对数据结构的运用</h4><ul><li>算法的特性</li></ul><ol><li>输入：算法具有零个或多个输入</li><li>输出：算法至少有一个或多个输出</li><li>有穷性：自动结束不会死循环</li><li>确定性：不会出现二义性</li><li>可行性：每一步都是可行的</li></ol><ul><li>算法设计要求</li></ul><ol><li>正确性<blockquote><ol><li>算法程序没有语法错误</li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果</li><li>算法程序对于非法的输入数据能够算得出满足规格说明的结果</li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果</li></ol></blockquote></li><li>可读性</li><li>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或者莫名其妙的结果</li><li>时间效率搞和存储量低</li></ol><hr><h4 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h4><ol><li>事后统计方法</li><li>事前分析估算方法</li></ol><hr><h4 id="函数的渐近增长与时间复杂度"><a href="#函数的渐近增长与时间复杂度" class="headerlink" title="函数的渐近增长与时间复杂度"></a>函数的渐近增长与时间复杂度</h4><ul><li>大O阶方法</li></ul><ol><li>用常数1取代运行时间中所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数，得到的结果就是大O阶。</li></ol><ul><li>常数阶<blockquote><p>无论n为多少，这个常数为多少，我们都记作O（1），而不能是O（3）、O（12）等任何数字，这是初学者常常犯的错。可以理解为常数项为最高项，然后去除系数，则为1</p></blockquote></li><li><p>线性阶</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">/*时间复杂度为O（1）的程序步骤序列*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对数阶</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">count</span> &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">count</span> = <span class="keyword">count</span> * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/*时间复杂度为O（1）的程序步骤序列*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>由2^x^=n得x=log(2)n，所以这个循环的时间复杂度为O（logn）</p><ul><li>平方阶<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i,<span class="keyword">j;</span></span><br><span class="line"><span class="keyword">for(i </span>= <span class="number">0</span><span class="comment">; i &lt; n;i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    for(<span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j &lt; n;j++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 时间复杂度为O（1）的程序步骤序列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = i;j &lt; n;j++) <span class="comment">/*注意j = i而不是0*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*时间复杂度为O（1）的程序步骤序列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总执行次数为：n+(n-1)+(n-2)+…+1= n^2^/2+n/2,因此这段代码的时间负责度为O(n^2^)</p><ul><li>最坏情况与平均情况</li></ul><ol><li>通常，除非特殊指定，我们提到的运行时间都是最坏情况的运行时间</li><li>平均运行时间是所有情况中最有意义的，因为它是期望的云习惯时间，但是平均运行时间和难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。</li><li>一般在没有特殊说明的情况下，都是指最坏时间复杂度</li></ol></blockquote><hr><h4 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;br&gt;    数据结构与算法绪论,打算将当初的数据结构笔记搬上博客，主要参照《大话数据结构》，此处强烈推荐&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;/DataStructure/2019/05/10/DataStructure-introduction/fade.jpg&quot; alt=&quot;fade&quot;&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://jhjhljh.github.io/categories/DataStructure/"/>
    
    
      <category term="introduction" scheme="http://jhjhljh.github.io/tags/introduction/"/>
    
  </entry>
  
  <entry>
    <title>article</title>
    <link href="http://jhjhljh.github.io/%E7%BB%83%E4%B9%A0/2019/05/08/article.html"/>
    <id>http://jhjhljh.github.io/练习/2019/05/08/article.html</id>
    <published>2019-05-08T08:31:34.000Z</published>
    <updated>2019-05-10T06:18:01.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="question">内容</blockquote><blockquote class="blockquote-center"><br>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！<br></blockquote><blockquote class="blockquote-center"><p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="练习" scheme="http://jhjhljh.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="jQuery" scheme="http://jhjhljh.github.io/tags/jQuery/"/>
    
      <category term="表格" scheme="http://jhjhljh.github.io/tags/%E8%A1%A8%E6%A0%BC/"/>
    
      <category term="表单验证" scheme="http://jhjhljh.github.io/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jhjhljh.github.io/uncategorized/2019/05/08/hello-world.html"/>
    <id>http://jhjhljh.github.io/uncategorized/2019/05/08/hello-world.html</id>
    <published>2019-05-08T08:02:01.327Z</published>
    <updated>2019-05-08T08:02:01.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>
