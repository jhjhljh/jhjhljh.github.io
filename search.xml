<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[赛马问题]]></title>
    <url>%2F2019-11-05%2Fhorse-thief.html</url>
    <content type="text"><![CDATA[腾讯面试题：赛马🐴问题 原来还有另一种赛马算法题，这里不提及，所谓的“田忌赛马”算法题，大概也是带记忆的广搜或者深搜吧，估摸着~ 64马8道选top4有64匹赛马，有8个跑道可以利用，赛马的速度是恒定的，不计时但记录每次比赛的名词，请问赛几次可以取得速度排名前四的赛马？ 具体做法： 首先把64匹马随机分成8组，分别进行8次比赛，记录成绩。 再将每组第一名集合起来进行一次比赛。这是第九次比赛。 留下第九次比赛前四名的马所在的组。因为对于后四名的马所在的组来说根据判断原则没有一匹有机会进入前四的。 剩下的四组按照每组第一名在第九次比赛的成绩排序，这样按照判断原则，只剩下10匹马（如下）可能进入前4，而第一组的第一名肯定是跑最快的马。 第一组： 1 2 3 4第二组： 1 2 3第三组： 1 2第四组： 1 我的理解： 找top3：2+2+1 找top4：3+3+2+1 找top5：4+4+3+2+1 找top6：5+5+4+3+2+1 或许可以用动态规划来解决赛马问题，但是代码的时间复杂度为平方阶，所以先不编写 这样问题就变成9匹马找出前三快的。情况好的话跑一次可以得到，不行的话两次。 所以结果是10或者11 30马5道容1马选top3问题：已知有30匹马，5个跑道，每个跑道只能容一匹马，没有计时器，至少需要比赛多少次，可以找出最快的前三匹马？ 此题跟上面唯一不同的时候，这里要求每个赛道只能容得下一匹马，那也就是说，30= 5 x 6中，我们需要6次的赛马，能得到6只相对快的马，其实就是把上题的解法逻辑纵向化，接下来是6只马在5赛道上决绝出top3，这里需要两次，因为6 &gt; 5，然后同理根据规律：找top3：2+2+1，只是在5匹马里面找出前两快的，1次即可 最终答案即使：6+2+1=9次，因此需要看清楚题意，即跑道一次性所能容得下的马量 25马5道选各个top马至少需要的比赛次数有25匹马，有一个5个赛道的马场，每场比赛可以决出5匹马的排名，假设每匹马发挥稳定，且不会出现名次相同的情况。问：如果要知道25匹马中跑得最快的马，需要几场比赛？如果需要知道跑得第二快的马，需要几场比赛？第三快的呢？ 转化成top1，top2，top3问题即可 口算易得： top1：6 top2：6+1 // 在1+1匹马里面选出最快的一匹 top3：6+1 // 在2+2+1匹马里面选出最快的两匹 所以答案是6、7、7]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS连接以及中间人攻击劫持]]></title>
    <url>%2F2019-11-04%2Fman-in-the-middle-attack.html</url>
    <content type="text"><![CDATA[中间人攻击👻（Man-in-the-middle attack） 连着上文介绍的加密算法等概念，现在补充一下中间人攻击 什么是中间人攻击简单来说攻击者就是一个介入通信的传话员，攻击者知道通信双方的所有通信内容，而且可以任意增加、删除、修改双方的通信内容，而双方对此并不知情。 而中间人攻击不仅仅局限于针对 HTTPS，对于开放性的连接，中间人攻击非常容易。比如在一个未加密的 Wi-Fi 网络中，一个攻击者可以很容易地将自己插入双方的通信之中以截取或者修改通信的内容。 一个通俗的例子： 假设 Tom 想和 Jerry 交换一些秘密信息，然而 Tom 又不想跑到 Jerry 家里，于是 Tom 叫来了邮递员，给了邮递员一封信。信的内容是希望 Jerry 给 Tom 一个盒子（这个盒子有两把钥匙）和其中一把钥匙（另一把在 Jerry 手里）。 邮递员在拿到 Tom 给的信件以后，把 Tom 的信拆开看了一遍，了解到 Tom 希望 Jerry 给 Tom 一个有锁的盒子，又用另一个信封装了回去，并交给了 Jerry。 Jerry 在收到 Tom 的信（实际已经被邮递员拆阅过了）之后，给了邮递员一个有锁的盒子和其中一把钥匙。 邮递员想知道他们的通信内容，于是他把 Jerry 给 Tom 的盒子换成了他自己的盒子，并附上了自己盒子中的一把钥匙，并在之后将自己的盒子交给了 Tom。 Tom 在收到盒子之后，以为这个盒子是 Jerry 给他的，于是就把秘密的信件放进了盒子里，并把钥匙留下了，之后又交给了邮递员。 邮递员在拿到盒子之后，用自己的另一把钥匙打开盒子，看了里面的信件。之后将信件调换之后放进了 Jerry 给的盒子，交给了 Jerry。 Jerry 在拿到邮递员给他的盒子之后，并不知道这个盒子里的信件其实已经被邮递员调换过了，所以 Jerry 认为盒子里的信件是来自 Tom 且未被修改过的。之后 Jerry 把回信放进了盒子里，又交给了邮递员。 邮递员再次调换盒子里的信件，交给了 Tom。 这就是一个典型中间人攻击的过程。在 HTTPS 中，Tom 就是客户端，Jerry 是服务端，而邮递员就是客户端和服务端之间的任何实体（包括代理服务器、路由器、反向代理服务器等等），两把钥匙分别是公钥和私钥。通信双方并不知道（且通常很难发觉）自己其实在和中间人通信而非直接和对方通信。在通信过程中，Tom 和 Jerry 并没有验证对方的身份，这就导致了邮递员可以任意查看、修改或者丢弃双方的通信内容。 HTTPS连接过程及中间人攻击原理https协议就是http+ssl协议，如下图所示为其连接过程： 1.https请求客户端向服务端发送https请求；2.生成公钥和私钥服务端收到请求之后，生成公钥和私钥。公钥相当于是锁，私钥相当于是钥匙，只有私钥才能够打开公钥锁住的内容；3.返回公钥服务端将公钥（证书）返回给客户端，公钥里面包含有很多信息，比如证书的颁发机构、过期时间等等；4.客户端验证公钥客户端收到公钥之后，首先会验证其是否有效，如颁发机构或者过期时间等，如果发现有问题就会抛出异常，提示证书存在问题。如果没有问题，那么就生成一个随机值，作为客户端的密钥，然后用服务端的公钥加密；5.发送客户端密钥客户端用服务端的公钥加密密钥，然后发送给服务端。6.服务端收取密钥，对称加密内容服务端收到经过加密的密钥，然后用私钥将其解密，得到客户端的密钥，然后服务端把要传输的内容和客户端的密钥进行对称加密，这样除非知道密钥，否则无法知道传输的内容。7.加密传输服务端将经过加密的内容传输给客户端。8.获取加密内容，解密客户端获取加密内容后，用之前生成的密钥对其进行解密，获取到内容。 中间人劫持攻击https也不是绝对安全的，如下图所示为中间人劫持攻击，中间人可以获取到客户端与服务器之间所有的通信内容。 中间人截取客户端发送给服务器的请求，然后伪装成客户端与服务器进行通信；将服务器返回给客户端的内容发送给客户端，伪装成服务器与客户端进行通信。通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。 如何防御中间人攻击中间人攻击是一个（缺乏）相互认证的攻击；由于客户端与服务器之间在SSL握手的过程中缺乏相互认证而造成的漏洞 防御中间人攻击的方案通常基于一下几种技术 公钥基础建设PKI 使用PKI相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例子中都是只验证服务器，这样就造成了SSL握手环节的漏洞，而如果使用相互认证的的话，基本可以 更强力的相互认证 延迟测试 使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费20秒来计算，并且整个通讯花费了60秒计算才到达对方，这就能表明存在第三方中间人。 使用其他形式的密钥交换形式 前方高能从邮递员的例子看起来，似乎任何在通信双方的实体都可以实施中间人攻击，那么 HTTPS 是如何防止中间人攻击的呢？要防止被中间人攻击，那么就要确保通信中的信息来自他声称的那个人，且没有被修改过。在现实中，有多种方式可以确定某个实体的身份，比如个人的签名 / 私章、组织的公章、甚至古时的信物。大部分情况下，只需要在信件最后盖上签上自己的名字或者盖上组织的公章，那么接收者就可以确定这封信件就来自于他所声称的那个人 / 组织。在二进制的世界中，可以使用数字签名来确保某段消息 / 某份文件确实是由他所声称的那个实体所发出来的。 在之前的文章中，我们介绍过非对称加密，其中公钥是公开的，而私钥只有拥有者知道。用私钥对某个文件 / 某段消息的散列值进行签名就像一个人亲手在信件最后签上了自己的名字一样，证明这份文件 / 这段消息确实来自私钥的拥有者（因为公钥是公开的，私钥只有拥有者知道，所以如果能用其公开的公钥解开数字签名，那就证明这条消息确实来自于他私钥的拥有者），这就可以确保消息是来自他所声称的那个实体。这样，在通信中，双方每次在写完消息之后，计算消息的散列值，并用自己的私钥加密生成数字签名，附在信件后面，接收者在收到消息和数字签名之后，先计算散列值，再使用对方的公钥解密数字签名中的散列值，进行对比，如果一致，就可以确保该消息确实是来自于对方，并且没有被篡改过。 不过有个问题，如果中间人在会话建立阶段把双方交换的真实公钥替换成自己的公钥了，那么中间人还是可以篡改消息的内容而双方并不知情。为了解决这个问题，需要找一个通信双方都信任的第三方来为双方确认身份。这就像大家都相信公证处，公证处拿着自己的公章为每一封信件都盖上了自己的章，证明这封信确实是由本人发出的，这样就算中间人可以替换掉通信双方消息的签名，也无法替换掉公证处的公章。这个公章，在二进制的世界里，就是数字证书，公证处就是 CA（数字证书认证机构）。 数字证书就是申请人将一些必要信息（包括公钥、姓名、电子邮件、有效期）等提供给 CA，CA 在通过各种手段确认申请人确实是他所声称的人之后，用自己的私钥对申请人所提供信息计算散列值进行加密，形成数字签名，附在证书最后，再将数字证书颁发给申请人，申请人就可以使用 CA 的证书向别人证明他自己的身份了。对方收到数字证书之后，只需要用 CA 的公钥解密证书最后的签名得到加密之前的散列值，再计算数字证书中信息的散列值，将两者进行对比，只要散列值一致，就证明这张数字证书是有效且未被篡改过的。 通信过程的安全性自下而上就是这样保证的： 双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由公钥的正确性来保证。 公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由数字证书的正确性来保证了。 数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。那么安全性就是由上级 CA 证书的正确性保证的了。 但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统根证书的私钥不被泄露或者其公钥不被篡改来保证的了。 根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中内置签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了。 至此，整个信任链就建立起来了，只需要有一台设备上安装了可以信任的根证书，就可以用来分发更多安全的操作系统了。之后的所有信任链都是安全的了。 SSLTrip 及 HSTSHTTP 协议最初的时候是明文的，因为安全问题所以现在很多网站都在逐渐过渡到 HTTPS，然而对于大部分使用者来说，他们并不知道 HTTP 和 HTTPS 之间的区别，在浏览器输入地址的时候都是直接输入 www.example.com 而非 https://www.example.com，在大部分情况下，如果一个网站启用了 HTTPS，服务器会将这个请求使用 301 或者 302 状态码以及一个 Location 头部将请求从 80 端口重定向至使用 HTTPS 的 443 端口。但是，如果中间人劫持了使用者的网络请求，那么中间人可以阻止客户端与服务器建立 HTTPS 连接，而是一直使用不安全的 HTTP 连接，而中间人则和服务器建立正常的 HTTPS 连接，让客户端以为自己正在和真实服务器通信。这种攻击手法称作 SSLTrip。 为了解决这个问题，IETF（互联网工程任务小组）引入了一个策略，叫做 HSTS (HTTP Strict Transport Security, HTTP 严格传输安全)。HSTS 的作用是强制客户端与服务端建立安全的 HTTPS 连接，而非不安全的 HTTP 连接。如果一个站点启用了 HSTS 策略，那么客户端在第一次与该站点建立连接之后，在未来的一段时间内（由一个 HTTP 头部控制，这个头部为：Strict-Transport-Security），客户端与该站点的所有连接都会直接使用 HTTPS，即使客户端访问的是 HTTP，也会直接在客户端重定向到 HTTPS 连接。 假设 https://example.com 的响应头部含有 Strict-Transport-Security: max-age=31536000; includeSubDomains，这意味着： 在未来的 1 年时间里（即 31536000 秒中），只要浏览器向 example.com 或者其子域名发送请求，必须采用 HTTPS 来发起连接。即使用户在地址栏里写的是 http://example.com，那也直接重写为 https://example.com 并直接发起 HTTPS 连接。 在接下去的一年中，如果服务器提供的 HTTPS 证书无效（不论是域名对不上还是自签名还是不在有效期内），用户都无法访问该站点。 如果站点没有启用 HSTS，用户可以忽略证书无效的警告，继续建立连接，而如果站点启用了 HSTS，那么用户即使想冒风险，浏览器也不会继续访问。 HSTS 可以很大程度上防止 SSLTrip 攻击，不过这样还是有个问题，那就是要启用 HSTS，浏览器至少要和服务器建立一次 HTTPS 连接，如果中间人一直阻止浏览器与服务器建立 HTTPS 连接，那么 HSTS 就失效了。解决这个问题有个办法，那就是将 HSTS 站点列表内置到浏览器中，这样只要浏览器离线判断该站点启用了 HSTS，就会跳过原先的 HTTP 重定向，直接发起 HTTPS 请求。]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>攻击</tag>
        <tag>HTTPS</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于密码学里面那些绕来绕去的概念]]></title>
    <url>%2F2019-11-04%2FCryptography.html</url>
    <content type="text"><![CDATA[非对称（私钥）算法、对称（公钥）算法、RSA算法、数字签名、数字证书及https协议、TLS/SSL 密码学真香真好玩 公钥算法与私钥算法私钥算法私钥加密算法，又称 对称加密算法，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《DES加密算法》、《AES加密算法》。 常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 公钥算法 RSA算法一直是最广为使用的非对称加密算法 公钥加密算法，也就是 非对称加密算法，这种算法加密和解密的密码不一样，一个是公钥，另一个是私钥： 公钥和私钥成对出现 公开的密钥叫公钥，只有自己知道的叫私钥 用公钥加密的数据只有对应的私钥可以解密 用私钥加密的数据只有对应的公钥可以解密 如果可以用公钥解密，则必然是对应的私钥加的密 如果可以用私钥解密，则必然是对应的公钥加的密 公钥和私钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥。 实现数据的安全传输要实现数据的安全传输，当然就要对数据进行加密了。 如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用非对称算法，过程如下： 首先 接收方 生成一对密钥，即私钥和公钥； 然后，接收方 将公钥发送给 发送方； 发送方用收到的公钥对数据加密，再发送给接收方； 接收方收到数据后，使用自己的私钥解密。 由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。 划重点：上图即是RSA算法 RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是1977年由罗纳德·李维斯特、阿迪·萨莫尔和伦纳德·阿德曼一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 图中关于cer证书跟pfx证书以后再说 对信息进行数字签名除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名。通常“数字签名”是用来验证发送方的身份并帮助保护数据的完整性。 例如：一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点： 保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。 保证信息自签发后到收到为止未曾作过任何修改。 之所以可以确认这两点，是因为用公钥可以解密的必然是用对应的私钥加的密，而私钥只有签名者持有。 公钥算法的缺点现实中，公钥机制也有它的缺点，那就是效率非常低，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法： 首先，发送方使用对称算法对原始信息进行加密。 接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。 接收方 将公钥发送给 发送方。 发送方用公钥对对称算法的密钥进行加密，并发送给接收方。 接收方用私钥进行解密得到对称算法的密钥。 发送方再把已加密的原始信息发送给接收方。 接收方使用对称算法的密钥进行解密。 数字签名跟数字证书数字签名 鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。鲍勃将这个签名，附在信件下面，一起发给苏珊。 苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的 对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 注意区分数字签名跟数字证书 数字证书 复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。 后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。 鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。 苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。 数字证书的实例：https协议这个协议主要用于网页加密 下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。 首先，客户端向服务器发出加密请求。 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。 我们就拿segmentfault为例。 我们可以看到这里显示sf安装了证书，并且显示是valid，证明： 12- sf是sf，我没有被劫持到其他站点- 我和sf之前的通信是加密的，安全的，其他人窃取不到 那么浏览器是怎么验证的sf的证书的呢？还记得上面我提了一句“根证书”么？因为一般我们去申请证书都是通过CA机构，同时大家都信任CA机构比如digicert，verisign，那么我们就可以事先将这些CA机构的证明安装到我们的电脑上，也就是这些CA机构的”公钥”，我们也称它们为“根证书”。（CA把张三的“个人信息”以及“公钥信息”用他的私钥加密成“密文”，把这个密文当做“电子签名”签在了证书上，然后这个证书就被称为“电子证书”，最后再把自己的公钥送给了用户）这些根证书是预先安装在我们电脑上的，所以每当我们访问segmentfault的时候，如果segmentfault服务器上安装了证书，他想和我们建立安全通信，就好比上面例子中，张三直接把公钥发给李四一样，在这里： 123segmentfault说：“hi，我们建立安全通信吧，这是我的公钥”你的浏览器：“你怎么证明你的公钥是你的呢？”segmentfault说：“这是我的证书，请查看” 然后segmentfault就把安装在服务器上的证书传给你的浏览器，因为你的浏览器已经有一些神器“根证书”的存在，所以这些根证书（CA机构的公钥）就可以来“解密”sf发过来的证书上的签名，然后对比一下解密后的信息和sf证书中所呈现的信息是否一致，如果一致，就ok拉！ 最后上一个截图： 大家注意，最上面“DigiCert Global Root CA”，说明我们使用digicert这个CA组织的根证书来进行认证sf的证书，然后digicert替我们证明了sf证书的合理性：“This certificate is valid”，同时给我列出来证书中的一些详细信息，比如：证书的持有者，证书的过期时间，证书中所携带的“公钥”信息（用来验证你得到的公钥确实是sf的） TLS/SSL协议不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。 （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。 （2） 篡改风险（tampering）：第三方可以修改通信内容。 （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS协议是为了解决这三大风险而设计的，希望达到： （1） 所有信息都是加密传播，第三方无法窃听。 （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。 （3） 配备身份证书，防止身份被冒充。 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 但是，这里有两个问题。 （1）如何保证公钥不被篡改？ 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 （2）公钥加密计算量太大，如何减少耗用的时间？ 解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 因此，SSL/TLS协议的基本过程是这样的： （1） 客户端向服务器端索要并验证公钥。 （2） 双方协商生成”对话密钥”。 （3） 双方采用”对话密钥”进行加密通信。 上面过程的前两步，又称为”握手阶段”（handshake）。 握手阶段的详细过程 “握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。 客户端发出请求（ClientHello）首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。 在这一步，客户端主要向服务器提供以下信息。 （1） 支持的协议版本，比如TLS 1.0版。 （2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。 （3） 支持的加密方法，比如RSA公钥加密。 （4） 支持的压缩方法。 这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。 对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。 服务器回应（SeverHello）服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。 （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 （2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。 （3） 确认使用的加密方法，比如RSA公钥加密。 （4） 服务器证书。 除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。 客户端回应客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。 （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。 上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。 至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好： “不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。 对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。 pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。” 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。 服务器的最后回应服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。 （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。 大白话SSL(secure sockets layer)是TLS(transport layer security)的前身，为什么将他们合起来的，大家可以理解成都属于同一东西的不同阶段吧，比如该协议之前叫SSL后来改名成TLS了。 为什么要有这种协议呢？因为HTTP是使用明文传输，随着网络的发展，安全性越来越重要，所以大家就要想办法让传输更加安全，同时使用密码学的成果，利用“非对称加密算法”的思想以及OSI模型，来对HTTP的信息进行加密。 根据OSI模型，如果向外传输信息就是要从上到下挨个层进行，TLS/SSL也是位于应用层，所以为了加密HTTP的内容，那么TLS/SSL必须位于HTTP下面，可以看成这样： 12345HTTPTLS/SSLTCPIp.. 信息从HTTP经过TLS/SSL非对称加密后传出去，而在接收方，接收到信息是需要一层层向上进行，经过每层的“解包/解密”，最终通过HTTP转换成超文本信息。 所以HTTPS 就是 “HTTP内容向下传输的时候加了一层TLS/SSL加密”，仅此而已，这样，我们就可以实现，使用HTTP协议进行互联网信息传播的时候，对信息进行加密处理了，相信大家已经对非对称加密算法有一定了解了。比如说我们通过HTTPS连接某银行网站，这样我们就可以将我们的密码通过银行给我们的公钥进行加密后发送给银行，而避免了在传输过程中被他人偷看的可能，因为即使他们讲我们的密文盗走，也无法解密，只有银行网站可以解密，为什么？因为只有银行拥有与我们使用“公钥”加密相对的那个“私钥”。 但是同样的问题，就是我们怎么知道我们使用的公钥就是银行给我们的呢？即使我们所访问的域名和银行的域名一致，因为黑客完全可以通过修改我们本地的hosts文件，或者入侵dns，将域名映射到黑客的服务器。所以，这就是CA(certificate authority)，数字证书，数字签名，公钥基础设施(PKI)的作用了 公开密钥基础建设（英语：Public Key Infrastructure，缩写：PKI），又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。 总结 每个用户都有一对私钥和公钥。 私钥用来进行解密和签名，是给自己用的。 公钥由本人公开，用于加密和验证签名，是给别人用的。 当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即数字签名。 当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他看到。即安全传输。]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>密码学</tag>
        <tag>加密算法</tag>
        <tag>TLS/SSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准数独技巧]]></title>
    <url>%2F2019-11-02%2FSudoku.html</url>
    <content type="text"><![CDATA[数独真香真好玩 记录自己忽略的技巧点 宫摒除区块 PointingGOT IT FINISH,通过数字标记的方法可以确定 适用情况在进行宫摒除时，发现某数在某宫可能位置不止一个，但是可能位置处在同行或同列，则可以排除相应行或列中除他们外其他格的该数。 数字5对第二宫摒除发现第二宫5的可能位置是2个星号格，虽然目前不能确定是哪一格，但可以确定的是第三行除了星号格外其他格（用短横线标示）一定不是5。如下图所示： 实际应用 观察数字6，对第七宫进行摒除，得到第七宫的6在星号两格（同在第七行），故第七行除星号格外不能再有6。 继而可以得到第八宫的6只能在r8c6。 行列摒除区块 ClaimingGOT IT BUT FAILED, 不熟练 使用情况在进行行列摒除时，发现某数在某行或某列可能位置不止一个，但是可能位置处在同宫，则可以排除相应宫中除他们外其他格的该数 A对第一行摒除发现第一行A的可能位置是2个星号格，虽然目前不能确定是哪一格，但可以确定的是第二宫除了星号格外其他格（用短横线标示）一定不是A。如下图所示： 实际应用 观察数字4，对第四行进行摒除，得到第四行的4在星号两格（同在第六宫），故第六宫除星号格外不能再有4。如下图所示： 数字4对第九列摒除，第九列的4只能在r4c9。 可以理解为取公共点 摒除数对 Hidden PairGOT IT BUT FAILED, 不熟练 使用情况与宫摒除、行列摒除相同，只是同时观察2个数，且这两个数恰好被锁定在一行、一列、一宫的两个相同位置 图中无论是字母A还是字母B在第一宫可能的位置都是星号格，故这两格不能再有除A、B外的其他数字。 实际应用 例子中14的标记对，容易忽略 为了阐述摒除数对，下面这个例子同时涉及到宫摒除数对（第一步）和行列摒除数对（第二步）。 数字2和3同时对第六宫摒除，得到第六宫的2和3只能在星号处。故星号两格除了2和3不再有其他可能的数。 数字1和4同时对第五行摒除，其中r5c7，我们之前已经得到它可能的候选数只有2或3，自然不能有1和4，第五行的1和4只能在星号处。故星号两格除了1和4不能会再有其他可能数字。 此时数字7对第五行摒除，第五行的7只能在星号处。 唯余数对 Naked Pair难 使用情况与唯一余数观察方法相同，只是同时观察两格，且这两格所剩可能填写的数字均为2个且组合相同。 图中星号所示两格可能的数字均只剩下8和9，由于他们同在第一宫，称其为89数对，继而可以删除它们同在的第一宫内其他格的候选数8和9。 实际应用为了阐述唯余数对，下面这个例子用到了3次唯余数对和1次摒除数对，方便大家对两者进行对比。 分别来看黑色星号的两格和白色星号的两格，通过点算他们所在行列宫已经出现过的数字，可以发现黑色星号两格剩余可能数字均为59，计为59数对；白色星号两格剩余可能数字均为57，计为57数对。 点算黑色星号可能的数字，我们发现在其行列宫已经出现过2,3,4,6,7，而第一步得到的59数对（蓝色所示）因为同在第三行，故第三行其他格不能再有5或9，黑色星号格可能数字只剩下1和8；同样的，看白色星号，其所在行列宫已经出现过的数字有2,3,4,5,6,9，第一步得到的57数对（紫色所示）同在第七行，故第七行的其他格内不能再有5或7，白色星号格可能数字只剩1和8。由于黑色和白色星号格同在第六列，且可能候选均为1和8，则称其为18数对，第六列除他们俩外其他格都不能是1或8。 数字1和3对第五行摒除，得到第五行的1和3只能在星号两格（摒除数对）。 数字4对第五行摒除，得到r5c8=4。 三链数 Triplet使用情况与摒除数对和唯余数对观察方法相同，只是拓展到3个数或3格。这三格需属于同行或同列或同宫。 实际应用下面这个例子同时用到了摒除三链数(Hidden Triplet)和唯余三链数(Naked Triplet)，并会把前面的区块和唯余复习一下。 点算星号3格，自左往右，可能的数字依次为249,249,29，且它们同时处于第五行，则第五行的其他格不能再有2、4、9。 数字2,7,8对第四宫摒除，得到第四宫的2,7,8只能在星号3格。 数字4对第四宫摒除，得到第四宫的4只能在星号格。 r2c1唯余解9。 四角对角线/矩形摒除 X-Wing使用情况注：四角对角线是日本书里面对X-Wing的称呼，国内的书和网站称矩形删除或者X翼之类的比较多，一般还是直接用英文的X-Wing即可。 观察某一个数字A，若在某两行(列)中数字A只可能存在于某相同的两列(行)，则这两列(行)的其他格都不能有A。 图中，第二行和第五行的A只能在第二列和第五列，对于第二行和第五行的A可能有以下两种排列： 不论是哪一种情况，第二列和第五列其他格都不能是A。 实际应用 数字1分别对第三列和第八列摒除，得到第三列的1在黑色星号2格，第八列的1在白色星号2格。所以第三行和第九行除他们外的其他格都不能是1。 点算星号格，本来还剩1和3的可能，其中1已经被X-Wing摒除，故r3c1=3。 *注：有的地方会把行列区块归结到X-Wing里面，例如我们用之前行列区块的例子来看。 数字4对第三宫摒除，得到第三宫的4在星号格。 数字4对第九宫摒除，得到第九宫的4在星号格。 第三宫和第九宫的4都在第七列和第八列，故第七列和第八列除它们外的其他格都不含4。 从描述中聪明如你们应该能够发现一些差别，这里就不多做解释了。 摩天楼 Skyscraper记住 使用情况当数字A在某两行（列）均只存在两个可能位置，且其中一侧两数存在于同列（行）时，则可对另一侧两格共同影响格的数字A删除。 左图：第二列和第五列的数字A可能的位置均只有2个，其中蓝色A处于同一行，故可以删除另一侧紫色A的共同作用格（星号所示）的A。 右图：第二行和第八行的数字A可能的位置均只有2个，其中蓝色A处于同一列，故可以删除另一侧紫色A的共同作用格（星号所示）的A。 原理：如果你之前已经学习过链的入门，可以用链的观点来看。 左图：r2c2==r5c2–r5c5==r1c5 -&gt; r1c1,r1c3,r2c4,r2c6&lt;&gt;A。 亦可进行如下推理：根据r2c2是否是A分为2种情况1）r2c2=A；2）r2c2!=A -&gt; r5c2=A -&gt; r5c5!=A -&gt; r1c5=A。即r1c5和r2c2至少有一个是A，故可以删除他们共同影响的r1c1,r1c3,r2c4,r2c6的候选数A。 右图：r2c7==r2c2–r8c2==r8c8 -&gt; r1c8,r3c8,r7c7,r9c7&lt;&gt;A。（与左图类似，恕不赘述） 实际应用 数字7对第一、四行摒除，各有2个可能位置，且一侧均在第五列，另一侧共同作用格（白色星号所示）可以排除7的可能。 第一宫的7只能在r1c1。 双线风筝 Two Strings Kite适用情况当数字A在一行、一列均只有2个可能位置，行的一个端点和列的一个端点属于同一宫，则可以删除另两个端点的共同作用格。 图中第一行的A可能位置在r1c3和r1c7，第一列A的可能位置在r3c1和r7c1，他们各自的一个端点r1c3和r3c1同属于第一宫，所以可以删除另外两个端点r1c7和r7c1共同作用格r7c7的候选数A。 用链表示：r1c7==r1c3–r3c1==r7c1 -&gt; r7c7!=A 实际应用 第一列和第九行的4都只有两个位置，且r7c1和r9c3同属于第七宫，故可以删除r2c1和r9c6共同影响的r2c6的候选数4。 星号处根据盘面还剩2和4的可能，其中4已被双线风筝删除，得唯余解2。 多宝鱼 Turbot Fish适用情况当数字A在一行（列）和一宫中均只有2个可能位置，且其中行的一个端点和宫的一个端点存在于同一行（列），则可以删除另两两个端点共同作用格的候选数A。 图中第二列和第三宫字母A都只有2个可能位置，其中第二列的一个端点r1c2和第三宫的端点r1c7同属于第一行，故可以删除另两个端点r7c2和r3c8共同影响的r7c8的候选数A。 用链表示r3c8==r1c7–r1c2==r7c2 -&gt; r7c8!=A 实际应用 图中第七宫的2有两个可能位置r7c3和r9c1，第七列的2可能在r4c7和r9c7，其中r9c1和r9c7同属于第九行，所以可以删除另两个端点r7c3和r4c7共同影响的r4c3的2。 第三列的2只能在r7c3（其中r4c3的2由Turbot Fish删除）。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>数独</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些零散的笔记与目标]]></title>
    <url>%2F2019-10-30%2Flesson.html</url>
    <content type="text"><![CDATA[When grace is lost from life 当生命失去恩宠 come with a burst of song. 请惠我以欢歌 webstorm lorem可以生成随机字符串 … element el-col加起来24 … target [ ] 大创-介绍页面 [ ] Android入门 [x] 算法pdf other狗屁不通文章生成器https://suulnnka.github.io/BullshitGenerator/index.html]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找解题模版与题型 🎈]]></title>
    <url>%2F2019-10-29%2FBinary-Search.html</url>
    <content type="text"><![CDATA[实现int sqrt(int x)：计算并返回 x 的平方根，其中 x 是非负整数，由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 记住不完备的二分算法写法所导致的死循环跟跳过查找的特例 🙄 愿岁月静好，安然若素 前言二分查找(Binary Search)算是最为基本的一个算法，也比较容易掌握。但是有些时候，我们可能因为一些细节的点没有考虑而导致程序出错，虽然这个算法比较简单，但文章也会有比较高级的应用，比如按值二分:近似sqrt操作。 什么是二分查找？比二分查找更简单的算法，我能想到的只有 ++遍历枚举++，说的直白些，就是写 for 循环。 我们通常需要在一个数组当中找一个数，这个时候我们可以写一个 for 循环去挨个查找，这么下来，时间复杂度就会是O(n)。 如果我告诉你，这个数组是排序好的，这时我们就可以使用二分查找去找这个数。 我们可以选择数组中间的元素，这个中间元素会把数组分成前后两个相等的区间，如果我们要找的元素比中间元素要大，证明这个元素只可能在后半部分区间，我们就只需要去到后半部分区间用类似的方法再次查找。 如果比中间元素要小，则需要去到前半部分区间用类似的方法再次查找，直到最后我们找到了，或者说整个数组给分完了（没找到） 这样的话时间复杂度是 O(logn)。 关于时间复杂度跟空间复杂度，详细见另一篇文章) 你可以形象地理解每次操作我们都把数组对折，形成一个新的数组，因此二分查找又叫做折半查找。相信有一定编程基础的人都能够理解这个算法，我们的重点将会放在具体的实现和题型上面。 下面划重点 二分查找模板12345678910int start = 0, end = nums.length - 1;while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2;// mid = start + ((end - start) &gt;&gt;&gt; 1); if (...) &#123; start = mid; &#125; else &#123; end = mid; &#125;&#125; 首先解释一下，上面模版当中的 start + (end - start) / 2，这里不直接写成 (end + start) / 2的目的是防止计算越界，举个例子，假如 end = 2^31 - 1, start = 100，如果是后一种写法的话就会在计算 end + start 的时候越界，导致结果不正确。 二分查找算法若没实现好的两种后果 死循环 跳过了本该查找的位置 死循环1234比如区间定为[2，2],需查元素为3，此时套用下方代码就会导致死循环mid 计算后都会等于 start 的初始值然后将 mid 赋值给 start，导致 start 和 end 一直紧挨在一起这时就会导致死循环. 12345678910// start + 1 &lt; end =&gt; start &lt; end errorint start = 0, end = nums.length - 1;while (start &lt; end) &#123; int mid = start + (end - start) / 2; if (...) &#123; start = mid; &#125; else &#123; end = mid; &#125;&#125; 故有些人就会认为，那好，就每次赋值的时候把mid往后移动一格就好了，于是乎就变成下面的形式： 跳过本该查找的位置12345678910int start = 0, end = nums.length - 1;while (start &lt; end) &#123; int mid = start + (end - start) / 2; if (...) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125;&#125; 哦吼，似乎例子通过了，但是还会存在一个新的问题，现在来思考这么一个问题“在一个允许重复元素的按升序排好序的数组中，返回元素的index，如果有重复，就返回最大的那个index” 比如[1，2，2，3]这个例子中，假如我们要找的元素的值是2，那么正确的返回值应该是2，也就是第二个2的index，如果我们使用上面的模板，最后的程序就会变成： 12345678910int start = 0, end = nums.length - 1;while (start &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &lt;= target) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125;&#125;//根据条件返回 end 或者 start 通过手写模拟观察，可以得到我们最后返回的值是3，这就是我们之前提到的 跳过本该查找的位置 的情况。网上还有一种很常见的模版，就是把 while 循环中的条件设为 start &lt;= end，如果用来实现上面这个问题，就会是： 1234567891011int start = 0, end = nums.length - 1;while (start &lt;= end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &lt;= target) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125;&#125;根据条件返回 end 或者 start 易发现，此时end指针所指向的位置即是我们要寻找的位置，在这个模板中，while循环结束后，end + 1 == start 这个等式一直都是成立，仅需满足数组长度不为0的条件。 但是这个模板也有不良之处： 如果输入数组为[1]，那么while循环结束后，要么是start超出数组范围，要么是end变成-1，所以就会导致你不仅需要判断 start 和 end 对应的元素是不是要找的元素，还需要判断 start 和 end 是否在合法的范围内，所以上面的模板固然好，但是还是要知道存在数组越界的漏洞的！ 万变不离其宗，我们回到原先的代码 12345678910int start = 0, end = nums.length - 1;while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (...) &#123; start = mid; &#125; else &#123; end = mid; &#125;&#125; 此时我们不需要关注 是否需要 mid +/- 1 ，也不需要去判断 while 循环后的 start、end 是否合法，具体问题我们只需要套模版即可。 下面实战演练看看： 一般分两步： if-else条件里面分别放置什么内容 返回要找的元素，是end，还是start？ 小试牛刀：刷题第一个错误的版本 题目来源于 LeetCode 上第 278 号问题：第一个错误的版本。题目难度为 Easy，目前通过率为 32.9% 题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 12345给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 思考其实题目就是要找最先出现的元素，在这种情况下，如果我们找到了元素，依旧不知道它是不是最先（小）的，但是我们知道答案肯定不在后面，肯定在这或者是之前，因此这种情况需要将尾指针往前移。 代码实现123456789101112131415public int firstBadVersion(int n) &#123; int start = 0, end = n; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (isBadVersion(mid)) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; if (isBadVersion(start)) &#123; return start; &#125; return end;&#125; 在排序数组中查找元素的第一个和最后一个位置 题目来源于 LeetCode 上第 34 号问题：在排序数组中查找元素的第一个和最后一个位置。题目难度为 Easy，目前通过率为 37.4% 。 题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回[-1, -1]。 示例 1: 1输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 1输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 思考给定一个元素，要找其最先出现的 index，还要找其最后出现的 index。这道题把之前的两个问题合在了一起。我们只需要用两次二分查找，一次找前，一次找后。(第一个错误的版本+最后一个错误的版本的亚子) 仔细看的话，你会发现，这道题其实 就是在找一个元素在数组中出现的范围，因为数组有序，所以这个范围是连续的。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142public int[] searchRange(int[] nums, int target) &#123; int[] result = new int[]&#123;-1, -1&#125;; if (nums == null || nums.length == 0) &#123; return result; &#125; // find front int start = 0, end = nums.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &gt;= target) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; if (nums[start] == target) &#123; result[0] = start; &#125; else if (nums[end] == target) &#123; result[0] = end; &#125; // find back start = 0; end = nums.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &lt;= target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (nums[end] == target) &#123; result[1] = end; &#125; else if (nums[start] == target) &#123; result[1] = start; &#125; return result;&#125; 搜索二维矩阵 题目来源于 LeetCode 上第 74 号问题：搜索二维矩阵。题目难度为 Medium，目前通过率为 35.7% 。 题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1: 12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2: 12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 思考我们需要去判断一个元素在不在矩阵中，这个矩阵是排序好的，前一行的元素都比后一行的元素小，在同一行中，元素也是从小到大排列的。这个问题也很简单，我们先找行，再找列，但是需要注意的是，在找行的时候，你必须确保这一行开头的元素是 小于等于 你要找的元素的，不然接下来的操作将会没有意义。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int startRow = 0, endRow = matrix.length - 1; while (startRow + 1 &lt; endRow) &#123; int mid = startRow + (endRow - startRow) / 2; if (matrix[mid][0] == target) &#123; //等于直接true return true; &#125; else if (matrix[mid][0] &lt; target) &#123; startRow = mid; &#125; else &#123; endRow = mid; &#125; &#125; int selectRow = 0; if (matrix[endRow][0] &lt;= target) &#123; // 确认是在哪一行 selectRow = endRow; &#125; else &#123; selectRow = startRow; &#125; int startCol = 0, endCol = matrix[0].length - 1; while (startCol + 1 &lt; endCol) &#123; int mid = startCol + (endCol - startCol) / 2; if (matrix[selectRow][mid] == target) &#123; //等于直接true return true; &#125; else if (matrix[selectRow][mid] &lt; target) &#123; startCol = mid; &#125; else &#123; endCol = mid; &#125; &#125; if (matrix[selectRow][startCol] == target || matrix[selectRow][endCol] == target) &#123; return true; &#125; return false;&#125; 搜索二维矩阵 Ⅱ 题目来源于 LeetCode 上第 240 号问题：搜索二维矩阵 II。题目难度为 Medium，目前通过率为 37.4% 。 题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 思考这道题是上面那道题的变种，问题没变，主要是变在输入矩阵上，题目只保证矩阵中元素行和列是排好序的，也就是说前一行的元素不一定都比后一行的元素小，这个时候，我们之前的先找行，再找列的策略就失效了。 这个二维数组是有特点的： 每一行都是递增的 每一列都是递增的 于是可以考虑从 对角线 入手，对角线上的点往右和往下分别做二分，这样可以把时间复杂度控制在 O(2 * (1 + log2 + … + log(n)) = O(log(n!)) = O(nlog(n))。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int numOfFind = Math.min(matrix.length, matrix[0].length); for (int i = 0; i &lt; numOfFind; ++i) &#123; boolean upDown = find(matrix, i, target, true); boolean leftRight = find(matrix, i, target, false); if (upDown || leftRight) &#123; return true; &#125; &#125; return false;&#125;private boolean find(int[][] matrix, int i, int target, boolean isFindRow) &#123; int start = i; int end = isFindRow ? matrix.length - 1 : matrix[0].length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (isFindRow) &#123; if (matrix[mid][i] &lt; target) &#123; start = mid; &#125; else if (matrix[mid][i] &gt; target) &#123; end = mid; &#125; else &#123; return true; &#125; &#125; else &#123; if (matrix[i][mid] &lt; target) &#123; start = mid; &#125; else if (matrix[i][mid] &gt; target) &#123; end = mid; &#125; else &#123; return true; &#125; &#125; &#125; if (isFindRow) &#123; if (matrix[start][i] == target || matrix[end][i] == target) &#123; return true; &#125; &#125; else &#123; if (matrix[i][start] == target || matrix[i][end] == target) &#123; return true; &#125; &#125; return false;&#125; 除了这种做法，还有一种 O(n) 的解法比较 tricky， 首先，我们初始化一个指向矩阵右上角的 元素 。 从这个元素开始查找，如果这个元素比 target 大，则说明需要找更小的，往左走；如果这个元素比 target 小，则说明应该找更大的，往下走。 登堂入室：Rotated Array 系列系列描述有一类题型是把一个数组向右或者向左移动了一下，比如数组 [1,2,3,4,5,6] 向右移动两格就会变成 [5,6,1,2,3,4]，这样这个数组就变成了一个非排序状态。但是仔细看的话你会发现，移动后的数组变成了两截，这两截内的元素是按序排列的，比如在上面的例子中，移动后的数组就会有 [5,6] 和 [1,2,3,4] 这两个区间，这两个区间内的元素都是按序排列的。 仔细观察这两个区间，你会发现，其中一个区间内的所有元素都比另一个区间的任意元素小， 这个点就给我们二分查找创造了条件，我们可以根据尾元素作为区分值，但要清楚一点的是，没有移动过的数组也需要被你的程序考虑在内。 我们结合实际的题目来看看。 旋转数组的最小数字 题目来源于 LeetCode 上第 153 号问题：旋转数组的最小数字。题目难度为 Medium，目前通过率为 49.2% 。 题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0，1，2，4，5，6，7] 可能变为 [4，5，6，7，0，1，2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3，4，5，1，2]输出: 1 示例 2: 输入: [4，5，6，7，0，1，2]输出: 0 思考找出转动数组中最小的值，之前讲过的转动数组的性质，这个数组其实可以看成两个排序好的数组，一前一后，一大一小， 我们做二分的时候，二分取到的中点有可能在前区间，也有可能在后区间，怎么判断？ 可以使用尾元素作为区分值，二分中点对应的值比尾元素小的话那就说明二分中点是在后面的区间，大的话就会是在前面的区间。 如果中点在后面的区间，那我们就要移动尾指针，如果是在前面的区间的话，我们就要移动首指针，其实就是逐步逼近后区间首元素的一个过程。 可能很多人会有一个疑问就是，这里能不能使用首元素作为区分值，其实是不行的，考虑一个例子 [1,2,3,4,5]，如果还是使用尾元素，那么整个过程就是一直移动尾指针，直到逼近答案，但是使用首元素的话，如果你还是考虑这个数组有两个区间，比首元素大证明在第一个区间，要移动首指针，这里就会出问题，我们跳过了答案。 多试几个例子，相信不难理解。 代码实现12345678910111213141516171819202122public int findMin(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int start = 0, end = nums.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &lt;= nums[end]) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; if (nums[start] &gt; nums[end]) &#123; return nums[end]; &#125; return nums[start];&#125; 搜索旋转排序数组 题目来源于 LeetCode 上第 33 号问题：搜索旋转排序数组。题目难度为 Medium，目前通过率为 36.1% 。 问题分析假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组[0,1,2,4,5,6,7] 可能变为[4,5,6,7,0,1,2])。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思考这道题和前面那道题相比更复杂了些，我们不是要找值最小的那个元素，而是要找给定元素在数组中出现的 index。 前一道题，我们只需要判断二分中点在哪个位置即可，这里会比之前多了一个判断，就是我们要找的元素是在前后两个区间中的哪一个？ 我们知道了二分中点所在的区间，以及要找的元素所在的区间后，就可以按情况移动前后指针，其实一共有下面几种情况，我用 t 表示 target，也就是我们要找的元素，用 m 表示二分中点: 1234567891011121314151617[...][...] -&gt; 二分中点在前区间，要找的元素在后区间 m t[...][...] -&gt; 二分钟点在后区间，要找的元素在前区间 t m[...][...] -&gt; 二分中点和要找的元素都在前区间，要找的元素在二分中点之后 m t[...][...] -&gt; 二分中点和要找的元素都在前区间，要找的元素在二分中点之前 t m[...][...] -&gt; 二分中点和要找的元素都在后区间，要找的元素在二分中点之后 m t[...][...] -&gt; 二分中点和要找的元素都在后区间，要找的元素在二分中点之前 t m 分析归分析，我们最后还是要转化成可执行的代码，写代码的时候你会发现有些情况是可以合并的： 1234567891011[...][...] -&gt; 要找的元素在前区间，二分中点在后区间，或者是在前区间但比要找的元素大，这时我们需要移动尾指针 t m m m[...][...] -&gt; 要找的元素和二分中点都在前区间，但是要找的元素比二分中点要大，这时移动首指针 m t[...][...] -&gt; 要找的元素在后区间，二分中点在前区间，或者是在后区间但比要找的元素小，这时我们需要移动首指针 m m m t[...][...] -&gt; 要找的元素和二分中点都在后区间，但是要找的元素比二分中点要小，这时移动尾指针 t m 注意思考分析的时候也需要想想，如果数组没有被转动，那么我们的思路是否正确。 代码实现1234567891011121314151617181920212223242526272829303132333435363738public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return -1; &#125; int start = 0, end = nums.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (target &gt; nums[end]) &#123; // ||后面理解成 nums[mid] &lt;= target的条件下满足 nums[mid] &lt;= nums[end]😷 if (nums[mid] &gt; target || nums[mid] &lt;= nums[end]) &#123; end = mid; &#125; else if (nums[mid] == target) &#123; return mid; &#125; else &#123; start = mid; &#125; &#125; else &#123; if (nums[mid] &gt; nums[end] || nums[mid] &lt; target) &#123; start = mid; &#125; else if (nums[mid] == target) &#123; return mid; &#125; else &#123; end = mid; &#125; &#125; &#125; if (nums[start] == target) &#123; return start; &#125; if (nums[end] == target) &#123; return end; &#125; return -1;&#125; 搜索旋转排序数组 II 题目来源于 LeetCode 上第 33 号问题：搜索旋转排序数组 II。题目难度为 Medium，目前通过率为 33.9% 。 题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2: 输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 思考这道题和前面那道题相比，只是增加了一个条件，就是数组中允许出现重复的元素。 可能很多人纠结的地方会是在首尾两个指针上，允许重复说明，这两个指针上的元素也会是重复的，就比如我们当前的二分中点的元素值是 x，然后你对比发现首尾两个元素的值也都是 x，那么你怎么确定这个数是在前区间还是后区间？ 我的做法是用循环去做判断，如果二分中点元素的值和尾指针元素的值相同，那么我就会向后移动这个二分中点，如果发现移到某一点，这一点并不是尾指针，那么说明这个二分中点在前区间，如果移到了尾指针处，说明这个点在后区间，其他照旧。 这里说明一点，这道题的最坏情况的时间复杂度会退化到 O(n) 的，也就是说数组里面的元素全部相同，但是我们要找的元素不在数组内，比如 [2,2,2,2,2,2,2]，我们要找的数是 1。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int start = 0, end = nums.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] == nums[end]) &#123; int tmp = mid; while (tmp &lt; end &amp;&amp; nums[tmp] == nums[end]) &#123; tmp++; &#125; //去除重复的多余项 if (nums[tmp] == nums[end]) &#123; //3 1 1 2 2 2 2 end = mid; &#125; else &#123; // 5 5 5 5 0 1 5 start = mid; &#125; continue; &#125; if (target &lt; nums[end]) &#123; if (nums[mid] &gt; nums[end] || nums[mid] &lt;= target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; else if (target == nums[end]) &#123; return true; &#125; else &#123; if (nums[mid] &lt; nums[end] || nums[mid] &gt;= target) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; &#125; if (nums[start] == target || nums[end] == target) &#123; return true; &#125; return false;&#125; 游刃有余：按值二分这一类题目在二分里面算是难题了。题目通常不会要你在数组中去做查找，往往是让你去使用二分去逼近一个答案，这个答案往往也是近似的。 x的平方根 题目来源于 LeetCode 上第 69 号问题：x 的平方根。题目难度为 Medium，目前通过率为 36.1% 。 题目分析实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 思考如果输入参数是任意的浮点数，可以想想怎么做。那么这个时候我们就需要一个精确度，然后我们逐渐去逼近答案。 但是这里有一个 tricky 的地方就是，如果输入的这个数是小于 1 的话，你得把 start 和 end 颠倒一下，因为小数是越乘越小的。 代码实现1234567891011121314151617181920212223242526public double mySqrtComp(double x) &#123; if (x == 0.0 || x == 1.0) &#123; return x; &#125; double left = 0.0, right = x, eps = 1e-7; if (x &lt; 1.0) &#123; left = x; right = 1.0; &#125; while (Math.abs(right - left) &gt; eps) &#123; double mid = left + (right - left) / 2.0; if (Math.abs(mid * mid - x) &lt; eps) &#123; return mid; &#125; else if (mid * mid &lt; x) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; 返璞归真：二分其他题型乘法表中第 k 小的数 题目来源于 LeetCode 上第 668 号问题：乘法表中第 k 小的数。题目难度为 Hard，目前通过率为 34.4% 。 题目描述几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第 k 小的数字吗？ 给定高度 m 、宽度 n 的一张 m * n的乘法表，以及正整数 k，你需要返回表中第 k 小的数字。 例 1： 1234567输入: m = 3, n = 3, k = 5输出: 3解释: 乘法表:1 2 32 4 63 6 9第5小的数字是 3 (1, 2, 2, 3, 3). 例 2： 123456输入: m = 2, n = 3, k = 6输出: 6解释: 乘法表:1 2 32 4 6第6小的数字是 6 (1, 2, 2, 3, 4, 6). 注意： 12m 和 n 的范围在 [1, 30000] 之间。k 的范围在 [1, m * n] 之间。 思考在一个乘法表里面寻找第 K 小的元素。 这道题自我感觉是非常 tricky 的一道题，一开始想很难想到可以用二分，其二分的思路类似按值二分，但是还是不一样，至少说这道题最后是可以得到一个确定的解的。 思路大概是，给定乘法表中，最后一个元素是最大的，其值是 mn，第一个元素是最小的，其值是 1，由此我们就可以确认前后指针，然后我们每次都用二分中点去判断，看看矩阵中有多少个数是小于这个值的，如果说矩阵中有超过 K 个数小于这个值，那说明这个二分中点大了，要移动后指针，反之，缩短前指针。 很难理解的原因是，我们可能会认为二分最后得到的答案有可能不在乘法矩阵中，但这个疑点其实是可以利用二分的性质来解释的，二分就是不断趋近于最后的答案的过程，而且这里我们是二分整数，你可以把这道题想象成找元素在数组中最先出现的位置。 举个例子，假如说乘法表中第 K 个出现的元素是 10，你会发现 11 也可以，但是 11 并不在乘法表中，在二分的过程中，我们找到 11 了，但是我们并不会直接返回结果，我们会把后指针移到 11 的位置，然后继续在 11 之前的区间查找。 直到二分把区间缩小到只剩下 1 到 2 个数，我们才会去判断并返回最后的结果。 代码实现12345678910111213141516171819202122232425262728293031public int findKthNumber(int m, int n, int k) &#123; int start = 1, end = m * n; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (count(mid, m, n, k)) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; if (count(start, m, n, k)) &#123; return start; &#125; return end;&#125;private boolean count(int mid, int m, int n, int k) &#123; int res = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (mid / i == 0) &#123; break; &#125; res += Math.min(mid / i, n); &#125; return res &gt;= k;&#125; 未完待续]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>习题</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高频面试题：接雨水 💦]]></title>
    <url>%2F2019-10-29%2Fwater-problem.html</url>
    <content type="text"><![CDATA[给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，下雨后能接多少雨水 题目描述 就是用一个数组表示一个条形图，问你这个条形图最多能接多少水。 1int trap(int[] height); 下面就来由浅入深介绍暴力解法 -&gt; 备忘录解法 -&gt; 双指针解法 -&gt; 奇技淫巧解法，在 O(N) 时间 O(1) 空间内解决这个问题。 核心思路我第一次看到这个问题，无计可施，完全没有思路，相信很多朋友跟我一样。所以对于这种问题，我们不要想整体，而应该去想局部；就像之前的文章处理字符串问题，不要考虑如何处理整个字符串，而是去思考应该如何处理每一个字符。 这么一想，可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 i，能装下多少水呢？ 能装 2 格水。为什么恰好是两格水呢？因为 height[i] 的高度为 0，而这里最多能盛 2 格水，2-0=2。 为什么位置 i 最多能盛 2 格水呢？因为，位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为l_max和r_max；位置 i 最大的水柱高度就是min(l_max, r_max)。 更进一步，对于位置 i，能够装的水为： 123456water[i] = min( # 左边最高的柱子 max(height[0..i]), # 右边最高的柱子 max(height[i..end]) ) - height[i] 这就是本问题的核心思路，我们可以简单写一个暴力算法： 有之前的思路，这个解法应该是很直接粗暴的，时间复杂度 O(N^2)，空间复杂度 O(1)。但是很明显这种计算r_max和l_max的方式非常笨拙，一般的优化方法就是备忘录。 备忘录优化之前的暴力解法，不是在每个位置 i 都要计算r_max和l_max吗？我们直接把结果都缓存下来，别傻不拉几的每次都遍历，这时间复杂度不就降下来了嘛。 我们开两个数组r_max和l_max充当备忘录，l_max[i]表示位置 i 左边最高的柱子高度，r_max[i]表示位置 i 右边最高的柱子高度。预先把这两个数组计算好，避免重复计算： 这个优化其实和暴力解法差不多，就是避免了重复计算，把时间复杂度降低为 O(N)，已经是最优了，但是空间复杂度是 O(N)。下面来看一个精妙一些的解法，能够把空间复杂度降低到 O(1)。 双指针解法这种解法的思路是完全相同的，但在实现手法上非常巧妙，我们这次也不要用备忘录提前计算了，而是用双指针边走边算，节省下空间复杂度。 首先，看一部分代码： 1234567891011int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); int left = 0, right = n - 1; int l_max = height[0]; int r_max = height[n - 1]; while (left &lt;= right) &#123; l_max = max(l_max, height[left]); r_max = max(r_max, height[right]); left++; right--; &#125;&#125; 对于这部分代码，请问l_max和r_max分别表示什么意义呢？ 很容易理解，l_max是height[0..left]中最高柱子的高度，r_max是height[right..end]的最高柱子的高度。 明白了这一点，直接看解法： 你看，其中的核心思想和之前一模一样，换汤不换药。但是细心的读者可能会发现次解法还是有点细节差异： 之前的备忘录解法，l_max[i]和r_max[i]代表的是height[0..i]和height[i..end]的最高柱子高度。 ans += min(l_max[i], r_max[i]) - height[i]; 但是双指针解法中，l_max和r_max代表的是height[0..left]和height[right..end]的最高柱子高度。比如这段代码： 1234if (l_max &lt; r_max) &#123; ans += l_max - height[left]; left++; &#125; 此时的l_max是left指针左边的最高柱子，但是r_max并不一定是left指针右边最高的柱子，这真的可以得到正确答案吗？ 其实这个问题要这么思考，我们只在乎min(l_max, r_max)。对于上图的情况，我们已经知道l_max &lt; r_max了，至于这个r_max是不是右边最大的，不重要，重要的是height[i]能够装的水只和l_max有关。 对于 l_max &gt; r_max 的情况也是类似的。 另外一种接水题目题目描述： 柱子不考虑宽度，存粹考虑能装的最多水，求容器装水量，即“水桶效应”题。 定义 i 和 j 两个指针分别指向数组的左右两端，然后两个指针向中间搜索，并且更新面积最大值 res，直到 i == j 时返回 res。 其中 容器装水量的算法是找出左右两个边缘中较小的那个乘以两边缘的距离。 123456789class Solution &#123; public int maxArea(int[] height) &#123; int i = 0, j = height.length - 1, res = 0; while(i &lt; j)&#123; res = height[i] &lt; height[j] ? Math.max(res, (j - i) * height[i++]): Math.max(res, (j - i) * height[j--]); &#125; return res; &#125;&#125; 时间复杂度 O(N)，双指针遍历一次底边宽度 N 。 空间复杂度 O(1)，指针使用常数额外空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三次握手与四次挥手是怎么完成的？]]></title>
    <url>%2F2019-10-28%2FTCP.html</url>
    <content type="text"><![CDATA[谈谈三次握手，四次分手的事情 ## ## ##]]></content>
  </entry>
  <entry>
    <title><![CDATA[中国农历日期的算法（gregorian date）]]></title>
    <url>%2F2019-10-28%2Fcalender.html</url>
    <content type="text"><![CDATA[主要就是节气积日公式跟朔日的计算 放在前面：公历就是阳历，农历就是阴历。 前言按照我们平常的经验，当我们打开一本日历，我们经常使用的公历和中国传统使用的农历总是会有一定的差距。 比如2019.11.01所对应的农历时间是十月初五 2020.11.01所应的农历日期是九月十六 为什么会出现这样的差距？公历我们所知道的最基础的概念就是一年有365天，但实际上从天文的角度上来看，一年的实际概念是地球绕太阳一周的时间，这个时间应该是365.2422天，如果我们一直用365天作为一年的话，那么长久过后，0.2422可能会造成很大误差。 每四年积累起来的路程可以近似让他再走个1天，即平均每四年会出一个闰年，或者说每四年会多一个二月二十九号，然而平均每四年补一天的方法也会造成误差，因为0.2422*4=0.9688，然后我们补一天会导致往前面偏移一点点，这个误差积累到100年的时候会多出一天，然后积累到 400年的时候又应该补回一个闰年 所以我们算法是：平均每四年算一次闰年，100年的时候不算即是-1天。400年的时候补回一个闰年 比如说2020是闰年，一直到2100年我们不认为它不是闰年 农历比如春节，可能出现在公历1月，也可能出现在公历2月，但是放在农历都是正月初一，相比公历，农历的定义为月球绕地球的一圈 规定： 满月为每个月的十五——古时称之为望 空月(看不见月亮)为每个月的初一——古时称之为朔 当月球从看不到到满月再回到看不到的状态，这样的一个过程我们称为朔望月：29.53天，古人把这个时间称为一个月，一年有十二个月，则农历时间的一年：29.52*12=354.36(天) 相比阳历：365.2422-354.36=10.8822 那要怎么弥补之间的空缺，古人算出最好的比例：19年补7个月，称闰月 365.2422*19=6939.6018 29.531219 + 7 * 29.53 = 6939.55 通过观测跟计算分配29天跟30天于各个月份，此为不均匀分配的 二十四节气 360度/15度 = 24因为是根据地球绕太阳来分的，所以二十四节气是一种阳历，所以说清明节是在每年的4.5，而不是在农历的4.5， 24节气分为2类：一类叫节气，一类叫中气，隔着来排列 农历中：正月前有腊月，农历一月称正月，十一月称冬月，十二月称腊月 农历里每一个月有且对应一个中气 比如2019年正月时间为：2月5日-3月6日，说明根据天文观测，2月5日这一天刚好看不到月亮，然后3月6日刚好回到看不到的状态。 只要满足 每一个月都包含一个中气的情况，就不会出现闰月 当发生闰月情况下，会有不包含中气的情况，比如2020年中有 四月 4.23-5.22空月(润四月) 5.23-6.20五月 6.21-7.20因为夏至一定要对应五月，则会导致出现空月的情况 当找不到一个中气跟其对应的时候，我们称之为闰月 节气积日公式123456import mathdef F(y,x): return 365.242 * (y - 1900) + 6.2 + 15.22 * x - 1.9 * sin(0.262 * x)F(1900,1) //20.9278，说明1900第二个节气，1月20号是大寒F(1900,2) //35.6893，F(1900,3) //50.5156 实现函数转化成正确的公历日期： 123456789101112131415161718192021222324import mathdef F(y,x): return 365.242 * (y - 1900) + 6.2 + 15.22 * x - 1.9 * sin(0.262 * x)days_in_month = [31,28,31,30,31,....]def days_to_gregorian_date(n):""":param n: num days from 1900-01-00""" m = 0 while n &gt; days_in_mmonth[m]: n = n - days_in_nmonth[m] m = (m + 1) % 12 month = m + 1 day = n return month,day // 测试 m,d = days_to_gregorian_date(10) //1月10号 如果传50 则为2月19号print("&#123;&#125;月&#123;&#125;日",format(m,d)) for i in range(0,4): days = int(F(1900,i)) m,d = days_to_gregorian_date(days) print("&#123;&#125;月&#123;&#125;日",format(m,d)) 输入2015，发现结果不匹配 ，其实是上边代码的2月份不能一直考虑为28天，因为有闰年夹杂在中间 1234567891011121314151617181920212223242526272829303132333435363738def F(y,x): return 365.242 * (y - 1900) + 6.2 + 15.22 * x - 1.9 * math.sin(0.262 * x) def is_leap_year(year): if year % 400 == 0 return true elif year % 100 == 0 return false elif yeaar % 4 == 0 return true else: return falsedef get_days_in_month(year,month): if is_leap_year(year) and mouth == 1: //如果为闰年，且所求为2月 return days_in_month[month] + 1 else return days_in_month[month] def days_to_gregorian_date(n):""":param n: num days from 1900-01-00""" m = 0 year = 1900 while n &gt; get_days_in_month(y,m): n = n - get_days_in_month(y,m) m = (m + 1) % 12 if m == 0: y = y + 1 year = y month = m + 1 day = n return year,month,dayfor i in range(0,4): days = int(F(2015,i)) y,m,d = days_to_gregorian_date(days) print("&#123;&#125;年&#123;&#125;月&#123;&#125;日",format(y,m,d)) 由此可以算出中气，节气 0 腊月 1 正月 … 朔日计算公式计算第m个朔日的时间 123456def M(m): return 1.6 + 29.5306 * m + 0.4 * math.sin(1 - 0.45058 * m)for i in range(0,4): days = int(M(i)) //求1900年的前面四个朔日时间 y,m,d = days_to_gregorian_date(days) print("&#123;&#125;年&#123;&#125;月&#123;&#125;日",format(y,m,d)) 综合性算法 求距1900-01-00过了多少天 求离当前时间最近的朔日 例：比如我想求2019年3月12日对应的农历日期 首先利用gregorian_date_to_days 得到当前天数 再利用get_nearest_shuo_day得到最近朔日点 计算出离当前时间最近的朔日点，然后days减去初一(朔日点)则可以得到农历时间几月几号 定月份（通过24节气来确定月份） 通过识别月份包裹哪个二十四节气的day数字，由此来判断农历月份 更为标准的写法(js)1234567891011121314151617181920212223242526272829303132333435/** * 农历1900-2100的润大小信息表 * @Array Of Property * @return Hex * * 5位16进制数代表20位2进制 * 比如1900年代表0x04bd8二进制 * 0000 0100 1011 1101 1000 * 其中0-3位代表此年的闰月是大月还是小月，1为大月30天，0为小月29天 * 4-15位代表1-12月每个月是大月还是小月，1为大月30天，0为小月29天 * 16-20位代表此年是否闰月，如果全0代表不闰月，否则代表润的月份 */lunarInfo: [0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950, 0x16554, 0x056a0, 0x09ad0, 0x055d2, //1900-1909 0x04ae0, 0x0a5b6, 0x0a4d0, 0x0d250, 0x1d255, 0x0b540, 0x0d6a0, 0x0ada2, 0x095b0, 0x14977, //1910-1919 0x04970, 0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54, 0x02b60, 0x09570, 0x052f2, 0x04970, //1920-1929 0x06566, 0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0, 0x02b60, 0x186e3, 0x092e0, 0x1c8d7, 0x0c950, //1930-1939 0x0d4a0, 0x1d8a6, 0x0b550, 0x056a0, 0x1a5b4, 0x025d0, 0x092d0, 0x0d2b2, 0x0a950, 0x0b557, //1940-1949 0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5b0, 0x14573, 0x052b0, 0x0a9a8, 0x0e950, 0x06aa0, //1950-1959 0x0aea6, 0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0, //1960-1969 0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558, 0x0b540, 0x0b6a0, 0x195a6, //1970-1979 0x095b0, 0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570, //1980-1989 0x04af5, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x055c0, 0x0ab60, 0x096d5, 0x092e0, //1990-1999 0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5, //2000-2009 0x0a950, 0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0, 0x0a930, //2010-2019 0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6, 0x0a4e0, 0x0d260, 0x0ea65, 0x0d530, //2020-2029 0x05aa0, 0x076a3, 0x096d0, 0x04afb, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45, //2030-2039 0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255, 0x06d20, 0x0ada0, //2040-2049 /**Add By JJonline@JJonline.Cn**/ 0x14b63, 0x09370, 0x049f8, 0x04970, 0x064b0, 0x168a6, 0x0ea50, 0x06b20, 0x1a6c4, 0x0aae0, //2050-2059 0x0a2e0, 0x0d2e3, 0x0c960, 0x0d557, 0x0d4a0, 0x0da50, 0x05d55, 0x056a0, 0x0a6d0, 0x055d4, //2060-2069 0x052d0, 0x0a9b8, 0x0a950, 0x0b4a0, 0x0b6a6, 0x0ad50, 0x055a0, 0x0aba4, 0x0a5b0, 0x052b0, //2070-2079 0x0b273, 0x06930, 0x07337, 0x06aa0, 0x0ad50, 0x14b55, 0x04b60, 0x0a570, 0x054e4, 0x0d160, //2080-2089 0x0e968, 0x0d520, 0x0daa0, 0x16aa6, 0x056d0, 0x04ae0, 0x0a9d4, 0x0a2d0, 0x0d150, 0x0f252, //2090-2099 0x0d520], //2100 比如说 0x055d2 表示1909年有个闰二月，有 29天， 中间 55D 则 代表 0101 0101 1101，12个位正好代表12个月，第11位跟第12位我们称之为冬月跟腊月，0代表29天，1代表30天 所以1月29天，2月30天，闰二月29天。。。 （其实我们农历一般不说年份），从1909公历一月 开始看，农历对应是从腊月初十开始到腊月三十，然后正月廿九，二月三十，闰二月廿九，三月廿九…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 1900-2100各年的24节气日期速查表 * @Array Of Property * @return 0x string For splice */ sTermInfo:['9778397bd097c36b0b6fc9274c91aa','97b6b97bd19801ec9210c965cc920e','97bcf97c3598082c95f8c965cc920f', '97bd0b06bdb0722c965ce1cfcc920f','b027097bd097c36b0b6fc9274c91aa','97b6b97bd19801ec9210c965cc920e', '97bcf97c359801ec95f8c965cc920f','97bd0b06bdb0722c965ce1cfcc920f','b027097bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e','97bcf97c359801ec95f8c965cc920f','97bd0b06bdb0722c965ce1cfcc920f', 'b027097bd097c36b0b6fc9274c91aa','9778397bd19801ec9210c965cc920e','97b6b97bd19801ec95f8c965cc920f', '97bd09801d98082c95f8e1cfcc920f','97bd097bd097c36b0b6fc9210c8dc2','9778397bd197c36c9210c9274c91aa', '97b6b97bd19801ec95f8c965cc920e','97bd09801d98082c95f8e1cfcc920f','97bd097bd097c36b0b6fc9210c8dc2', '9778397bd097c36c9210c9274c91aa','97b6b97bd19801ec95f8c965cc920e','97bcf97c3598082c95f8e1cfcc920f', '97bd097bd097c36b0b6fc9210c8dc2','9778397bd097c36c9210c9274c91aa','97b6b97bd19801ec9210c965cc920e', '97bcf97c3598082c95f8c965cc920f','97bd097bd097c35b0b6fc920fb0722','9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e','97bcf97c3598082c95f8c965cc920f','97bd097bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa','97b6b97bd19801ec9210c965cc920e','97bcf97c359801ec95f8c965cc920f', '97bd097bd097c35b0b6fc920fb0722','9778397bd097c36b0b6fc9274c91aa','97b6b97bd19801ec9210c965cc920e', '97bcf97c359801ec95f8c965cc920f','97bd097bd097c35b0b6fc920fb0722','9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e','97bcf97c359801ec95f8c965cc920f','97bd097bd07f595b0b6fc920fb0722', '9778397bd097c36b0b6fc9210c8dc2','9778397bd19801ec9210c9274c920e','97b6b97bd19801ec95f8c965cc920f', '97bd07f5307f595b0b0bc920fb0722','7f0e397bd097c36b0b6fc9210c8dc2','9778397bd097c36c9210c9274c920e', '97b6b97bd19801ec95f8c965cc920f','97bd07f5307f595b0b0bc920fb0722','7f0e397bd097c36b0b6fc9210c8dc2', '9778397bd097c36c9210c9274c91aa','97b6b97bd19801ec9210c965cc920e','97bd07f1487f595b0b0bc920fb0722', '7f0e397bd097c36b0b6fc9210c8dc2','9778397bd097c36b0b6fc9274c91aa','97b6b97bd19801ec9210c965cc920e', '97bcf7f1487f595b0b0bb0b6fb0722','7f0e397bd097c35b0b6fc920fb0722','9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e','97bcf7f1487f595b0b0bb0b6fb0722','7f0e397bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa','97b6b97bd19801ec9210c965cc920e','97bcf7f1487f531b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722','9778397bd097c36b0b6fc9274c91aa','97b6b97bd19801ec9210c965cc920e', '97bcf7f1487f531b0b0bb0b6fb0722','7f0e397bd07f595b0b6fc920fb0722','9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c9274c920e','97bcf7f0e47f531b0b0bb0b6fb0722','7f0e397bd07f595b0b0bc920fb0722', '9778397bd097c36b0b6fc9210c91aa','97b6b97bd197c36c9210c9274c920e','97bcf7f0e47f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722','9778397bd097c36b0b6fc9210c8dc2','9778397bd097c36c9210c9274c920e', '97b6b7f0e47f531b0723b0b6fb0722','7f0e37f5307f595b0b0bc920fb0722','7f0e397bd097c36b0b6fc9210c8dc2', '9778397bd097c36b0b70c9274c91aa','97b6b7f0e47f531b0723b0b6fb0721','7f0e37f1487f595b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc9210c8dc2','9778397bd097c36b0b6fc9274c91aa','97b6b7f0e47f531b0723b0b6fb0721', '7f0e27f1487f595b0b0bb0b6fb0722','7f0e397bd097c35b0b6fc920fb0722','9778397bd097c36b0b6fc9274c91aa', '97b6b7f0e47f531b0723b0b6fb0721','7f0e27f1487f531b0b0bb0b6fb0722','7f0e397bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa','97b6b7f0e47f531b0723b0b6fb0721','7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722','9778397bd097c36b0b6fc9274c91aa','97b6b7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722','7f0e397bd07f595b0b0bc920fb0722','9778397bd097c36b0b6fc9274c91aa', '97b6b7f0e47f531b0723b0787b0721','7f0e27f0e47f531b0b0bb0b6fb0722','7f0e397bd07f595b0b0bc920fb0722', '9778397bd097c36b0b6fc9210c91aa','97b6b7f0e47f149b0723b0787b0721','7f0e27f0e47f531b0723b0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722','9778397bd097c36b0b6fc9210c8dc2','977837f0e37f149b0723b0787b0721', '7f07e7f0e47f531b0723b0b6fb0722','7f0e37f5307f595b0b0bc920fb0722','7f0e397bd097c35b0b6fc9210c8dc2', '977837f0e37f14998082b0787b0721','7f07e7f0e47f531b0723b0b6fb0721','7f0e37f1487f595b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc9210c8dc2','977837f0e37f14998082b0787b06bd','7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722','7f0e397bd097c35b0b6fc920fb0722','977837f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721','7f0e27f1487f531b0b0bb0b6fb0722','7f0e397bd097c35b0b6fc920fb0722', '977837f0e37f14998082b0787b06bd','7f07e7f0e47f531b0723b0b6fb0721','7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722','977837f0e37f14998082b0787b06bd','7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722','7f0e397bd07f595b0b0bc920fb0722','977837f0e37f14998082b0787b06bd', '7f07e7f0e47f149b0723b0787b0721','7f0e27f0e47f531b0b0bb0b6fb0722','7f0e397bd07f595b0b0bc920fb0722', '977837f0e37f14998082b0723b06bd','7f07e7f0e37f149b0723b0787b0721','7f0e27f0e47f531b0723b0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722','977837f0e37f14898082b0723b02d5','7ec967f0e37f14998082b0787b0721', '7f07e7f0e47f531b0723b0b6fb0722','7f0e37f1487f595b0b0bb0b6fb0722','7f0e37f0e37f14898082b0723b02d5', '7ec967f0e37f14998082b0787b0721','7f07e7f0e47f531b0723b0b6fb0722','7f0e37f1487f531b0b0bb0b6fb0722', '7f0e37f0e37f14898082b0723b02d5','7ec967f0e37f14998082b0787b06bd','7f07e7f0e47f531b0723b0b6fb0721', '7f0e37f1487f531b0b0bb0b6fb0722','7f0e37f0e37f14898082b072297c35','7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721','7f0e27f1487f531b0b0bb0b6fb0722','7f0e37f0e37f14898082b072297c35', '7ec967f0e37f14998082b0787b06bd','7f07e7f0e47f531b0723b0b6fb0721','7f0e27f1487f531b0b0bb0b6fb0722', '7f0e37f0e366aa89801eb072297c35','7ec967f0e37f14998082b0787b06bd','7f07e7f0e47f149b0723b0787b0721', '7f0e27f1487f531b0b0bb0b6fb0722','7f0e37f0e366aa89801eb072297c35','7ec967f0e37f14998082b0723b06bd', '7f07e7f0e47f149b0723b0787b0721','7f0e27f0e47f531b0723b0b6fb0722','7f0e37f0e366aa89801eb072297c35', '7ec967f0e37f14998082b0723b06bd','7f07e7f0e37f14998083b0787b0721','7f0e27f0e47f531b0723b0b6fb0722', '7f0e37f0e366aa89801eb072297c35','7ec967f0e37f14898082b0723b02d5','7f07e7f0e37f14998082b0787b0721', '7f07e7f0e47f531b0723b0b6fb0722','7f0e36665b66aa89801e9808297c35','665f67f0e37f14898082b0723b02d5', '7ec967f0e37f14998082b0787b0721','7f07e7f0e47f531b0723b0b6fb0722','7f0e36665b66a449801e9808297c35', '665f67f0e37f14898082b0723b02d5','7ec967f0e37f14998082b0787b06bd','7f07e7f0e47f531b0723b0b6fb0721', '7f0e36665b66a449801e9808297c35','665f67f0e37f14898082b072297c35','7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721','7f0e26665b66a449801e9808297c35','665f67f0e37f1489801eb072297c35', '7ec967f0e37f14998082b0787b06bd','7f07e7f0e47f531b0723b0b6fb0721','7f0e27f1487f531b0b0bb0b6fb0722'], 拿1900做例子：9778397bd097c36b0b6fc9274c91aa 五个为一组： 9778397bd097c36b0b6fc9274c91aa 转化为十进制 比如 97783，十进制为 620419（在控制台输入0x97783可以快速得到） 然后按照1：2：1：2的拆分，得到6 20 4 19，说明为正月6号，二月20号，三月4号，四月19号]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oh, I want something just like this]]></title>
    <url>%2F2019-10-26%2Fmusic01.html</url>
    <content type="text"><![CDATA[Something Just Like This – The Chainsmokers,Coldplay Do not mistake coincidence for fate. When grace is lost from life 当生命失去恩宠 come with a burst of song. 请惠我以欢歌 var ap = new APlayer({ element: document.getElementById("aplayer-eVRXHzUO"), narrow: false, autoplay: false, showlrc: false, music: { title: "Something Just Like This", author: "The Chainsmokers,Coldplay", url: "http://pzdbj8uw8.bkt.clouddn.com/something%20just%20like%20this.mp3", pic: "http://pzdbj8uw8.bkt.clouddn.com/something%20just%20like%20this.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); I’ve been reading books of oldThe legends and the mythsAchilles and his goldHercules and his giftsSpider-Man’s controlAnd Batman with his fistsAnd clearly I don’t see myself upon that listBut she said where d’you wanna go?How much you wanna risk?I’m not looking for somebodyWith some superhuman giftsSome superhero, some fairytale blissJust something I can turn to, somebody I can kissI want something just like thisDo do do do do do doDo do do do do do doDo do do do do doOh I want something just like thisDo do do do do doDo do do do do do doDo do do do do doOh I want something just like thisOh I want something just like thisI’ve been reading books of oldThe legends and the mythsThe testaments they toldThe moon and its eclipseSuperman unrollsA suit before he liftsBut I’m not the kind of person that it fitsShe said where d’you wanna go?How much you wanna risk?I’m not looking for somebodyWith some superhuman giftsSome superhero, some fairytale blissJust something I can turn to, somebody I can missOh I want something just like thisDo do do do do doDo do do do do do doDo do do do do doOh I want something just like thisDo do do do do doDo do do do do do doDo do do do do doOh I want something just like thisOh I want something just like thisWhere d’you wanna go?How much you wanna risk?I’m not looking for somebodyWith some superhuman giftsSome superhero, some fairytale blissJust something I can turn to, somebody I can kiss comments It’s not who you are underneath, it’s what you do that defines you Keep your friends close and your enemies closer Be the change you want to see in the world. To remember, to let go, and to move on. DNA decides what we are, but not who we are. What we are never changed, but who we are never stop changing. Don’t mistake coincidence for fate.]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TwoSum 相关问题思路总结]]></title>
    <url>%2F2019-10-26%2Ftwo-sum.html</url>
    <content type="text"><![CDATA[leetcode初见题，不能再熟悉，那K数之和呢？😐 文章收录TwoSum的各种玩法 核心思想这个问题的最基本形式是这样：给你一个数组和一个整数target，可以保证数组中存在两个数的和为target，请你返回这两个数的索引。 比如输入nums = [3,1,3,6],target = 6，算法应该返回数组[0,2]，因为 3 + 3 = 6。 这个问题如何解决呢？首先最简单粗暴的办法当然是穷举了： 这个解法非常直接，时间复杂度 O(N^2)，空间复杂度 O(1)。 更好一点的解法，可以通过一个哈希表减少时间复杂度： 这样，由于哈希表的查询时间为 O(1)，算法的时间复杂度降低到 O(N)，但是需要 O(N) 的空间复杂度来存储哈希表。不过综合来看，是要比暴力解法高效的。 我觉得 Two Sum 系列问题就是想教我们如何使用哈希表处理问题。我们接着往后看。 两种思路对于 TwoSum 类问题，总的来说有两种大的方向，一种方向是借助 Hash 表，另外一种是借助排序，然后利用相向双指针来解决问题，我们分别来看看： Hash表1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; remainValues = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (remainValues.containsKey(target - nums[i])) &#123; int anotherIndex = remainValues.get(target - nums[i]); return new int[] &#123;i, anotherIndex&#125;; &#125; remainValues.put(nums[i], i); &#125; return new int[] &#123;-1, -1&#125;;&#125; 思路很简单，遍历数组，每访问一个元素，先判断其配对的元素是否在 Hash 表中，如果在的话就说明我们找到了答案，将其输出即可，如果没有找到，就将当前的元素放入 Hash 表中，以方便后面的元素来配对。 这里因为题目要求输出元素在数组中的位置，所以用 HashMap 来存储访问过的元素和其对应的 index。 我们再来分析一下其时空复杂度。 由于使用了 Hash 表，空间复杂度是 O(n) 的，另外就是最差的情况，数组中的每个元素都要遍历到，因此时间复杂度也是 O(n)。 从时间上面来看，这个算法肯定是最优的，这很好理解，你要在数组中寻找配对的答案，数组当中的数肯定都需要看一遍。 排序加双指针的思路12345678910111213141516171819202122public int[] twoSum(int[] n, int t) &#123; if (n == null || n.length == 0) &#123; return new int[0]; &#125; Arrays.sort(n); int[] result = new int[2]; int l = 0, r = n.length - 1; while (l &lt; r) &#123; if (n[l] + n[r] == t) &#123; result[0] = n[l]; result[1] = n[r]; return result; &#125; else if (n[l] + n[r] &lt; t) &#123; l++; &#125; else &#123; r--; &#125; &#125; return new int[0];&#125; 这种思路的前提是题目没有要求我们必须输出元素在数组中的位置，因为排序会改变元素在数组中的位置，这里，我们输出元素本身即可。 这里的思路就是一头一尾两个指针。 每次判断的时候，我们将左右两个指针指向的元素加起来的和与我们要找的 target 对比，如果比 target 小，也就是说明如果在左指针不变的情况下，左指针加上左右指针中间的任意一个元素都会比 target 小，这也说明左指针不可能是我们要找的答案，因此向右移动左指针。 如果是加起来和我们要找的 target 对比，比 target 大，分析类似，这时需要将右指针向左移动。 我们来看看这里的时间复杂度，因为做了排序这么一个操作，其时间复杂度就会是O(nlgn) ，对于空间复杂度来说，这里并没有使用额外的空间，因此空间复杂度是常数级的 O(1)。 你有没有想过这两种方法分别比较适合什么样的情况呢，基于 TwoSum 问题，思考下面的变化： 如果题目要求输出所有可能的答案，该怎么处理？ 如果题目要求输出所有可能的答案，并且数组中有重复元素该怎么处理？ 如果题目要求找到比 target 小/大 的配对该怎么处理？ 如果要找出两数之差等于 target 的配对，该如何进行？ TwoSum 的解题思路是否可以拓展到 TreeSum 或者更多的配对？ 上面的问题可能有些你曾想过，有些没有，那么就让我们带着上述的问题来看看具体的例题，熟练地将上述两种方法应用到实际的题目中去。 变形题目分析返回所有可能情况题目描述题目还是 TwoSum，但是这时需要你返回所有可能的情况（不重复），并且数组中允许重复元素的出现。 思考首先我们需要思考的是，使用之前提到的两种方法中的哪一种会比较好。 是不是两种方法都可以，你分析一下会发现其实两种方法都是可行的，和之前的 TwoSum 不一样的是，这时当找到答案后，需要继续寻找，而不是直接返回。 但是由于数组中存在重复元素，因此两种方法里面都需要考虑去重的机制。 对于 Hash 表的方法来说，其实你并不清楚之前是否添加过相同的答案，因此我们考虑使用一个集合去存储答案，保证答案的不重复性； 对于排序的方法来说，去重的方式有所不同，排完序后，相同的元素会挨在一起，对于之前考虑过的元素，我们只需要略过就行，指针的移动很好地保证了这一点。 这里就展示排序实现的方法： 代码实现1234567891011121314151617181920212223242526public List&lt;int[]&gt; twoSum6(int[] nums, int target) &#123; if (nums == null || nums.length &lt; 2) return 0; Arrays.sort(nums); List&lt;int[]&gt; results = new ArrayList&lt;&gt;(); int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int v = nums[left] + nums[right]; if (v == target) &#123; int[] result = &#123;nums[left], nums[right]&#125;; results.add(result); left++; right--; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; right--; &#125; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])&#123; left++; &#125; &#125; else if (v &gt; target) &#123; right--; &#125; else &#123; left++; &#125; &#125; return results;&#125; 小于 K 的两数之和题目描述给你一个整数数组 A 和一个整数 K，请在该数组中找出两个元素，使它们的和小于 K但尽可能地接近 K，返回这两个元素的和。 如不存在这样的两个元素，请返回 -1。 示例 1： 123输入：A = [34,23,1,24,75,33,54,8], K = 60输出：58解释：34 和 24 相加得到 58，58 小于 60，满足题意。 示例 2： 123输入：A = [10,20,30], K = 15输出：-1解释：我们无法找到和小于 15 的两个元素。 思考传统的 TwoSum 都是要你找到等于 target 的配对，那么如果说要找到 大于/小于 target 的配对呢？ 这个时候 Hash 表的方法就很难 work 了，因为 Hash 表比较适合处理 等于 的情况 ！ 那么就需要考虑如何使用排序加双指针的方法来解决这个问题，这里，题目是要求小于 target 的数量，我们还是按照之前的分析思路来分析。 如果说当前左右指针指向的元素的和大于或者等于 target，那么势必我们需要向左移动右指针，让两个元素的和尽可能地小，当前头尾指针指向的元素和小于 target 的时候，这时我们需要记录答案，虽然这道题目里面没提，如果说要记录配对数量的话，这时并不是记录一个答案，如果说当前左指针固定，除了当前的右指针指向的元素，在左指针和右指针之间的数都是满足要求的，我们只需要加上这个区间的数量即可，当然如果数组中存在重复元素，那么我们就需要按照之前的套路遍历去重了，当然对于这道题来说，我们选择满足条件的最大值即可。 代码实现1234567891011121314151617public int twoSumLessThanK(int[] A, int K) &#123; if (A == null || A.length == 0) &#123; return -1; &#125; Arrays.sort(A); int l = 0, r = A.length - 1; int result = Integer.MIN_VALUE; while (l &lt; r) &#123; if (A[l] + A[r] &gt;= K) &#123; r--; &#125; else &#123; result = Math.max(result, A[l] + A[r]); l++; &#125; &#125; return result == Integer.MIN_VALUE ? -1 : result;&#125; 两数之和 III题目描述设计并实现一个 TwoSum 的类，使该类需要支持 add 和 find 的操作。 add 操作 - 对内部数据结构增加一个数。find 操作 - 寻找内部数据结构中是否存在一对整数，使得两数之和与给定的数相等。 示例 1: 123add(1); add(3); add(5);find(4) -&gt; truefind(7) -&gt; false 示例 2: 123add(3); add(1); add(2);find(3) -&gt; truefind(6) -&gt; false 思考题目要求让你实现一个数据结构，这个结构支持 “添加元素” 和 “TwoSum” 两个功能。 这时你需要综合两种方法的优劣性来选择。 首先是 Hash 表的方法，如果使用这个方法，我们不需要考虑太多的东西，元素来了直接扔进数组就行，也就是说 添加元素 操作只需要 O(1) 的时间复杂度就可以完成，但是TwoSum 的完成需要额外 O(n) 的空间； 再来看看排序的方法，因为这里插入元素我们需要保证元素有序，因此 添加元素 需要 O(n) 的时间，但是这里 TwoSum 操作并不需要额外空间，综合来考虑，因为 添加元素和 TwoSum 操作都会比较频繁，因此 Hash 表的方法在时间上面更优。 代码实现① 对于这个解法的时间复杂度呢，add方法是 O(1)，find方法是 O(N)，空间复杂度为 O(N)，和上一道题目比较类似。 但是对于 API 的设计，是需要考虑现实情况的**。**比如说，我们设计的这个类，使用find方法非常频繁，那么每次都要 O(N) 的时间，岂不是很浪费费时间吗？对于这种情况，我们是否可以做些优化呢？ 是的，对于频繁使用find方法的场景，我们可以进行优化。我们可以参考上一道题目的暴力解法，借助哈希集合来针对性优化find方法： 这样sum中就储存了所有加入数字可能组成的和，每次find只要花费 O(1) 的时间在集合中判断一下是否存在就行了，显然非常适合频繁使用find的场景。 ② 123456789101112131415161718192021222324252627private Map&lt;Integer, Integer&gt; elements;private int MAX_VALUE = Integer.MIN_VALUE;private int MIN_VALUE = Integer.MAX_VALUE;/** Initialize your data structure here. */public TwoSum() &#123; elements = new HashMap&lt;&gt;();&#125;/** Add the number to an internal data structure.. */public void add(int number) &#123; elements.put(number, elements.getOrDefault(number, 0) + 1); MAX_VALUE = Math.max(MAX_VALUE, number); MIN_VALUE = Math.min(MIN_VALUE, number);&#125;/** Find if there exists any pair of numbers which sum is equal to the value. */public boolean find(int value) &#123; if (value &lt; 2 * MIN_VALUE || value &gt; 2 * MAX_VALUE) &#123; return false; &#125; for (int i : elements.keySet()) &#123; if (i * 2 == value &amp;&amp; elements.get(i) &gt;= 2) &#123; return true; &#125; else if (i * 2 != value &amp;&amp; elements.containsKey(value - i)) &#123; return true; &#125; &#125; return false;&#125; 三数之和题目描述题目来源于 LeetCode 上第 15 号问题： 三数之和。 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 123456例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]]· 思考三数之和，Hash 表以及排序的思路都是可行的。 但是这里涉及到去重，这里比较推荐的做法是排序加双指针。 思路其实比较直观，确定一个元素，然后去找另外两个元素，这么一来就把 3Sum 转变成了 2Sum 的问题，这里我两个方法都实现了一下，你可以进行参考。 代码实现 排序加双指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// sort + two pointerspublic List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; if (nums == null || nums.length &lt; 3) &#123; return new ArrayList&lt;&gt;(); &#125; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; ++i) &#123; if ((i != 0) &amp;&amp; (nums[i] == nums[i - 1])) &#123; continue; &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); twoSum(results, nums, i + 1, -nums[i]); result = null; &#125; return results;&#125;private void twoSum(List&lt;List&lt;Integer&gt;&gt; results, int[] nums, int startIndex, int target) &#123; int left = startIndex, right = nums.length - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] &gt; target) &#123; right--; &#125; else if (nums[left] + nums[right] &lt; target) &#123; left++; &#125; else &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); result.add(-target); result.add(nums[left]); result.add(nums[right]); results.add(result); left++; right--; while ((left &lt; right) &amp;&amp; (nums[left - 1] == nums[left])) &#123; left++; &#125; while ((right &gt; left) &amp;&amp; (nums[right + 1] == nums[right])) &#123; right--; &#125; &#125; &#125;&#125; 哈希表 12345678910111213141516171819202122232425262728293031323334353637// HashSetpublic List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; if (nums == null || nums.length &lt; 3) &#123; return new ArrayList&lt;&gt;(); &#125; Arrays.sort(nums); Set&lt;List&lt;Integer&gt;&gt; resultsSet = new HashSet&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; ++i) &#123; if ((i != 0) &amp;&amp; (nums[i - 1] == nums[i])) &#123; continue; &#125; Set&lt;Integer&gt; existedValue = new HashSet&lt;&gt;(); for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (!existedValue.contains(nums[j])) &#123; existedValue.add(-nums[j] - nums[i]); &#125; else &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Collections.addAll(result, nums[i], -nums[j] - nums[i], nums[j]); resultsSet.add(result); &#125; &#125; existedValue = null; &#125; results.addAll(resultsSet); return results;&#125; 有效三角形个数题目描述题目来源于 LeetCode 上第 611 号问题：有效三角形的个数。 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。 示例 1: 1234567输入: [2,2,3,4]输出: 3解释:有效的组合是:2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3 注意: 数组长度不超过1000。 数组里整数的范围为 [0, 1000]。 思考题目要求选出三条边，使得这三条边能够构成三角形，咋眼看上去这道题貌似和 TwoSum 没啥关系。 但我们回顾一下中学时期学的东西，三边构成三角形的条件是 任意两边之和大于第三边，那是不是说我们需要把三条边都组合配对考虑一下？其实不用，我们可以得出下面的结论 1a &lt; b &lt; c &amp;&amp; a + b &gt; c =&gt; 三角形 如果已知三条边的大小顺序，那么其实我们只需要比较一次即可。 你再看看这是不是我们熟悉的 TwoSum 变种问题 - 如果题目要求找到比 target 小/大 的配对该怎么处理？ 这个时候我们从右往左选定 c ，然后使用 TwoSum 来找出 a 、b 即可，由于题目只要求输出个数，那么就按照之前讲的思路，直接相加即可。 代码实现12345678910111213141516171819public int triangleCount(int[] S) &#123; if (S == null || S.length == 0) &#123; return 0; &#125; Arrays.sort(S); int result = 0; for (int i = S.length - 1; i &gt;= 2; --i) &#123; int l = 0, r = i - 1; while (l &lt; r) &#123; if (S[i] &lt; S[l] + S[r]) &#123; // S[i] &lt; S[l] + S[r] &amp;&amp; S[i] &gt; S[r] &gt; S[l] result += r - l; // 直接加上可能的个数 r--; &#125; else &#123; l++; &#125; &#125; &#125; return result;&#125; 四数之和题目描述题目来源于 LeetCode 上第 18 号问题： 四数之和。 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思考4Sum 的思路和 3Sum 的思路是一样的，只不过这时我们需要先将其转换成 3Sum 来处理，其实就是比 3Sum 多了一次选择。 原先是三数之和为0，然后转化成c = -a-b 的形式 现在是四数之和为target，也是类似的做法，不简单😷 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; if (nums.length &lt; 4) &#123; return new ArrayList&lt;&gt;(); &#125; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 3; ++i) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; List&lt;List&lt;Integer&gt;&gt; subResults = threeSum(nums, i + 1, target - nums[i]); for (List&lt;Integer&gt; res : subResults) &#123; res.add(nums[i]); results.add(res); &#125; &#125; return results;&#125;private List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums, int start, int target) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = start; i &lt; nums.length - 2; ++i) &#123; if (i != start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; List&lt;List&lt;Integer&gt;&gt; res = twoSum(nums, i + 1, target - nums[i]); for (List&lt;Integer&gt; r : res) &#123; r.add(nums[i]); results.add(r); &#125; &#125; return results;&#125;private List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int start, int target) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); int l = start, r = nums.length - 1; while (l &lt; r) &#123; if (nums[l] + nums[r] &lt; target) &#123; l++; &#125; else if (nums[l] + nums[r] &gt; target) &#123; r--; &#125; else &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); result.add(nums[l]); result.add(nums[r]); results.add(result); r--; l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) &#123; r--; &#125; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) &#123; l++; &#125; &#125; &#125; return results;&#125; 两数之差题目描述给定一个 target，求出两数之差等于 target 的情况。 思考如果使用 Hash 表的做法，对于传统的 TwoSum，我们找到的答案是满足等式: 1num1 + num2 = target 因此这个时候判断的时候，我们只需要判断 target - nums 在不在 Hash 表中即可，对于两数之差的话，我们找到的答案是满足等式： 1num1 - num2 = target or num2 - num1 = target 在这种情况下，我们需要判断 target + num 以及 num - target 即可，也就是相比之前，判断条件不同且多了一个。 如果是使用排序加双指针的方法呢？这其实是个打破思路局限的很好例子，这个时候我们需要用到同向双指针了，两个指针均从左向右移动，一前一后，用右边的减去左边的差值来和 target 做比较，如果小了，移动右指针，大了，移动左指针，等于，输出答案。 代码实现123456789101112131415161718192021222324public int[] twoDiff(int[] n, int t) &#123; if (n == null || n.length == 0) &#123; return new int[0]; &#125; Arrays.sort(n); int[] result = new int[2]; int l = 0, r = 1; while (r &lt; n.length) &#123; if (l == r) &#123; r++; &#125; if (n[r] - n[l] == t) &#123; result[0] = n[l]; result[1] = n[r]; return result; &#125; else if (n[r] - n[l] &lt; t) &#123; r++; &#125; else &#123; l++; &#125; &#125; return new int[0];&#125; 总结TwoSum 相关的问题就分析到这里，非常有趣的一点是，TwoSum 不仅可以扩展成 3Sum，4Sum，它也可以扩展为 KSum， 但是这里就需要用到动态规划的知识了，暂不在这里讨论。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用「栈」实现「队列」/ 用「队列」实现「栈」]]></title>
    <url>%2F2019-10-26%2Fstack-queue.html</url>
    <content type="text"><![CDATA[复习栈跟队列的同时，再拓展两者的转换方法 队列是一种先进先出的数据结构，栈是一种先进后出的数据结构 栈与队列的异同点 用栈实现队列首先，队列的 API 如下： 12345678910class MyQueue &#123; /** 添加元素到队尾 */ public void push(int x); /** 删除队头的元素并返回 */ public int pop(); /** 返回队头元素 */ public int peek(); /** 判断队列是否为空 */ public boolean empty();&#125; 我们使用两个栈s1, s2就能实现一个队列的功能（这样放置栈可能更容易理解）： 123456789class MyQueue &#123; private Stack&lt;Integer&gt; s1, s2; public MyQueue() &#123; s1 = new Stack&lt;&gt;(); s2 = new Stack&lt;&gt;(); &#125; // ...&#125; 当调用push让元素入队时，只要把元素压入s1即可，比如说push进 3 个元素分别是 1,2,3，那么底层结构就是这样： 1234/** 添加元素到队尾 */public void push(int x) &#123; s1.push(x);&#125; 那么如果这时候使用peek查看队头的元素怎么办呢？按道理队头元素应该是 1，但是在s1中 1 被压在栈底，现在就要轮到s2起到一个中转的作用了： 当s2为空时，可以把s1的所有元素取出再添加进s2，这时候s2中元素就是先进先出顺序了。 12345678/** 返回队头元素 */public int peek() &#123; if (s2.isEmpty()) // 把 s1 元素压入 s2 while (!s1.isEmpty()) s2.push(s1.pop()); return s2.peek(); //这里调用的是栈本身的方法peek()&#125; 同理，对于pop操作，只要操作s2就可以了。 123456/** 删除队头的元素并返回 */public int pop() &#123; // 先调用 peek 保证 s2 非空 peek(); return s2.pop(); //这里调用的是栈本身的方法pop()&#125; 最后，如何判断队列是否为空呢？如果两个栈都为空的话，就说明队列为空： 1234/** 判断队列是否为空 */public boolean empty() &#123; return s1.isEmpty() &amp;&amp; s2.isEmpty();&#125; 至此，就用栈结构实现了一个队列，核心思想是利用两个栈互相配合。 值得一提的是，这几个操作的时间复杂度是多少呢？其他操作都是 O(1)，有点意思的是peek操作，调用它时可能触发while循环，这样的话时间复杂度是 O(N)，但是大部分情况下while循环不会被触发，时间复杂度是 O(1)。由于pop操作调用了peek，它的时间复杂度和peek相同。 像这种情况，可以说它们的最坏时间复杂度是 O(N)，因为包含while循环，可能需要从s1往s2搬移元素。 但是它们的均摊时间复杂度是 O(1)，这个要这么理解：对于一个元素，最多只可能被搬运一次，也就是说peek操作平均到每个元素的时间复杂度是 O(1)。 用队列实现栈如果说双栈实现队列比较巧妙，那么用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构。首先看下栈的 API： 12345678910class MyStack &#123; /** 添加元素到栈顶 */ public void push(int x); /** 删除栈顶的元素并返回 */ public int pop(); /** 返回栈顶元素 */ public int top(); /** 判断栈是否为空 */ public boolean empty();&#125; 先说pushAPI，直接将元素加入队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要top查看栈顶元素的话可以直接返回： 12345678910111213141516class MyStack &#123; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int top_elem = 0; /** 添加元素到栈顶 */ public void push(int x) &#123; // x 是队列的队尾，是栈的栈顶 q.offer(x); //这里调用的是队列本身具有的入队方法 top_elem = x; &#125; /** 返回栈顶元素 */ public int top() &#123; return top_elem; &#125;&#125; 我们的底层数据结构是先进先出的队列，每次pop只能从队头取元素；但是栈是后进先出，也就是说popAPI 要从队尾取元素。 解决方法简单粗暴，把队列前面的都取出来再加入队尾，让之前的队尾元素排到队头，这样就可以取出了： 12345678910/** 删除栈顶的元素并返回 */public int pop() &#123; int size = q.size(); while (size &gt; 1) &#123; q.offer(q.poll()); // 这里调用的是队列本身具有的出/入队方法 size--; &#125; // 之前的队尾元素已经到了队头 return q.poll();&#125; 这样实现还有一点小问题就是，原来的队尾元素被提到队头并删除了，但是top_elem变量没有更新，我们还需要一点小修改： 1234567891011121314/** 删除栈顶的元素并返回 */public int pop() &#123; int size = q.size(); // 留下队尾 2 个元素 while (size &gt; 2) &#123; q.offer(q.poll()); size--; &#125; // 记录新的队尾元素 top_elem = q.peek(); q.offer(q.poll()); // 删除之前的队尾元素 return q.poll();&#125; 最后，API empty就很容易实现了，只要看底层的队列是否为空即可： 1234/** 判断栈是否为空 */public boolean empty() &#123; return q.isEmpty();&#125; 很明显，用队列实现栈的话，pop 操作时间复杂度是 O(N)，其他操作都是 O(1)。 个人认为，用队列实现栈没啥亮点，但是用双栈实现队列是值得学习的。 出栈顺序本来就和入栈顺序相反，但是从栈s1搬运元素到s2之后，s2中元素出栈的顺序就变成了队列的先进先出顺序，这个特性有点类似「负负得正」，确实不容易想到。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DataStructure</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT 圈里的这些词你读对了吗？]]></title>
    <url>%2F2019-10-25%2Fpronounciation.html</url>
    <content type="text"><![CDATA[这次在逼乎上看到有大佬分享一些常用词汇的读法，日常阅读提升自我。 活到老，学到老 公司/产品名 Youtube (You-tube [tju:b]) 念 优tiu啵 不念 优吐毙 Skype [ˈskaɪp] 念 死盖破 不念 死盖屁 Adobe [əˈdəʊbi] 念 阿兜笔 不念 阿斗伯 Chrome [krəʊm] 念 克肉姆 C# (C Sharp) 念 C煞破 GNU [(g)nuː] 念 哥怒 GUI [ˈɡui] 念 故意 JAVA [ˈdʒɑːvə] 念 扎蛙 不念 夹蛙 AJAX [ˈeɪdʒæks] 念 诶(ei)贾克斯 不念 阿贾克斯 Ubuntu [uˈbuntuː] 念 巫不恩兔 不念 友邦兔 Debian [ˈdɛbiən] 念 得(dei)变 Linux [ˈlɪnəks] [ˈlɪnʊks] 两种发音 丽娜克斯 和 李扭克斯 都可以 LaTeX [ˈleɪtɛk] [ˈleɪtɛx] [ˈlɑːtɛx] [ˈlɑːtɛk] 雷泰克，拉泰克 都可以 （根据Knuth的建议，雷泰克斯和拉泰克斯不正确。而且LaTeX的重音是放在雷或拉上。感谢@Rio讨论。另外感谢发音大牛@梁海刚刚指出， [ˈlɑːtɛx] 注音符号里的x发的不是克斯的音，而是接近“巴赫”的那个赫。） GNOME [ɡˈnoʊm] [noʊm] 两种发音 格弄姆 弄姆 都可以 App [ˈæp] 念阿破（与爱破也比较像，参见音标），不能把三个字母拆开念成A P P Tumblr (Tumbler) 念 贪不勒 一般英语 null [nʌl] 念 闹 jpg [ˈdʒeɪpɛɡ] 念 zhei派个 不念 勾屁记 WiFi [ˈwaɪfaɪ] 念 歪fai mobile [moˈbil] [ˈmoˌbil] [ˈməubail] 膜拜哦 和 牟bou 都可以 integer [ˈɪntɪdʒə] 念 音剃摺儿 不念 阴太阁儿 cache [kæʃ] 念 喀什 不念 卡尺 @ 念 at nginx (Engine X)念 恩静 爱克斯（@Lawrence Li有不同意见） Apache [əˈpætʃiː] 念 阿趴气 Lucene [ˈluːsin] 念 鲁信 MySQL [maɪ ˌɛskjuːˈɛl] [maɪ ˈsiːkwəl] 念 买S奎儿 或 买吸扣 都可以 Exposé [ɛksˈpəʊzeɪ] 念 埃克斯剖Z （重音在Z上） RFID 【本条争议颇大】：有人念af rid, ri fid，但是RFID官方念法依然是四个字母分开读R F I D JSON (jason) 念 zhei森Processing [ˈprəʊsesɪŋ] 重音在Pro上 avatar [ˌævə’tɑr] 念 艾瓦塌儿]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.1 + 0.2 != 0.3 ? 为什么？该如何正确回答？]]></title>
    <url>%2F2019-10-25%2FWeirdMathInJs.html</url>
    <content type="text"><![CDATA[关于JavaScript中0.1 + 0.2 != 0.3的结果深入人心，但是原理 🐴 像这种变态的问题，在 JS 中存在很多 在解决0.1+0.2的问题之前，我们先来聊一聊js中的基本类型 基本类型的分类JS 的基本类型分为两大类型，分别为原始类型和对象类型。 原始类型包括哪些？对象类型包括哪些？为什么要这样分类？他们的区别又是什么？ 原始类型存储的都是值，而对象类型存储的都是地址。如下图： 1234let i = 2;let a = 'hello';let j = i;let b = a; 12let obj1 = new Object();let obj2 = obj1; 如上图所示，我们清楚了原始类型和对象类型最根本的区别，那么问题又来了，当我们进行变量之间赋值的时候，原始类型直接赋值的是值，而对象类型赋值的是地址。 所以，当我们将对象作为参数进行传递的时候，在函数内改变的是该地址指向的对象，而传递的参数是原始类型，则改变的是一个副本（复制的另一个值）。也就是说，如果是对象，则改变了原始的值，而不能改变原始类型原始的值。 原始类型共六种，分别为String、Number、Boolean、null、undefined、symbol。 null对于null有一个历史存留的 bug，null是对象类型吗？虽然我们使用 typeof 检测null是对象类型，这其实是一个 bug。 typeof null == Object 😑 bug的原因因为 JS 最初的版本是 32 位系统的，为了将性能将用低位存储变量类型信息，000 开头表示代表的是对象，此时null表示全零，所以系统就错误的将null判断为对象类型。虽然 JS 内部判断代码已经更改，但是这个 bug 一直留存下来。 null 出现的情况汇总 手动设置变量的值或者对象某一个属性值为null（此时不赋值，后边会赋值）。 在 JS 的 DOM 元素获取中，如果没有获取到指定的元素对象，结果一般都是null。 Object.prototype._proto_的值也是null。 正则捕获的时候，如果没有获取到结果，默认的也是null。 symbol有关symbol使用的比较少，但是它的存在是有原因的。 symbol是什么symbol表示独一无二的值，因为由于对象的属性都是字符串类型，我们避免不了相同字符串冲突的问题。所以为了防止对象的属性都是字符串类型而冲突引入的。 symbol的使用1234567891011 // 通常参数是字符串类型，如果为对象类型，就会调用 toString 方法 let s1 = Symbol(参数);// 这个参数可以认为是 Symbol 实例的一个描述,用于区分 // 第一种写法 let a = &#123;&#125;; a[s1] = 'Hello!'; // 第二种写法 let a = &#123; [s1] = 'Hello';&#125; undefinedundefined出现的情况 变量提升: 只声明未定义默认值就是undefined。 严格模式下：没有明确的执行主体,this就是undefined。 对象没有这个属性名，属性值是undefined。 函数定义形参不传值，默认就是undefined。 函数没有返回值（没有return或者return;），默认返回的就是 undefined。 为什么有的编程规范要求用 void 0 代替 undefinedUndefined 类型表示未定义，它的类型只有一个值，就是 undefined。 任何变量在被赋值前它的值都是 undefined，但是在 JavaScript 引擎中，undefined 是一个变量而非关键字。在旧的浏览器中，全局变量 undefined 可以被重写 12345678/** * IE8 浏览器 */var value;console.log(value === undefined); //true// 重写 undefinedundefined = 'hi';console.log(value === undefined); //false 从上面的例子可知，在旧的浏览器下如果 undefined 被重写为非 undefined 值，那么它就无法用来正确检测一个变量是否被赋值。 这个问题在 ECMAScript 5 中被修复了，在实现了 ECMAScript 5 规范的浏览器中运行以下代码。 1234/** * Chrome 浏览器 */ Object.getOwnPropertyDescriptor(window, undefined); //运行结果：&#123;"writable":false,"enumerable":false,"configurable":false&#125; 从上面的运行结果可知，全局变量 undefined 的 writable 属性是 false，也就是不可写。 voidvoid 运算符对给定的表达式进行求值，会忽略计算结果并始终返回 undefined。 12345var value1 = 'hi';console.log(value1); //"hi"var value2 = void 'hi';console.log(value2); //undefined 因此，我们可以利用这一点准确地获取预期的 undefined 值。 123var value;console.log(value === void 0); //trueconsole.log(value === void(0)); //true 为什么 0.1 + 0.2 != 0.3 ?120.1 + 0.2 &gt; 0.3 // true0.1 * 0.1 = 0.010000000000000002 是什么导致了这种情况？原因很简单，JS 采用的是双精度版本，这个版本就存在精度问题，就导致了上边这种情况。 内部的原理是什么？我们计算机的信息全部转化为二进制进行存储的，那么0.1的二进制表示的是一个无限循环小数，该版本的 JS 采用的是浮点数标准需要对这种无限循环的二进制进行截取，从而导致了精度丢失，造成了0.1不再是0.1，截取之后0.1变成了 0.100...001，0.2变成了0.200...002。所以两者相加的数大于0.3。 那好，既然0.1不等于0.1了，那为什么我在控制台上输出console.log(0.1)还等于0.1呢？ 因为在输入内容进行转换的时候，二进制转换成十进制，然后十进制转换成字符串，在这个转换的过程中发生了取近似值，所以打印出来的是一个近似值。 深入原理计算机内部如何表示数1. 计算机内部如何表示整数这里以十进制数13来展示“按位计数法”如何表示整数： 十进制值 进制 按位格式 描述 13 10 13 1x10^1 + 3x10^0 = 10 + 3 13 2 1101 1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1 2. 计算机内部如何表示小数再看小数怎么用按位计数法表示，以十进制数0.625为例： 十进制值 进制 按位格式 描述 0.625 10 0.625 6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005 0.625 2 0.101 1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8 3. 如何用二进制表示0.1关于十进制与二进制间如何转换，这里不细说，直接给出结论： 十进制整数转二进制方法：除2取余；十进制小数转二进制方法：乘2除整 十进制0.1转换成二进制，乘2取整过程： 123456780.1 * 2 = 0.2 # 00.2 * 2 = 0.4 # 00.4 * 2 = 0.8 # 00.8 * 2 = 1.6 # 10.6 * 2 = 1.2 # 10.2 * 2 = 0.4 # 0..... 从上面可以看出，0.1的二进制格式是：0.0001100011….。这是一个二进制无限循环小数，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？ 答案是：在某个精度点直接舍弃。当然，代价就是，0.1在计算机内部根本就不是精确的0.1，而是一个有舍入误差的0.1。当代码被编译或解释后，0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于0.3 的原因。 有误差的两个数，其计算的结果，当然就很可能与我们期望的不一样了。注意前面的这句话中的“很可能”这三个字？为啥是很可能昵？ 0.1 + 0.1 为什么等于0.2答案是：两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。 又如，对于 0.1 + 0.3 ，结果其实并不是0.4，但0.4是最接近真实结果的数，比其它任何浮点数都更接近。许多语言也就直接显示结果为0.4了，而不展示一个浮点数的真实结果了。 另外要注意，二进制能精确地表示位数有限且分母是2的倍数的小数，比如0.5，0.5在计算机内部就没有舍入误差。所以0.5 + 0.5 === 1 前方高能 上图是IEEE对浮点数表示的说明，这里分单精度与双精度之分，如下图： 对于单精度浮点数，采用32位存储，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。对于双精度浮点数，采用64位存储，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。在单精度浮点格式中，s、exp和frac字段分别为 1 位、k = 8 位和 n = 23 位，得到一个 32 位的表示。 在双精度浮点格式(C 语言中的 double)中，s、exp 和 frac 字段分别为 1 位、k = 11 位和 n = 52 位，得到一个 64 位的表示。 根据 exp 的值，被编码的值可以分成三种不同的情况(最后一种情况有两 个变种)。下图说明了对单精度格式的情况。 情况1:格式化的值 情况2:非格式化的值 情况3:特殊值 好了，下面我们重点关注一下情况1，并举例来看，不然实在头大啊。以单精度举例。 浮点数转换为二进制浮点数转换成二进制，我们要将整数部分和小数部分分开，整数部分采用除2取余，小数部分采用乘2取整。例如，13.125 转换为二进制：1.整数部分 1234567891011121314 13 ÷ 2-------------- ↑ 6 1 | ÷ 2 |-------------- | 3 0 | ÷ 2 |-------------- | 1 1 | ÷ 2 |-------------- | 0 1 ---- 逆序将余数拼上得到13的二进制：1101 2.小数部分 12345678910 0.125 x 2 --------------------- | 0.25 0 | x 2 |----------------- | 0.5 0 | x 2 |----------------- | 1.0 1 ↓ 得到小数部分的二进制：0.001 两部分相加，得到13.125的二进制：1101.001 好了，到现在，我们知道了如何将浮点数转换为二进制表示，也知道了IEEE中浮点数的存储方式，那么，我们接下来用13.125这个例子来看看计算机中具体是如何表示的呢。 二进制 1101.001可以写成 1.101001 * 2^3，即这里 M 为 1.101001,E为3,s为0。单精度下，符号位s即为0,阶码字段exp的值e=E+127，即e=3+127=130，130的二进制表示为10000010小数字段，frac为尾数M的二进制，即1.101001那么，在单精度下，计算机中的表示为： 1230 10000010 101001 00000000000000000-------------------------------------s exp frac 0.1+0.2好了，关于浮点数转换二进制，以及浮点数的表示我们都知道了，那么，现在我们来看看，为什么 0.1+0.2!=0.3的吧。首先，我们还是先看看js里到底输出多少吧： 12&gt; 0.1+0.20.30000000000000004 0.1的二进制1234567891011121314151617 0.1x 2------- 0.2 0x 2------- 0.4 0x 2------- 0.8 0x 2------- 0.6 1x 2------- 0.2 1------- 又从0.2开始循环了 于是，我们得到了0.1的二进制表示，即为0.0001100110011(0011循环)，即1.100110011(0011)*2^-4即，M 1.100110011(0011),E -4,那么，s=0,e=-4+1023=1019,那么，js中由于是双精度的，那么0.1的表示为： 1230 01111111011 1001100110011001100110011001100110011001100110011001--------------------------------------------------------------------s exp(11位) frac(52位) 0.2的二进制1234567891011121314 0.2x 2------- 0.4 0x 2------- 0.8 0x 2------- 0.6 1x 2------- 0.2 1------- 又从0.2开始循环了 0.2的二进制表示：0.001100110011(0011循环)，即1.100110011(0011)*2^-3那么，js双精度0.2的表示： 10 01111111100 1001100110011001100110011001100110011001100110011001 浮点数运算浮点数的加减运算一般由以下五个步骤完成： 对阶 尾数运算 结果规格化 舍入处理 溢出判断 对阶将两个进行运算的浮点数的阶码对齐的操作。对阶的目的是为使两个浮点数的尾数能够进行加减运算。因为，当进行Mx·2Ex与My·2Ey加减运算时，只有使两浮点数的指数值部分相同，才能将相同的指数值作为公因数提出来，然后进行尾数的加减运算。对阶的具体方法是：首先求出两浮点数阶码的差，即⊿E＝Ex-Ey，将小阶码加上⊿E，使之与大阶码相等，同时将小阶码对应的浮点数的尾数右移相应位数，以保证该浮点数的值不变。几点注意： （1）对阶的原则是小阶对大阶，之所以这样做是因为若大阶对小阶，则尾数的数值部分的高位需移出，而小阶对大阶移出的是尾数的数值部分的低位，这样损失的精度更小。 （2）若⊿E＝0，说明两浮点数的阶码已经相同，无需再做对阶操作了。 （3）采用补码表示的尾数右移时，符号位保持不变。 （4）由于尾数右移时是将最低位移出，会损失一定的精度，为减少误差，可先保留若干移出的位，供以后舍入处理用。 尾数运算尾数运算就是进行完成对阶后的尾数相加减。这里采用的就是我们前面讲过的纯小数的定点数加减运算。 结果规格化在机器中，为保证浮点数表示的唯一性，浮点数在机器中都是以规格化形式存储的。对于IEEE754标准的浮点数来说，就是尾数必须是1.M的形式。由于在进行上述两个定点小数的尾数相加减运算后，尾数有可能是非规格化形式，为此必须进行规格化操作。 规格化操作包括左规和右规两种情况。 左规操作：将尾数左移，同时阶码减值，直至尾数成为1.M的形式。例如，浮点数0.0011·25是非规格化的形式，需进行左规操作，将其尾数左移3位，同时阶码减3，就变成1.1100·22规格化形式了。 右规操作：将尾数右移1位，同时阶码增1，便成为规格化的形式了。要注意的是，右规操作只需将尾数右移一位即可，这种情况出现在尾数的最高位（小数点前一位）运算时出现了进位，使尾数成为10.xxxx或11.xxxx的形式。例如，10.0011·25右规一位后便成为1.00011·26的规格化形式了。 舍入处理浮点运算在对阶或右规时，尾数需要右移，被右移出去的位会被丢掉，从而造成运算结果精度的损失。为了减少这种精度损失，可以将一定位数的移出位先保留起来，称为保护位，在规格化后用于舍入处理。 IEEE754标准列出了四种可选的舍入处理方法： （1）就近舍入（round to nearest） 这是标准列出的默认舍入方式，其含义相当于我们日常所说的“四舍五入”。例如，对于32位单精度浮点数来说，若超出可保存的23位的多余位大于等于100…01，则多余位的值超过了最低可表示位值的一半，这种情况下，舍入的方法是在尾数的最低有效位上加1；若多余位小于等于011…11，则直接舍去；若多余位为100…00，此时再判断尾数的最低有效位的值，若为0则直接舍去，若为1则再加1。 （2）朝+∞舍入（round toward +∞） 对正数来说，只要多余位不为全0，则向尾数最低有效位进1；对负数来说，则是简单地舍去。 （3）朝-∞舍入（round toward -∞） 与朝+∞舍入方法正好相反，对正数来说，只是简单地舍去；对负数来说，只要多余位不为全0，则向尾数最低有效位进1。 （4）朝0舍入（round toward 0） 即简单地截断舍去，而不管多余位是什么值。这种方法实现简单，但容易形成累积误差，且舍入处理后的值总是向下偏差。 溢出判断与定点数运算不同的是，浮点数的溢出是以其运算结果的阶码的值是否产生溢出来判断的。若阶码的值超过了阶码所能表示的最大正数，则为上溢，进一步，若此时浮点数为正数，则为正上溢，记为+∞，若浮点数为负数，则为负上溢，记为-∞；若阶码的值超过了阶码所能表示的最小负数，则为下溢，进一步，若此时浮点数为正数，则为正下溢，若浮点数为负数，则为负下溢。正下溢和负下溢都作为0处理。 计算0.1+0.20.1的阶码-4,0.2的阶码-3,对阶阶段，将0.1的阶码变为-3，然后0.1的尾数部分： 11100110011001100110011001100110011001100110011001100 可能会有人问，这里最高位怎么是1，移位后不应该是0么，别忘了，尾数部分我们隐含了一个最高位是1的条件，因此，移位后，会将该位一并移过来。将其与0.2的尾数部分进行相加： 1234 1100110011001100110011001100110011001100110011001100+ 1001100110011001100110011001100110011001100110011001 ---------------------------------------------------- 100110011001100110011001100110011001100110011001100111 注意，这里计算时，进位2位，去除原来最高位默认的1，相当于阶码部分加1，即由原来的-3变为-2，那么，阶码部分的表示： 11111111101 而尾数部分，去除最高位1，最后一位1，进行舍入，得到52位新的二进制表示： 10011001100110011001100110011001100110011001100110100 即，最后计算的结果如下： 10 01111111101 0011001100110011001100110011001100110011001100110100 该数表示的即0.1+0.2的结果 2^-2 * 1.0011001100110011001100110011001100110011001100110100将其转换成十进制数为：0.3000000000000000444089209850062616169452667236328125由于精度问题，只取到0.30000000000000004 到这里，就把所有的推演过程所需要的知识补充完整了，在推演的过程中，真心觉得，人工推演二进制真累啊，十分感谢计算机前辈，设计出方案并实践于计算机，感谢。 Number.EPSILONNumber.EPSILON是在Number对象上面，新增一个极小的常量。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数(double)来说，大于 1 的最小浮点数相当于二进制的 1.00..001 ，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的-52 次方。Number.EPSILON 实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是 JS 原型和原型链?]]></title>
    <url>%2F2019-10-25%2Fprototype.html</url>
    <content type="text"><![CDATA[搞懂 JS 的继承机制思想（原型和原型链）。 转自小鹿动画学编程 写在前面在我初学 JS 语言的继承机制原型和原型链的时候，我一直理解不了这种设计机制，再加上之前原有对 Java继承的理解，在学习 JS 继承机制的设计上踩了一个大坑，很多知识点前期都是死记硬背，无法真正的理解它的设计思想。 JS 中的继承机制思想可以说是学习 JS 的一个核心思想，更可以说是 JS 中的一个命脉，往往这些复杂、抽象的继承关系，以及专业术语、代名词确成为了困扰初学者的绊脚石。当我真正理解它的设计思想时，其实并没有那么复杂，而且觉得非常简单。 在写这篇 JS 的原型和原型链的文章之前，我在谷歌搜索检索了大量的高赞有关 JS 原型和原型链的文章，大部分都是围绕着“是什么”来讲的，导致部分初学者缺少对 JS 继承的设计与实现的前后关联性，还是很难准确的去理解。 我们先要明白，学习这块内容知识要知道设计者“ 为什么这样做 ” 远比 “怎么做的” 重要的多这才是掌握这部分内容的关键。 js的发展史要想贯彻 JS 的核心设计思想，我们要从 JS 的诞生说起。 为什么会诞生 JavaScript ？相对比较成熟的浏览器是由网景公司发布的，早些年间，浏览器只能浏览网页内容，而不能进行用户交互。比如我们登录输入用户名和密码，在浏览器是不能进行判断用户是否真正输入了，而是通过服务器来判断，如果没有输入，返回错误提示用户，这种设计非常的浪费时间和服务器资源。 为了解决这个问题，网景公司需要开发一种运行在浏览器中的脚本语言，用来简单的做用户输入校验等操作。 当时最流行的语言是面向对象的Java编程语言 ，网景公司为了能够借助 Java将浏览器脚本语言流传开，所以起名 JavaScript。其实两者没有任何的关系。 存在的问题JS 中的数据类型设计受当时 Java流行的影响，都是对象类型，这时候就遇到问题了，有对象必然涉及到继承机制，那么 JS 的继承机制要设计成 Java一样呢？还是另有设计思想？ js继承的设计思想JS 的开发者想如果设计成像 Java一样有“类”的概念岂不是和 Java一样成为了一种完全面向对象的编程语言了？最后决定自己设计一种继承机制，但是它的设计思想还是采用了 Java的一些特性。 生成对象通常 Java 生成对象是通过 new 的方式，通过类生成一个实例对象的过程。但是 JS 中并没有类，那 JS 的设计者要怎么做？ 12//new 一个新对象Dog dog = new Dog('冬冬') 他找到了 Java 和 JS 的共同点就是两者都有构造函数， Java的 new 的过程内部其实调用了构造函数。但是 JS 是没有“类”的概念的，于是 JS 就把new 一个“类”设计成了 new 一个构造函数，于是构造函数成为了一个实例对象的原型对象。 123456789// 构造函数function Dog(name,weight) &#123; this.name = name; this.weight = weight; this.type = '犬类'&#125;// new 一个新对象var dog1 = new Dog('冬冬',20)var dog2 = new Dog('春春',25) 为什么要设计原型对象上述这样的原型设计有一个致命的缺点就是无法共享公共属性。 因为我们知道，每 new 一个对象，生成的实例是两个不同的对象。所以共有的属性也不是共享的。 1dog1.type == dog2.type // false 所以要设计一个对象专门用来存储对象共享的属性，那么我们叫它「原型对象」。 什么是原型对象要想让构造函数生成的所有实例对象都能够共享属性，那么我们就给构造函数加一个属性叫做prototype，用来指向原型对象，我们把所有实例对象共享的属性和方法都放在这个构造函数的prototype属性指向的原型对象中，不需要共享的属性和方法放在构造函数中。 这里有一点疑惑就是，我们知道对象可以设置属性，函数也可以设置属性吗？对于初学者来说是比较懵逼的，那我们可以稍微的简单说一下： JavaScript 中的函数拥有对象的所有能力，也因此可被称作为任意其他类型对象来对待。当我们说函数是第一类对象的时候，就是说函数也能够对象的一些功能，比如添加属性，函数当做参数传递等。 所以说，实例对象一旦通过构造函数创建，就会自动给实例对象赋值上原型对象上共享的属性或方法。说清楚一点就是该对象属性都指向了原型对象的属性值。 对象和函数在原型链关系？ 上述的图反映了对象以及函数在原型链中的关系，我们文章的开头也说了什么是原型对象，说白了就是构造函数的一个 prototype属性，这个属性就指向原型对象。 其实我们其中一些连接属性没有讲到，只讲到了prototype属性，下面一张图来将剩下的属性补充完整，我们只要把这张图印到大脑中就可以了。 构造函数有prototype属性，构造函数的prototype指向其原型对象，而由构造函数实例出来的对象比如豆豆跟贝贝，这些实例对象拥有proto属性，指向的也是原型对象，也就是他们的构造函数的原型对象 而原型对象有一个constructor属性指回构造函数 我们来分析一下上图，首先我们先要声明一个狗的构造函数，定义其名字和体重属性（私有属性）,同时每个构造函数我们上边讲到了，都会有一个prototype属性。 这个prototype指向的就是原型对象，原型对象放的就是对象共享的属性。但是注意，原型对象里有一个constructor属性，这个属性又指回了构造函数。 我们通过 new 构造函数生成两个狗的对象实例，一个叫豆豆，一个叫贝贝，这两个是两个不同的对象，名字体重都不相同，但是他们会共享原型对象上的属性 type，它们共有的属性都是犬类。 在 JS 所有对象中，只要是对象，都会有一个内置属性叫做_proto_，而且这个属性是系统自动生成的，只要你创建一个对象，这个对象就有这个属性。这个_proto_属性指向的是原型对象。 通过上边的分布讲解，我们明白了构造函数与对象实例以及原型对象的关系。 总结为一句话为： 构造函数的 prototype 指向原型对象，原型对象有一个 constructor 属性指回构造函数，每个构造函数生成的实例对象都有一个 proto 属性，这个属性指向原型对象。 没错，原型就是这么简单。但是你会发现，原型也是对象呀，你说只要是对象都会有一个_proto_属性指向自身构造函数的原型对象。 没错，要想知道原型对象的_proto_属性指向谁，就要知道是哪个构造函数创建了原型对象？🙄 我们知道，所有的 JS 对象的都是继承了一个叫做 Object 的对象。可以理解为Object 构造函数创造了这个万物，他们的关系如下，和上边是同样的道理，上边总结的那句话好好理解一下。 但是上图中会有一个疑问，Object 构造函数原型对象的也是对象，它肯定也有一个_proto_属性，为什么会指向 null 呢？ 我们在拿上述总结的那句话，_proto_属性指向的是自身构造函数的原型对象，自身的构造函数是谁？是 Object 构造函数，那 Object构造函数的原型是谁？当然是本身（如图），所以把_proto_指向了null。 原型链我们还有一个问题没有解决就是原型链？既然我么你知道什么是原型了，原型链是什么？顾名思义，肯定是一条链，既然每个对象都有一个_proto_属性指向原型对象，那么原型对象也有_proto_指向原型对象的原型对象，直到指向上图中的null，这才到达原型链的顶端。 不要忘了，上边那种图我们还没有把它理解，我们把图自上而下理解 f1，f2属于实例，他们的proto指向构造函数function Foo()的prototype，那就是Foo.prototype 不要混，构造函数的prototype就是原型，就是它的点prototype，而不是它的构造函数的prototype，所以要看好操作对象是构造函数还是实例对象（这段话可以当我没说❌） 我们继续向下分割，看第二张图。 第三张图，稍微绕个弯子 看着还是眼熟，只不过把function换成了Function，f 变成了大写的 F，这里涉及到一个知识点就是，在 JS 中，所有的 function函数都是由Function继承来的，可以说是Function是所有 function的祖宗。 那Function是由谁生产来的？我们看到图中的Function函数有_proto_属性了，而且属性指向自己的原型对象，那不就是自己繁衍自己吗？可以这么理解。 小结这里我们在纵观全图，总结几条定义你比对着图去找。 所有的实例的_proto_都指向该构造函数的原型对象（prototype）。 所有的函数（包括构造函数）是Function的实例，所以所有函数的 proto的都指向Function的原型对象。 所有的原型对象（包括 Function的原型对象）都是Object的实例，所以_proto_都指向 Object（构造函数）的原型对象。而 Object构造函数的 _proto_指向 null。 Function构造函数本身就是 Function 的实例，所以_proto_指向Function的原型对象。 全篇文章的精华都在最后的总结部分，前边的所有分解讲解是为了让你理解这些函数对象以及原型对象之间的关系，这关系都是固定的，谁指向谁，都是写死额，只要你记住了他们的关系，这张图就理解的差不多了，能够理解完这张图，你的原型和原型链已经了解的很扎实了，但是还需要做一些面试题巩固一下。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[睿智游戏合集 😶]]></title>
    <url>%2F2019-10-25%2Fintellectual-game.html</url>
    <content type="text"><![CDATA[某种意义上算是有趣的「脑筋急转弯」题目，可以使用算法编程解决，但只要稍加思考，就能找到规律 主要介绍Nim游戏的衍生 Nim 游戏游戏规则是这样的：你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜。 假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个正整数 n，返回你是否能赢（true 或 false）。 比如现在有 4 颗石子，算法应该返回 false。因为无论你拿 1 颗 2 颗还是 3 颗，对方都能一次性拿完，拿走最后一颗石子，所以你一定会输。 首先，这道题肯定可以使用动态规划，因为显然原问题存在子问题，且子问题存在重复。但是因为你们都很聪明，涉及到你和对手的博弈，动态规划会比较复杂。 我们解决这种问题的思路一般都是反着思考： 如果我能赢，那么最后轮到我取石子的时候必须要剩下 1~3 颗石子，这样我才能一把拿完。 如何营造这样的一个局面呢？显然，如果对手拿的时候只剩 4 颗石子，那么无论他怎么拿，总会剩下 1~3 颗石子，我就能赢。 如何逼迫对手面对 4 颗石子呢？要想办法，让我选择的时候还有 5~7 颗石子，这样的话我就有把握让对方不得不面对 4 颗石子。 如何营造 5~7 颗石子的局面呢？让对手面对 8 颗石子，无论他怎么拿，都会给我剩下 5~7 颗，我就能赢。 这样一直循环下去，我们发现只要踩到 4 的倍数，就落入了圈套，永远逃不出 4 的倍数，而且一定会输。所以这道题的解法非常简单： 12345bool canWinNim(int n) &#123; // 如果上来就踩到 4 的倍数，那就认输吧 // 否则，可以把对方控制在 4 的倍数，必胜 return n % 4 != 0;&#125; PS：其实这个问题是一个简化版的 Nim 游戏，真正的 Nim 游戏比较复杂，不只有一堆石子，不限制一次拿的石子数。但是，这个问题最终的解法却出奇的巧妙，和异或运算有关。文末「阅读原文」链接有一篇详细讲解 Nim 游戏的文章。 石头游戏见另一篇文章 电灯开关问题这个问题是这样描述的：有 n 盏电灯，最开始时都是关着的。现在要进行 n 轮操作： 第 1 轮操作是把每一盏电灯的开关按一下（全部打开）。 第 2 轮操作是把每两盏灯的开关按一下（就是按第 2，4，6… 盏灯的开关，它们被关闭）。 第 3 轮操作是把每三盏灯的开关按一下（就是按第 3，6，9… 盏灯的开关，有的被关闭，比如 3，有的被打开，比如 6）… 如此往复，直到第 n 轮，即只按一下第 n 盏灯的开关。 现在给你输入一个正整数 n 代表电灯的个数，问你经过 n 轮操作后，这些电灯有多少盏是亮的？ 我们当然可以用一个布尔数组表示这些灯的开关情况，然后模拟这些操作过程，最后去数一下就能出结果。但是这样显得没有灵性，最好的解法是这样的： 1int bulbSwitch(int n) &#123; return (int)Math.sqrt(n);&#125; 什么？这个问题跟平方根有什么关系？其实这个解法挺精妙，如果没人告诉你解法，还真不好想明白。 首先，因为电灯一开始都是关闭的，所以某一盏灯最后如果是点亮的，必然要被按奇数次开关。 我们假设只有 6 盏灯，而且我们只看第 6 盏灯。需要进行 6 轮操作对吧，请问对于第 6 盏灯，会被按下几次开关呢？这不难得出，第 1 轮会被按，第 2 轮，第 3 轮，第 6 轮都会被按。 为什么第 1、2、3、6 轮会被按呢？因为 6=1×6=2×3。一般情况下，因子都是成对出现的，也就是说开关被按的次数一般是偶数次。但是有特殊情况，比如说总共有 16 盏灯，那么第 16 盏灯会被按几次? 16=1×16=2×8=4×4 其中因子 4 重复出现，所以第 16 盏灯会被按 5 次，奇数次。现在你应该理解这个问题为什么和平方根有关了吧？ 不过，我们不是要算最后有几盏灯亮着吗，这样直接平方根一下是啥意思呢？稍微思考一下就能理解了。 就假设现在总共有 16 盏灯，我们求 16 的平方根，等于 4，这就说明最后会有 4 盏灯亮着，它们分别是第 1×1=1 盏、第 2×2=4 盏、第 3×3=9 盏和第 4×4=16盏。 我们不是想求有多少个可开方的数吗，4 是最大的平方根，那么小于 4 的正整数的平方都是在 1~16 内的，是会被按奇数次开关，最终亮着的灯。 就算有的 n 平方根结果是小数，强转成 int 型，也相当于一个最大整数上界，比这个上界小的所有整数，平方后的索引都是最后亮着的灯的索引。所以说我们直接把平方根转成整数，就是这个问题的答案。 分针时针重合问题在一天的时间里，钟表的时针和分针会重合多少次？ 解析： 答案是22次。 这个问题可以使用编程的方式，具体地求出这22个时针和分针重合的时间都在几点几分。不过，其实只需要稍微想一想，就能想出这个答案：） 大家可以思考一下，在午夜零点的时候，是一天里第一次时针和分针发生重合的时候。下一次在什么时候呢？因为第一分钟，分针就会直接越过时针，所以，在0:00-1:00之间，不可能再发生时针和分针重合的时候了。 下一次时针和分针发生重合的时候，一定是在1点多。具体多少我们可以不求了，但我们知道，1点多一定有一次时针和分针重合的时候。 那么再下一次呢？相信聪明的同学们很快就能想明白，在两点多的位置。 再下一次呢？是三点多。 依此类推。 大家可以思考一下，在时针走回12点之前，最后一次时针和分针重合的时候是什么时候？答案是在十点多，而不是11点多。11:00-11:59这段时间里，时针和分针不会再重合了。分针走过11:00-11:59这一圈的过程中，时针总会比分针更接近12点的位置，直到最后一分钟，时针和分针再次同时指向12点。 因此，在0:00-11:59这12个小时里，时针和分针一共重合了11次。这11次分别是零点；1点多；2点多；3点多；4点多；5点多；6点多；7点多；8点多；9点多；10点多。 那么在一天的时间里，一共24个小时，也就是时针要绕表盘转两圈，所以，一共重合了22次：） 有兴趣的同学可以尝试一下，具体用编程的方式（甚至用数学的方式？）求解一下这22次分别是什么时间：） 电话号码验证问题你想要检验你的好朋友，同时也是计算机大牛的bobo老师是否知道你的正确的手机号码。 但是，小慕同学不让你接近bobo老师，只给你一张卡片，让你写一个问题给bobo老师。**小慕会将这张卡片传给bobo老师，然后再将bobo老师的回答用这个卡片传回来。这一问一答的过程，你就需要判断出：bobo老师是否知道你的正确的电话号码。** 但是，你并不希望小慕同学知道你的电话号码。**可是，小慕同学一定会偷看你和bobo老师写在卡片上的内容的。** 请问，你要怎么写这张卡片？ 解析： 最中规中矩的方法，是使用校验算法（或者摘要算法，哈希算法，不可逆的加密算法，但不管怎样，核心是做校验。）你可以在卡片上写上任意校验算法名称，根据正确的手机号码得到的校验码，以及其他必须的校验信息（如果有的话）。由于bobo老师是计算机大牛，所以可以假设bobo老师可以看懂你写的任何校验算法，然后将他知道的手机号码相应地转换成校验码，和你提供的校验码作比较，之后回答校验成功或者失败就好了。 整个过程，小慕只能看到校验算法相关的信息和校验码，是不能反推出原始信息的。 但是，对于这个问题，其实可以直接在卡片上要求bobo老师根据他所知道的号码给你打一个电话，就能知道bobo老师手上的电话号码是否正确啦！ 是不是发现，有些时候，跳出程序员思维，事情会更简单：**）**]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>智力题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从「石头游戏」到博弈类问题中的动态规划]]></title>
    <url>%2F2019-10-24%2Fstones-problem.html</url>
    <content type="text"><![CDATA[所有石头被拿完后，谁拥有的石头多，谁获胜。 博奕问题 - - - 「假设两个人都足够聪明，最后谁会获胜」 流年安稳，世事无尘 游戏规则游戏规则是这样的：你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。 假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个数组 piles，返回你是否能赢（true 或 false）。 注意，石头的堆的数量为偶数，所以你们两人拿走的堆数一定是相同的。石头的总数为奇数，也就是你们最后不可能拥有相同多的石头，一定有胜负之分。 举个例子，piles=[2, 1, 9, 5]，你先拿，可以拿 2 或者 5，你选择 2。 piles=[1, 9, 5]，轮到对手，可以拿 1 或 5，他选择 5。 piles=[1, 9] 轮到你拿，你拿 9。 最后，你的对手只能拿 1 了。 这样下来，你总共拥有 2+9=11 颗石头，对手有 5+1=6 颗石头，你是可以赢的，所以算法应该返回 true。 你看到了，并不是简单的挑数字大的选，为什么第一次选择 2 而不是 5 呢？因为 5 后面是 9，你要是贪图一时的利益，就把 9 这堆石头暴露给对手了，那你就要输了。 这也是强调双方都很聪明的原因，算法也是求最优决策过程下你是否能赢。 这道题又涉及到两人的博弈，也可以用动态规划算法暴力试，比较麻烦。但我们只要对规则深入思考，就会大惊失色：只要你足够聪明，你是必胜无疑的，因为你是先手。 智力题解法题目有两个条件很重要：一是石头总共有偶数堆，石头的总数是奇数。这两个看似增加游戏公平性的条件，反而使该游戏成为了一个割韭菜游戏。我们以 piles=[2, 1, 9, 5] 讲解，假设这四堆石头从左到右的索引分别是 1，2，3，4。 如果我们把这四堆石头按索引的奇偶分为两组，即第 1、3 堆和第 2、4 堆，那么这两组石头的数量一定不同，也就是说一堆多一堆少。因为石头的总数是奇数，不能被平分。 而作为第一个拿石头的人，你可以控制自己拿到所有偶数堆，或者所有的奇数堆。 你最开始可以选择第 1 堆或第 4 堆。如果你想要偶数堆，你就拿第 4 堆，这样留给对手的选择只有第 1、3 堆，他不管怎么拿，第 2 堆又会暴露出来，你就可以拿。同理，如果你想拿奇数堆，你就拿第 1 堆，留给对手的只有第 2、4 堆，他不管怎么拿，第 3 堆又给你暴露出来了。 也就是说，你可以在第一步就观察好，奇数堆的石头总数多，还是偶数堆的石头总数多，然后步步为营，就一切尽在掌控之中了。 睿智的代码解法本文就借石头游戏来讲讲「假设两个人都足够聪明，最后谁会获胜」这一类问题该如何用动态规划算法解决。 博弈类问题的套路都差不多，下文举例讲解，其核心思路是在二维 dp 的基础上使用元组分别存储两个人的博弈结果。掌握了这个技巧以后，别人再问你什么俩海盗分宝石，俩人拿硬币的问题，你就告诉别人：我懒得想，直接给你写个算法算一下得了。 博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？ 我们把「石头游戏」改的更具有一般性： 问题描述石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 piles = [1,100,3]，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。 假设双方实力相当，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。 dp数组的定义定义 dp 数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。 二维 dp table 中存储的是元组，怎么编程表示呢？这个 dp table 有一半根本没用上，怎么优化？很简单，都不要管，先把解题的思路想明白了再谈也不迟。 下文讲解时，认为元组是包含 first 和 second 属性的一个类，而且为了节省篇幅，将这两个属性简写为 fir 和 sec。比如按上图的数据，我们说 dp[1][3].fir = 10，dp[0][1].sec = 3。 12345dp[i][j].fir 表示，对于 piles[i...j]这部分石堆，先手能获得的最高分数dp[i][j].sec 表示，对于 piles[i...j]这部分石堆，后手能获得的最高分举例解释一下，假设piles=[3,9,1,2],索引从0开始dp[0][1].fir=9 意味着：面对石头堆[3,9]，先手最终能获得9分dp[1][3].sec=2 意味着：面对石头堆[9,1,2]，后手最终能获得2分 我们想求的答案是先手和后手最终分数之差，按照这个定义也就是 dp[0][n−1].fir−dp[0][n−1].sec 思考上面的伪码是动态规划的一个大致的框架，股票系列问题中也有类似的伪码。这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？ 根据我们对 dp 数组的定义，很容易解决这个难点，写出状态转移方程： 根据 dp 数组的定义，我们也可以找出 base case，也就是最简单的情况： 这里需要注意一点，我们发现 base case 是斜着的，而且我们推算 dp[i][j] 时需要用到 dp[i+1][j] 和 dp[i][j-1]： 所以说算法不能简单的一行一行遍历 dp 数组，而要斜着遍历数组： 代码实现🙄如何实现这个 fir 和 sec 元组呢，你可以用 python，自带元组类型；或者使用 C++ 的 pair 容器；或者用一个三维数组 dp[n][n][2]，最后一个维度就相当于元组；或者我们自己写一个 Pair 类： 1234567class Pair &#123; int fir, sec; Pair(int fir, int sec) &#123; this.fir = fir; this.sec = sec; &#125;&#125; 然后直接把我们的状态转移方程翻译成代码即可，可以注意一下斜着遍历数组的技巧： 动态规划解法，如果没有状态转移方程指导，绝对是一头雾水，但是根据前面的详细解释，读者应该可以清晰理解这一大段代码的含义。 而且，注意到计算 dp[i][j] 只依赖其左边和下边的元素，所以说肯定有优化空间，转换成一维 dp，想象一下把二维平面压扁，也就是投影到一维。但是，一维 dp 比较复杂，可解释性很差，大家就不必浪费这个时间去理解了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯面试题--厉害了我的杯]]></title>
    <url>%2F2019-10-23%2Fglass.html</url>
    <content type="text"><![CDATA[杯具题：厉害了我的杯 🙄 阅读理解：一个杯子定区间，一个杯子定位置，关键在于区间怎么划分。 问题有一种玻璃杯质量确定但未知，需要检测。有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？ 思考 2 个杯子的脆弱程度是一样的 如果杯子从 N 楼扔下来没有碎，那么它从小于 N 楼扔下来，也不会碎 如果杯子从 N 楼扔下来碎了，那么它从大于 N 楼扔下来，也一定会碎 一个扔出去但没有碎的杯子，可以继续被用于试验 碎了的杯子将无法再继续试验。 问题的关键是，怎么快速找到这个楼层呢？这是一个查找问题。我们需要一个策略方法来快速地找到它，就看谁的方法比较优秀拉。而优秀的方法其评价标准显而易见：各种情况下都能快速地找到目标楼层。 再度思考如果只有一个杯子的话，应该怎么做呢？稍微想一下也可以知道，必定只能一层一层地扔，1楼没碎扔2楼，2楼没碎扔3楼，直到碎掉。 现在我有两个杯子。 学习过算法和程序的人应该都知道二分法，很容易想到这样去做，因为面对的是一个搜索问题。所以可能会给出这样的策略：从50楼扔下，没碎的话，再扔75楼，再没碎我扔88楼，依次下去很快就可以锁定楼层？很快你会意识到问题所在，万一第一次从50层楼扔下去，碎了咋整，难道又一层一层地扔？杯子的质量是刚好在49层碎掉的话。最差的情况我需要扔50次，这方法不行。 再一个比较常见的方法是，先分区间的扔，再慢慢地一层一层地扔，隐含着分段查找的策略。具体操作方式是：先从第10楼扔，再从第20楼扔，依次下去，如果到某一层碎掉，比如50层碎掉了，我再从41楼开始扔，这样的话应该算是比较快了把？这个方法是要快一点不过如果我杯子的质量比较好，在99楼才会刚好碎掉。这样，最差的情况下，需要扔19次才能找到目标楼层，还是不能让面试官满意。 我们需要的方法是无论杯子的质量如何，不论是在1楼碎，49楼碎，99楼碎都要能快速锁定的方法。 继续思考刚才方法的缺陷，当杯子质量比较差的时候，此方法还是比较快速的找到的。比如杯子是在19楼刚好碎，我只需要扔11次，比99楼刚好碎的情况要少很多次。 所以我们的愿望是：杯子的质量无论分布在哪个查找区间，都可以快速地找到。所以我想到的是可以“匀”一下刚才的方法。即最开始我需要大胆地扔，然后再慢慢小心地扔。 具体方法设计：每次扔的区间减少一层，这样做可以保证每个区间查找的最差次数是一样的。假定第一步在15楼扔，没碎的话则下一步在29楼扔，没碎下一步在42楼扔….碎掉之后则在上一次没碎的楼层开始向上扔。那么最开始在哪一层开始扔呢？？这里我们需要拿支笔算一下：x+(x-1)+(x-2)+…+2 &gt;=100求解出答案为14。 即最终给出的解决方案是：最开始从14楼开始扔，没碎的话在27楼扔，再没碎的话在39楼扔…..一旦碎掉，则从上一次没碎的楼层逐层往上扔，即可快速确认杯子在哪一层刚好会碎掉。 这样的方法可以保证在最差的情况下也能在14次内找到楼层，平均需要的次数不到10次。（列式子算了下期望是9次多） 整理方案方案一：二分法从 50 楼扔下，没碎的话，再扔 75 楼，再没碎我扔 88 楼，依次下去貌似很快就可以锁定楼层。 不过，很不巧，第一次从 50 层楼扔下去就碎了，这个时候就只能从 1 层开始慢慢的的一层一层地扔，如果杯子的质量是刚好在 49 层碎掉的话，那么最差的情况是需要扔 50 次。 方案二：分段查找区间法核心点：先分区间的扔，再慢慢地一层一层地扔。 举个🌰：先从第 10 楼扔，再从第 20 楼扔，依次下去，如果到某一层碎掉，比如 60 层碎掉了，我再从 51 楼开始扔，这样比前面的二分法更快，因为即使又很不巧，杯子的质量比较好，在 99 楼才会刚好碎掉。这样的话，在这种最差的情况下，也只需要扔 19 次就能找到目标楼层。 方案三：基于数学方程的方法事实上，这算是一道趣味问题，可以从数学的角度进行分析。 假设最少尝试次数为 x ，那么，第一个杯子必须要从第 x 层扔下，因为：如果碎了，前面还有 x - 1 层楼可以尝试，如果没碎，后面还有 x-1 次机会。 如果没碎，第一个杯子，第二次就可以从 x +（x - 1）层进行尝试，这里加上 x - 1，是因为当此时，第一个杯子碎了，第二个杯子还有可以从 x + 1 到 （ x + (x - 1) - 1 ） 层进行尝试，有 x - 2 次机会。 如果还没碎，那第一个杯子，第三次从 x + (x - 1) + (x - 2)层尝试。不管杯子碎或者没碎，都有 x - 3 次尝试机会，依次类推。 那么经过 x 次的尝试可以确定最高的楼层为 x + (x - 1) + (x - 2) + … + 1 = x(x+1) / 2 。 那反过来，当最高楼层是100层，最少需要多少次呢？即 x(x+1)/2 &gt;= 100, 得到 x &gt;= 14 ，最少要尝试 14 次。 方案四：动态规划(为什么是k-1？)先思考上面的 分段查找区间法 ，如果杯子的质量没那么好，在第 19 层就碎了，那么需要扔 11 次，这样比 99 楼刚好碎的情况要少很多次。 那么问题来了：能否无论杯子的质量如何，不管是很好还是很差，都可以快速地找到。 能！ 上面的分析都是从杯子的角度出发的，这样想要得到最少的尝试次数，似乎比较难。我们可以换个角度，从每个高度的楼层来看：如果，某个楼层是可以安全落下的，那么最少需要多少次尝试呢？ 事实上，这就是一个求最优解的问题了。 而我们编程解决问题的过程中，如果遇到最优问题的时候，往往可以先尝试一下动态规划的方法。 动态规划的一个出发点就是去 找到构成这个最优问题的最优子问题。 我们可以将这样的问题简记为 W(n,k) ，其中 n 代表可用于测试的杯子数，k 代表被测试的楼层数。对于问题 W(2,10)， 我们可以如此考虑 将第 1 个杯子，在第 i 层扔下（ i 可以为 1～k 的任意值），如果碎了，则我们需要用第 2 个杯子，解决从第 1 层到第 i-1 层楼的 子问题 W(1,i-1)； 如果这个杯子没碎，则我们需要用这两个杯子，解决从 i+1 层到第 100 层的子问题 W(2,100-i)。 解决这两个问题，可以分别得到一个尝试次数 p 与 q，我们取这两个次数中的较大者(假设是 p )，将 p 与第 1 次在 i 层执行测试的这一次相加，则 p+1 就是第一次将杯子扔在 i 层来解决 W(2，100) 所需的最少测试次数，将其表示为ti。 对于这 100 层楼的问题，第一次，我们可以把杯子扔在 100 层中的任何一层，所以可以得到 100 中解决方案的测试次数 T{t1,t2,t3,……,t100} ，在这些结果中，我们选取最小的 ti，使得对于集合 T 中任意的值 tj(1 &lt;= j &lt;= 100,j != i)，都有ti &lt;= tj，则 ti 就是这个问题的答案。 用公式来描述就是： 1W(n, k) = 1 + min&#123;max(W(n -1, x -1), W(n, k - x))&#125;, x 其中x是第一次的测试的楼层位置 其中W(1,k) = k（相当于 1 个杯子测试 k 层楼问题），W(0,k) = 0，W(n, 0) = 0 所以在计算 W(2,100) 之前，我们需先计算出所有 W(1,0) ,……, W(1,100) , W(2,0),……,W(2,99)这些的值。 使用递推的方法实现，代码如下： 123456789101112131415161718192021222324unsigned int DroppingCups(unsigned int cups, unsigned int floors)&#123;unsigned int i, j, k, t, max;unsigned int temp[cups + 1][floors + 1]; for(i = 0; i &lt; floors + 1; ++i)&#123; temp[0][i] = 0; temp[1][i] = i; &#125; for(i = 2; i &lt; cups + 1; ++i)&#123; temp[i][0] = 0; temp[i][1] = 1; &#125; for(i = 2; i &lt; cups + 1; ++i)&#123; for(j = 2; j &lt; floors + 1; ++j)&#123; for(k = 1, max = UINT_MAX; k &lt; j; ++k)&#123; t = temp[i][j-k]&gt;temp[i - 1][k -1]? temp[i][j - k]:temp[i - 1][k -1]; if(max &gt; t)&#123; max = t; &#125; &#125; temp[i][j] = max + 1; &#125; &#125; return temp[cups][floors]; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「时间」与「空间」复杂度]]></title>
    <url>%2F2019-10-21%2Ftime-space-complexity.html</url>
    <content type="text"><![CDATA[实现一个栈，要求实现Push、Pop、Min的时间复杂度为O（1）,能否使空间复杂度也为O(1) 时光未央，岁月静好 前言BEFORE前一阵子，刷题遇坎，实现栈功能并加入getMinValue功能，在算法效率上，能想到的只是疯狂在时间复杂度上优化，而忽略了空间复杂度这个维度，故做整理。 AND算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，比如排序就有前面的十大经典排序和几种奇葩排序，虽然结果相同，但在过程中消耗的资源和时间却会有很大的区别，比如快速排序与猴子排序：）。 不实用的几个排序算法 – 睡眠排序、猴子排序、面条排序、珠排序 除此之外，对于排序算法的稳定性也应该再做考虑，那为什么要考虑稳定性呢，作用在哪？ AFTER那么我们应该如何去衡量不同算法之间的优劣呢？ 主要还是从算法所占用的「时间」和「空间」两个维度去考量。 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。 大O符号表示法基础概念大O表示法：算法的时间复杂度通常用大O符号表述，定义为 T[n]=O(f(n))。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。 大O符号是一种算法「复杂度」的「相对」「表示」方式。 如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。 上面公式中用到的 Landau符号是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。 常见的时间复杂度量级 我们先从常见的时间复杂度量级进行大O的理解： 常数阶O(1) 线性阶O(n) 平方阶O(n²) 对数阶O(logn) 线性对数阶O(nlogn) O(1)无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1).12345void swapTwoInts(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125; O(n)在下面这段代码，for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用O(n)来表示它的时间复杂度.1234567int sum ( int n )&#123; int ret = 0; for ( int i = 0 ; i &lt;= n ; i ++)&#123; ret += i; &#125; return ret;&#125; 123456void reverse ( string &amp;s ) &#123; int n = s.size(); for (int i = 0 ; i &lt; n/2 ; i++)&#123; swap ( s[i] , s[n-1-i]); &#125;&#125; O(n²)当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。12345678910 void selectionSort(int arr[],int n)&#123; for(int i = 0; i &lt; n ; i++)&#123; int minIndex = i; for (int j = i + 1; j &lt; n ; j++ ) if (arr[j] &lt; arr[minIndex]) minIndex = j; swap ( arr[i], arr[minIndex]); &#125;&#125; 不妨推导一下： 当 i = 0 时，第二重循环需要运行 (n - 1) 次 当 i = 1 时，第二重循环需要运行 (n - 2) 次 。。。。。。故可以得到公式：123(n - 1) + (n - 2) + (n - 3) + ... + 0= (0 + n - 1) * n / 2= O (n ^2) ++并不是所有的双重循环都是O(n^2)++: 比如下面这段输出 30n 次 Hello Abo：）的代码。12345void printInformation (int n )&#123; for (int i = 1 ; i &lt;= n ; i++) for (int j = 1 ; j &lt;= 30 ; j ++) cout&lt;&lt; "Hello,Abo：）"&lt;&lt; endl;&#125; O(logn)在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。12345678910 int binarySearch( int arr[], int n , int target)&#123; int l = 0, r = n - 1; while ( l &lt;= r) &#123; int mid = l + (r - l) / 2; if (arr[mid] == target) return mid; if (arr[mid] &gt; target ) r = mid - 1; else l = mid + 1; &#125; return -1;&#125; 同样的还有下面两段代码也是 O(logn) 级别的时间复杂度。123456789101112131415161718 // 整形转成字符串string intToString ( int num )&#123; string s = ""; // n 经过几次“除以10”的操作后，等于0 while (num )&#123; s += '0' + num%10; num /= 10; &#125; reverse(s) return s;&#125;void hello (int n ) &#123; // n 除以几次 2 到 1 for ( int sz = 1; sz &lt; n ; sz += sz) for (int i = 1; i &lt; n; i++) cout&lt;&lt; "Hello,Abo：）"&lt;&lt; endl;&#125; O(nlogn)将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。12345678void hello ()&#123; for( m = 1 ; m &lt; n ; m++)&#123; i = 1; while( i &lt; n )&#123; i = i * 2; &#125; &#125;&#125; 递归算法中的时间复杂度在前面的学习中，归并排序 与 快速排序 都带有递归的思想，并且时间复杂度都是O(nlogn) ，但并不是有递归的函数就一定是 O(nlogn) 级别的。从以下两种情况进行分析。 递归中进行一次递归调用的复杂度分析二分查找法12345678910 int binarySearch(int arr[], int l, int r, int target)&#123; if( l &gt; r ) return -1; int mid = l + (r-l)/2; if( arr[mid] == target ) return mid; else if( arr[mid] &gt; target ) return binarySearch(arr, l, mid-1, target); // 左边 else return binarySearch(arr, mid+1, r, target); // 右边&#125; 在这个递归函数中，每一次没有找到target时，要么调用 左边 的 binarySearch函数，要么调用 右边 的 binarySearch函数。也就是说在此次递归中，最多调用了一次递归调用而已。根据数学知识，需要log2n次才能递归到底。因此，二分查找法的时间复杂度为 O(logn)。 求和1234int sum (int n) &#123; if (n == 0) return 0; return n + sum( n - 1 )&#125; 在这段代码中比较容易理解递归深度随输入 n 的增加而线性递增，因此时间复杂度为 O (n)。 求幂123456789//递归深度：logn//时间复杂度：O(logn)double pow( double x, int n)&#123; if (n == 0) return 1.0; double t = pow(x,n/2); if (n %2) return x*t*t; return t * t;&#125; 递归深度为 logn，因为是求需要除以 2 多少次才能到底。 递归中进行多次递归调用的复杂度分析递归算法中比较难计算的是多次递归调用。 先看下面这段代码，有两次递归调用。12345// O(2^n) 指数级别的数量级，后续动态规划的优化点int f(int n)&#123; if (n == 0) return 1; return f(n-1) + f(n - 1);&#125; 比如 当 n = 3 时，调用次数计算公式为:1 + 2 + 4 + 8 = 15一般的，调用次数计算公式为1232^0 + 2^1 + 2^2 + …… + 2^n = 2^(n+1) - 1= O(2^n) 划重点：与之有所类似的是 归并排序 的递归树，区别点在于 上述例子中树的深度为 n，而 归并排序 的递归树深度为logn。 上述例子中每次处理的数据规模是一样的，而在 归并排序 中每个节点处理的数据规模是逐渐缩小的因此，在如 归并排序 等排序算法中，每一层处理的数据量为 O(n) 级别，同时有 logn 层，时间复杂度便是 O(nlogn)。平均、均摊时间复杂度这里不多做介绍最好最坏时间复杂度，主要是字面意思理解起来不难，相对而言平均跟均摊可能会忽略。平均情况时间复杂度最好、最坏时间复杂度反应的是极端条件下的复杂度，发生的概率不大，不能代表平均水平。那么为了更好的表示平均情况下的算法复杂度，就需要引入平均时间复杂度。 平均情况时间复杂度可用代码在所有可能情况下执行次数的加权平均值表示。123456789int find(int[] array, int n, int x) &#123; for ( int i = 0 ; i &lt; n; i++) &#123; if (array[i] == x) &#123; return i; break; &#125; &#125; return -1;&#125; 还是以 find 函数为例，从概率的角度看， x 在数组中每一个位置的可能性是相同的，为 1 / n。那么，那么平均情况时间复杂度就可以用下面的方式计算： ((1 + 2 + … + n) / n + n) / 2 = (3n + 1) / 4 find 函数的平均时间复杂度为 O(n)。 均摊复杂度我们通过一个动态数组的 push_back 操作来理解 均摊复杂度。12345678910111213141516171819202122232425262728293031323334 template &lt;typename T&gt; class MyVector&#123; private: T* data; int size; // 存储数组中的元素个数 int capacity; // 存储数组中可以容纳的最大的元素个数 // 复杂度为 O(n) void resize(int newCapacity)&#123; T *newData = new T[newCapacity]; for( int i = 0 ; i &lt; size ; i ++ )&#123; newData[i] = data[i]; &#125; data = newData; capacity = newCapacity; &#125;public: MyVector()&#123; data = new T[100]; size = 0; capacity = 100; &#125; // 平均复杂度为 O(1) void push_back(T e)&#123; if(size == capacity) resize(2 * capacity); data[size++] = e; &#125; // 平均复杂度为 O(1) T pop_back()&#123; size --; return data[size]; &#125;&#125;; push_back实现的功能是往数组的末尾增加一个元素，如果数组没有满，直接往后面插入元素；如果数组满了，即 size==capacity ，则将数组扩容一倍，然后再插入元素。 例如，数组长度为 n，则前 n 次调用 push_back 复杂度都为 O(1) 级别；在第 n + 1 次则需要先进行 n 次元素转移操作，然后再进行 1 次插入操作，复杂度为 O(n)。 因此，平均来看：对于容量为 n 的动态数组，前面添加元素需要消耗了 1 n 的时间，扩容操作消耗 n 时间 ，总共就是 2 n 的时间，因此均摊时间复杂度为 O(2n / n) = O(2)，也就是 O(1) 级别了。 可以得出一个比较有意思的结论：一个相对比较耗时的操作，如果能保证它不会每次都被触发，那么这个相对比较耗时的操作，它所相应的时间是可以分摊到其它的操作中来的。 空间复杂度一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分： 固定部分，这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。 空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。 空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看： 空间复杂度O(1)如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)举例： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 空间复杂度O(n)123456int[] m = new int[n]for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; 这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n) 附录]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编程解决华容道问题？]]></title>
    <url>%2F2019-10-20%2Fleetcode-02.html</url>
    <content type="text"><![CDATA[数字华容道居然有无解的情况，长见识了 🤨 内含DFS跟BFS算法，以及迷宫算法 时光未央，岁月静好 ## ## ##]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql注入 (sql Injection)]]></title>
    <url>%2F2019-10-20%2FsqlInjection.html</url>
    <content type="text"><![CDATA[对有关SQL Injection的相关介绍，主要包括原理跟实操 内容来自数据库的一次小作业，那天人类终于回想起被sql注入的恐惧，某种意义上比专业课有趣 start前言 在当今的数字世界中，人们发现在维持公开的Internet连接的同时，保护网络和计算机系统的安全变得越来越困难。病毒、木马、后门、蠕虫等攻击层出不穷，虚假网站的钓鱼行为为让警惕性不高的公众深受其害。SQL漏洞攻击是目前网上最流行最热门的黑客脚本攻击方法之一。 文章涉及知识点主要包括： sql注入原理 sql注入攻击类型 sql注入攻击过程 sql注入危害 sql注入防御方案 sql注入原理(Structured Query Language Injection）是从正常的WWW端口访问，而且表面看出来跟一般的Web页面没什么区别，所以目前市面的防火墙都不会对SQL注入发出警报，如果管理员没查看IIS日志的习惯，可能被入侵很长时间都不会被发觉。SQL注入攻击是攻击者通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 sql攻击类型 按照注入点类型来分类数字型注入点许多网页链接有类似的结构 http://xxx.com/users.php?id=1 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字，在大多数的网页中，诸如 查看用户个人信息，查看文章等，大都会使用这种形式的结构传递id等信息，交给后端，查询出数据库中对应的信息，返回给前台。这一类的 SQL 语句原型大概为 select * from 表名 where id=1 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：select * from 表名 where id=1 and 1=1 字符型注入点网页链接有类似的结构 http://xxx.com/users.php?name=admin 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为 select * from 表名 where name=&#39;admin&#39; 值得注意的是这里相比于数字型注入类型的sql语句原型多了引号，可以是单引号或者是双引号。若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：select * from 表名 where name=&#39;admin&#39; and 1=1 &#39; 我们需要将这些烦人的引号给处理掉。 搜索型注入点这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 &quot;keyword=关键字&quot; 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：select * from 表名 where 字段 like &#39;%关键字%&#39; 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：select * from 表名 where 字段 like &#39;%测试%&#39; and &#39;%1%&#39;=&#39;%1%&#39; 按照数据提交的方式来分类GET 注入提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接http://xxx.com/news.php?id=1 , id 是注入点。 POST 注入使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。 Cookie 注入HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。 HTTP 头部注入注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。 按照执行效果来分类基于布尔的盲注即可以根据返回页面判断条件真假的注入。 基于时间的盲注即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 基于报错注入即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 单引号 双引号 基于数字型注入 联合查询注入可以使用union的情况下的注入。 堆查询注入可以同时执行多条语句的执行时的注入。 宽字节注入sql攻击过程 sql危害 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。 网页篡改：通过操作数据库对特定网页进行篡改。 网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。 服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。 破坏硬盘数据，瘫痪全系统。 sql预防 不要使用动态SQL（使用参数化过滤性语句） 避免将用户提供的输入直接放入SQL语句中；最好使用准备好的语句和参数化查询，这样更安全。 不要将敏感数据保留在纯文本中（加密处理） 加密存储在数据库中的私有/机密数据；这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。 限制数据库权限和特权，确保数据库安全 将数据库用户的功能设置为最低要求；这将限制攻击者在设法获取访问权限时可以执行的操作。 避免直接向用户显示数据库错误（错误消息处理） 攻击者可以使用这些错误消息来获取有关数据库的信息。要使用一种标准的输入确认机制来验证所有的输入数据的长度、类型、语句、企业规则等。 对访问数据库的Web应用程序使用Web应用程序防火墙（WAF） 这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试；根据设置，它还可以帮助防止SQL注入尝试到达应用程序（以及数据库）。 定期测试与数据库交互的Web应用程序 这样做可以帮助捕获可能允许SQL注入的新错误或回归。 将数据库更新为最新的可用修补程序 这可以防止攻击者利用旧版本中存在的已知弱点/错误。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易2020校招心得]]></title>
    <url>%2F2019-09-22%2Finterview.html</url>
    <content type="text"><![CDATA[主要是针对网易校招要了命的编程题做一次心得感想 体验了一波失心疯的“小易”编程题，生活从此无小易，难度跟字节跳动不是一个级别的 内容 var ap = new APlayer({ element: document.getElementById("aplayer-CZhBOtrA"), narrow: false, autoplay: true, showlrc: false, music: { title: "Faded (Restrung)", author: "Alan Walker", url: "http://prc4nro7n.bkt.clouddn.com/faded.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/faded.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 最小各位数之和动态规划（积木/背包问题）箭头函数以及回调地狱补充：为什么要写成常量 == 变量的形式 一般来说是把常量写左边，变量写右边 这样在你不小心把==写成=的时候就会报错了： 12if (2 = x) &#123;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie是什么？]]></title>
    <url>%2F2019-09-14%2Fcookie.html</url>
    <content type="text"><![CDATA[Cookies现在经常被大家提到，那么到底什么是Cookies，它有什么作用呢？ 图解HTTP是一本好书(lll￢ω￢)~ 东山大发好~ 知识简介什么是Cookie ？1Cookies是数据包，可以让网页具有记忆功能，在某台电脑上记忆一定的信息。Cookies的工作原理是，第一次由服务器端写入到客户端的系统中。以后每次访问这个网页，都是先由客户端将Cookies发送到服务器端，再由服务器端进行判断，然后再产生HTML代码返回给客户端。通过这个原理服务器就可以根据不同用户产生不同cookies文件，这样当该用户再次访问同一个站点时就可以根据不同的cookies文件返回不同的页面信息了。 Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。 浏览器需要保存这段数据，不得轻易删除。 此后每次浏览器访问该服务器，都必须带上这段数据。 Cookie 就是这么简单，这就是 Web 开发里 Cookie 的含义 1234通俗点讲：Cookies是一种能够让网站服务器把少量数据储存到客户端的硬盘或内存，或是从客户端的硬盘读取数据的一种技术。Cookies是当你浏览某网站时，由Web服务器置于你硬盘上的一个非常小的文本文件，它可以记录你的用户ID、密码、浏览过的网页、停留的时间等信息。 当你再次来到该网站时，网站通过读取Cookies，得知你的相关信息，就可以做出相应的动作，如在页面显示欢迎你的标语，或者让你不用输入ID、密码就直接登录等等 Cookies文件是在无声无息中伴随浏览器进入我们本地硬盘的，当我们浏览某个站点时，该站点很可能将记录我们隐私的cookies文件上传到本地硬盘。那么我们如何防范阻止cookies文件泄露我们的隐私呢？实际上我们可以通过浏览器设置不容许计算机接收cookies文件即可。 问题1：「Cookie是什么？」 答：Cookie是服务器给客户端发的一个「通信证」。 无论谁访问服务器时都必须携带自己的「通行证」，这样服务器就可以通过「通行证」确定用户身份了。 注：Cookie有不可跨域名性。即浏览器不会将http://baidu.com的cookie发送给http://google.com 问题2：「Cookie有属性吗？都是什么？」 答：Cookie有属性，它们是： 1. String「name」 ：该Cookie的「名称」。Cookie一旦创建，名称便不可更改。 2. Object「value」：该Cookie的「值」 3. Int「maxAge」：该Cookie的「失效时间」，单位秒 注：如果为正数，则该Cookie在maxAge秒后失效。如果为负数，则该Cookie为临时Cookie，关闭浏览器即失效。如果为0，表示删除该Cookie。默认为-1，即关闭浏览器即失效 4. Boolean「secure」：「是否仅使用安全协议传输」，默认为false 5. String「path」：该Cookie的「使用路径」 注：如果设置为“/shit/”，则只有“http:http://xxx.xxx.xxx/shit”的程序可以访问该Cookie。如果设置为“/”，则本域名下的程序都可以访问Cookie，注意最后一个字符必须为“/”。 6. String「domain」：「可以访问该Cookie的域名」。 注：如果设置为”.http://google.com“，则所有以”http://google.com“结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。 7. String「comment」：该Cookie的「用处说明」，用来再浏览器显示Cookie信息的时候显示该说明。 8. Int「version」：该Cookie的「版本号」。0表示遵循Netspace的Cookie规范，1表示遵循W3C的RFC2109规范。 问题3：「怎么修改Cookie？怎么删除Cookie？」 答： 修改：创建同名Cookie，覆盖原来的Cookie 删除：创建同名Cookie，并将maxAge属性设置为0 问题4：「Cookie有什么用？」 答：挺多的，列举几个。 自动登陆：第一次登陆成功后，给你的电脑发送一个存有你用户名的Cookie。于是，在Cookie失效之前，你每一次登陆服务器，服务器都会直接读取你的Cookie中的用户名，然后返回给你一个登陆成功的页面。挺危险的是吧，所以通常会有一些加密手段以及借助Session的帮助。 京东未登录时的购物车：意思差不多，诸位应该明白。 问题5：「Session是什么？」 答：Session是「你去理发店办卡后，店家记录你剩余次数的那个大本子」。它保存在服务器端，不负责记录你还能剪几次，但是它会把客户端的某种信息保存在服务器上。当客户端下一次来访问时，根据信息确定客户身份即可。 问题6：「Session保存在哪？」 答：Session保存在服务器端的内存中。 问题7：「Session的有效期？」 答：由「最后访问时刻」和「超时时段」构成。当「当前时刻」 - 「超时时段」&gt;「最后访问时刻」时，Session就失效了。 在Tomcat中的「超时时段」为20分钟。 如何使用 CookieCookie 一般有两个作用。 第一个作用是识别用户身份。 比如用户 A 用浏览器访问了 http://a.com，那么 http://a.com 的服务器就会立刻给 A 返回一段数据「uid=1」（这就是 Cookie）。当 A 再次访问 http://a.com 的其他页面时，就会附带上「uid=1」这段数据。 同理，用户 B 用浏览器访问 http://a.com 时，http://a.com 发现 B 没有附带 uid 数据，就给 B 分配了一个新的 uid，为2，然后返回给 B 一段数据「uid=2」。B 之后访问 http://a.com 的时候，就会一直带上「uid=2」这段数据。 借此，http://a.com 的服务器就能区分 A 和 B 两个用户了。 第二个作用是记录历史。 假设 http://a.com 是一个购物网站，当 A 在上面将商品 A1 、A2 加入购物车时，JS 可以改写 Cookie，改为「uid=1; cart=A1,A2」，表示购物车里有 A1 和 A2 两样商品了。 这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 A1、A2 躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。 借此，就达到里记录用户操作历史的目的了。 （上面的例子只是为了让大家了解 Cookie 的作用而构想出来的，实际的网站使用 Cookie 时会更谨慎一些。） 深入认识Cookie跟Session使用Cookie来管理状态HTTP是无状态协议，所以它不能以状态来区分和管理请求和响应。也就是说，无法根据之前的状态进行本次的请求处理。不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU 及内存资源的消耗。从另一侧面来说，也正是因为HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。 我们登录淘宝的时候首先要登录，我们看到了一个商品点进去，进行了页面跳转/刷新，按照HTTP的无状态协议岂不是又要登录一次？所以为了解决这个问题，Cookie诞生了，在保留无状态协议这个特征的同时又要解决类似记录状态的矛盾问题。Cookie 技术通过在请求和响应报文中写入Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出去。服务器端发现客户端发送过来的Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。 （以下图来自图解HTTP，值得入手实体版） 没有Cookie信息状态下的请求 第2次以后（存有Cookie信息状态）的请求 HTTP 请求报文和响应报文的内容如下（数字和图中对应）。 ①请求报文（没有Cookie 信息的状态） 123GET /reader/ HTTP/1.1Host: hackr.jp*首部字段内没有Cookie的相关信息 ②响应报文（服务器端生成Cookie 信息） 12345HTTP/1.1 200 OKDate: Thu, 12 Jul 2012 07:12:20 GMTServer: Apache＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞Content-Type: text/plain; charset=UTF-8 ③请求报文（自动发送保存着的Cookie 信息） 123GET /image/ HTTP/1.1Host: hackr.jpCookie: sid=1342077140226724 关于Cookie的首部字段]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏观和微观任务执行顺序]]></title>
    <url>%2F2019-08-28%2Fdifference01.html</url>
    <content type="text"><![CDATA[换个问题：setTimeout跟promise跟promise.then中代码的执行先后顺序为？ 除了promise还有generator跟async的用法也记住一下 内容 整个串起来Philip搞了一个的碉堡的工具来可视化这个过程，这玩意儿叫Loupe。这是一个能够把JavaScript运行时可视化的工具。 我们用它来看一个简单的例子：在一个异步的setTimeout回调中用console.log在控制台打些log出来。 整个过程到底都发生了什么呢？我们来看一下： 执行进入console.log(&#39;Hi&#39;);函数，因此这个函数被丢进了调用栈里。 console.log(&#39;Hi&#39;);函数return了，因此他就被弹出了栈顶。 执行进入setTimeout函数，因此这个函数被丢进了调用栈里。 setTimeout是Web APIs的一部分，因此Web APIs处理了他，并且等了2秒 继续执行脚本，进入console.log(&#39;EvenyBody&#39;)函数，把他也丢进调用栈。 console.log(&#39;EvenyBody&#39;)函数return了，所以把他从栈顶弹出去 2秒的定时已经完成了，所以就把对应的回调函数放到回调队列里。 事件循环检查调用栈是否为空，如果非空的话，他就等着。因为调用栈现在是空的，所以把回调队列中的回调函数丢进调用栈。 console.log(&#39;There&#39;)函数返回了，因此把他从栈顶弹出去(译者按：原文为console.log(‘Everybody’)，应为书写错误)。 有趣的一点是：setTimeout(function(...), 0)的情况。setTimeout为0的时候这个过程看起来可能不明显，除非考虑到调用栈的执行环境和事件循环的情况。基本上都会推迟到调用栈为空才执行。 ## ##]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式的常见用法]]></title>
    <url>%2F2019-08-27%2Fexpression.html</url>
    <content type="text"><![CDATA[经常见到的正则表达式，但是却经常忘记,,ԾㅂԾ,,可以记住常见的语句，比如身份证跟邮箱、电话操作，没准面试问了呢？内容 var ap = new APlayer({ element: document.getElementById("aplayer-temPFIix"), narrow: false, autoplay: true, showlrc: false, music: { title: "Faded (Restrung)", author: "Alan Walker", url: "http://prc4nro7n.bkt.clouddn.com/faded.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/faded.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); ## 什么是正则表达式?&gt; 正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.体验了一波失心疯的“小易”编程题，生活从此无小易，难度跟字节跳动不是一个级别的想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.我们使用以下正则表达式来验证一个用户名: 以上的正则表达式可以接受 john_doe, jo-hn_doe, john12_as.但不匹配Jo, 因为它包含了大写的字母而且太短了. 目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 + 号 2.3.3 ? 号 2.4 {} 号 2.5 (…) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 零宽度断言(前后预查) 4.1 ?=… 正先行断言 4.2 ?!… 负先行断言 4.3 ?&lt;= … 正后发断言 4.4 ?&lt;!… 负后发断言 5. 标志 5.1 忽略大小写 (Case Insensitive) 5.2 全局搜索 (Global search) 5.3 多行修饰符 (Multiline) 额外补充 贡献 许可证 1. 基本匹配正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成.例如: 一个正则表达式 the, 它表示一个规则: 由字母t开始,接着是h,再接着是e. "the" => The fat cat sat on the mat. 在线练习 正则表达式123匹配字符串123. 它逐个字符的与输入的正则表达式做比较. 正则表达式是大小写敏感的, 所以The不会匹配the. "The" => The fat cat sat on the mat. 在线练习 2. 元字符正则表达式主要依赖于元字符.元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍: 元字符 描述 . 句号匹配任意单个字符除了换行符. [ ] 字符种类. 匹配方括号内的任意字符. [^ ] 否定的字符种类. 匹配除了方括号里的任意字符 * 匹配&gt;=0个重复的在*号之前的字符. + 匹配&gt;=1个重复的+号前的字符. ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符 (n &lt;= num &lt;= m). (xyz) 字符集, 匹配与 xyz 完全相等的字符串. &#124; 或运算符,匹配符号前或后的字符. &#92; 转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \ &#124; ^ 从开始行开始匹配. $ 从末端开始匹配. 2.1 点运算符 ..是元字符中最简单的例子..匹配任意单个字符, 但不匹配换行符.例如, 表达式.ar匹配一个任意字符后面跟着是a和r的字符串. ".ar" => The car parked in the garage. 在线练习 2.2 字符集字符集也叫做字符类.方括号用来指定一个字符集.在方括号中使用连字符来指定字符集的范围.在方括号中的字符集不关心顺序.例如, 表达式[Tt]he 匹配 the 和 The. "[Tt]he" => The car parked in the garage. 在线练习 方括号的句号就表示句号.表达式 ar[.] 匹配 ar.字符串 "ar[.]" => A garage is a good place to park a car. 在线练习 2.2.1 否定字符集一般来说 ^ 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.例如, 表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符. "[^c]ar" => The car parked in the garage. 在线练习 2.3 重复次数后面跟着元字符 +, * or ? 的, 用来指定匹配子模式的次数.这些元字符在不同的情况下有着不同的意思. 2.3.1 * 号*号匹配 在*之前的字符出现大于等于0次.例如, 表达式 a* 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串. "[a-z]*" => The car parked in the garage #21. 在线练习 *字符和.字符搭配可以匹配所有的字符.*.*和表示匹配空格的符号\s连起来用, 如表达式\s*cat\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串. "\s*cat\s*" => The fat cat sat on the concatenation. 在线练习 2.3.2 + 号+号匹配+号之前的字符出现 &gt;=1 次.例如表达式c.+t 匹配以首字母c开头以t结尾,中间跟着任意个字符的字符串. "c.+t" => The fat cat sat on the mat. 在线练习 2.3.3 ? 号在正则表达式中元字符 ? 标记在符号前面的字符为可选, 即出现 0 或 1 次.例如, 表达式 [T]?he 匹配字符串 he 和 The. "[T]he" => The car is parked in the garage. 在线练习 "[T]?he" => The car is parked in the garage. 在线练习 2.4 {} 号在正则表达式中 {} 是一个量词, 常用来一个或一组字符可以重复出现的次数.例如, 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字. "[0-9]{2,3}" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 我们可以省略第二个参数.例如, [0-9]{2,} 匹配至少两位 0~9 的数字. "[0-9]{2,}" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 如果逗号也省略掉则表示重复固定的次数.例如, [0-9]{3} 匹配3位数字 "[0-9]{3}" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 2.5 (...) 特征标群特征标群是一组写在 (...) 中的子模式. 例如之前说的 {} 是用来表示前面一个字符出现指定次数. 但如果在 {} 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab. 我们还可以在 () 中用或字符 | 表示或. 例如, (c|g|p)ar 匹配 car 或 gar 或 par. "(c|g|p)ar" => The car is parked in the garage. 在线练习 2.6 | 或运算符或运算符就表示或, 用作判断条件. 例如 (T|t)he|car 匹配 (T|t)he 或 car. "(T|t)he|car" => The car is parked in the garage. 在线练习 2.7 转码特殊字符反斜线 \ 在表达式中用于转码紧跟其后的字符. 用于指定 { } [ ] / \ + * . $ ^ | ? 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 \. 例如 . 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 . 则要写成 \. 以下这个例子 \.?是选择性匹配. "(f|c|m)at\.?" => The fat cat sat on the mat. 在线练习 2.8 锚点在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. ^ 指定开头, $ 指定结尾. 2.8.1 ^ 号^ 用来检查匹配的字符串是否在所匹配字符串的开头. 例如, 在 abc 中使用表达式 ^a 会得到结果 a. 但如果使用 ^b 将匹配不到任何结果. 因为在字符串 abc 中并不是以 b 开头. 例如, ^(T|t)he 匹配以 The 或 the 开头的字符串. "(T|t)he" => The car is parked in the garage. 在线练习 "^(T|t)he" => The car is parked in the garage. 在线练习 2.8.2 `### 号同理于 ^ 号, $ 号用来匹配字符是否是最后一个. 例如, (at\.)$ 匹配以 at. 结尾的字符串. "(at\.)" => The fat cat. sat. on the mat. 在线练习 "(at\.)$" => The fat cat. sat. on the mat. 在线练习 3. 简写字符集正则表达式提供一些常用的字符集简写. 如下: 简写 描述 . 除换行符外的所有字符 \w 匹配所有字母数字, 等同于 [a-zA-Z0-9_] \W 匹配所有非字母数字, 即符号, 等同于: [^\w] \d 匹配数字: [0-9] \D 匹配非数字: [^\d] \s 匹配所有空格字符, 等同于: [\t\n\f\r\p{Z}] \S 匹配所有非空格字符: [^\s] \f 匹配一个换页符 \n 匹配一个换行符 \r 匹配一个回车符 \t 匹配一个制表符 \v 匹配一个垂直制表符 \p 匹配 CR/LF (等同于 \r\n)，用来匹配 DOS 行终止符 4. 零宽度断言(前后预查)先行断言和后发断言都属于非捕获簇(不捕获文本 ，也不针对组合计进行计数).先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束). 例如, 我们想要获得所有跟在 $ 符号后的数字, 我们可以使用正后发断言 (?&lt;=\$)[0-9\.]*.这个表达式匹配 $ 开头, 之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次. 零宽度断言如下: 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?&lt;= 正后发断言-存在 ?&lt;! 负后发断言-排除 4.1 ?=... 正先行断言?=... 正先行断言, 表示第一部分表达式之后必须跟着 ?=...定义的表达式. 返回结果只包含满足匹配条件的第一部分表达式.定义一个正先行断言要使用 (). 在括号内部使用一个问号和等号: (?=...). 正先行断言的内容写在括号中的等号后面.例如, 表达式 (T|t)he(?=\sfat) 匹配 The 和 the, 在括号中我们又定义了正先行断言 (?=\sfat) ,即 The 和 the 后面紧跟着 (空格)fat. "(T|t)he(?=\sfat)" => The fat cat sat on the mat. 在线练习 4.2 ?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式.正先行断言 定义和 负先行断言 一样, 区别就是 = 替换成 ! 也就是 (?!...). 表达式 (T|t)he(?!\sfat) 匹配 The 和 the, 且其后不跟着 (空格)fat. "(T|t)he(?!\sfat)" => The fat cat sat on the mat. 在线练习 4.3 ?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式.例如, 表达式 (?&lt;=(T|t)he\s)(fat|mat) 匹配 fat 和 mat, 且其前跟着 The 或 the. "(? 在线练习 4.4 ?&lt;!... 负后发断言负后发断言 记作 (?&lt;!...) 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式.例如, 表达式 (?&lt;!(T|t)he\s)(cat) 匹配 cat, 且其前不跟着 The 或 the. "(?&lt;!(T|t)he\s)(cat)" => The cat sat on cat. 在线练习 5. 标志标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果.这些标志可以任意的组合使用, 它也是整个正则表达式的一部分. 标志 描述 i 忽略大小写. g 全局搜索. m 多行的: 锚点元字符 ^ $ 工作范围在每行的起始. 5.1 忽略大小写 (Case Insensitive)修饰语 i 用于忽略大小写.例如, 表达式 /The/gi 表示在全局搜索 The, 在后面的 i 将其条件修改为忽略大小写, 则变成搜索 the 和 The, g 表示全局搜索. "The" => The fat cat sat on the mat. 在线练习 "/The/gi" => The fat cat sat on the mat. 在线练习 5.2 全局搜索 (Global search)修饰符 g 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).例如, 表达式 /.(at)/g 表示搜索 任意字符(除了换行) + at, 并返回全部结果. "/.(at)/" => The fat cat sat on the mat. 在线练习 "/.(at)/g" => The fat cat sat on the mat. 在线练习 5.3 多行修饰符 (Multiline)多行修饰符 m 常用于执行一个多行匹配. 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 m. 例如, 表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t , 末尾可选除换行符外任意字符. 根据 m 修饰符, 现在表达式匹配每行的结尾. "/.at(.)?$/" => The fat cat sat on the mat. 在线练习 "/.at(.)?$/gm" => The fat cat sat on the mat. 在线练习 6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。 "/(.*at)/" => The fat cat sat on the mat. 在线练习 "/(.*?at)/" => The fat cat sat on the mat. 在线练习]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于slice,split,splice的区别与用法]]></title>
    <url>%2F2019-08-25%2Fdifference.html</url>
    <content type="text"><![CDATA[毫无疑问，slice,split,splice三大易混淆数组用法，笔试经常遇到 内容 var ap = new APlayer({ element: document.getElementById("aplayer-KdULyzzR"), narrow: false, autoplay: true, showlrc: false, music: { title: "Faded (Restrung)", author: "Alan Walker", url: "http://prc4nro7n.bkt.clouddn.com/faded.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/faded.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); slice截取数组，返回截取到的新数组，不改变原有数组 arr.slice(start,end); start：必需，从原数组的start位置开始截取(包括下标为start的元素)。start-为负数，表示从尾部开始截取。如-1表示最后一个元素，-2表示倒数第二个元素 end：可选，截取到的指定位置（不包括下标为end的元素）。没有指定，则截取到最后一个元素。end要大于start，否则截取不到元素 ​ 规则： ​ A、只传一个参数时，且是负数，且绝对值小于length,该负数会和length相加在截取 12var a = [1,2,3,4];var b = a.slice(-1); //b = [4] a = [1,2,3,4] B、只传一个参数，且是负数，且绝对值大于大于等于length，则截取整个数组 12var a = [1,2,3,4];var b = a.slice(-4); //b = [1,2,3,4] a = [1,2,3,4] C、只传一个参数，且是正数，且大于等于length，则返回空数组 12var a = [1,2,3,4];var b = a.slice(4); //b = [] a = [1,2,3,4] D、只传一个参数，且是正数，小于length，从该参数的下标截取一直都数组尾 12var a = [1,2,3,4];var b = a.slice(1); //b = [2,3,4] a = [1,2,3,4] E、传入两个参数，有负数（不管先后顺序，但结果必须保证第一个参数小于第二个参数才会截取到数值），负数先和length相加在截取 1234567891011121314var a = [1,2,3,4];var b = a.slice(1,-1); //b = [2,3] a = [1,2,3,4] var a = [1,2,3,4];var b = a.slice(-2,3); console.log(b) //[3] var a = [1,2,3,4];var b = a.slice(-2,-1); console.log(b) //[3] var a = [1,2,3,4];var b = a.slice(-2,-3); console.log(b) //[] splice从数组中添加、删除元素，改变原有数组，返回被删除的元素 删除元素 12345678&lt;script&gt; var arr = ['a','b','c','d']; var delete = arr.splice(1,2) //从下标1开始，删除两个元素 console.log(arr); //a,d console.log(delete) // b,c &lt;/script&gt; 添加元素 123456&lt;script&gt; var arr = ['a','b','c','d']; var delete = arr.splice(1,0,'e','f'); //0-表示没有删除元素 console.log(arr); // a,e,f,b,c,d console.log(delete); //''-即返回空的数组，因为没有删除元素&lt;/script&gt; split用于把一个字符串切割为字符串数组，返回新的字符串数组，每个变量用”，“分隔，源字符串不改变 stringObject.split(seperator,howmany) 1234var str = ''how are?;console.log(str.split('')); //h,o,w,a,r,e,? ( seperator = '',则把每个字符都分割)console.log(str.split(' '));//how,are?console.log(str.split(' ',1));//how]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《寄生虫》-- 源自生活·本就你我]]></title>
    <url>%2F2019-08-07%2Fmovie-02.html</url>
    <content type="text"><![CDATA[金棕榈，实至名归 某种意义上生活中长存着寄生虫，但是……😑 内容 ## ## ##]]></content>
      <categories>
        <category>观影有感</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入手RSS订阅]]></title>
    <url>%2F2019-06-06%2Frss.html</url>
    <content type="text"><![CDATA[记录平时网站RSS订阅的操作，可以获得实时更新 疯狂鸽掉博客更新的自己 内容 var ap = new APlayer({ element: document.getElementById("aplayer-NxDDlpbO"), narrow: false, autoplay: true, showlrc: false, music: { title: "Faded (Restrung)", author: "Alan Walker", url: "http://prc4nro7n.bkt.clouddn.com/faded.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/faded.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); ## ## ##]]></content>
      <categories>
        <category>RSS</category>
      </categories>
      <tags>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所谓js作用域和闭包]]></title>
    <url>%2F2019-06-06%2Fjs.html</url>
    <content type="text"><![CDATA[记录一下上次面试题所设计到的js作用域和闭包 🎁大白话解释作用域和闭包是个啥作用域的分类常见的变量作用域就是 静态作用域（词法作用域） 与 动态作用域 。词法作用域注重的是 write-time ，即 编程时的上下文 ，而 动态作用域 则注重的是 run-time ，即 运行时上下文 。词法作用域中我们需要知道一个函数 在什么地方被定义 ，而动态作用域中我们需要关心的是函数 在什么地方被调用 而 javascript 使用的则是词法作用域 12345678910111213let value = 1function foo() &#123; console.log(value)&#125;function bar() &#123; let value = 2 foo()&#125;bar() // 1复制代码 在 javascript 解析模式中，当 foo 被调用的时候： 检查 foo 函数内是否存在 value 存在则使用这个 value 不存在则根据书写代码的位置查找上一层代码（这里的 window），找到 value 为 1 在动态作用域的解析模式中，当 foo 被调用的时候： 检查 foo 函数内是否存在 value 存在则使用这个 value 不存在则根据调用该函数的作用域中去寻找也就是这里的 bar 函数，找到 value 为 2 在从内层到外层的变量搜索过程中，当前作用域到外层作用域再到更外层作用域直到最外层的全局作用域，整个搜寻轨迹就是 作用域链 变量的两种查找类型一种是 rhs 一种是 lhs 假设有这么一段代码： 1234console.log(a) // 输出 undefinedconsole.log(a2) // 报错 a2 is not definedvar a = 1复制代码 上述代码实际上在变量提升的作用下应该是下面这个顺序： 12345var aconsole.log(a) // 输出 undefinedconsole.log(a2) // 报错 a2 is not defineda = 1复制代码 第一个 console 输出 undefined 因为还未执行赋值操作，查询过程是 rhs 也就是 right-hand-side 第二个 console 报错，是因为 rhs 查询 a2 变量不存在因此报错 a = 1 则是赋值操作，也就是 lhs，英文 left-hand-side 闭包闭包是啥？闭包就是从函数外部访问函数内部的变量，函数内部的变量可以持续存在的一种实现。 在了解了词法作用域和变量的查询方式之后，我们看看一个简单的闭包的实现逻辑： 1234567891011121314151617function f() &#123; let num = 1 // 里面的变量 function add() &#123; num += 1 &#125; function log() &#123; console.log(num) &#125; return &#123; add, log &#125; // 我要到外面去了&#125;const &#123; add, log &#125; = f()log() // 1 我从里面来，我在外面被调用，还是可以获得里面的变量add()log() // 2复制代码 首先定义一个 f 函数，函数内部维护一个变量 num，然后定义两个函数 add 和 log add 函数每次调用会增加 num 的值 log 函数每次调用会打印 num 的值 然后我们将两个函数通过 return 方法返回 紧接着先调用外部的 log 方法打印 f 方法维护的 num，此时为 1 然后调用外部的 add 方法增加 num 的值 最后再次调用 log 方法打印 num，此时则为 2 为什么外部定义的 add 函数可以访问 f 函数内部的变量呢。正常情况下外部作用域不可访问内部作用域的变量，但我们将内部访问其内部变量的方法“导出”出去，以至于可以从外部直接调用函数内部的方法，这样我们就可以从函数的外部访问函数内部的变量了。 经典的 for 循环问题12345678arr = []for (var i = 0; i &lt; 10; i ++) &#123; arr[i] = function() &#123; console.log(i) &#125;&#125;arr[2]() // 10复制代码 首先我们知道 for 循环体内的 i 实际上会被定义在全局作用域中 每次循环我们都将 function 推送到一个 arr 中，for 循环执行完毕后，arr 中张这样： 随后我们执行代码 arr[2]() 此时 arr[2] 对应的函数 function(){ console.log(i) } 会被触发 函数尝试搜索函数局部作用域中的 i 变量，搜索不到则会继续向外层搜索，i 被定义到了外层，因此会直接采用外层的 i，就是这里的全局作用域中的 i，等到这个时候调用这个函数，i 早已变成 10 了 那么有什么方法能够避免出现这种情况吗？ ES6 之前的解决方案： 了解了闭包我们就知道了闭包内的变量可以持续存在，所以修改代码将 arr 中的每一项改为指向一个闭包： 12345678910arr = []for (var i = 0; i &lt; 10; i ++) &#123; arr[i] = (function() &#123; // 这是一个闭包 var temp = i // 闭包内部维护一个变量，这个变量可以持续存在 return function() &#123; console.log(temp) &#125; &#125;)()&#125;复制代码 这样程序就能按照我们的想法运行了 ES6 之后的解决方案： ES6 之后我们就有了块级作用域因此代码可以改为这样： 1234567arr = []for (let i = 0; i &lt; 10; i ++) &#123; // 使用 let arr[i] = function() &#123; console.log(i) &#125;&#125;复制代码 在使用 let 之后，我们每次定义 i 都是通过 let i 的方法定义的，这个时候 i 不再是被定义到全局作用域中了，而是被绑定在了 for 循环的块级作用域中 因为是块级作用域所以对应 i 的 arr 每一项都变成了一个闭包，arr 每一项都在不同的块级作用域中因此不会相互影响 参考： https://github.com/mqyqingfeng/blog/issues/3 https://www.datchley.name/basic-scope/ https://segmentfault.com/a/1190000006671020]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关socket通讯的相关小知识]]></title>
    <url>%2F2019-06-05%2Fwebsocket.html</url>
    <content type="text"><![CDATA[由于课设的原因，查阅不少socket、轮询、ajax、comet、三次握手的相关资料 关于TCP协议提到TCP协议，那就离不开三次握手跟四次分手 三次握手但是为什么一定要进行三次握手来保证连接是双工的呢，一次不行么？两次不行么？我们举一个现实生活中两个人进行语言沟通的例子来模拟三次握手。 引用网上的一些通俗易懂的例子，虽然不太正确，后面会指出，但是不妨碍我们理解，大体就是这么个理解法。 第一次对话：老婆让甲出去打酱油，半路碰到一个朋友乙，甲问了一句：哥们你吃饭了么？ 结果乙带着耳机听歌呢，根本没听到，没反应。甲心里想：跟你说话也没个音，不跟你说了，沟通失败。说明乙接受不到甲传过来的信息的情况下沟通肯定是失败的。 如果乙听到了甲说的话，那么第一次对话成功，接下来进行第二次对话。 第二次对话：乙听到了甲说的话，但是他是老外，中文不好，不知道甲说的啥意思也不知道怎样回答，于是随便回答了一句学过的中文 ：我去厕所了。甲一听立刻笑喷了，“去厕所吃饭”?道不同不相为谋，离你远点吧，沟通失败。说明乙无法做出正确应答的情况下沟通失败。 如果乙听到了甲的话，做出了正确的应答，并且还进行了反问：我吃饭了，你呢？那么第二次握手成功。 通过前两次对话证明了乙能够听懂甲说的话，并且能做出正确的应答。 接下来进行第三次对话。 第三次对话：甲刚和乙打了个招呼，突然老婆喊他，“你个死鬼，打个酱油咋这么半天，看我回家咋收拾你”，甲是个妻管严，听完吓得二话不说就跑回家了，把乙自己晾那了。乙心想：这什么人啊，得，我也回家吧，沟通失败。说明甲无法做出应答的情况下沟通失败。 如果甲也做出了正确的应答：我也吃了。那么第三次对话成功，两人已经建立起了顺畅的沟通渠道，接下来开始持续的聊天。 通过第二次和第三次的对话证明了甲能够听懂乙说的话，并且能做出正确的应答。 可见，两个人进行有效的语言沟通，这三次对话的过程是必须的。 为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。 这个例子举得挺好的。不过个人感觉为什么是三次而不是二次，不是因为为了证明甲能听懂乙并回应（第二次乙能正确的响应甲说明俩人之间沟通已无障碍了），而是怕出现以下情况而浪费感情。这个情景是这样的（例子有点不实际意会就好）：甲在路上跟乙打招呼，由于刮风什么的这句活被吹跑了，然后甲又跟打了个招呼，乙听到了并作出了回应。此时不管是三次握手还是两次握手两个人都能愉快的沟通。0.1秒后俩人四次挥手告别了。此时被风刮跑的那句话又传到了乙的耳朵里，乙认为甲又要跟他沟通，所以做出了响应的回应。（问题出现了）假如采用2次握手，乙就认定了甲要跟他沟通，于是就不停的等，浪费感情。可如果是采用3次握手，乙等了一会后发现甲没有回应他就认为甲走了然后自己也就走了！ 这就很明白了，其实第三步是防止了乙的一直等待而浪费自己的时间，而不是为了保证甲能够正确回应乙的信息。。。后面的也会讲到。 引用知乎上的别人引用的一个回答，从另外一个角度阐释： 在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。 上面的纯属大白话娱乐讲解，可能还有偏差，例子可能有点不得体。在我们真正了解TCP的三次握手和四次分手之前，必须了解一些基本的概念，最后和这大白话例子对比结合一下理解，说不定就会顿时融会贯通。 HTTP与SOCKETHTTP连接HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常 的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道 客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。 SOCKET原理套接字（socket）概念套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。 建立socket连接建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 SOCKET连接与TCP连接创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。 Socket连接与HTTP连接由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求， 不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。TCP(Transmission Control Protocol) 传输控制协议 TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接: 位码即tcp标志位,有6种标示:SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码) TCP是什么？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 具体的关于TCP是什么，我不打算详细的说了；当你看到这篇文章时，我想你也知道TCP的概念了，想要更深入的了解TCP的工作，我们就继续。它只是一个超级麻烦的协议，而它又是互联网的基础，也是每个程序员必备的基本功。首先来看看OSI的七层模型： 我们需要知道TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层；在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在OSI七层模型中，每一层的作用和对应的协议见上图。 TCP是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记TCP协议中每个字段的含义。哦，来吧。 TCP头部上面就是TCP协议头部的格式，由于它太重要了，是理解其它内容的基础，下面就将每个字段的信息都详细的说明一下。 Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接； Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题； Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题； Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节； TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下： URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据； ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0； PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队； RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包； SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手； FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。 Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制；这是一个复杂的问题，这篇博文中并不会进行总结的； 暂时需要的信息有： ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1 SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。 FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。 为什么要有三次握手跟四次分手？三次握手与四次分手的过程： 多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。 那四次分手呢？当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。 为什么要三次握手？ 在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。 在谢希仁著《计算机网络》书中同时举了一个例子，如下： “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 这就很明白了，防止了服务器端的一直等待而浪费资源。 为什么要四次分手？那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方） FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方） CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方） LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方） TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方） CLOSED: 表示连接中断。 关于AJAX轮询以及cometAjax轮询“定时的通过Ajax查询服务端” 概念：轮询（polling）：客户端按规定时间定时像服务端发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 百闻不如一见，来段代码相信你一看就明白 Reception.html //前端代码 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var getting = &#123; url:'server.php', dataType:'json', success:function(res) &#123; console.log(res);&#125;&#125;;//关键在这里，Ajax定时访问服务端，不断获取数据 ，这里是1秒请求一次。window.setInterval(function()&#123;$.ajax(getting)&#125;,1000);&lt;/script&gt;&lt;/html&gt; //服务端。 server_polling.php 123456789101112&lt;?php$pdo = new PDO('mysql:dbname=test;host=127.0.0.1','root','root');$resource = $pdo-&gt;query('select * from t1');$result = $resource-&gt;fetchall();if ($result) &#123; //exits data print_r(json_encode(array('success'=&gt;'存在数据'))); exit();&#125;print_r(json_encode(array('failed'=&gt;'不存在数据')));exit();?&gt; 上面就是最基本最简化的Ajax轮询。判断t1表是否有数据，并执行对应输出。 实际项目中的话查询语句就根据实际需求来定就可以了。 Ajax轮询最关键的地方在于”window.setInterval(function(){$.ajax(getting)},1000);” ，也就是文章开头所说的”客户端按规定时间定时像服务端发送ajax请求”。 我们用图解释一下吧： 从图中我们可以看出，客户端是按照规定时间（这个时间由你设定，此处默认为1秒）像服务端发送请求，前一次请求完成后，无论有无结果返回，一秒之后下一次请求又会发出。这就叫做Ajax轮询。 用伪代码来表示一下： 1234567&lt;?php//Ajax轮询while(true)&#123; echo'发送一次请求'; sleep(1) ; //这次请求发送完毕了，休息一秒钟之后继续发起请求&#125;?&gt; 最关键的地方在于，客户端需要通过JS设定一个定时器，按照规定时间不断的请求。 容易吧，其实真就没那么难，很多时候，仅仅是我们自己被新技术吓到罢了 嗯那么我们接下来看看Ajax 长轮询，算是Ajax轮询的升级版 Ajax长轮询Ajax长轮询属于Ajax轮询的升级版，在客户端和服务端都进行了一些改造，使得消耗更低，速度更快。 “不间断的通过Ajax查询服务端”。 来，小二，先上代码~： Reception.html //客户端 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //前端Ajax持续调用服务端，称为Ajax轮询技术 var getting = &#123; url:'server.php', dataType:'json', success:function(res) &#123; console.log(res); $.ajax(getting); //关键在这里，回调函数内再次请求Ajax&#125; //当请求时间过长（默认为60秒），就再次调用ajax长轮询 error:function(res)&#123; $.ajax($getting); &#125;&#125;;$.ajax(getting);&lt;/script&gt;&lt;/html&gt; server.php: //服务端 123456789101112131415&lt;?php//这段AJAX请求时间永不过期set_time_limit(0);$pdo = new PDO('mysql:dbname=test;host=127.0.0.1','root','root');$resource = $pdo-&gt;query('select * from t1');$result = $resource-&gt;fetchall();while (true) &#123; if ($result) &#123; //exits data print_r(json_encode(array('success'=&gt;'存在数据，返回'))); exit(); //输出数据，退出。然后客户端不间断继续发起请求 &#125; //数据不存在，继续循环。&#125;?&gt; 看出了玄机了嘛？长轮询的精髓就在于Ajax的回调函数，继续再次调用Ajax请求（不间断的原理就在这里，成功返回后立即再次调用）： $.ajax(getting); 下面是是Ajax 长轮询的图解： 图中有两次请求（本文中的请求默认均为Ajax），第一次很快返回了结果，然后不间断的立即发送第二次请求，但是第二次请求没有获得数据，所以请求迟迟没有返回（被挂在服务器了，但只要有数据就会再次返回），如果第二次的请求返回数据后，第三次请求旋即会立刻发出，这种技术就称为Ajax 长轮询。 用伪代码来表示就是这样： 123456789&lt;?php//客户端通过Ajax发起请求if ('客户端发送请求' &amp;&amp; '服务端有数据可以返回') &#123; echo '返回数据给客户端'; echo '客户端通过Ajax继续发起请求，然后继续if判断';&#125;else&#123; echo'没有数据可以返回，再次执行一次if判断';&#125;?&gt; 最关键的地方在于前一次请求结束后，第二次请求立即不间断的发起，这个就叫做Ajax长轮询 comet—反向AJAX不得不说Ajax确实是一个好东西，由它的出现使得WEB端新技术不断产生，Comet就属于这么一个技术，这个技术有时叫做反向AJAX，有时叫做服务器”推”技术，嗯，不要被牛逼闪闪的名词吓倒，其实没那么难。 先看一下维基的解释： “Comet是一种用于web的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求，目前有两种实现方式，Ajax和iframe流。” ——维基百科 维基的解释比较绕，那我们用人话来解释一下： 凡是由服务端（即服务器，再具体点就是你目前访问的那个文件）实时的，不间断的往客户端（浏览器）发送数据的技术，都可以称之为Comet技术，目前这个技术可以通过两个方式实现，Ajax和iframe流。 还是有些不明觉厉的话，看代码： 12345678910111213&lt;?php$pdo = new PDO('mysql:dbname=test;host=127.0.0.1','root','root');$resource = $pdo-&gt;query('select * from t1');$result = $resource-&gt;fetchall();while (true) &#123; if ($result) &#123; echo '往服务器发数据' ; print_r($result); &#125;else&#123; &#125;&#125;?&gt; 将这段代码运行起来，就是一个最最最简化版的Comet技术。 想象一下，当服务器运行这段代码的时候，服务器是不是像吃炫迈一样一起像客户端（浏览器）发送数据？而且是根本停不下来那种，这就叫做Comet，也叫作服务器”推”，也叫反向ajax。 前台请求的代码如果是iframe，那就叫做iframe流，如果是ajax请求，那就叫做ajax 轮询/长轮询（见上文）。 内什么，你还问我Comet是啥？Comet就是服务器一直像客户端发送数据呀！ 关于iframe流，可见文章：https://www.cnblogs.com/lecaf/archive/2011/07/20/2111618.html 关于websocket]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>计网</tag>
        <tag>ajax</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一首独特的Faded(remix)]]></title>
    <url>%2F2019-06-05%2Fmusic00.html</url>
    <content type="text"><![CDATA[百听不厌fade系列，我觉得稳得不行 Fade 相信很多人都知道，只是一首特别火的 remix 音乐。 Faded 是基于这首曲子的一首音乐。原唱是个女声，这个版本感觉节奏律动都要更好一点。]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于四六级及拈算法--给易班技术服务部的你们]]></title>
    <url>%2F2019-05-26%2FE-class.html</url>
    <content type="text"><![CDATA[易班技术♂服务部，希望来年可以少一点♂，多一点♀ 天下无难事，只怕有心人，天下天易事，只怕粗心人！ ——袁枚It is dogged does it. The days of easy, but careless people. ——Yuan Mei var ap = new APlayer({ element: document.getElementById("aplayer-rqjoeHhf"), narrow: false, autoplay: true, showlrc: false, music: { title: "There's nothing holding me back (Acoustic)", author: "Shawn Mendes", url: "http://psu4sovbi.bkt.clouddn.com/There%27s%20nothing%20holding%20me%20back.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/19220562765374618.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 关于四六级考试技巧前言上学期其实说过四级的一些刷分技巧，但是正常也忘得差不多了:)，WDNMD 无论怎么样，我所言仅是蒙题技巧，英文日常优秀的人只要升级自己的词汇量即可，其中四级为4000，而六级为6000，但词汇量这种东西多多益善，而平心而论一般&gt;4000之后四六级基本可以水过，不过六级建议刷高分 这里附上词汇量测试链接：Click Me 英语高手请出门左转，或者右转 题型组成 写作 听力理解 短篇新闻 长对话 长听力篇章（六级为讲话/报道/讲座）⭐偏难 阅读理解 15选10 阅读匹配 仔细阅读（⭐重要） 翻译 刷分技巧听力理解一般而言，25个答案包括：6A+6B+6C+6D=24个选项然后+ABCD其中的任易一个，其中每五个选项中，普遍会出现ABCD 针对听力的蒙题方法只能适用于四级，少量适用于六级，而且比较佛，除非听不懂，不然不建议 听不懂说的就是你吧… 四级的听力且还行，但六级的听力我觉得不行 之前提及的重要一点：不要等到听力提问再选题，我们只能听到什么选什么 看到听力题之后，需要马上圈出选项中的异处（浏览ABCD四个选项，提取共同点，圈出异同点，这即是需要留意的地方，一般提及的时候就稳了，如果仍提及时间，最好标识上记号，那这个时候要根据提问来选题） 学会取舍放弃，不能在一棵树上挂死，对话两三个来回出一个题目选项，如果已经很久，那要往下看，在下一棵树上挂死（一个来回：一问一答） 听力中反复出现的词，高几率会答案选项 六级听力最难的题在于讲座题，长篇大论你听不到你想要的，这个时候最好打开耳朵听听得出个大意，重点在高频出现的词 阅读理解选词填空15选10，四六级难度相差很大，这道题若要精准命中，那就需要一定的词汇量积累，但对于懵题技巧，四六级都差不多，在于对主谓宾的划分，以及时态跟主被动的筛选，具体说法上个学期已经讲的很仔细了。只是六级多了很多长难句，所以这就是难点。 （切忌在这道题纠结太多时间，推荐有剩余时间再去纠结） 阅读匹配（送分题）无论四六级，这道题都是送人头的，不需要你读懂文章，你唯一需要做的仅仅是先看题目划题目特殊主谓宾，然后回去原文找即可，这道题只是考你的观察力。对你的语感能力不要求，走过路过，这题不要放过。 注意：同一段落可以多次出现在答案里，但基本不超过2次 阅读理解得阅读理解者得天下 四六级难度差异大，六级会增添一堆长难句，以及一堆陷阱 对于四级，仅需要跟高考英语一样，划主干回去文章找选项即可 对于六级，理解文意是必要的，六级阅读的选项将会出现一堆概述，这说明你从选项里找回原文，将会无从下手。 若选项中直接照搬原文，完全无增添，那样基本是陷阱，可以不考虑 写作及翻译写作龙头凤尾，这即是四六级写作的重点，字体跟字数也是重点，基本把握头尾，无出现乱涂乱划，分数不会差到哪里去，那么关于龙头凤尾怎么速成，那即是作文模板 题目类型（切记看好题目，偏题即死） 看图说话 对某句话进行议论 开放式写作 针对题目类型记忆文章 （之后会贴上一些文章模板） 模板类型 翻译翻译还是那句话：宁可直译，不可跳句，总会出现那么几句刁钻的话，那个时候追求最大相似度的翻译即可 祝语最后希望大家都能顺利过四六级，当然是没那么简单的，无论什么样的技巧，英语本身最主要在于词汇跟口语，两者不可丢。(:≡加油加油，多刷几次 拈算法关于之前 n进制的幂 约瑟夫斯–互砍算法 婚姻匹配算法 missing number 以上为部门例会所提及过的算法 可以见我的另一篇博客 Click Me 下面是之前提及到的拈算法 拈 (Nim)最有名的玩法​ 單堆遊戲是拈的遊戲中較簡單的一種。據說，拈的遊戲源自中國，經由被販賣到美洲的奴工外傳。所以這個小遊戲先在工人間流行，他們就地取材撿小石子來玩。後來流傳到上流人士，改以銅板在酒吧櫃檯上玩。最有名的玩法是將十二枚銅板分三列排成「三、四、五」的遊戲，如下圖： ​ 遊戲的規則很簡單：兩人輪流取銅板，每次需在某一列取一枚或一枚以上的銅板，但不能同時在兩列取銅板，最後將銅板拿光的人贏得此遊戲。（或是相反的情形：最後將銅板拿光的人輸。） ​ 讓我們先看二列的例子： 假設甲先取，乙後取，甲如何可取得勝利？ 我們先注意到，甲若欲取勝，就得避免將某一列完全取光，否則對方可全取剩下的一列，而拿到最後一枚銅板。 &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; 由 1~ 4，我們可以推得，甲若留下兩列枚數相同的銅板給乙，甲必可獲勝。反之乙若留下兩列枚數相同的銅板給甲，乙必可獲勝。 ​ 抓到兩列的訣竅之後，再來看看三列的情況： 假設甲先取，乙後取，甲如何可取得勝利？ &lt;由二列的情形得知，乙勝&gt; &lt;由二列的情形得知，乙勝&gt; &lt;由二列的情形得知，乙勝&gt; 由 1 ~ 3 可推得，若甲欲贏得勝利，就必需避免在留下的三列銅板中，有兩列的銅板數相同。 此外，甲取完之後三列的銅板數若分別剩下1, 2, 3，則甲勝。 &lt;甲勝&gt; (二三列相同) &lt;甲勝&gt; (一三列相同) &lt;甲勝&gt; &lt;甲勝&gt; (一二列相同) &lt;甲勝&gt; &lt;甲勝&gt; 多玩幾次之後，大家可以發現一開始若甲在第一列取二枚，可取得勝利。 &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; (一二列相同) &lt;甲勝&gt; &lt;甲勝&gt; (二三列相同) &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; (一三列相同) &lt;甲勝&gt; 因此，一開始甲只要在第一列取2枚，就可以搶得先機而取得勝利。 一般法則與二進位​ 玩久了「三、四、五」的型態，很容易便知道勝利的關鍵是什麼，玩起來也沒什麼意思。所以可以將銅板的列數或每一列的銅板數改變，這樣要找出所有規律就不太容易了。 ​ 直到本世紀初，哈佛大學數學系副教授查理士．理昂納德．包頓 (Charles Leonard Bouton) 才利用數的二進位表示法，解出了這個遊戲的一般法則： ​ 對於任意列數，每列有任意枚數的銅板，致勝之道為何？包頓的方法很簡單。首先，將各列的銅板數化成二進位數，然後相加，但不進位。換句話說，就是 ​ 1 + 0 = 1​ 0 + 1 = 1​ 1 + 1 = 0​ 0 + 0 = 0 再看一個例子： 1 + 1 + 1 = (1 + 1) + 1 = 0 + 1 = 1 於是我們知道：偶數個1相加會得到0，奇數個1相加會得到1。 ​ 如果遊戲規則為：最後將銅板拿光的人贏得遊戲。各列的銅板數化成二進位數相加之後（不進位）的每一位數都是0的狀況為安全殘局；相反地，只要其中有任何一位數是1，就是不安全殘局。 例如「三、四、五」遊戲，一開始就是不安全殘局，先拿的人可以適當取二枚（第一列取2枚）而造成安全殘局。 一般情形之下，將不安全殘局轉變成安全殘局的方法常常不只一種，如下： ​ 為什麼安全殘局和不安全殘局可以利用上述的方法判定呢？這可以分成幾個部分來看： 若你留下上述所謂的安全殘局，即總和的每一位數都是0，由於不論對方取那一列的多少枚銅板，該列銅板數所對應的二進位數中，必定至少有一位數會由0變成1或者由1變成0，於是其總和的相對位數也會由0變成1。例如，{1,4,5}這個安全殘局，從第二列的4枚銅板中取走2枚，則 相反的，如果總和的某一位數是1，我們總有辦法在適當的列取走適當枚數的銅板，使得新總和的每一位數都是0。 首先，找出總和中所有是1的位數{n1,n2,…,nk}其中n1&lt;n2&lt;…&lt;nk；在之前提到的例子{ 14, 15, 18, 22 }中，{n1,n2}={ 1, 3}；也就是說，總和的第1位與第3位都是1。 找出一列其銅板數之（二進位表示法）第nk位數（也就是最左邊的一位，本例中是第3位）剛好是1；本例中，14（第一列）、15（第二列）、22（第三列）皆是。 接著改變該列二進位數中的所有ni位數值，亦即將0變為1，將1變為0。如此，我們會得到一個新數；以14（第一列）為例，14 = 1110，將其第1位與第3位改變，便得到1011 = 11枚銅板。 ​ 利用上面的方法，我們可以在該列中取走適當的銅板，使剩下的銅板數二進位總和的每一位數都是0；例如，在第一列取走14 – 11 = 3枚銅板。 ​ 反過來，若規定取走最後一枚銅板的人輸，也就是變成取完後的銅板數為0的人輸。之前的安全殘局現在變成了不安全殘局，而之前的不安全殘局也變成了安全殘局。所以若欲贏，就得讓取完後的二進位總和中至少有一位數是1。再來看看3, 4, 5的例子： ​ &lt;甲勝&gt; ​ 從以上的例子，你應該可以發現，前面幾步中，甲乙都可以留下自己的安全殘局，直到後來出現有某一列的銅板數大於1，而其他列都只剩一枚的情況。這時輪到甲來取，甲如何取就是勝負的關鍵：甲可以選擇將較多枚銅板的那一列拿光，或拿到只剩一枚。在這個例子中，甲選擇將該列拿到只剩一枚，因為這樣才能使剩下的列數為“奇數”，當然每一列均只有一枚銅板。顯而易見的是，以後一人取一列，到最後拿的一定是乙，於是甲必勝。 以上内容搬运自书籍《数学游戏》，拈游戏可以视作为单堆游戏的拓展包，而关于单堆游戏玩法多样，就不放在这里，之后会另开一篇]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ppt的“代码”收录]]></title>
    <url>%2F2019-05-24%2Fppt-code.html</url>
    <content type="text"><![CDATA[连续两天折腾powerpoint后，才发现里面含有开发工具，对某些功能的实现提供了方便 这年头啥都有开发工具，真是累了 “你不必生来勇敢、天赋过人，只要能投入勤奋，诚诚恳恳”第一次听见这首歌，是在雨夜，配合着雨声，莫名被这首歌勾住了魂( •̀ ω •́ )✧ 抽奖代码实现关于抽奖关于抽奖的流程，主要是两种途径，一种是在ppt里加上此功能，第二种是使用第三方软件或者网页。 第一种实在是找不到什么比较贴切的主题，多半比较low，而且有一点就是如果自己设置的话略微麻烦 第二种的话会给人一种违和感，需要切出ppt的操作感，会给观众一种莫名的不舒适感，所以个人是比较排斥这种方法。 ⭐然后就有了第三种方法，就是通过代码动态生成 必备品powerpoint一般是不会将开发工具这一tab栏打开，需要用户自行设置 设置方法：文件-设置-开发工具√ 加载代码的ppt似乎需要将原格式（ppt或者pptx）更改为另存为适用宏定义的格式，比如pptm，详细可以见右键另存为，格式列表讲的很清楚了 代码1234567891011121314151617181920212223Public a, b As IntegerPrivate Sub Label1_Click()End SubPrivate Sub 结束抽奖_Click()b = 1Label1.Caption = aEnd SubPrivate Sub 开始抽奖_Click()b = 0Do While Truea = 1 + Int(Rnd() * 100)Label1.Caption = aDim Savetime As SingleSavetime = TimerWhile Timer &lt; Savetime + 0.005DoEventsWendIf b = 1 Then Exit DoEnd IfLoopEnd Sub 效果图（略）(≧︶≦))(￣▽￣ )ゞ]]></content>
      <categories>
        <category>ppt</category>
      </categories>
      <tags>
        <tag>ppt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechatVote脚本探讨]]></title>
    <url>%2F2019-05-20%2FwechatVote.html</url>
    <content type="text"><![CDATA[对之前班级评比“被”微信刷票的事情耿耿于怀￣へ￣ 对wechatVote的兴趣，主要是来自班级里的“拉拉队投票事件”，希望wechat早点修复这块存在的漏洞，不然以后如果再遭遇这种不正当待遇，只能大家一起刷一起爽了……正所谓“谈，大门敞开；打奉陪到底”，最近真的痴迷于新闻联播这句话~(￣▽￣)” var ap = new APlayer({ element: document.getElementById("aplayer-CRUsFEqh"), narrow: false, autoplay: true, showlrc: false, music: { title: "Faded (Restrung)", author: "Alan Walker", url: "http://psu4sovbi.bkt.clouddn.com/faded.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/faded.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); WechatVote对于之前遭遇的微信拉票事件，闲来无事研究了一下，确实发现这个活动是可以刷票的，简要的记录一下写刷票脚本的过程。实际上，这种爬虫代码的实现永远都是小问题的，重要的是你要知道别人的页面的逻辑，如何去分析和爬取才是难点。 打开微信的投票页面，将屏幕往下拉会发现屏幕顶端显示为”本网页由XXX提供”，需要注意的是，这里的”XXX”并不是”mp.weixin.qq.com”，而是活动举办方的域名。也就是说，这个投票活动的程序是运行在S商城的服务器上面的。这里就涉及到微信公众平台OpenID的概念了，官方对OpenID的解释是：加密后的微信号，每个用户对每个公众号的OpenID是唯一的。也就是一个用户对一个公众号有一个唯一的OpenId。 投票的逻辑是用户在投票请求时，会在POST参数中提供用户的OpenID；S商城服务器在接收到投票的POST请求后，通过查询当前OpenID是否在4小时已经投过票，就可以阻止单一用户重复投票的行为了。 然而，这里面却存在一个很大的漏洞！ S商城只能判断OpenID是否出现了重复，但是却无法校验OpenID的有效性，因为它是无法调用微信服务器来对这个OpenID进行校验的。 那么我们只需要生成符合格式OpenId然后发送post请求就可以了。 但是一次投票也很奇怪，实际上是分两步完成的。第一次是一个get请求（图片中被打码的部分设计到隐私，只需要知道一次投票是通过两个请求来完成的就行了 当我看到第一个请求的名字的时候，我以为是这次请求就完成了，但当使用爬虫访问这个接口时，并不能使得票数增加。仔细观察后发现是有另外一个请求。 这个请求的path很奇怪，是一串乱码，而且每次不一样。只触发了第一个请求之后没有再进行其余的操作，这时我就能我就能确定，一次投票是通过第一个请求得到一些随机生成的参数，然后再第二次请求带上这些参数来保证第二次请求的合法性，这样来完成一次投票过程。所以第一个请求的页面中一定有地方调用了第二个请求。这个时候查看源代码时发现在页面中有一串这样的代码 当在页面中发现乱码的时候，往往是代码被加密了 其中有两个参数是第二个请求的path，可以看出这串乱码是和第二个请求有关联的，而那一串颜文字是对js代码的加密。虽然我们看不懂这串乱码是什么意思，但我们可以按分号（；）将这串乱码格式化之后直接在chrome控制台中跑，发现这串颜文字代码的效果就是执行第二个请求。（这个地方应该是可以还原代码的，有知道的可以讲解一下） 总结到这里基本上就算做完了，剩下的就是代码实现，总的来说，就是访问第一个请求，用正则在页面中爬取参数，将参数作为第二个请求的path进行对第二个请求的访问。当然还有ip代理，访问的随机的时间间隔，最好能动态模拟不同的设备，即修改User-Agent这些常见问题就不做说明，如果对这些有什么问题可以发邮件。 总的来说，使用python进行代码实现并没有多大的难度，难度在于一步步的分析，掌握网站的逻辑，并不断的尝试。这点只有多做才有效果。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197import randomimport reimport stringimport timefrom bs4 import BeautifulSoupimport requestsclass Ip_List: """ ip代理池 """ def __init__(self): self.ip_list = [] self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36' &#125; self.proxy = &#123; "http":"60.191.201.38:45461" &#125; def get_ip_list(self): """ 从网站爬取ip_list :return: """ for page in range(1, 20): url = "http://www.xicidaili.com/nn/" + str(page) web_data = requests.get(url=url, headers=self.headers,proxies = self.proxy) print(web_data) soup = BeautifulSoup(web_data.text, "lxml") ips = soup.find_all('tr') print(ips) for i in range(2, len(ips)): ip_info = ips[i] print(ip_info) tds = ip_info.find_all('td') self.ip_list.append(( tds[5].text,tds[1].text + ":" + tds[2].text)) return self.ip_list def get_random_ip(self): """ :return: 1.http还是https 2.ip """ random_one = random.choice(self.ip_list) return random_one[0].lower(), random_one[1]class Vote: def __init__(self): self.activityId = self.playerId = self.number = self.activityName = self.isGift = self.success_url = self.vote_url = @staticmethod def random_sleep_time(digits_length): """ 随机睡眠 :param digits_length: :return: """ digits_char = string.digits need_sleep_time = '' for i in range(digits_length): need_sleep_time += random.choice(digits_char) return int(need_sleep_time) + 2 def get_open_id(self): def getRandomString(id_length): charSeq = string.ascii_letters + string.digits randString = '' for i in range(id_length): randString += random.choice(charSeq) return randString return getRandomString(16) + "-" + getRandomString(11) def success(self, open_id, ip_t): """ 访问第一个页面，得到参数 :param open_id: open_id :param ip_t: ip状态和ip地址 :return: 返回得到的两个钩子参数 """ url = self.success_url proxy = &#123; ip_t[0]: ip_t[1] &#125; params = &#123; "activityId": self.activityId, "openId": open_id, "playerId": self.playerId, "number": self.number, "activityName": self.activityName, "isGift": self.isGift &#125; headers = &#123; # "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", # "Accept-Encoding": "gzip, deflate", # "Accept-Language": "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7", # "Connection": "keep-alive", # "Cookie": "JSESSIONID=BEDA66485B52B1FB4C916C39499EA081", # "Upgrade-Insecure-Requests": "1", "User-Agent": "Mozilla/5.0 (Linux; U; zh-cn; GT-S5660 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 MicroMessenger" &#125; # params = parse.urlencode(params) # print(params) r = requests.get(url=url, params=params, headers=headers, proxies=proxy) html = r.text # soup = BeautifulSoup(html,"html.parser") # 正则找出埋的钩子参数 pattern1 = re.compile(r'var _0sdfad="(.*?)"', re.MULTILINE | re.DOTALL) pattern2 = re.compile(r'var _0ees88="(.*?)"', re.MULTILINE | re.DOTALL) index1 = re.search(pattern1, html) index2 = re.search(pattern2, html) res1 = index1.group().replace(r'var _0sdfad="', "").replace('"', '') res2 = index2.group().replace(r'var _0ees88="', "").replace('"', '') # print(soup) return res1, res2 def vote_real(self, open_id, ip_t): index1, index2 = self.success(open_id, ip_t) url = self.vote_url +"/"+ index2 + "/" + index1 proxy = &#123; ip_t[0]: ip_t[1] &#125; params = &#123; "activityId": self.activityId, "openId": open_id, "playerId": self.playerId &#125; headers = &#123; # "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", # "Accept-Encoding": "gzip, deflate", # "Accept-Language": "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7", # "Connection": "keep-alive", # "Cookie": "JSESSIONID=BEDA66485B52B1FB4C916C39499EA081", # "Upgrade-Insecure-Requests": "1", "User-Agent": "Mozilla/5.0 (Linux; U; zh-cn; GT-S5660 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 MicroMessenger" &#125; r = requests.post(url=url, params=params, headers=headers, proxies=proxy) print(r) def do(self, ip_t): open_id = self.get_open_id() self.vote_real(open_id, ip_t)class FileWriter(object): def writer(self, text): with open('ip_list.txt', 'a', encoding='utf-8') as f: f.write(text + '\n')if __name__ == "__main__": ipList = Ip_List() ipList.get_ip_list() vote = Vote() file_writer = FileWriter() success_count, error_count = 0, 0 ip_useful_list = [] for i in range(5): try: ip_t = ipList.get_random_ip() print(ip_t) vote.do(ip_t=ip_t) random_wait_time = vote.random_sleep_time(1) time.sleep(random_wait_time) except Exception: error_count += 1 print("error_count: ",error_count) else: print("success_count: ",success_count) success_count += 1 if ip_useful_list.count(ip_t)==0: ip_useful_list.append(ip_t) print("---") for ip_t in ip_useful_list: file_writer.writer(ip_t[0]+" "+ip_t[1])]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>刷票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《宠物坟场》--观影有感]]></title>
    <url>%2F2019-05-18%2Fmovie-01.html</url>
    <content type="text"><![CDATA[期待了很久的《宠物坟场》终于在考完概率论后补完，借此利用博客记录一波电影感想 一部让人在观影后对猫产生“反感”的电影 既然是微恐怖片，那先来首惊悚配乐先，而网易云这类曲子生成外链也基本没有版权分享障碍，那就不借助aplayer插件来配置背景音乐了，也懒得上传到七牛(￣y▽￣)╭ Ohohoho….. 关于去年大火的《IT》说到恐怖片，一定少不了斯蒂芬·金，提到他那就不得不提到去年改编自其原小说的一度引起烂番茄9.0的高分恐怖片《IT》，没错，是IT，小丑惊魂（今年将会推出续作，所谓大咖云集，想必可以在这部大作见识到）。作为题外话，我个人倒是对小丑惊魂不是很有feel，整体给我一种美剧《怪奇物语》的感觉，但是毕竟是电影，讲述故事的程度不如美剧丰满，所以我也不是很能懂老外对这类电影的审美要求。虽然观影下来也不赖就是了，今年IT2出炉后估计又会引出一波狂潮……大概吧 小丑惊魂第二篇的预告片 看完会觉得绝佳有木有，不得不提19年真是大片云集的一年，撇去妇联4不说，恐怖片这一类型今年简直疯狂输出，而且题材都是让人看得心痒痒的。 下面贴出19年我比较期待的电影 寂静之地 宠物坟场 污秽的房间 遗孀秘闻（友谊永固） 鬼眨眼 她 网诱惊魂 爬行 我们 亮光 爬行 哭泣女人的诅咒 在黑暗中讲述的恐怖的故事 安娜贝尔3：回家 小丑回魂2 仲夏夜惊魂 贞子 哭声（差评，看得我难受，一段时间都不想接触韩恐） 电影观感 电影中的主角(误)——起死回生的猫，满满的萌点有木有又是一部看完让人“万能钥匙”的电影，不过随着阅历的增长，倒是觉得这类结局也没什么。19年的宠物坟场作为翻拍，导演又自己增加恐怖要素，比如脊骨扭曲的女主姐姐跟车祸毁去半边脸的学生，这两个倒是确实瘆人，但是跟剧情不是很沾边，姐姐那边的剧情倒还行，但是学生的穿插还是有点莫名其妙的，最后搞得整部电影前面趋于平淡（虽然平淡，但是剧情还是挺有看点的），电影转折点莫过于就在于女儿被猫所引导车祸死（在我看来就是如此，━┳━ ━┳━），这一段的长镜头先点个赞先，还是给边吃外卖边看电影的我一定震撼感的，惊呆了呀！ 最后真的想打死男主的冲动，以为是残血反杀的烂作，但是竟然大家都入了宠物坟场，那就给个好评吧~ 那接下来还是好好期待今年第二部改编自斯蒂芬·金小说的恐怖片《小丑惊魂2》吧 电影资源这里给上电影的资源，#号后面为提取码，welcome to Pet Sematary https://pan.baidu.com/s/1zY3oTAIRNwu8HdkQo13sfA#w125]]></content>
      <categories>
        <category>观影有感</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>猫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多想在平庸的生活拥抱你]]></title>
    <url>%2F2019-05-15%2Fbbforfun-1.html</url>
    <content type="text"><![CDATA[“时间无言 如此这般 直到看见平凡才是唯一的答案 ——————记与师弟谈心的一日” var ap = new APlayer({ element: document.getElementById("aplayer-RKLqSCjW"), narrow: false, autoplay: false, showlrc: false, music: { title: "平凡之路", author: "华晨宇", url: "http://psu4sovbi.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/109951163911444882.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); “我想用半年彻底放空自己，什么都不想” 来自师弟的感谢文 “学长，真的谢谢你这段时间的帮助和关心，结果还是有点小遗憾，但是还是要再道声谢谢” 诸多师弟中，这位师弟是我比较希望能够转成功的18级新生，虽说失败在所难免，但是似乎对转专业这条路有所误解，作为大一新生，本身对毕业出路本就了解甚少，今天道出来的丧气话愣是让我想到了那个早年那天那时刻–我鼓起勇气尝试去转专业 那年转专业的那些事转专业是否是就业计算机的唯一出路呢？ 关于这个问题，其实谁心中都有所答案，都会说出像：“就业跟你的专业无关，看个人能力”，这句话愣是动摇了不少要转专业的新生们，但作为一个大一新生，对这类话语的理解又能是多少呢？多半会认为是自我安慰罢了，没错，这也是我当初的真实写照，当初我打算无论成败都尝试看看咯，我的大一，并不会像这位师弟那般充满着对转专业的憧憬，相反，我是时刻抱着转专业失败的心情，告诉自己：“未来的道路你能走多远，从你高考失利的那一年开始就已经决定了”，我否认了自己，但却不打算屈服于自己，所以大一那年抽空把C语言给入门了一波，借着在部门所学的片面知识打算冲一波工作室。 随着转专业资格名单公布时间的推进，心里越是波折，辗转反侧，难以入眠，焦虑，害怕，恐惧，紧张…… 可是我又能怎么办？这种事情避免不了…… 随着时间推移，就越发否认自己的能力。所以我决定好：转专业必定不是就业的唯一出路，我要在资格公布之前规划好另一个平行时空的我的学习计划：综合即是在学好环境本科的前提下深造计算机，即使对环境的热爱为0，也不能耽误自己的本科学习，因为这就是这一个平行时空的你应该遭受的待遇，你只能如此…… 随着规划的全面，自己的心也渐渐稳定下来，虽然对转专业的期待并不少，但至少不会把它当成大学四年的唯一稻草了，我开始做二手准备：学习C语言准备转专业考试的同时，准备工作室面试考核，学习web开发。 当天平趋近于平衡的时候，人们的心也会明明平缓下来，对自己的否认程度也会降低，对未来不会特别迷茫 终于那一天到了。 紧张兮兮点开官网，下载转专业考试资格表，一行一行仔仔细细生怕错过自己的名字，前面十六位究竟有无我的名字，1.2.3….10.11.12.13.14.15!!! 明明还没有开始转专业考试，只是一个名单，我就乐得笑不出声，因为点开的那一瞬间已经做好各种失败的想法了，是另一个平行时空的绝望？堕落？或是按照二手准备那样好好安排自己？ 另一个平行时空的自己另一个平行时空的自己时隔一年出现了，这位师弟的所言所行即是当年的我脑子所想的画面 “我开始相信命运会有上限，这一次我真的疲倦了，我不想再做一个充满危机感和焦虑感的大学生了” 这句话很扎心，是堕落感跟赤裸裸的绝望，可想而知，师弟也经历过同样的波折，辗转反侧，难以入眠，焦虑，害怕，恐惧，紧张……而且经历过这些后经历的惨痛的失败，惨痛痛在一年之久的准备，痛在自责，痛在开始怨天尤人，表面上能笑着说：“谢谢师兄，我之后会继续努力的”，但是心理上的刺痛，其实我也模拟过，所以很心疼他，一言一行很想让我多在平庸的生活多多关怀安慰，但是这种时候最重要的还是自己的自我排解。 看到他真的仿佛看到自己本人，或许转专业顺利成功的我没多大资格去安慰他，但是至少可以提供当初自己二手准备所铺好的路，加油吧，小师弟，也献给另一个平行时空的自己。 多想在平庸的生活拥抱你 var ap = new APlayer({ element: document.getElementById("aplayer-nNPSUUnu"), narrow: false, autoplay: false, showlrc: false, music: { title: "多想在平庸的生活拥抱你", author: "隔壁老樊", url: "http://psu4sovbi.bkt.clouddn.com/%E5%A4%9A%E6%83%B3%E5%9C%A8%E5%B9%B3%E5%BA%B8%E7%9A%84%E7%94%9F%E6%B4%BB%E6%8B%A5%E6%8A%B1%E4%BD%A0.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/109951163911444882.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 仅以此曲希望师弟早日摆脱阴霾，成为不平凡的自己]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于n的幂次方问题]]></title>
    <url>%2F2019-05-13%2Fleetcode-01.html</url>
    <content type="text"><![CDATA[收录一些见到的比较耐人寻味的leetcode上的算法题(⓿_⓿) (●’◡’●) 希望一周至少更新两次 按照算法题类型会逐步更新 var ap = new APlayer({ element: document.getElementById("aplayer-xCxZqxEL"), narrow: false, autoplay: false, showlrc: false, music: { title: "Viva la Vida", author: "Coldplay", url: "http://psu4sovbi.bkt.clouddn.com/Viva%20la%20Vida.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/Viva.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); n的幂问题LeetCode 第 231 号问题：2 的幂题目描述给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 123输入: 1输出: true解释: 20 = 1 示例 2: 123输入: 16输出: true解释: 24 = 16 示例 3: 12输入: 218输出: false 题目解析首先，先来分析一下 2 的次方数的二进制写法： 仔细观察，可以看出 2 的次方数都只有一个 1 ，剩下的都是 0 。根据这个特点，只需要每次判断最低位是否为 1 ，然后向右移位，最后统计 1 的个数即可判断是否是 2 的次方数。 代码很简单： 1234567891011class Solution &#123;public: bool isPowerOfTwo(int n) &#123; int cnt = 0; while (n &gt; 0) &#123; cnt += (n &amp; 1); n &gt;&gt;= 1; &#125; return cnt == 1; &#125; &#125;; 该题还有一种巧妙的解法。再观察上面的表格，如果一个数是 2 的次方数的话，那么它的二进数必然是最高位为1，其它都为 0 ，那么如果此时我们减 1 的话，则最高位会降一位，其余为 0 的位现在都为变为 1，那么我们把两数相与，就会得到 0。 比如 2 的 3 次方为 8，二进制位 1000 ，那么 8 - 1 = 7，其中 7 的二进制位 0111。 图片描述 代码实现利用这个性质，只需一行代码就可以搞定。 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return (n &gt; 0) &amp;&amp; (!(n &amp; (n - 1))); &#125; &#125;; LeetCode 第 326 号问题：3 的幂题目描述给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 12输入: 27输出: true 示例 2: 12输入: 0输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 题目解析正常的思路是不停地去除以 3，看最后的迭代商是否为 1。这种思路的代码使用到了循环，逼格不够高。 这里取巧的方法 用到了数论的知识：3 的幂次的质因子只有 3。 题目要求输入的是 int 类型，正数范围是 0 - 231，在此范围中允许的最大的 3 的次方数为 319 = 1162261467 ，那么只要看这个数能否被 n 整除即可。 动画描述待补充 代码实现12345class Solution &#123; public boolean isPowerOfThree(int n) &#123; return n &gt; 0 &amp;&amp; 1162261467 % n == 0; &#125;&#125; LeetCode 第 342 号问题：4 的幂题目描述给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。 示例 1: 12输入: 16输出: true 示例 2: 12输入: 5输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 题目解析这道题最直接的方法就是不停的去除以 4 ，看最终结果是否为 1 ，参见代码如下： 12345678class Solution &#123; public boolean isPowerOfFour(int num) &#123; while ( (num != 0) &amp;&amp; (num % 4 == 0)) &#123; num /= 4; &#125; return num == 1; &#125;&#125; 不过这段代码使用了 循环 ，逼格不够高。 对于一个整数而言，如果这个数是 4 的幂次方，那它必定也是 2 的幂次方。 我们先将 2 的幂次方列出来找一下其中哪些数是 4 的幂次方。 十进制 二进制 2 10 4 100 （1 在第 3 位） 8 1000 16 10000（1 在第 5 位） 32 100000 64 1000000（1 在第 7 位） 128 10000000 256 100000000（1 在第 9 位） 512 1000000000 1024 10000000000（1 在第 11 位） 找一下规律： 4 的幂次方的数的二进制表示 1 的位置都是在奇数位。 之前在小吴的文章中判断一个是是否是 2 的幂次方数使用的是位运算 n &amp; ( n - 1 )。同样的，这里依旧可以使用位运算：将这个数与特殊的数做位运算。 这个特殊的数有如下特点： 足够大，但不能超过 32 位，即最大为 1111111111111111111111111111111（ 31 个 1） 它的二进制表示中奇数位为 1 ，偶数位为 0 符合这两个条件的二进制数是： 11010101010101010101010101010101 如果用一个 4 的幂次方数和它做与运算，得到的还是 4 的幂次方数。 将这个二进制数转换成 16 进制表示：0x55555555 。有没有感觉逼格更高点。。。 图片描述 代码实现12345678910111213class Solution &#123; public boolean isPowerOfFour(int num) &#123; if (num &lt;= 0) return false; //先判断是否是 2 的幂 if ((num &amp; num - 1) != 0) return false; //如果与运算之后是本身则是 4 的幂 if ((num &amp; 0x55555555) == num) return true; return false; &#125;&#125; 有趣的动态规划题目 稳定婚姻算法（Stable Matching Problem）问题的引出有N男N女，每个人都按照他对异性的喜欢程度排名。现在需要写出一个算法安排这N个男的、N个女的结婚，要求两个人的婚姻应该是稳定的。 何为稳定？ 有两对夫妻M1 F2，M2 F1。M1心目中更喜欢F1，但是他和F2结婚了，M2心目中更喜欢F2，但是命运（￣︶￣）↗ 却让他和F1结婚了，显然这样的婚姻是不稳定的，随时都可能发生M1和F1私奔或者M2和F2私奔的情况。所以在做出匹配选择的时候（也就是结婚的时候），我们需要做出稳定的选择，以防这种情况的发生。 算法步骤算法中采用了男生主动追求女孩的形式。 第一轮，每个男人都选择自己名单上排在首位的女人，并向她表白。 这种时候会出现两种情况： （1）该女士还没有被男生追求过，则该女士接受该男生的请求。 （2）若该女生已经接受过其他男生的追求，那么该女生会将该男士与她的现任男友进行比较，若更喜欢她的男友，那么拒绝这个人的追求，否则，抛弃其男友(´▽`ʃ♡ƪ)…… 第一轮结束后，有些男人已经有女朋友了，有些男人仍然是单身。 在第二轮追女行动中，每个单身男都从所有还没拒绝过他的女孩中选出自己最中意的那一个，并向她表白，不管她现在是否是单身。这种时候还是会遇到上面所说的两种情况，还是同样的解决方案。直到所有人都不在是单身。 算法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define NUM 4#define NIL -1int GetPositionFromLaday(int ladayArray[][NUM], int laday, int man)&#123; for(int i=0; i&lt;NUM; i++) if(ladayArray[laday][i] == man) return i; return NIL;&#125;void ChoosePartener(stack&lt;int&gt;&amp; manStack, int manPos, int manArray[][NUM], int ladayArray[][NUM], int manPerfer[], int manStartPos[], int ladayNow[])&#123; //选择自己名单上排在首位的女人 int perferLaday = manArray[manPos][manStartPos[manPos]]; //如果该女孩没有接受过表白，则接受该男孩的表白 if(ladayNow[perferLaday] == NIL) &#123; ladayNow[perferLaday] = manPos; manPerfer[manPos] = perferLaday; &#125; //如果已经有人向她表白，则判断其现在拥有的有没有现在追求的好 else &#123; int oldPos = GetPositionFromLaday(ladayArray, perferLaday, ladayNow[perferLaday]); int newPos = GetPositionFromLaday(ladayArray, perferLaday, manPos); if(oldPos &lt; newPos) &#123; manStartPos[manPos]++;//说明该女生更喜欢现在拥有的，选心目中第二位 //加入单身行列 manStack.push(manPos); &#125; else //换男友 &#123; //被甩的男友恢复自由身份 manStartPos[ladayNow[perferLaday]]++; //加入单身行列 manStack.push(ladayNow[perferLaday]); //将追求的男士改为现任男友 ladayNow[perferLaday] = manPos; manPerfer[manPos] = perferLaday; &#125; &#125;&#125;int main()&#123; int manArray[NUM][NUM] =&#123;&#123;2,3,1,0&#125;,&#123;2,1,3,0&#125;,&#123;0,2,3,1&#125;,&#123;1,3,2,0&#125;&#125;; int ladayArray[NUM][NUM] = &#123;&#123;0,3,2,1&#125;,&#123;0,1,2,3&#125;,&#123;0,2,3,1&#125;,&#123;1,0,3,2&#125;&#125;;&#125; 算法总结祝大家早日找到自己的婚姻匹配 杨辉三角(Pascal Triangle) 前些天看了杨永乐老师的视频，其中提到了杨辉三角，有兴趣的可以去看看。 问题的引出(●’◡’●) 老师所提到的生活中的弹珠抽奖模型杨辉三角应该是大家很早就接触到的一个数学知识，它有很多有趣的性质： 每个数字等于上一行的左右两个数字之和，即 C(n+1,i) = C(n,i) + C(n,i-1) 每行数字左右对称，由 1 开始逐渐变大 第 n 行的数字有 n 项 第 n 行的第 m 个数和第 n - m + 1 个数相等 ，为组合数性质之一 ( a + b )n的展开式中的各项系数依次对应杨辉三角的第 ( n + 1 ) 行中的每一项 。。。 题目来源于 LeetCode 上第 118 号问题：杨辉三角。题目难度为 Easy，目前通过率为 61.8% 。 题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题目解析 这道题目在各大高校的习题中经常出现。 对于本题而言，利用性质 1 ：每一行的首个和结尾一个数字都是 1，从第三行开始，中间的每个数字都是上一行的左右两个数字之和。 代码实现1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (numRows &lt; 1) return result; for (int i = 0; i &lt; numRows; ++i) &#123; //扩容 List&lt;Integer&gt; list = Arrays.asList(new Integer[i+1]); list.set(0, 1); list.set(i, 1); for (int j = 1; j &lt; i; ++j) &#123; //等于上一行的左右两个数字之和 list.set(j, result.get(i-1).get(j-1) + result.get(i-1).get(j)); &#125; result.add(list); &#125; return result; &#125;&#125; 杨辉三角II题目来源于 LeetCode 上第 119 号问题：杨辉三角II。题目难度为 Easy，目前通过率为 55.5% 。 题目描述给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 题目解析这道题目的难点与思考点在于题目有额外限制条件，程序只能使用 O(k) 的额外空间，因此无法通过累加的方式将每一行都输出打印。 这里依旧使用杨辉三角的规律，很隐藏的规律：对于杨辉三角的同一行，第 ( i + 1) 项是第 i 项的( k - i ) /( i + 1 ) 倍。 比如： 第 k 索引行的第 0 项：1 第 k 索引行的第 1 项：1 * k 第 k 索引行的第 2 项：1 k ( k - 1) / 2 第 k 索引行的第 3 项：[1 k ( k - 1) / 2 ] * ( k - 2 ) / 3 代码实现1234567891011class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(rowIndex + 1); long index = 1; for (int i = 0; i &lt;= rowIndex; i++) &#123; res.add((int) index); index = index * ( rowIndex - i ) / ( i + 1 ); &#125; return res; &#125;&#125; 扫雷算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈回家安顿的一周]]></title>
    <url>%2F2019-05-11%2Fbbforfun.html</url>
    <content type="text"><![CDATA[既然生活多有不堪，那就更应花费时间在自己喜欢的事情上面，随之拥抱生活 “其实孤独并不可怕，只要你学会了自己与自己对话。” var ap = new APlayer({ element: document.getElementById("aplayer-nMmWtrjP"), narrow: false, autoplay: false, showlrc: false, music: { title: "长子", author: "杨坤", url: "http://psu4sovbi.bkt.clouddn.com/%E9%95%BF%E5%AD%90.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/ykun.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 花费三天时间搭建自己的博客曾经自己老是觉得也感叹自己对于编程类学习的无力感，这种感觉不知道什么时候飘离了自己，但是有个朋友说到心坎上了：“做自己喜欢的事情，从而带动兴趣，挖掘自己的潜能”，这几天脱离了学习的功课，而去尝试全心投入于搭建博客，这是之前自己一直想做却又不敢去做的事情。事实证明，我做到了，在参考hexo的next主题，而且也“云拜访”各家博主的博客，最终找到了自己希望的风格，一直不喜欢文章的我，在搭建完博客完，居然会沉迷于写文，像是现在也不想停手，然而明天就要离去前往大学继续上课了~╯︿╰ 关于概率论这位大叔哇，谁能想到，假期刚结束的周末就要开始概率论考试了，接下来要回去好好刷题练习了，争取&gt;=90,然后再继续研究完成easySale的项目吧，希望能够从这个项目找到自己的属性。 拥抱生活吧愿你即使生活在泥泞之中，也不要放弃仰望星空，有一天，你将如浩瀚星河，在平凡的生活里发出最耀眼的光。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构课程设计-平衡二叉树]]></title>
    <url>%2F2019-05-11%2FDataStructureAssign.html</url>
    <content type="text"><![CDATA[当年的数据结构课程设计-平衡二叉树，想了想还是放上来吧，当初费尽心思，怕是如今都已看不懂了இ௰இ “那片笑声让我想起我的那些花儿，在我生命每个角落静静为我开着~” var ap = new APlayer({ element: document.getElementById("aplayer-LQQUPxkw"), narrow: false, autoplay: false, showlrc: false, music: { title: "那些花儿", author: "吴青峰", url: "http://psu4sovbi.bkt.clouddn.com/%E9%82%A3%E4%BA%9B%E8%8A%B1%E5%84%BF+%E6%9C%9B%E6%98%A5%E9%A3%8E.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 需求分析“平衡二叉树操作演示”系统是利用平衡二叉树实现一个动态查找表的三种基本功能：查找、插入和删除，同时，还能拓展实现新的功能：初始化、求深度、求最大最小结点、先中后序及层序遍历、打印平衡二叉树、判空、合并和分裂平衡二叉树等功能，并通过括号表示方法和凹入表表示方法将动态查找表和平衡二叉树的详细信息展示给用户知晓；同时，还要求系统界面设计简洁明了、用户操作简单方便，提高系统实用性与运行效率。 说明：使用anyview或者codeblock运行；输入值形式是数字，无论对功能的选则还是对数据的录入，都是以数字的形式进行输入，如若超过规定范围程序将直接结束。 概要设计接口设计Status InitBBST(BBSTree &amp;T) 初始化平衡二叉树 void DestroyBBSTree(BBSTree &amp;T) 销毁平衡二叉树 Status BBSTreeEmpty(BBSTree T) 判空平衡二叉树 void PrintTree(BBSTree &amp;T) 打印平衡二叉树 void CreateBBST(BBSTree &amp;T) 输入结点数目，动态创建一棵平衡二叉树 Status InsertAVL(BBSTree &amp;T, RcdType e, Status &amp;taller) 平衡二叉树的插入操作，将e插入到T中 插入成功返回TRUE，失败返回FALSE Status DeleteAVL(BBSTree &amp;t, RcdType e, Status &amp;shorter) 平衡二叉树的删除操作，将e从T中删除 删除成功返回TRUE，失败返回FALSE void L_Rotate(BBSTree &amp;p) 对p左旋操作 void R_Rotate(BBSTree &amp;p) 对p右旋操作 void LeftBalance(BBSTree &amp;T) 对T左平衡操作 void RightBalance(BBSTree &amp;T) 对T右平衡操作 Status PreOrder(BBSTree T) 递归先序遍历输出 Status InOrder(BBSTree T) 递归中序遍历输出 Status PostOrder(BBSTree T) 递归后序遍历输出 void PreOrderTravese_I(BBSTree T) 非递归先序遍历输出 void InOrderTraverse_I(BBSTree T) 非递归中序遍历输出 void LastOrderTravese_I(BBSTree T) 非递归后序遍历输出 void LevelOrederTraverse_Print(BBSTree T) 层次遍历输出 BBSTree SearchBBST(BBSTree T,RcdType key) 二叉平衡树查找的递归实现 BBSTree SearchBBST_I(BBSTree T,RcdType e) 二叉平衡树查找的非递归实现 BBSTree FindMin(BBSTree T) 寻找平衡二叉树最小元素所在结点地址 BBSTree FindMax(BBSTree T) 寻找平衡二叉树最大元素所在结点地址 int BBSTreeDepth(BBSTree T) 求平衡二叉树的深度 void MergeBBST(BBSTree &amp;T1, BBSTree T2) 合并两棵平衡二叉树 void SpiltBBST(BBSTree T, RcdType key, BBSTree &amp;T1, BBSTree &amp;T2) 按关键值key分裂T成两棵二叉树 主程序与各接口函数的调用int main(){ ​ BBSTree T = NULL; ​ int choice; ​ printf(“================================================\n”); ​ printf(“*平衡二叉树*\n”); ​ printf(“================================================\n”); ​ printf(“ 1：创建一棵平衡二叉树\n”); ​ printf(“ 2：平衡二叉树的插入\n”); ​ printf(“ 3：平衡二叉树的删除\n”); ​ printf(“ 4：平衡二叉树的查找\n”); ​ printf(“ 5：平衡二叉树的遍历\n”); ​ printf(“ 6：求平衡二叉树的深度\n”); ​ printf(“ 7：合并平衡二叉树\n”); ​ printf(“ 8：分裂平衡二叉树\n”); ​ printf(“ 请根据上述说明选择所需操作1-8: “); ​ scanf(“%d”,&amp;choice); ​ while(choice &gt; 0 &amp;&amp; choice &lt;= 3) ​ { ​ if(choice == 1) ​ { ​ if(OK == InitBBST(T)); ​ CreateBBST(T); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T,0); ​ printf(“\n”); ​ PrintTree1(T); ​ printf(“\n请重新输入你的选择: “); ​ scanf(“%d”,&amp;choice); ​ } ​ if(choice == 2) ​ { ​ int num; ​ RcdType s; ​ Status taller = TRUE; ​ printf(“请输入要插入的元素：”); ​ scanf(“%d”,&amp;num); ​ s = num; ​ InsertAVL(T,s,taller); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T,0); ​ PrintTree1(T); ​ printf(“\n请重新输入你的选择: “); ​ scanf(“%d”,&amp;choice); ​ } ​ if(choice == 3){ ​ RcdType e; ​ Status shorter = TRUE; ​ printf(“请输入要删除的元素：”); ​ scanf(“%d”,&amp;e); ​ DeleteAVL(T, e, shorter); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T,0); ​ PrintTree1(T); ​ printf(“\n请重新输入你的选择: “); ​ scanf(“%d”,&amp;choice); ​ } ​ } ​ if(choice == 4){ ​ int choice2; ​ printf(“40:递归查找\n41:非递归查找\n”); ​ printf(“42:查找最小元素\n43:查找最大元素\n”); ​ printf(“请选择一种查找方式：”); ​ scanf(“%d”,&amp;choice2); ​ switch(choice2){ ​ case 40: ​ int key1; ​ printf(“\n请输入欲查找元素：”); ​ scanf(“%d”,&amp;key1); ​ if(NULL != SearchBBST(T,key1)) ​ printf(“\n查找成功”); ​ else ​ printf(“\n查找失败”); ​ break; ​ case 41: ​ int key2; ​ printf(“\n请输入欲查找元素：”); ​ scanf(“%d”,&amp;key2); ​ if(NULL != SearchBBST_I(T,key2)) ​ printf(“\n查找成功”); ​ else ​ printf(“\n查找失败”); ​ break; ​ case 42: ​ BBSTree T1 = FindMin(T); ​ if(T1) ​ printf(“\n查找成功，且为%d”,T1-&gt;data); ​ break; ​ // case 43: ​ BBSTree T2 = FindMax(T); ​ if(T2) ​ printf(“\n查找成功，且为%d”,T2-&gt;data); ​ break; ​ } ​ } ​ if(choice == 5){ ​ int choice2; ​ printf(“50:递归先序\n51:递归中序\n52:递归后序\n”); ​ printf(“53:非递归先序\n54:非递归中序\n55:非递归后序\n56:层次遍历\n”); ​ printf(“请选择一种遍历方式：”); ​ scanf(“%d”,&amp;choice2); ​ switch(choice2){ ​ case 50: ​ printf(“\n递归先序遍历输出：”); ​ PreOrder(T); break; ​ case 51: ​ printf(“\n递归中序遍历输出：”); ​ InOrder(T); break; ​ case 52: ​ printf(“\n递归后序遍历输出：”); ​ PostOrder(T);break; ​ case 53: ​ printf(“\n非递归先序遍历输出：”); ​ PreOrderTravese_I(T);break; ​ case 54: ​ printf(“\n非递归中序遍历输出：”); ​ InOrderTraverse_I(T); break; ​ case 55: ​ printf(“\n非递归后序遍历输出：”); ​ LastOrderTravese_I(T); ​ printf(“\n”); break; ​ case 56: ​ printf(“\n层次遍历输出：”); ​ LevelOrederTraverse_Print(T); ​ printf(“\n”); break; ​ } ​ } ​ if(choice == 6) ​ { ​ printf(“深度为：%d\n”,BBSTreeDepth(T)); ​ } ​ if(choice == 7) ​ { ​ BBSTree T1,T2,T3; ​ if(OK == (InitBBST(T1))&amp;&amp;(InitBBST(T2))&amp;&amp;(InitBBST(T))) ​ { ​ printf(“请构造第一棵子树\n”); ​ CreateBBST(T1); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T1,0); ​ PrintTree1(T1); ​ printf(“\n”); ​ printf(“请构造第二棵子树\n”); ​ CreateBBST(T2); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T2,0); ​ PrintTree1(T2); ​ printf(“\n”); ​ printf(“合并后为：”); ​ MergeBBST(T,T1); ​ MergeBBST(T,T2); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T,0); ​ PrintTree1(T); ​ } ​ } ​ if(choice == 8) ​ { ​ BBSTree T1,T2; ​ if(OK == (InitBBST(T1))&amp;&amp;(InitBBST(T2))) ​ { ​ int x; ​ printf(“请输入要分裂时作为参照的关键字：”); ​ scanf(“%d”,&amp;x); ​ SpiltBBST(T,x,T1,T2); ​ printf(“分裂后的第一棵树为：”); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T1,0); ​ PrintTree1(T1); ​ printf(“\n”); ​ printf(“分裂后的第二棵树为：”); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T2,0); ​ PrintTree1(T2); ​ } ​ } } 详细设计 以下高能代码段，慎看吧(╯‵□′)╯炸弹！•••*～● 重要变量和存储结构定义#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define LH +1 //左高 #define EH 0 //等高 #define RH -1 //右高 #define FALSE 0 #define TRUE 1 #define OK 1 #define ERROR 0 #define OVERFLOW -1 typedef int Status; typedef int RcdType; /平衡二叉树结构体/ typedef struct BBSTNode { ​ RcdType data; ​ int bf; ​ struct BBSTNode lchild, rchild; }*BBSTree; 算法设计/初始化平衡二叉树/Status InitBBST(BBSTree &amp;T){ ​ T = NULL; ​ return OK; } /销毁平衡二叉树/void DestroyBBSTree(BBSTree &amp;T){ ​ if(T != NULL){ ​ DestroyBBSTree(T -&gt; lchild); ​ DestroyBBSTree(T -&gt; rchild); ​ free(T); ​ T = NULL; ​ } } /判空平衡二叉树/Status BBSTreeEmpty(BBSTree T){ ​ if(!T){ ​ return TRUE; ​ } ​ else{ ​ return FALSE; ​ } } /创建一棵平衡二叉树/void CreateBBST(BBSTree &amp;T) { ​ RcdType e; ​ int num; ​ Status taller = TRUE; ​ printf(“\n请输入平衡二叉树的结点个数:”); ​ scanf(“%d”, &amp;num); ​ getchar(); ​ printf(“请顺序输入元素(按’回车键’结束):”); ​ for (int i = 0; i &lt; num; i++) { ​ scanf(“%d”, &amp;e); ​ InsertAVL(T, e, taller); ​ } } /输出平衡二叉树/void PrintTree(BBSTree T, int nLayer){ ​ if(T == NULL) { ​ return; ​ } ​ PrintTree(T-&gt;rchild, nLayer + 4); ​ for(int i = 0; i &lt; nLayer; i++) { ​ printf(“ “); ​ } ​ printf(“%d\n”, T-&gt;data); ​ PrintTree(T-&gt;lchild, nLayer + 4); } /输出平衡二叉树/void PrintTree1(BBSTree &amp;T) { ​ if(T) ​ { ​ printf(“%d”,T-&gt;data); ​ if(T-&gt;lchild || T-&gt;rchild) ​ { ​ printf(“(“); ​ PrintTree1(T-&gt;lchild); ​ if(T-&gt;rchild) ​ printf(“,”); ​ PrintTree1(T-&gt;rchild); ​ printf(“)”); ​ } ​ } } /平衡二叉树的插入操作//若平衡二叉树中不存在值为e的结点，则插入到T/ Status InsertAVL(BBSTree &amp;T, RcdType e, Status &amp;taller){ ​ if(NULL==T){ ​ T = (BBSTree)malloc(sizeof(BBSTNode)); ​ T-&gt;data = e; ​ T-&gt;bf = EH; ​ T-&gt;lchild = NULL; ​ T-&gt;rchild = NULL; ​ }else if(e==T-&gt;data){ //书中已存在和e相等的结点 ​ taller = FALSE; return FALSE; ​ }else if(edata){ ​ if(FALSE==InsertAVL(T-&gt;lchild, e, taller)) return FALSE; ​ if(TRUE==taller){ ​ switch(T-&gt;bf){ ​ case LH: LeftBalance(T); taller = FALSE; break; ​ case EH: T-&gt;bf = LH; taller = TRUE; break; ​ case RH: T-&gt;bf = EH; taller = FALSE; break; ​ } ​ } ​ }else{ ​ if(FALSE==InsertAVL(T-&gt;rchild, e, taller)) return FALSE; ​ if(TRUE==taller){ ​ switch(T-&gt;bf){ ​ case LH: T-&gt;bf = EH; taller = FALSE; break; ​ case EH: T-&gt;bf = RH; taller = TRUE; break; ​ case RH: RightBalance(T); taller = FALSE; break; ​ } ​ } ​ } ​ return TRUE; } /左旋调整（右旋与之类似，不再列出）/void L_Rotate(BBSTree &amp;p) { ​ BBSTree rc = p -&gt; rchild; ​ p -&gt; rchild = rc -&gt; lchild; ​ rc -&gt; lchild = p; ​ p = rc; } /左平衡处理操作（右平衡与之类似，不再列出）/void LeftBalance(BBSTree &amp;T){ ​ BBSTree lc, rd; ​ lc = T-&gt;lchild; ​ switch(lc-&gt;bf){ ​ case LH: ​ T-&gt;bf = lc-&gt;bf = EH; R_Rotate(T); break; ​ case RH: ​ rd = lc-&gt;rchild; ​ switch(rd-&gt;bf){ ​ case LH: T-&gt;bf = RH; lc-&gt;bf = EH; break; ​ case EH: T-&gt;bf = lc-&gt;bf = EH; break; ​ case RH: T-&gt;bf = EH; lc-&gt;bf = LH; break; ​ } ​ rd-&gt;bf = EH; ​ L_Rotate(T-&gt;lchild); ​ R_Rotate(T); ​ break; ​ } } /平衡二叉树的删除操作//平衡二叉树中存在值为key的结点，则删除/Status DeleteAVL(BBSTree &amp;T, RcdType e, Status &amp;shorter){ //当被删结点是有两个孩子，且其前驱结点是左孩子时，tag=1 ​ int tag = 0; ​ if(T == NULL){ ​ return FALSE; //如果不存在元素，返回失败 ​ }else if(e==T-&gt;data){ ​ BBSTNode *q = NULL; ​ //如果该结点只有一个孩子，则将自子树取代该结点 ​ if(T-&gt;lchild == NULL){ ​ q = T; ​ T = T-&gt;rchild; ​ free(q); ​ shorter = TRUE; ​ } ​ else if(T-&gt;rchild == NULL){ ​ q = T; ​ T = T-&gt;lchild; ​ free(q); ​ shorter = TRUE; ​ } ​ //如果被删结点有两个孩子，则找到结点的前驱结点， ​ //并将前驱结点的值赋给该结点，然后删除前驱结点 ​ else{ ​ q = T-&gt;lchild; ​ while(q-&gt;rchild){ ​ q = q-&gt;rchild; ​ } ​ T-&gt;data = q-&gt;data; ​ if(T-&gt;lchild-&gt;data==q-&gt;data){ ​ tag = 1; ​ } ​ DeleteAVL(T-&gt;lchild, q-&gt;data, shorter); ​ if(tag==1){ ​ BBSTree r = T-&gt;rchild; ​ if(NULL==r) T-&gt;bf = 0; ​ else{ ​ switch(r-&gt;bf){ ​ case EH: T-&gt;bf=-1;break; ​ default: RightBalance(T);break; ​ } ​ } ​ } ​ } ​ }else if(edata){ //左子树中继续查找 ​ if(!DeleteAVL(T-&gt;lchild, e, shorter)){ ​ return FALSE; ​ } ​ //删除完结点之后，调整结点的平衡因子 ​ if(shorter&amp;&amp;(tag==0)) { ​ switch(T-&gt;bf){ ​ case LH: ​ T-&gt;bf = EH; ​ shorter = TRUE; ​ break; ​ case EH: ​ T-&gt;bf = RH; ​ shorter = FALSE; ​ break; ​ //如果本来就是右子树较高，删除之后就不平衡，需要做右平衡操作 ​ case RH: ​ RightBalance(T); //右平衡处理 ​ if(T-&gt;rchild-&gt;bf == EH) ​ shorter = FALSE; ​ else ​ shorter = TRUE; ​ break; ​ } ​ } ​ }else if(e&gt;T-&gt;data){ //右子树中继续查找 ​ if(!DeleteAVL(T-&gt;rchild, e, shorter)){ ​ return FALSE; ​ } ​ //删除完结点之后，调整结点的平衡因子 ​ if(shorter&amp;&amp;(tag==0)) { ​ switch(T-&gt;bf){ ​ case LH: ​ LeftBalance(T); //左平衡处理 ​ if(T-&gt;lchild-&gt;bf == EH) ​ shorter = FALSE; ​ else ​ shorter = TRUE; ​ break; ​ case EH: ​ T-&gt;bf = LH; ​ shorter = FALSE; ​ break; ​ case RH: ​ T-&gt;bf = EH; ​ shorter = TRUE; ​ break; ​ } ​ } ​ if(tag==1){ ​ int depthLeft = BBSTreeDepth(T-&gt;lchild); ​ int depthRight = BBSTreeDepth(T-&gt;rchild); ​ T-&gt;bf = depthLeft - depthRight; ​ } ​ } ​ return TRUE; } /二叉平衡树查找的递归实现//若平衡二叉树中存在值为key的结点，则返回该结点指针，否则返回NULL/ BBSTree SearchBBST(BBSTree T,RcdType key) { ​ if(NULL == T) ​ return NULL; ​ if(T -&gt; data == key) ​ return T; ​ if(T -&gt; data &gt; key) ​ return SearchBBST(T -&gt; lchild,key); ​ return SearchBBST(T -&gt; rchild,key); } /二叉平衡树查找的非递归实现//若平衡二叉树中存在值为key的结点，则返回该结点指针，否则返回NULL*/ BBSTree SearchBBST_I(BBSTree T,RcdType e) { ​ while(T) { ​ if(e &lt; T -&gt; data) ​ T = T -&gt; lchild; ​ else if(e &gt; T -&gt; data) ​ T = T -&gt; rchild; ​ else ​ return T; ​ } ​ return NULL; } /寻找平衡二叉树最小元素所在结点地址（寻找最大元素类似不再列出）/BBSTree FindMin(BBSTree T){ ​ if(T) ​ while(T -&gt; lchild) ​ T = T -&gt; lchild; ​ return T; } /递归先序遍历（中序、后序遍历类似不再列出）/Status PreOrder(BBSTree T){ ​ if(T) { ​ printf(“%5d”,T-&gt;data); ​ PreOrder(T -&gt; lchild); ​ PreOrder(T -&gt; rchild); ​ } ​ return OK; } /非递归中序遍历/void InOrderTraverse_I(BBSTree T){ ​ LStack S; ​ InitStack_LS(S); ​ BBSTree p = NULL; ​ p = GoFarLeft(T, S); ​ while(p!=NULL){ ​ printf(“%d “,p-&gt;data); ​ if(p-&gt;rchild!=NULL){ ​ p = GoFarLeft(p-&gt;rchild, S); ​ } ​ else if(StackEmpty_LS(S)!=TRUE) Pop_LS(S, p); ​ else p = NULL; ​ } } /非递归先序遍历/void PreOrderTravese_I(BBSTree T){ ​ LStack S; ​ InitStack_LS(S); ​ BBSTree p; ​ p = VisitFarLeft(T, S); //先将左边的数据先序读取 ​ while(p!=NULL){ ​ if(p-&gt;rchild!=NULL) //如果最左下结点的右子树不为空 ​ p = VisitFarLeft(p-&gt;rchild, S); //执行遍历该结点的左子树 ​ else if(StackEmpty_LS(S)!=TRUE) Pop_LS(S,p); //如果S不为空栈，出栈 ​ else p = NULL; //如果为空栈，p赋予空 ​ } } /非递归后序遍历/void LastOrderTravese_I(BBSTree root){ ​ BBSTree p = root; ​ BBSTree stack[30]; ​ int num=0; ​ BBSTree have_visited = NULL; ​ while(NULL!=p||num&gt;0){ ​ while(NULL!=p){ ​ stack[num++]=p; ​ p=p-&gt;lchild; ​ } ​ p=stack[num-1]; ​ if(NULL==p-&gt;rchild||have_visited==p-&gt;rchild){ ​ printf(“%d “,p-&gt;data); ​ num–; ​ have_visited=p; ​ p=NULL; ​ } ​ else{ ​ p=p-&gt;rchild; ​ } ​ } ​ printf(“\n”); } /层次遍历/void LevelOrederTraverse_Print(BBSTree T){ ​ if(T==NULL){ ​ printf(“这是一棵空树!”); ​ } ​ if(T!=NULL){ ​ LQueue Q; ​ InitQueue_LQ(Q); ​ BBSTree p = T; ​ printf(“%d “,p-&gt;data); EnQueue_LQ(Q,p);//首先访问根结点，并将根节点入队 ​ while(DeQueue_LQ(Q,p)){ //队非空时重复操作，出队 ​ if(p-&gt;lchild!=NULL){ //访问左孩子并入队 ​ printf(“%d “, p-&gt;lchild-&gt;data); ​ EnQueue_LQ(Q, p-&gt;lchild); ​ } ​ if(p-&gt;rchild!=NULL){ //访问右孩子并入队 ​ printf(“%d “, p-&gt;rchild-&gt;data); ​ EnQueue_LQ(Q, p-&gt;rchild); ​ } ​ } ​ } } /求平衡二叉树的深度/int BBSTreeDepth(BBSTree T){ ​ int depthLeft, depthRight; ​ if(NULL==T) return 0; ​ else{ ​ depthLeft = BBSTreeDepth(T-&gt;lchild); ​ depthRight = BBSTreeDepth(T-&gt;rchild); ​ return 1+(depthLeft &gt; depthRight ? depthLeft : depthRight); ​ } } /合并平衡二叉树/void MergeBBST(BBSTree &amp;T1, BBSTree T2) { ​ Status taller = FALSE; ​ if (T2 != NULL) { ​ MergeBBST(T1, T2-&gt;lchild); ​ InsertAVL(T1, T2-&gt;data, taller); ​ MergeBBST(T1, T2-&gt;rchild); ​ } } /分裂平衡二叉树/void SpiltBBST(BBSTree T, RcdType key, BBSTree &amp;T1, BBSTree &amp;T2) { ​ Status taller = FALSE; ​ if (T != NULL) { ​ SpiltBBST(T-&gt;lchild, key, T1, T2); // 递归访问左子树 ​ if(T-&gt;data &gt; key) { ​ InsertAVL(T1, T-&gt;data, taller); ​ } else { ​ InsertAVL(T2, T-&gt;data, taller); ​ } ​ SpiltBBST(T-&gt;rchild, key, T1, T2); ​ } } 调试分析调试过程中遇到的问题及处理方法一开始运行过程中程序停止运行。遇到这个情况一开始我以为是编译器有问题，但是换了个编译器还是同样的问题，后来我上网查询了有关资料，大概明白了是自己的代码出现了问题。所以只能将新增的代码注释掉，一条一条测试，调试过程很漫长，最后才发现是内存泄露和空指针异常，将指针不适用之后指向为 NULL，才把问题解决了。 算法改进与设想在对动态查找表的查找方式上，课程设计选择的是平衡二叉树，那么当查找的结点元素与关键字数量庞大的时候，就会造成平衡二叉树的高度过高，查找、添加、删除等操作的时候效率就会变得很低，而且输入后的排序与整合平衡二叉树T所需要用到的时间就会很长，所以，如果动态查找表中的元素数量庞大的时候可以优先选择B树和B+树等，可以有效降低查找树的高度，提高查找处理效率。 经验与体会本次课程设计主要实现平衡二叉树的查找，插入和删除，增加合并和分裂的功能。许多接口的实现都是基于之前二叉树等的操作，根据平衡二叉树的特性进行改动和完善，删除的难点在于找待删除点的前驱结点和删除后对失衡情况的调节.合并和分裂平衡二叉树，一开始我是想用一个数组先把元素汇总再进行创建新的平衡二叉树，但查阅资料后，觉得这一种方法有些死板，不及直接递归访问结点元素并进行插入操作。总结来说，平衡二叉树是一种基于二叉树的抽象数据类型，平衡这一特性，给一些基本操作增加了不小的难度，值得去思考和研究。 在做一个比较大的程序过程中，应该学会边编写程序边运行，即当你完成了一个比较小的功能时便对其调试， 这样有助于我们高效地完成项目，而且在调试 BUG 的过程也可以大大减小其难度。必须要有良好的编程习惯。首先编码风格一定要规范，这样不仅有利于读者和编程者对代码的阅读，更有利于对代码的维护。其次要对代码要细心，比较一些指针的初始化和不需要时指为空，这些都是可以极大减少我们出现 BUG 的几率]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>课设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas学习笔记]]></title>
    <url>%2F2019-05-11%2Fcanvas.html</url>
    <content type="text"><![CDATA[canvas画布，不容小觑的“标签”，得有一定的数学几何底子，虽然目前我还是没用到就是了，但是以后总该会用到的，有想过利用canvas制作小游戏_〆(´Д｀ ) canvas画布，顾名思义即是如图所示绘图的“工具”，然而并不简单(lll￢ω￢)~ 最近毛毛的《奉献》特别耐人寻味，有跟原版不一样的感觉~ var ap = new APlayer({ element: document.getElementById("aplayer-hyXCMCkS"), narrow: false, autoplay: false, showlrc: false, music: { title: "奉献", author: "毛不易", url: "http://psu4sovbi.bkt.clouddn.com/%E5%A5%89%E7%8C%AE.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/maomao.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); canvas简介什么是canvas？（了解） 是HTML5提供的一种新标签 12&lt;canvas&gt;&lt;/canvas&gt; 英 ['kænvəs] 美 ['kænvəs] 帆布 画布 Canvas是一个矩形区域的画布，可以用JavaScript在上面绘画。控制其每一个像素。 canvas 标签使用 JavaScript 在网页上绘制图像，本身不具备绘图功能。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 HTML5之前的web页面只能用一些固定样式的标签：比如p、div、h1等 canvas主要应用的领域（了解） 游戏：canvas在基于Web的图像显示方面比Flash更加立体、更加精巧，canvas游戏在流畅度和跨平台方面更牛。25 超棒的 HTML5 Canvas 游戏 可视化数据.数据图表话，比如:百度的echart banner广告：Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。 未来=&gt; 模拟器：无论从视觉效果还是核心功能方面来说，模拟器产品可以完全由JavaScript来实现。 未来=&gt; 远程计算机控制：Canvas可以让开发者更好地实现基于Web的数据传输，构建一个完美的可视化控制界面。 未来=&gt; 图形编辑器：Photoshop图形编辑器将能够100%基于Web实现。 其他可嵌入网站的内容(多用于活动页面、特效)：类似图表、音频、视频，还有许多元素能够更好地与Web融合，并且不需要任何插件。 完整的canvas移动化应用 我们课程的目标 我们不是主要做游戏开发的 要求必须会做基本的用canvas绘制的特效页面：比如，传智前端官网。 会用canvas做一些简单的广告、活动页面 我们课程的案例和项目演示 canvas的标准： 最新标准：http://www.w3.org/TR/2dcontext/ 稳定版本的标准：http://www.w3.org/TR/2013/CR-2dcontext-20130806/ 目前来说，标准还在完善中。先用早期的api足够完成所有的应用 canvas绘图基础sublime配置canvas插件（推荐）1234推荐： 安装插件：AndyJS2 github地址： https://github.com/malun666/AndyJS2 直接下载到：X:\Users\用户名\AppData\Roaming\Sublime Text 3\Packages Canvas标签canvas标签语法和属性 （重点） canvas：画布油布的意思 ==英 [‘kænvəs] 美 [‘kænvəs] == 标签名canvas，需要进行闭合。就是一普通的html标签。 可以设置width和height属性，但是属性值单位必须是px，否则忽略。 width和hegiht：默认300*150像素 注意： 不要用CSS控制它的宽和高,会走出图片拉伸， 重新设置canvas标签的宽高属性会让画布擦除所有的内容。 可以给canvas画布设置背景色 浏览器不兼容处理（重点） ie9以上才支持canvas, 其他chrome、ff、苹果浏览器等都支持 只要浏览器兼容canvas，那么就会支持绝大部分api(个别最新api除外) 移动端的兼容情况非常理想，基本上随便使用 2d的支持的都非常好，3d（webgl）ie11才支持，其他都支持 如果浏览器不兼容，最好进行友好提示 1234例如： &lt;canvas id="cavsElem"&gt; 你的浏览器不支持canvas，请升级浏览器.浏览器不支持，显示此行文本&lt;/canvas&gt; 浏览器不兼容，可以使用flash等手段进行优雅降级 canvas绘图上下文contextContext：Canvas的上下文、绘制环境。（重点掌握） 上下文：上知天文，下知地理。是所有的绘制操作api的入口或者集合。 Canvas自身无法绘制任何内容。Canvas的绘图是使用JavaScript操作的。 Context对象就是JavaScript操作Canvas的接口。*使用[CanvasElement].getContext(‘2d’)来获取2D绘图上下文。 12var canvas = document.getElementById( 'cavsElem' ); //获得画布var ctx = canvas.getContext( '2d' );//注意：2d小写， 3d：webgl 基本的绘制路径（重点）canvas坐标系1canvas坐标系，从最左上角0,0开始。x向右增大， y向下增大 设置绘制起点(moveTo)1234* 语法：ctx.moveTo(x, y); * 解释：设置上下文绘制路径的起点。相当于移动画笔到某个位置* 参数：x,y 都是相对于 canvas盒子的最左上角。* 注意：**绘制线段前必须先设置起点，不然绘制无效。** 绘制直线(lineTo)123* 语法：ctx.lineTo(x, y);* 解释：从x,y的位置绘制一条直线到起点或者上一个线头点。* 参数：x,y 线头点坐标。 路径开始和闭合12345* 开始路径：ctx.beginPath();* 闭合路径：ctx.closePath();* 解释：如果复杂路径绘制，必须使用路径开始和结束。闭合路径会自动把最后的线头和开始的线头连在一起。* beginPath: 核心的作用是将 不同绘制的形状进行隔离， 每次执行此方法，表示重新绘制一个路径,跟之前的绘制的墨迹可以进行分开样式设置和管理。 描边(stroke)1234* 语法：ctx.stroke();* 解释：根据路径绘制线。路径只是草稿，真正绘制线必须执行stroke* stroke: （用笔等）画；轻抚；轻挪；敲击；划尾桨；划掉；（打字时）击打键盘 英 [strəʊk] 美 [strok] canvas绘制的基本步骤： 第一步：获得上下文 =&gt;canvasElem.getContext(‘2d’); 第二步：开始路径规划 =&gt;ctx.beginPath() 第三步：移动起始点 =&gt;ctx.moveTo(x, y) 第四步：绘制线(矩形、圆形、图片…) =&gt;ctx.lineTo(x, y) 第五步：闭合路径 =&gt;ctx.closePath(); 第六步：绘制描边 =&gt;ctx.stroke(); 1234567891011121314151617181920212223html部分： &lt;canvas id="cavsElem"&gt; 你的浏览器不支持canvas，请升级浏览器 &lt;/canvas&gt;javascript部分：//===============基本绘制api====================//获得画布var canvas = document.querySelector('#cavsElem');var ctx = canvas.getContext('2d'); //获得上下文canvas.width = 900; //设置标签的属性宽高canvas.height = 600; //千万不要用 canvas.style.heightcanvas.style.border = "1px solid #000";//绘制三角形ctx.beginPath(); //开始路径ctx.moveTo(100,100); //三角形，左顶点ctx.lineTo(300, 100); //右顶点ctx.lineTo(300, 300); //底部的点ctx.closePath(); //结束路径ctx.stroke(); //描边路径 综合案例：02绘制定位表格.html 综合案例：03画画板.html 填充(fill)12* 语法：ctx.fill(); * 解释：填充，是将闭合的路径的内容填充具体的颜色。默认黑色。 12345678910111213* 注意：交叉路径的填充问题，“非零环绕原则”，顺逆时针穿插次数决定是否填充。 以下是非0环绕原则的原理：（了解即可，非常少会用到复杂的路径） “非零环绕规则”是这么来判断有自我交叉情况的路径的：对于路径中的任意给定区域，从该区域内部画一条足够长的线段， 使此线段的终点完全落在路径范围之外。 图2-14中的那三个箭头所描述的就是上面这个步骤。 接下来，将计数器初始化为0， 然后，每当这条线段与路径上的直线或曲线相交时， 就改变计数器的值。如果是与路径的顺时针部分相交，则加1， 如果是与路径的逆时针部分相交，则减1。若计数器的最终值不是0，那么此区域就在路径里面，在调用fill()方法时， 浏览器就会对其进行填充。 如果最终值是0，那么此区域就不在路径内部，浏览器也就不会对其进行填充了* 案例： 04填充矩形.html 快速创建矩形rect()方法12345* 语法：ctx.rect(x, y, width, height);* 解释：x, y是矩形左上角坐标， width和height都是以像素计* rect方法只是规划了矩形的路径，并没有填充和描边。* 改造案例：04填充矩形.html*rect: abbr. 矩形（rectangular）；收据（receipt） 快速创建描边矩形和填充矩形1234* 语法： ctx.strokeRect(x, y, width, height); - 参数跟2.3.8相同，注意此方法绘制完路径后立即进行stroke绘制* 语法：ctx.fillRect(x, y, width, height); - 参数跟2.3.8相同， 此方法执行完成后。立即对当前矩形进行fill填充。 清除矩形(clearRect)12* 语法：ctx.clearRect(x, y, width, hegiht);* 解释：清除某个矩形内的绘制的内容，相当于橡皮擦。 绘制圆形（arc) 概述：arc() 方法创建弧/曲线（用于创建圆或部分圆）。 语法：ctx.arc(x,y,r,sAngle,eAngle,counterclockwise); arc: 弧（度）弧形物；天穹 英 [ɑːk] 美 [ɑrk] counter 反击，还击；反向移动，对着干；反驳，回答 [‘kaʊntə] 美 [‘kaʊntɚ] 解释： x,y：圆心坐标。 r：半径大小。 sAngle:绘制开始的角度。 圆心到最右边点是0度，顺时针方向弧度增大。 eAngel:结束的角度，注意是弧度。π counterclockwise：是否是逆时针。true是逆时针，false：顺时针 弧度和角度的转换公式： rad = deg*Math.PI/180; 在Math提供的方法中sin、cos等都使用的弧度 案例：05绘制圆形.html 案例：06绘制饼状图.html 绘制文字（会使用就可以了）绘制上下文的文字属性 （有印象就行了） font 设置或返回文本内容的当前字体属性 font 属性使用的语法与 CSS font 属性相同。 1例如：ctx.font = "18px '微软雅黑'"; textAlign 设置或返回文本内容的当前对齐方式 start : 默认。文本在指定的位置开始。 end : 文本在指定的位置结束。 center: 文本的中心被放置在指定的位置。 left : 文本左对齐。 right : 文本右对齐。 1* 例如：ctx.textAlign = 'left'; textBaseline 设置或返回在绘制文本时使用的当前文本基线 alphabetic ： 默认。文本基线是普通的字母基线。 top ： 文本基线是 em 方框的顶端。。 hanging ： 文本基线是悬挂基线。 middle ： 文本基线是 em 方框的正中。 ideographic： 文本基线是em基线。 bottom ： 文本基线是 em 方框的底端。 1234例如： ctx.textBaseline = 'top';单词: alphabetic: 字母的；照字母次序的 [,ælfə'bɛtɪk] ideographic：表意的；表意字构成的 英 [,ɪdɪəʊ'ɡræfɪk] 美 [,ɪdɪə'græfɪk] ​ 上下文绘制文字方法1234* ctx.fillText() 在画布上绘制“被填充的”文本* ctx.strokeText() 在画布上绘制文本（无填充）* ctx.measureText() 返回包含指定文本宽度的对象* 单词：measure 测量；估量；权衡 英 ['meʒə] 美 ['mɛʒɚ] 12345678//综合案例代码：ctx.moveTo( 300, 300 );ctx.fillStyle = "purple"; //设置填充颜色为紫色ctx.font = '20px "微软雅黑"'; //设置字体ctx.textBaseline = "bottom"; //设置字体底线对齐绘制基线ctx.textAlign = "left"; //设置字体对齐的方式//ctx.strokeText( "left", 450, 400 );ctx.fillText( "Top-g", 100, 300 ); //填充文字 绘制图片（drawImage） （重点）基本绘制图片的方式12context.drawImage(img,x,y);参数说明： x,y 绘制图片左上角的坐标， img是绘制图片的dom对象。 在画布上绘制图像，并规定图像的宽度和高度12345context.drawImage(img,x,y,width,height); 参数说明：width 绘制图片的宽度， height：绘制图片的高度如果指定宽高，最好成比例，不然图片会被拉伸&lt;/em&gt; 等比公式： toH = Height * toW / Width; //等比 设置高 = 原高度 * 设置宽/ 原宽度; 图片裁剪，并在画布上定位被剪切的部分12345context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);参数说明： sx,sy 裁剪的左上角坐标， swidth：裁剪图片的高度。 sheight:裁剪的高度 其他同上 用JavaScript创建img对象123456789第一种方式： var img = document.getElementById("imgId");第二种方式： var img = new Image();//这个就是 img标签的dom对象 img.src = "imgs/arc.gif"; img.alt = "文本信息"; img.onload = function() &#123; //图片加载完成后，执行此方法 &#125; 面向对象基础复习补充： 创建对象的方式： 123* var o = &#123; name: '123', age: 18 &#125;; //json方式创建* var o = new Object(); //通过new的方式创建* var o = new Persion(); //通过类的构造函数创建 JS中对象的属性创建方式 12345* json的方式： var o = &#123; age: 19 &#125;;* 直接添加属性：var o = &#123;&#125;; o.age = 19;//太分散了，不利于管理* 由于js动态语言的特性，如果属性不存在的时候，直接添加属性。* 构造函数添加属性* 原型添加公共的属性 JS的构造函数的原型构造函数的原型就是：构造对象的模板，构造函数原型里面的所有的属性和方法都会共享给所有的 构造函数构造出来的所有实例。 案例： 08绘制图片.html 案例： 09绘制图片裁剪.html 案例： 10序列帧动画.html 案例： 11面向对象版本的动画帧.html 重点 补充 sublime制作代码段（推荐–已结讲过了）第一步：sublime菜单栏→ 工具 → 制作代码段 第二步：修改输出的sublime代码段文本 1234567891011&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[1、这里放要tab键 输出的内容2、 $&#123;1:this&#125; 占位符，tab可以进行切换，数字是切换的索引。 ：后面的是默认的文本。]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;简写的字母&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;&lt;/snippet&gt; 第三步：保存到插件的文件夹中，后缀名为：.sublime-snippet比如我存放的位置： C:\Users\malunmac\AppData\Roaming\Sublime Text 3\Packages\User\snippetssnippets是我自己新建的文件夹。 canvas进阶Canvas颜色样式和阴影设置填充和描边的颜色（掌握） fillStyle : 设置或返回用于填充绘画的颜色 strokeStyle: 设置或返回用于笔触的颜色 以上两个值都可以接受颜色名,16进制数据，rgb值，甚至rgba.一般先进行设置样式然后进行绘制。 12345例如：ctx.strokeStyle = "red"; ctx.strokeStyle = "#ccc"; ctx.strokeStyle = "rgb(255,0,0)"; ctx.strokeStyle = "rgba(255,0,0,6)"; 设置阴影（了解，少用，性能差） 类比于CSS3的阴影。 shadowColor ： 设置或返回用于阴影的颜色 shadowBlur ： 设置或返回用于阴影的模糊级别,大于1的正整数，数值越高，模糊程度越大 shadowOffsetX： 设置或返回阴影距形状的水平距离 shadowOffsetY： 设置或返回阴影距形状的垂直距离 123456ctx.fillStyle = "rgba(255,0,0, .9)"ctx.shadowColor = "teal";ctx.shadowBlur = 10;ctx.shadowOffsetX = 10;ctx.shadowOffsetY = 10;ctx.fillRect(100, 100, 100, 100); 例如： 案例： 12设置box盒子阴影.html 设置png图片的阴影，图片透明部分不会被投影。 复杂样式（了解）创建线性渐变的样式（了解） 一般不用，都是用图片代替，canvas绘制图片效率更高。 线性渐变可以用于 矩形、圆形、文字等颜色样式 线性渐变是一个对象 语法：ctx.createLinearGradient(x0,y0,x1,y1); //参数：x0,y0起始坐标，x1,y1结束坐标 123456例如：//创建线性渐变的对象，var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,"black"); //添加一个渐变颜色，第一个参数介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。grd.addColorStop(1,"white"); //添加一个渐变颜色ctx.fillStyle =grd; //关键点，把渐变设置到 填充的样式 案例13设置线性渐变.html 设置圆形渐变（径向渐变） 了解 创建放射状/圆形渐变对象。可以填充文本、形状等 context.createRadialGradient(x0,y0,r0,x1,y1,r1); radial 半径的；放射状的；光线的；光线状的 英 [‘reɪdɪəl] 美 [‘redɪəl] 参数详解： x0: 渐变的开始圆的 x 坐标 y0: 渐变的开始圆的 y 坐标 r0: 开始圆的半径 x1: 渐变的结束圆的 x 坐标 y1: 渐变的结束圆的 y 坐标 r1: 结束圆的半径 123456var rlg = ctx.createRadialGradient(300,300,10,300,300,200);rlg.addColorStop(0, 'teal'); //添加一个渐变颜色rlg.addColorStop(.4, 'navy');rlg.addColorStop(1, 'purple');ctx.fillStyle = rlg;//设置 填充样式为延续渐变的样式ctx.fillRect(100, 100, 500, 500); 案例14圆形渐变.html 绘制背景图（了解） ctx.createPattern(img,repeat) 方法在指定的方向内重复指定的元素了解 pattern：n. 模式；图案；样品 英 [‘pæt(ə)n] 美 [‘pætɚn] 第一参数：设置平铺背景的图片，第二个背景平铺的方式。 image ： 规定要使用的图片、画布或视频元素。 repeat ： 默认。该模式在水平和垂直方向重复。 repeat-x ： 该模式只在水平方向重复。 repeat-y ： 该模式只在垂直方向重复。 no-repeat： 该模式只显示一次（不重复）。 123456var ctx=c.getContext("2d");var img=document.getElementById("lamp");var pat=ctx.createPattern(img,"repeat");ctx.rect(0,0,150,100);ctx.fillStyle=pat;// 把背景图设置给填充的样式ctx.fill(); 案例15背景图填充.html 变换（重点）缩放（重点） scale() 方法缩放当前绘图，更大或更小 语法：context.scale(scalewidth,scaleheight) scalewidth : 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) scaleheight : 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.)+注意：缩放的是整个画布，缩放后，继续绘制的图形会被放大或缩小。 案例16缩放案例.html 位移画布（重点） ctx.translate(x,y) 方法重新映射画布上的 (0,0) 位置 参数说明： x： 添加到水平坐标（x）上的值 y： 添加到垂直坐标（y）上的值 发生位移后，相当于把画布的0,0坐标 更换到新的x,y的位置，所有绘制的新元素都被影响。 位移画布一般配合缩放和旋转等。 案例： 17位移画布.html 旋转（重点） context.rotate(angle); 方法旋转当前的绘图 注意参数是弧度（PI） 如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。 案例：18旋转画布.html 绘制环境保存和还原（重要） ctx.save() 保存当前环境的状态 可以把当前绘制环境进行保存到缓存中。 ctx.restore() 返回之前保存过的路径状态和属性 获取最近缓存的ctx 一般配合位移画布使用。 案例： 19矩形旋转案例.html 设置绘制环境的透明度（了解） context.globalAlpha=number; number:透明值。必须介于 0.0（完全透明） 与 1.0（不透明） 之间。 设置透明度是全局的透明度的样式。注意是全局的。 画布限定区域绘制（了解） ctx.clip(); 方法从原始画布中剪切任意形状和尺寸 一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域） 一般配合绘制环境的保存和还原。 画布保存base64编码内容（重要） 把canvas绘制的内容输出成base64内容。 语法：canvas.toDataURL(type, encoderOptions); 例如：canvas.toDataURL(“image/jpg”,1); 参数说明： type，设置输出的类型，比如 image/png image/jpeg等 encoderOptions： 0-1之间的数字，用于标识输出图片的质量，1表示无损压缩，类型为： image/jpeg 或者image/webp才起作用。 123456789案例1：var canvas = document.getElementById("canvas");var dataURL = canvas.toDataURL();console.log(dataURL);// "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC"var img = document.querySelector("#img-demo");//拿到图片的dom对象img.src = canvas.toDataURL("image/png"); //将画布的内容给图片标签显示 画布渲染画布（重要） context.drawImage(img,x,y); img参数也可以是画布，也就是把一个画布整体的渲染到另外一个画布上。 1234567var canvas1 = document.querySelector('#cavsElem1');var canvas2 = document.querySelector('#cavsElem2');var ctx1 = canvas1.getContext('2d');var ctx2 = canvas2.getContext('2d');ctx1.fillRect(20, 20, 40, 40); //在第一个画布上绘制矩形ctx2.drawImage(canvas1, 10, 10); //将第一个画布整体绘制到第二个画布上 了解：线条样式（了解） lineCap 设置或返回线条的结束端点(线头、线冒)样式 butt ： 默认。向线条的每个末端添加平直的边缘。 翻译.：屁股；烟头；笑柄；靶垛；粗大的一端 英 [bʌt] 美 [bʌt] round ： 向线条的每个末端添加圆形线帽。 square： 向线条的每个末端添加正方形线帽。 参考：23线的样式.html lineJoin 设置或返回两条线相交时，所创建的拐角类型 bevel: 创建斜角。 翻译. 斜角；斜面；[测] 斜角规 英 [‘bev(ə)l] 美 [‘bɛvl] round: 创建圆角。 miter: 默认。创建尖角 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 意思: 斜接 英 [‘maɪtə] 斜接长度指的是在两条线交汇处内角和外角之间的距离。 一般用默认值：10就可以了。除非需要特别长的尖角时，使用此属性。 了解贝塞尔曲线（知道有）绘制一条二次方曲线。 微软的画图板中的曲线的颜色。 quadratic：二次方的意思， 英 [kwɒ’drætɪk] 美 [kwɑ’drætɪk] Curve：曲线的意思， 英 [kɜːv] 美 [kɝv] 语法： context.quadraticCurveTo(cpx,cpy,x,y); 参数： cpx： 贝塞尔控制点的 x 坐标 cpy： 贝塞尔控制点的 y 坐标 x ： 结束点的 x 坐标 y ： 结束点的 y 坐标 12345ctx.beginPath();ctx.moveTo(20,20);//绘制2次方曲线，贝赛尔曲线ctx.quadraticCurveTo(20,100,200,20);ctx.stroke(); 绘制贝塞尔曲线（知道有） 绘制一条三次贝塞尔曲线 语法：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); 提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 参数说明： cp1x： 第一个贝塞尔控制点的 x 坐标 cp1y： 第一个贝塞尔控制点的 y 坐标 cp2x： 第二个贝塞尔控制点的 x 坐标 cp2y： 第二个贝塞尔控制点的 y 坐标 x: 结束点的 x 坐标 y: 结束点的 y 坐标 123456789101112//绘制复杂的贝塞尔曲线ctx.beginPath();ctx.moveTo(400,400);//参数说明：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);// cp1x： 第一个贝塞尔控制点的 x 坐标// cp1y： 第一个贝塞尔控制点的 y 坐标// cp2x： 第二个贝塞尔控制点的 x 坐标// cp2y： 第二个贝塞尔控制点的 y 坐标// x: 结束点的 x 坐标// y: 结束点的 y 坐标ctx.bezierCurveTo(500, 200, 600, 600, 700, 300);ctx.stroke(); 案例：25绘制贝塞尔曲线.html 了解创建两条切线的弧（知道有） 在画布上创建介于当前起点和两个点形成的夹角的切线之间的弧 语法： context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。 例如： ctx.arcTo(240, 100, 240, 110, 40); 参数： x1: 弧的端点1的 x 坐标 y1: 弧的端点1的 y 坐标 x2: 弧的端点2(终点)的 x 坐标 y2: 弧的端点2(终点)的 y 坐标 r : 弧的半径 12345678//代码demo：ctx.beginPath();ctx.moveTo(100,100);ctx.lineTo(200,100);//context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。ctx.arcTo(240, 100, 240, 110, 40);ctx.lineTo(240, 300);ctx.stroke(); 了解判断点是否在路径中（知道有）123context.isPointInPath(x,y);//isPointInPath() 方法返回 true，如果指定的点位于当前路径中；否则返回 false。//判断x,y坐标的点是否在当前的路径中。 了解文本宽度计算（知道有）1context.measureText(text).width; 如果以后做canvas游戏方向开发深入学习可以扩展内以下容： setTransform() 将当前转换重置为单位矩阵。然后运行 transform() transform() 替换绘图的当前转换矩阵 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 像素操作 Canvas开发库封装封装常用的绘制函数封装一个矩形123456789101112131415161718192021222324252627282930313233343536373839//思考：我们用到的矩形需要哪些绘制的东西呢？1、矩形的 x、y坐标2、矩形的宽高3、矩形的边框的线条样式、线条宽度4、矩形填充的样式5、矩形的旋转角度6、矩形的缩小放大//下面是把上面所有的功能进行封装的代码：function ItcastRect( option ) &#123;//矩形构造函数 this._init(option);&#125;ItcastRect.prototype = &#123; //矩形的原型对象 _init: function( option ) &#123; //初始化方法 option = option || &#123;&#125;; this.x = option.x === 0 ? 0 : option.x || 100; this.y = option.y === 0 ? 0 : option.y || 100; this.w = option.w || 100; this.h = option.h || 100; this.angle = option.angle === 0 ? 0 : option.angle || 0; this.fillStyle = option.fillStyle || 'silver'; this.strokeStyle = option.strokeStyle || 'red'; this.strokeWidth = option.strokeWidth || 4; this.scaleX = option.scaleX || 1; this.scaleY = option.Y || 1; &#125;, render: function( ctx ) &#123;//把矩形渲染到canvas中 ctx.save(); ctx.translate( this.x, this.y );//位移画布 ctx.rotate( this.angle * Math.PI / 180 );//旋转角度 ctx.scale( this.scaleX, this.scaleY );//缩放 ctx.fillStyle = this.fillStyle; ctx.fillRect( 0, 0, this.w, this.h ); //填充矩形 ctx.lineWidth = this.strokeWidth; //线宽 ctx.strokeStyle = this.strokeStyle; //填充样式 ctx.strokeRect( 0,0,this.w,this.h ); //描边样式 ctx.restore(); &#125;, constructor: ItcastRect&#125;; 4.1.2作业：尝试着封装一个圆形？ 123456789101112131415161718192021222324252627282930313233343536373839404142//封装圆形的代码的答案：不要偷看function ItcastCircle( option ) &#123; this._init( option );&#125;ItcastCircle.prototype = &#123; _init: function( option ) &#123; option = option || &#123;&#125;; this.x = option.x === 0 ? 0 : option.x || 100; this.y = option.y === 0 ? 0 : option.y || 100; this.w = option.w || 100; this.h = option.h || 100; this.angle = option.angle === 0 ? 0 : option.angle || 0; this.fillStyle = option.fillStyle || 'silver'; this.strokeStyle = option.strokeStyle || 'red'; this.strokeWidth = option.strokeWidth || 4; this.scaleX = option.scaleX || 1; this.scaleY = option.Y || 1; this.opactity = option.opactity || 1; this.counterclockwise = option.counterclockwise === true ? true : option.counterclockwise || false; this.startAngle = option.startAngle == 0 ? 0 : option.startAngle || 0; this.endAngle = option.endAngle == 0 ? 0 : option.endAngle || 0; this.startAngle = this.startAngle * Math.PI/180; this.endAngle = this.endAngle * Math.PI / 180; this.r = option.r || 100; &#125;, render: function( ctx ) &#123; ctx.save(); ctx.translate( this.x, this.y); ctx.scale( this.scaleX, this.scaleY ); ctx.rotate( this.agnle * Math.PI / 180 ); ctx.globalAlpha = this.opacity; ctx.fillStyle = this.fillStyle; ctx.strokeStyle = this.strokeStyle; ctx.moveTo(0, 0); ctx.arc( 0, 0, this.r, this.startAngle, this.endAngle, this.counterclockwise); ctx.fill(); ctx.stroke(); ctx.restore(); &#125;, constructor: ItcastCircle&#125;; 第三方库使用 Rgraph vs 百度的echart 1https://roopons.com.au/wp-content/plugins/viral-optins/js/rgraph/ 国产的egret引擎 1http://www.egret-labs.org/ 比较火的3d引擎：treejs 1http://threejs.org/ Konva 12345678官网：http://konvajs.github.io/ 特点： * 小巧、使用方便、适合移动端和pc端 * 支持丰富的事件处理操作 * 支持类似JQuery的操作方式（顺带能复习jQueyr） * 开源，可以随意更改 * 社区更新比较活跃，github托管源码 * 性能也不错 其他的还有很多，希望以后能用到你们的库。 Konva的使用快速上手Konva的整体理念 舞台的概念的引入。整个视图看做是一个舞台 stage 舞台中可以绘制很多个层 layer layer下面可以有很多的group group下面可以有 矩形、图片、其他形状等 参看：快速上手文档—查看翻译文档 1234567891011121314151617 Stage | +------+------+ | | Layer Layer | | +-----+-----+ Shape | | Group Group | | + +---+---+ | | |Shape Group Shape | + | Shape Konva矩形案例创建一个矩形： Konva.Rect(option);12345678910111213141516171819202122232425262728293031323334353637383940//Konva使用的基本案例//第一步：创建舞台var stage = new Konva.Stage(&#123; container: 'container', //需要存放舞台的Dom容器 width: window.innerWidth, //设置全屏 height: window.innerHeight&#125;);//第二步：创建层var layer = new Konva.Layer(); //创建一个层stage.add(layer); //把层添加到舞台//第三步： 创建矩形var rect = new Konva.Rect(&#123; //创建一个矩形 x: 100, //矩形的x坐标，相对其父容器的坐标 y: 100, width: 100, //矩形的宽度 height: 100, //矩形高度 fill: 'gold', //矩形填充的颜色 stroke: 'navy', //矩形描边的颜色 strokeWidth: 4, //填充宽度 opactity: .2, //矩形的透明度 scale: 1.2, //矩形的缩放 1：原来大小 rotation: 30, //旋转的角度，是deg不是弧度。 cornerRadius: 10, //圆角的大小（像素） id: 'rect1', //id属性，类似dom的id属性 name: 'rect', draggable: true //是否可以进行拖拽&#125;);//创建一个组var group = new Konva.Group(&#123; x: 40, y: 40,&#125;);group.add( rect ); //把矩形添加到组中//第四步： 把形状放到层中layer.add( group ); //把组添加到层中layer.draw(); //绘制层到舞台上 Konva的动画系统tween对象(重点) tween，英文意思：两者之间， 英 [twiːn] 美 [twin] tween是控制Konva对象进行动画的核心对象。 tween可以控制所有数字类型的属性进行动画处理，比如：x, y, rotation,width, height, radius, strokeWidth, opacity, scaleX等 1234567891011121314//案例：var tween = new Konva.Tween(&#123; node: rect, //要进行动画的Konva对象 x: 300, //要进行动画的属性 opacity: .8, duration: 1, //持续时间 easing: Konva.Easings.EaseIn, //动画的动画效果 yoyo: true, //是否进行循环播放的设置 onFinish: function() &#123; //动画执行结束后，执行此方法 &#125;&#125;);tween.play(); //启动动画 tween的控制方法 tween.play(), //播放动画 tween.pause(), //暂停动画 tween.reverse(), //动画逆播放 tween.reset(), //重置动画 tween.finish(), //立即结束动画 seek：英文：寻找 英 [siːk] 美 [sik] tween的缓动控制选项 Konva.Easings.Linear //线性 Konva.Easings.EaseIn //缓动，先慢后快 Konva.Easings.EaseOut //先快后慢 Konva.Easings.EaseInOut //两头慢，中间快 Konva.Easings.BackEaseIn //往回来一点，然后往前冲，汽车启动类似… Konva.Easings.BackEaseOut Konva.Easings.BackEaseInOut Konva.Easings.ElasticEaseIn //橡皮筋 英 [ɪ’læstɪk] 美 [ɪ’læstɪk] Konva.Easings.ElasticEaseOut Konva.Easings.ElasticEaseInOut Konva.Easings.BounceEaseIn //弹跳；弹起，反跳；弹回 英 [baʊns] 美 [baʊns] Konva.Easings.BounceEaseOut Konva.Easings.BounceEaseInOut Konva.Easings.StrongEaseIn //强力 Konva.Easings.StrongEaseOut Konva.Easings.StrongEaseInOut 动画效果参考： 29Konva动画缓动效果案例.html 动画to的使用 to就是对tween的封装，比较简单好用。 1234567891011121314151617181920212223//案例：var rect = new Konva.Rect(&#123; x: 10, y: 10, width: 100, height: 100, fill: 'red'&#125;);layer.add(rect);layer.draw();//动画系统rect.to(&#123; x: 100, y: 100, opactity: .1, duration: 3, onFinish: function() &#123; &#125;&#125;);//to: 就是对tween的简单应用。 Animate的应用 Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间 12345678910111213var anim = new Konva.Animation(function(frame) &#123; //动画系统提供的frame有三个属性可以使用： var time = frame.time, // 动画执行的总时间 timeDiff = frame.timeDiff, // 距离上一帧的时间 frameRate = frame.frameRate; // 帧率（既1000/间隔时间） //动画的动作&#125;, layer);anim.start();//启动动画//anim.stop();//结束动画 循环播放动画的实现12345678910111213//总体思路，使用tween 配合onFinish事件中重新播放动画，达到循环播放的效果var loopTween = new Konva.Tween(&#123; node: star, //设置要表现动画的 Konva对象 rotation: 360, //旋转360度 duration: 2, //动画持续时间 easing: Konva.Easings.Linear, onFinish: function() &#123; // this === loopTween //true this.reset();//重置动画 this.play(); //重新播放动画 &#125;&#125;);loopTween.play(); 回放且循环播放动画 yoyo属性可以进行对动画进行播放完后，回放当前动画，并持续循环来回切换播放。 12345rect.to(&#123; duration: 2, scale: 1.5, yoyo: true// 此设置也可以用于 tween&#125;); 进度条案例传智官网案例 三角函数的补充 Math.sin(弧度); //夹角对面的边 和 斜边的比值 Math.cos(弧度); //夹角侧边 与斜边的比值 圆形上面的点的坐标的计算公式 x =x0 + Math.cos(rad) * R;//x0和y0是圆心点坐标 y =y0 + Math.sin(rad) * R;//注意都是弧度 group的灵活运用 konva的group很灵活，每个group都有自己的坐标系 group可以包含其他的group，可以对group做整个组的动画 group可以通过getChidren();//可以拿到直接子级元素。 12345var group = new Konva.Group(&#123; x: 0, y: 0&#125;);group.add(rect); Konva的事件（重要）123456789101112131415161718192021222324252627282930var rect = new Konva.Rect(&#123; x: 100, y: 100, fill: 'red', width: 200, height: 200&#125;);//绑定事件 Konva支持事件：mouseover, mouseout, mouseenter, mouseleave, mousemove, mousedown, mouseup, mousewheel, click, dblclick, dragstart, dragmove, and dragendrect.on('click', function()&#123; //jQuery一模一样！！ console.log('^_^ ^_^');&#125;);//绑定多个事件rect.on('click mousemove',function(e)&#123;&#125;);//解除绑定事件rect.off('click'); //这不是jQuery吗？//触发事件rect.fire('click');//取消事件冒泡rect.on('click', function(evt) &#123; alert('You clicked the circle!'); evt.cancelBubble = true; //取消事件冒泡&#125;); Konva的选择器 选择方法。 ID选择法：stage.find(‘#id’); //此方法返回的是一个数组 name选择法：group.findOne(‘.name’);//返回一个Konva对象 type选择法： group.find(‘Circle’);//查找所有的圆形Konva对象 1234//组中查找圆形的Konva对象groupCircle.find('Circle').each(function( circle, index )&#123; circle.setZIndex( 3 - index );&#125;); 饼状图案例 wedge: 楔形 柱状图案例 histogram n. [统计] 直方图；柱状图 英 [‘hɪstəgræm] 美 [‘hɪstəɡræm] Canvas项目实战Canvas优化]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap开发实例]]></title>
    <url>%2F2019-05-11%2Fweb-bootstrap.html</url>
    <content type="text"><![CDATA[去年参照Bootstrap文档测试尝试的微金所项目实战，搬到博客上来看看 让我累觉不爱的前端项目之一 代码之余让人有点想玩幻想魔录了 微金所项目实战搭建Bootstrap页面骨架及项目目录结构12345678├─ /weijinsuo/ ··················· 项目所在目录└─┬─ /css/ ······················· 我们自己的CSS文件 ├─ /font/ ······················ 使用到的字体文件 ├─ /img/ ······················· 使用到的图片文件 ├─ /js/ ························ 自己写的JS脚步 ├─ /lib/ ······················· 从第三方下载回来的库【只用不改】 ├─ /favicon.ico ················ 站点图标 └─ /index.html ················· 入口文件 约定编码规范HTML约定 在head中引入必要的CSS文件，优先引用第三方的CSS，方便我们自己的样式覆盖 在body末尾引入必要的JS文件，优先引用第三方的JS，注意JS文件之间的依赖关系，比如bootstrap.js依赖jQuery，那就应该先引用jquery.js 然后引用bootstrap.js CSS约定 除了公共级别样式，其余样式全部由 模块前缀 尽量使用 直接子代选择器， 少用间接子代 避免错杀 HTML5文档结构12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; Viewport设置1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"&gt; html中插入视口设置，可以通过emmet meta:vp 插入 浏览器兼容模式1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; html中插入兼容模式设置，可以通过emmet meta:compat 插入 favicon（站点图标）1&lt;link rel="shortcut icon" type="image/x-icon" href="favicon.ico"&gt; html中插入图标链接，可以通过emmet link:favicon 插入 引入相应的第三方文件123456&lt;link rel="stylesheet" href="bootstrap.css"&gt;&lt;link rel="stylesheet" href="my.css"&gt;...&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap.js"&gt;&lt;/script&gt;&lt;script src="my.js"&gt;&lt;/script&gt; 在我们默认的样式表中将默认字体设置为：12345678body&#123; font-family: "Helvetica Neue", Helvetica, Microsoft Yahei, Hiragino Sans GB, WenQuanYi Micro Hei, sans-serif;&#125; 完成页面空结构 先划分好页面中的大容器，然后在具体看每一个容器中单独的情况 1234567891011121314151617181920212223242526&lt;body&gt; &lt;!-- 头部区域 --&gt; &lt;header&gt;&lt;/header&gt; &lt;!-- /头部区域 --&gt; &lt;!-- 广告轮播 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /广告轮播 --&gt; &lt;!-- 特色介绍 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /特色介绍 --&gt; &lt;!-- 立即预约 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /立即预约 --&gt; &lt;!-- 产品推荐 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /产品推荐 --&gt; &lt;!-- 新闻列表 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /新闻列表 --&gt; &lt;!-- 合作伙伴 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /合作伙伴 --&gt; &lt;!-- 脚注区域 --&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!-- /脚注区域 --&gt;&lt;/body&gt; 构建顶部通栏123&lt;header&gt; &lt;div class="topbar"&gt;&lt;/div&gt;&lt;/header&gt; container类 用于定义一个固定宽度且居中的版心 12345678&lt;div class="topbar"&gt; &lt;div class="container"&gt; &lt;!-- 此处的代码会显示在一个固定宽度且居中的容器中 该容器的宽度会跟随屏幕的变化而变化 --&gt; &lt;/div&gt;&lt;/div&gt; 栅格系统 Bootstrap中定义了一套响应式的网格系统， 其使用方式就是将一个容器划分成12列， 然后通过col-xx-xx的类名控制每一列的占比 row类 因为每一个列默认有一个15px的左右外边距 row类的一个作用就是通过左右-15px屏蔽掉这个边距 123&lt;div class="container"&gt; &lt;div class="row"&gt;&lt;/div&gt;&lt;/div&gt; col-\-*类 col-xs-[列数]：在超小屏幕下展示几份 col-sm-[列数]：在小屏幕下展示几份 col-md-[列数]：在中等屏幕下展示几份 col-lg-[列数]：在大屏幕下展示几份 xs : 超小屏幕 手机 (&lt;768px) sm : 小屏幕 平板 (≥768px) md : 中等屏幕 桌面显示器 (≥992px) lg : 大屏幕 大桌面显示器 (≥1200px) 123456&lt;div class="row"&gt; &lt;div class="col-md-2 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-5 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-2 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-3 text-center"&gt;&lt;/div&gt;&lt;/div&gt; 此处顶部通栏已经被划分成四列text-center的作用就是让内部内容居中显示 字体图标12345678910111213141516@font-face &#123; font-family: 'itcast'; src: url('../font/MiFie-Web-Font.eot') format('embedded-opentype'), url('../font/MiFie-Web-Font.svg') format('svg'), url('../font/MiFie-Web-Font.ttf') format('truetype'), url('../font/MiFie-Web-Font.woff') format('woff');&#125;[class^="icon-"],[class*=" icon-"] &#123; /*注意上面选择器中间的空格*/ /*我们使用的名为itcast的字体就是上面的@font-face的方式声明的*/ font-family: itcast; font-style: normal;&#125;.icon-mobilephone::before&#123; content: '\e908';&#125; 123456789&lt;div class="col-md-2 text-center"&gt; &lt;a class="mobile-link" href="#"&gt; &lt;i class="icon-mobile"&gt;&lt;/i&gt; &lt;span&gt;手机微金所&lt;/span&gt; &lt;!-- 这里使用的是bootstrap中的字体图标 --&gt; &lt;i class="glyphicon glyphicon-chevron-down"&gt;&lt;/i&gt; &lt;img src="..." alt=""&gt; &lt;/a&gt;&lt;/div&gt; 字体文件格式 eot : embedded-opentype svg : svg ttf : truetype woff : woff hover图片展示123.mobile-link:hover &gt; img &#123; display: block;&#125; 按钮样式生成 http://blog.koalite.com/bbg/ 可以通过界面生成一个新的按钮样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445.btn-itcast &#123; color: #ffffff; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast:hover,.btn-itcast:focus,.btn-itcast:active,.btn-itcast.active,.open .dropdown-toggle.btn-itcast &#123; color: #ffffff; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast:active,.btn-itcast.active,.open .dropdown-toggle.btn-itcast &#123; background-image: none;&#125;.btn-itcast.disabled,.btn-itcast[disabled],fieldset[disabled] .btn-itcast,.btn-itcast.disabled:hover,.btn-itcast[disabled]:hover,fieldset[disabled] .btn-itcast:hover,.btn-itcast.disabled:focus,.btn-itcast[disabled]:focus,fieldset[disabled] .btn-itcast:focus,.btn-itcast.disabled:active,.btn-itcast[disabled]:active,fieldset[disabled] .btn-itcast:active,.btn-itcast.disabled.active,.btn-itcast[disabled].active,fieldset[disabled] .btn-itcast.active &#123; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast .badge &#123; color: #E92322; background-color: #ffffff;&#125; 小屏幕隐藏1&lt;div class="topbar hidden-xs hidden-sm"&gt;&lt;/div&gt; 或者 1&lt;div class="topbar visible-md visible-lg"&gt;&lt;/div&gt; hidden-xx : 在某种屏幕下隐藏 visible-xx : 在某种屏幕尺寸下显示 导航通栏 在使用了boostrap过后，大多数界面元素都是通过bootstrap提供好的界面组件修改得来 1234567891011121314151617181920212223242526272829&lt;nav class="navbar navbar-itcast navbar-static-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button id="btn" type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav_list" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;切换菜单&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt; &lt;i class="icon-icon"&gt;&lt;/i&gt; &lt;i class="icon-logo"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;div id="nav_list" class="collapse navbar-collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;我要投资&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;我要借款&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;平台介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新手专区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;最新动态&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;微论坛&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right hidden-sm"&gt; &lt;li&gt;&lt;a href="#"&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; Bootstrap扩展 通过bootstrap文档对导航条样式的设置发现，其实本身是有一个类似于主题的概念 navbar-default：默认的外观 navbar-inverse：暗色背景的样式 所以我们希望可以通过自定义一套完整的风格： navbar-itcast 1234.navbar-itcast&#123; ...&#125;...具体代码参考navbar-default实现即可 品牌logo 任然使用字体图标 菜单行高调整 默认样式中菜单的行高为20px，我们可以调整为自己想要的高度 一般都是通过自己的样式去覆盖 轮播图Bootstrap JS插件使用 对于Bootstrap的JS插件，我们只需要将文档实例中的代码粘到我们自己的代码中让后作出相应的样式调整 Bootstrap中轮播图插件叫作Carousel基本的轮播图实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 以下容器就是整个轮播图组件的整体， 注意该盒子必须加上 class="carousel slide" data-ride="carousel" 表示当前是一个轮播图 bootstrap.js会自动为当前元素添加图片轮播的特效--&gt;&lt;div id="轮播图的ID" class="carousel slide" data-ride="carousel"&gt; &lt;!-- ol标签是图片轮播的控制点 --&gt; &lt;ol class="carousel-indicators"&gt; &lt;!-- 每一个li就是一个单独的控制点 data-target属性就是指定当前控制点控制的是哪一个轮播图，其目的是如果界面上有多个轮播图，便于区分到底控制哪一个 data-slide-to属性是指当前的li元素绑定的是第几个轮播项 注意，默认必须给其中某个li加上active，展示的时候就是焦点项目 --&gt; &lt;li data-target="#轮播图的ID" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#轮播图的ID" data-slide-to="1"&gt;&lt;/li&gt; &lt;!-- ...更多的 --&gt; &lt;/ol&gt; &lt;!-- .carousel-inner是所有轮播项的容器盒子， 注意role="listbox"代表当前div是一个列表盒子，作用就是给当前div添加一个语义 --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;!-- 每一个.item就是单个轮播项目，注意默认要给第一个轮播项目加上active，表示为焦点 --&gt; &lt;div class="item active"&gt; &lt;!-- 轮播项目中展示的图片 --&gt; &lt;img src="example.jpg" alt="示例图片"&gt; &lt;div class="carousel-caption"&gt; &lt;!-- 标题或说明性文字，如果不需要，直接删除当前div.carousel-caption --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;!-- ... --&gt; &lt;/div&gt; &lt;!-- ... --&gt; &lt;/div&gt; &lt;!-- 图片轮播上左右两个控制按钮，分别点击可以滚动到上一张和下一张 --&gt; &lt;!-- 此处需要注意的是 该a链接的href属性必须指向需要控制的轮播图ID --&gt; &lt;!-- 另外a链接中的data-slide="prev"代表点击该链接会滚到上一张，如果设置为next的话则相反 --&gt; &lt;a class="left carousel-control" href="#轮播图的ID" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;上一张&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#轮播图的ID" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;下一张&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 由于轮播图片超宽造成的影响 美工为了在不同屏幕下更好地展示将图片两边做的非常宽，但是我们大多数情况的页面宽度都无法满足这样的图片宽度 而且Bootstrap的样式中默认将图片的max-width设置为100%； 造成界面图片缩放 想在一个较小屏幕下展示一个超宽的图片，并让图片居中显示 两种办法： 换用背景图的方式，background-position: center center; 使img元素绝对定位，left:50%，margin-left: -width/2 background使用 将容器的高度固定（410px） 将轮播图改为背景显示 由于可能图片的高度不一定是410px 所以需要设置css3中的background-size background-size length 如 background-size: 100px 100px，将背景图固定到多大尺寸 percentage 如 background-size: 90% 90%，以百分比的形式设置背景大小 cover 1.背景图片等比例缩放 2.让背景图相对较小边放大到目标容器大小结束 如：一张100*200的背景图放到一个300*400的盒子中，最终背景图片的大小是300*600 因为背景图的较小边为100，将100放大到目标容器300的宽度，放大了3倍，最终结果300*600 contain 1.背景图片等比例缩放 2.让背景图相对较大边放大到目标容器大小结束 如：一张100*200的背景图放到一个300*400的盒子中，最终背景图片的大小是200*400 因为背景图的较大边为200，将200放大到目标容器400的高度，放大了2倍，最终结果200*400 democover contain 图片响应式 目的 各种终端都需要正常显示图片 移动端应该使用更小（体积）的图片 实现方式 将元素中直接设置的图片背景删除，换成两个data-属性（如：data-img-sm=”小图路径”，data-img-lg=”大图路径”） 通过JS的方式获取屏幕的宽度； 判断屏幕宽度是否小于一定的值（如：768） 根据判断情况决定使用具体的大图还是小图 12345678910111213141516// 获取屏幕宽度var windowWidth = $(window).width();// 判断屏幕属于大还是小var isSmallScreen = windowWidth &lt; 768;// 根据大小为界面上的每一张轮播图设置背景// $('#main_ad &gt; .carousel-inner &gt; .item') // 获取到的是一个DOM数组（多个元素）$('#main_ad &gt; .carousel-inner &gt; .item').each(function(i, item) &#123; // 因为拿到是DOM对象 需要转换 var $item = $(item); // var imgSrc = $item.data(isSmallScreen ? 'image-xs' : 'image-lg'); var imgSrc = isSmallScreen ? $item.data('image-xs') : $item.data('image-lg'); // 设置背景图片 $item.css('backgroundImage', 'url("' + imgSrc + '")');&#125;); window resize事件 由于上一步我们实现的过程是指在页面加载完成判断一次， 当用户手动调整页面宽度过后没有及时发生变化， 所以我们可以通过window的resize事件中重新完成以上操作来解决这个问题 1234function 窗口变化后执行的函数名()&#123; // 具体的操作&#125;$(window).on('resize', 窗口变化后执行的函数名); 这个事件只会在窗口尺寸发生变化后执行，但是我们需要一开始时执行一次 12...$(window).on('resize', 窗口变化后执行的函数名).trigger('resize'); 小图片不需要使用背景的方式 小图如果还是使用背景的方式，当屏幕特别小时，效果很差 所以当使用小图时，改用img的方式 123456// 因为我们需要小图时 尺寸等比例变化，所以小图时我们使用img方式if (isSmallScreen) &#123; $item.html('&lt;img src="' + imgSrc + '" alt="" /&gt;');&#125; else &#123; $item.empty();&#125; 按照目前的情况，如果是小图展示则不需要给容器加上410px的固定高度 所以我们可以通过CSS媒体查询的方式解决 12345678910111213#main_ad &gt; .carousel-inner &gt; .item &#123; background-repeat: no-repeat; background-position: center center; background-size: cover;&#125;@media (min-width: 768px) &#123; #main_ad &gt; .carousel-inner &gt; .item &#123; height: 410px; &#125;&#125;#main_ad &gt; .carousel-inner &gt; .item &gt; img &#123; width: 100%;&#125; 网站特性网格系统 该板块当屏幕为中等尺寸时分为3列，较小屏幕是分为2列 所以使用网格系统划分 1234&lt;div class="col-sm-6 col-md-4"&gt; &lt;!-- ... --&gt;&lt;/div&gt;&lt;!-- ... --&gt; 媒体对象样式 每一个小块的样式可以通过Bootstrap中的媒体对象样式实现 1234567891011&lt;a href="#"&gt; &lt;div class="media"&gt; &lt;div class="media-left"&gt; &lt;i class="icon-uniE907"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;支付交易保障&lt;/h4&gt; &lt;p&gt;银联支付全称保证支付安全&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/a&gt; 响应式辅助类型 整个板块在超小屏幕下是隐藏起来的 只需要给当前板块加上hidden-xs的class 预约投标pull-left 左边文字段落 pull-right 右边文字段落 投资产品Tab选项卡 选项卡功能可以通过Bootstrap中提供的相应组件实现http://v3.bootcss.com/javascript/#tabs 1234567891011121314151617181920&lt;div class="container"&gt; &lt;!-- 所有的选项卡标签，每个标签点击分别对应面板展示出来 --&gt; &lt;ul class="nav nav-tabs" role="tablist"&gt; &lt;!-- 下面的li定义了一个选项卡的标签，其中a标签的href属性指向的就是对应要展开的面板ID aria-controls属性是说当前a链接控制的是哪个元素（注意此属性和功能无关，只是语义） 注意一定要给a标签加上data-toggle="tab"，如果不加则boostrap无法知道这是一个选项卡标签，也就不会有相应的效果 --&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#第一个标签的ID" aria-controls="第一个标签的ID" role="tab" data-toggle="tab"&gt;标签页1&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#第二个标签的ID" aria-controls="第二个标签的ID" role="tab" data-toggle="tab"&gt;标签页2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- Tab panes --&gt; &lt;div class="tab-content"&gt; &lt;!-- .tab-pane定义当前是一个tab面板，通过id和选项卡标签关联起来 --&gt; &lt;div role="tabpanel" class="tab-pane active" id="第一个标签的ID"&gt; &lt;!-- 标签展开后的内容 --&gt; &lt;/div&gt; &lt;div role="tabpanel" class="tab-pane" id="第二个标签的ID"&gt;...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 网格系统 和网站特色板块的网格系统定义一样 ::before ::after1234567891011121314151617181920.panel-czbk &gt; .panel-heading::before,.panel-czbk &gt; .panel-heading::after &#123; content: ' '; width: 16px; height: 16px; border-radius: 8px; background-color: #f0f0f0; position: absolute;&#125;.panel-czbk &gt; .panel-heading::before &#123; top: -8px; left: -8px;&#125;.panel-czbk &gt; .panel-heading::after &#123; bottom: -8px; left: -8px; box-shadow: 0 2px 1px #ccc inset;&#125; tooltip插件 注意，bootstrap中的tooltip插件必须通过js方式初始化 选项卡标签横向滚动 要给ul加一个容器，这个容器有横向滚动条 动态设置ul的宽度，宽度是根据内容大小决定的width= sum (li.width) 新闻资讯Tab选项卡响应式偏移合作伙伴相邻兄弟选择器登录对话框模态框表单样式导航吸顶affix组件深度自定义http://v3.bootcss.com/customize通过 Less 文件修改version 4http://www.cnblogs.com/micua/p/bootstrap-version4-alpha.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day6]]></title>
    <url>%2F2019-05-11%2FVue-Day6.html</url>
    <content type="text"><![CDATA[继续介绍webpack以及Element饿了么组件 Vue.js - day6注意：有时候使用npm i node-sass -D装不上，这时候，就必须使用 cnpm i node-sass -D 在普通页面中使用render函数渲染组件在webpack中配置.vue组件页面的解析 运行cnpm i vue -S将vue安装为运行依赖； 运行cnpm i vue-loader vue-template-compiler -D将解析转换vue的包安装为开发依赖； 运行cnpm i style-loader css-loader -D将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式； 在webpack.config.js中，添加如下module规则： 123456789101112module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.vue$/, use: 'vue-loader' &#125; ] &#125; 创建App.js组件页面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt; &lt;div&gt; &lt;h1&gt;这是APP组件 - &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h3&gt;我是h3&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象export default &#123; data() &#123; return &#123; msg: 'OK' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1 &#123; color: red;&#125;&lt;/style&gt; 创建main.js入口文件： 12345678910111213141516171819202122// 导入 Vue 组件import Vue from 'vue'// 导入 App组件import App from './components/App.vue'// 创建一个 Vue 实例，使用 render 函数，渲染指定的组件var vm = new Vue(&#123; el: '#app', render: c =&gt; c(App)&#125;); 在使用webpack构建的Vue项目中使用模板对象？ 在webpack.config.js中添加resolve属性：12345resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125; &#125; ES6中语法使用总结 使用 export default 和 export 导出模块中的成员; 对应ES5中的 module.exports 和 export 使用 import ** from ** 和 import &#39;路径&#39; 还有 import {a, b} from &#39;模块标识&#39; 导入其他模块 使用箭头函数：(a, b)=&gt; { return a-b; } 在vue组件页面中，集成vue-router路由模块vue-router官网 导入路由模块： 12import VueRouter from 'vue-router' 安装路由模块： 12Vue.use(VueRouter); 导入需要展示的组件: 1234import login from './components/account/login.vue'import register from './components/account/register.vue' 创建路由对象: 1234567891011121314var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;); 将路由对象，挂载到 Vue 实例上: 12345678910111213141516var vm = new Vue(&#123; el: '#app', // render: c =&gt; &#123; return c(App) &#125; render(c) &#123; return c(App); &#125;, router // 将路由对象，挂载到 Vue 实例上&#125;); 改造App.vue组件，在 template 中，添加router-link和router-view： 12345678&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 组件中的css作用域问题抽离路由为单独的模块使用 饿了么的 MintUI 组件Github 仓储地址 Mint-UI官方文档 导入所有MintUI组件： 12import MintUI from 'mint-ui' 导入样式表： 12import 'mint-ui/lib/style.css' 在 vue 中使用 MintUI： 12Vue.use(MintUI) 使用的例子： 12&lt;mt-button type="primary" size="large"&gt;primary&lt;/mt-button&gt; 使用 MUI 组件官网首页 文档地址 导入 MUI 的样式表： 12import '../lib/mui/css/mui.min.css' 在webpack.config.js中添加新的loader规则： 12&#123; test: /\.(png|jpg|gif|ttf)$/, use: 'url-loader' &#125; 根据官方提供的文档和example，尝试使用相关的组件 将项目源码托管到oschina中 点击头像 -&gt; 修改资料 -&gt; SSH公钥 如何生成SSH公钥 创建自己的空仓储，使用 git config --global user.name &quot;用户名&quot; 和 git config --global user.email ***@**.com 来全局配置提交时用户的名称和邮箱 使用 git init 在本地初始化项目 使用 touch README.md 和 touch .gitignore 来创建项目的说明文件和忽略文件； 使用 git add . 将所有文件托管到 git 中 使用 git commit -m &quot;init project&quot; 将项目进行本地提交 使用 git remote add origin 仓储地址将本地项目和远程仓储连接，并使用origin最为远程仓储的别名 使用 git push -u origin master 将本地代码push到仓储中 App.vue 组件的基本设置 头部的固定导航栏使用 Mint-UI 的 Header 组件； 底部的页签使用 mui 的 tabbar; 购物车的图标，使用 icons-extra 中的 mui-icon-extra mui-icon-extra-cart，同时，应该把其依赖的字体图标文件 mui-icons-extra.ttf，复制到 fonts 目录下！ 将底部的页签，改造成 router-link 来实现单页面的切换； Tab Bar 路由激活时候设置高亮的两种方式： 全局设置样式如下： 123456.router-link-active&#123; color:#007aff !important; &#125; 或者在 new VueRouter 的时候，通过 linkActiveClass 来指定高亮的类： 1234567891011121314// 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/home' &#125; ], linkActiveClass: 'mui-active' &#125;); 实现 tabbar 页签不同组件页面的切换 将 tabbar 改造成 router-link 形式，并指定每个连接的 to 属性； 在入口文件中导入需要展示的组件，并创建路由对象： 12345678910111213141516171819202122232425262728293031323334// 导入需要展示的组件import Home from './components/home/home.vue'import Member from './components/member/member.vue'import Shopcar from './components/shopcar/shopcar.vue'import Search from './components/search/search.vue'// 创建路由对象var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/home' &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/member', component: Member &#125;, &#123; path: '/shopcar', component: Shopcar &#125;, &#123; path: '/search', component: Search &#125; ], linkActiveClass: 'mui-active'&#125;); 使用 mt-swipe 轮播图组件 假数据： 12345678910lunbo: [ 'http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg', 'http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg', 'http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg' ] 引入轮播图组件： 123456789101112131415161718&lt;!-- Mint-UI 轮播图组件 --&gt; &lt;div class="home-swipe"&gt; &lt;mt-swipe :auto="4000"&gt; &lt;mt-swipe-item v-for="(item, i) in lunbo" :key="i"&gt; &lt;img :src="item" alt=""&gt; &lt;/mt-swipe-item&gt; &lt;/mt-swipe&gt; &lt;/div&gt; &lt;/div&gt; 在.vue组件中使用vue-resource获取数据 运行cnpm i vue-resource -S安装模块 导入 vue-resource 组件 12import VueResource from 'vue-resource' 在vue中使用 vue-resource 组件 12Vue.use(VueResource);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day5]]></title>
    <url>%2F2019-05-11%2FVue-Day5.html</url>
    <content type="text"><![CDATA[本文介绍babel以及Webpack的使用方式，之后会补上具体操作 Webpack以及babel的配置 Vue.js - Day5 - Webpack在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack官网 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑： 1234567// 导入jquery类库 import $ from 'jquery' // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor','lightblue'); // 设置奇数行背景色 $('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理：1webpack src/js/main.js dist/bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：1234567891011// 导入处理路径的模块var path = require('path');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;&#125; 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：1"dev": "webpack-dev-server --contentBase src" 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： 123456789101112131415161718// 导入处理路径的模块var path = require('path');// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 &#125;) ]&#125; 修改package.json中script节点中的dev指令如下： 1"dev": "webpack-dev-server" 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：1"dev": "webpack-dev-server --hot --port 4321 --open" 方式2： 修改webpack.config.js文件，新增devServer节点如下： 12345devServer:&#123; hot:true, open:true, port:4321 &#125; 在头部引入webpack模块： 1var webpack = require('webpack'); 在plugins节点下新增： 1new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件： 12345module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;//处理css文件的规则 ] &#125; 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：1&#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：1&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块： 1&#123; test: /\.(png|jpg|gif)$/, use: 'url-loader' &#125; 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码： 1&#123; test: /\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' &#125;, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： 1&#123; test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下： 1234&#123; "presets":["es2015", "stage-0"], "plugins":["transform-runtime"]&#125; 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法； 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day4]]></title>
    <url>%2F2019-05-11%2FVue-Day4.html</url>
    <content type="text"><![CDATA[本文主要介绍父子组件的调用方式，以及Vue.js中重要的路由思想 Vue.js - Day4父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', props: ['finfo'] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func="getMsg"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 组件中data和props的区别评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则 &#125;); 使用tag属性指定router-link渲染的标签类型设置路由重定向设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: '/register/:id', component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;' &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: "/login", component: login &#125;, &#123; path: "/register", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是 npm 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day3]]></title>
    <url>%2F2019-05-11%2FVue-Day3.html</url>
    <content type="text"><![CDATA[主要介绍组件化，组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可； Vue.js - Day3定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend(&#123; template: '&lt;h1&gt;登录&lt;/h1&gt;' &#125;); Vue.component('login', login); 直接使用 Vue.component 方法： 123Vue.component('register', &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125;); 将模板字符串，定义到script标签种： 123&lt;script id="tmpl" type="x-template"&gt; &lt;div&gt;&lt;a href="#"&gt;登录&lt;/a&gt; | &lt;a href="#"&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt; 同时，需要使用 Vue.component 来定义组件：123Vue.component('account', &#123; template: '#tmpl' &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 12345678910111213Vue.component('account', &#123; template: '#tmpl', data() &#123; return &#123; msg: '大家好！' &#125; &#125;, methods:&#123; login()&#123; alert('点击了登录按钮'); &#125; &#125; &#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示 使用components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // 定义子组件 account: &#123; // account 组件 template: '&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;', // 在这里使用定义的子组件 components: &#123; // 定义子组件的子组件 login: &#123; // login 组件 template: "&lt;h3&gt;这是登录组件&lt;/h3&gt;" &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt; 引用组件： 123&lt;div id="app"&gt; &lt;account&gt;&lt;/account&gt; &lt;/div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 12345&lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;my-com1 v-if="flag"&gt;&lt;/my-com1&gt; &lt;my-com2 v-else="flag"&gt;&lt;/my-com2&gt; &lt;/div&gt; Vue实例定义： 123456789101112131415161718&lt;script&gt; Vue.component('myCom1', &#123; template: '&lt;h3&gt;奔波霸&lt;/h3&gt;' &#125;) Vue.component('myCom2', &#123; template: '&lt;h3&gt;霸波奔&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819202122// 登录组件 const login = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component('login', login); // 注册组件 const register = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;注册组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component('register', register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' &#125;, methods: &#123;&#125; &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 12345678&lt;div id="app"&gt; &lt;a href="#" @click.prevent="comName='login'"&gt;登录&lt;/a&gt; &lt;a href="#" @click.prevent="comName='register'"&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;transition mode="out-in"&gt; &lt;component :is="comName"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt; 添加切换样式： 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;/style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', props: ['finfo'] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func="getMsg"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则 &#125;); 设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: '/register/:id', component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;' &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: "/login", component: login &#125;, &#123; path: "/register", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day2]]></title>
    <url>%2F2019-05-11%2FVue-Day2.html</url>
    <content type="text"><![CDATA[Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） Vue.js - Day2品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end('404'); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log('server running at http://127.0.0.1:3000');&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构： 1234567&lt;div id="app"&gt; &lt;input type="button" value="动起来" @click="myAnimate"&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name="fade"&gt; &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例： 123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;); 定义两组类样式： 12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt; 定义 transition 及属性： 123456&lt;transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="&#123; enter: 500, leave: 800 &#125;"&gt; &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数： 123456789&lt;div id="app"&gt; &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125; 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式： 123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： 1234567&lt;div id="app"&gt; &lt;input type="text" v-model="txt" @keyup.enter="add"&gt; &lt;transition-group tag="ul" name="list"&gt; &lt;li v-for="(item, i) in list" :key="i"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构： 1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; txt: '', list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = ''; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day1]]></title>
    <url>%2F2019-05-11%2FVue-Day1.html</url>
    <content type="text"><![CDATA[Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架,本文主要讨论Vue基本的语法和概念 Vue.js - Day1什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 12345678910&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type="button" value="开启" v-on:click="go"&gt; &lt;input type="button" value="停止" v-on:click="stop"&gt; &lt;/div&gt; Vue实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; info: '猥琐发育，别浪~！', intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;input type="text" v-model="n1"&gt; &lt;select v-model="opt"&gt; &lt;option value="0"&gt;+&lt;/option&gt; &lt;option value="1"&gt;-&lt;/option&gt; &lt;option value="2"&gt;*&lt;/option&gt; &lt;option value="3"&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"&gt; &lt;input type="button" value="=" v-on:click="getResult"&gt; &lt;input type="text" v-model="result"&gt;&lt;/div&gt; Vue实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '0' &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class="['red', 'thin']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class="['red', 'thin', isactive?'active':'']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class="['red', 'thin', &#123;'active': isactive&#125;]"&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class="&#123;red:true, italic:true, active:true, thin:true&#125;"&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style="&#123;color: 'red', 'font-size': '40px'&#125;"&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="h1StyleObj"&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;, h1StyleObj2: &#123; fontStyle: 'italic' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="[h1StyleObj, h1StyleObj2]"&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for="(item, i) in list"&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for="(val, key, i) in userInfo"&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 12&lt;p v-for="i in 10"&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-排序]]></title>
    <url>%2F2019-05-11%2FDataStructure-07.html</url>
    <content type="text"><![CDATA[提到排序，鸡皮疙瘩都起来了，排序思想固然是好玩的，但是代码的实现也是无比蛋疼，记忆起来噩梦级别，之后会在这里补充一些排序算法相关的练习题 排序习题 听首歌先，缓解接下来乏味的过程，Lantern是我很喜欢的挪威剧中的配乐 前言我们根据待排序记录是否全部被放置在内存中，将排序分为内排序和外排序两种，外排序需要在内外存之间多次交换数据才能进行。我们本章主要讲的是内排序的算法 我们根据排序过程中借助的主要操作，将内排序分为： 插入排序类 包括直接插入排序跟希尔排序 选择排序类 包括简单选择排序和堆排序 交换排序类 包括冒泡排序跟快速排序 归并排序类 包括归并排序 排序的基本概念与分类 内排序与外排序 内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行 对于内排序来说，排序算法的性能主要是受3个方面影响 时间性能 辅助空间 算法的复杂度 我们根据排序过程中借助的主要操作，将内排序分为：插入排序，交换排序，选择排序，归并排序排序用到的结构与函数123456#define MAXSIZE 10 /*用于要排序数组个数的最大值，可根据需要修改*/typedef struct&#123; int r[MAXSIZE+1]; /*用于存储要排序数组，r[0]用于哨兵或临时变量*/ int length; /*用于记录顺序表的长度*/&#125;SqList; 另外，由于排序最常用的操作是数组两元素的交换，我们将它写成函数1234567/*交换L中数组r的下标为i和j的值*/void swap(SqList *L,int i,int j)&#123; int temp = L-&gt;r[i]; L-&gt;r[i]=L-&gt;[j]; L-&gt;r[j]=temp;&#125; 冒泡排序(Bubble Sort) 冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止 冒泡实现在细节上可以有多种变化，我们将分别就3种不同的冒泡实现代码。 123456789101112131415/*对顺序表L作交换排序(冒泡排序初级版)*/void BubbleSort0(SqList *L)&#123; int i,j; for(i=1;i&lt;L-&gt;length;i++) &#123; for(j=i+1;i&lt;L-&gt;length;j++) &#123; if(L-&gt;r[i] &gt; L-&gt;r[j]) &#123; swap(L,i,j); &#125; &#125; &#125;&#125; 这段代码严格意义上，不算是标准的冒泡排序算法，因为它不满足两两比较相邻记录的冒泡排序思想，它更应该是最最简单的交换排序而已，而且效率很低 以下是正宗的冒泡排序1234567891011121314void BubbleSort(SqList *L)&#123; int i,j; for(i=1;i&lt;L-&gt;length;i++) &#123; for(j=L-&gt;length-1;j&gt;=i;j--) /*注意j是从后往前循环*/ &#123; if(L-&gt;r[j] &gt; L-&gt;r[j+1]) /*若前者大于后者(注意与前者的差异)*/ &#123; swap(L,j,j+1); &#125; &#125; &#125;&#125; 冒泡排序优化123456789101112131415161718/*对顺序表L作改进冒泡算法*/void BubbleSort2(SqList *L)&#123; int i,j; Status flag=TRUE; /*flag用来作为标记*/ for(i=1;i&lt;L-&gt;length &amp;&amp; flag;i++) /*若flag为false则退出循环*/ &#123; flag = FALSE; /*初始为false*/ for(j=L-&gt;length-1;j&gt;=i;j--) &#123; if(L-&gt;r[j] &gt; L-&gt;r[j+1]) &#123; swap(L,j,j+1); flag=TRUE; /*若有数据交换，则flag为true*/ &#125; &#125; &#125;&#125; 冒泡排序法复杂度分析，总时间复杂度为O(n^2^) 简单选择排序(Simple Selection Sort) 简单选择排序法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和i个记录交换之123456789101112131415void SelectSort(SqList *L)&#123; int i,j; for(i=1;i&lt;L-&gt;length;i++) &#123; min = i; /*将当前下标定义为最小值下标*/ for(j=i+1;j&lt;=L-&gt;length;j++) /*循环之后的数据*/ &#123; if(L-&gt;r[min]&gt;L-&gt;r[j]) /*如果有小于当前最小值的关键字*/ min=j; /*将此关键字的下标赋值给min*/ &#125; if(i!=min) /*若min不等于i，说明找到最小值，交换*/ swap(L,i,min); &#125;&#125; 简单选择排序复杂度仍然为O(n^2^)，尽管如此，但是性能上还是要略优于冒泡排序 直接插入排序(Straight Insertion Sort) 直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表1234567891011121314void InsertSort(SqList *L)&#123; int i,j; for(i=2;i&lt;=L-&gt;length;i++) &#123; if(L-&gt;r[i] &lt; L-&gt;r[i-1]) /*需将L-&gt;r[i]插入有序子表*/ &#123; L-&gt;r[0]=L-&gt;r[i]; /*设置哨兵*/ for(j=i-1;L-&gt;r[j] &gt; L-&gt;r[0];j--) L-&gt;r[j+1]=L-&gt;r[j]; /*记录后移*/ L-&gt;r[j+1]=L-&gt;r[0]; /*插入到正确位置*/ &#125; &#125;&#125; 直接插入排序法的时间复杂度还是O(n^2^)，但是直接插入排序法比冒泡和简单选择排序的性能更好一些. 希尔排序(Shell Sort)1234567891011121314151617181920void ShellSort(SqList *L)&#123; int i,j; int increment=L-&gt;length; do &#123; increment=increment/3 + 1; /*增量序列*/ for(i=increment+1;i&lt;=L-&gt;length;i++) &#123; if(L-&gt;r[i] &lt; L-&gt;r[i-increment]) &#123; /*需将L-&gt;r[i]插入有序增量子表*/ L-&gt;r[0]=L-&gt;r[i]; /*暂存在L-&gt;r[0]*/ for(j=i-increment;j&gt;0 &amp;&amp; L-&gt;r[0] &lt; L-&gt;r[j];j-=increment) L-&gt;r[j+increment]=L-&gt;r[j]; /*记录后移，查找插入位置*/ L-&gt;r[j+increment]=L-&gt;r[0] /*插入*/ &#125; &#125; &#125; while(increment&gt;1);&#125; “增量”的选取非常关键，需要注意增量序列的最后一个增量必须等于1才行 希尔排序的时间复杂度为O(n^3/2^)，终于突破了慢速排序的时代(超越了时间复杂度为O(n^2^) 堆排序(Heap Sort) 堆是具有下列性质的完全二叉树 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆 或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 故根结点一定是堆中所有的结点的最大(小)者 12345678910111213/*对顺序表L进行堆排序*/void HeapSort(SqList *L)&#123; int i; for(i=L-&gt;length/2;i&gt;0;i--) /*把L中的r构建成一个大顶堆*/ HeapAdjust(L,i,L-&gt;length); for(i=L-&gt;length;i&gt;1;i--) &#123; swap(L,1,i); /*将堆顶记录和当前未经排序子序列的最后一个记录交换*/ HeapAdjust(L,1,i-1); /*将L-&gt;r[1..i-1]重新调整未大顶堆*/ &#125;&#125; 弄清楚i的变化是在调整哪些元素后，可以看关键的HeapAdjust(堆调整)函数是如何实现的1234567891011121314151617/*已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义*//*本函数调整L-&gt;r[s]的关键字，使L-&gt;r[s..m]成为一个大顶堆*/void HeapAdjust(SqList *L,int s,int m)&#123; int temp,j; temp=L-&gt;r[s]; for(j=2*s;j&lt;=m;j*=2) /*沿关键字较大的孩子结点向下筛选*/ &#123; if(j&lt;m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j+1]) ++j; /*j为关键字中较大的记录的下标*/ if(temp&gt;=L-&gt;r[j]) break; /*rc应插入在位置s上*/ L-&gt;r[s]=L-&gt;r[j]; s=j; &#125; L-&gt;r[s]=temp; /*插入*/&#125; 12345for(i=L-&gt;length;i&gt;1;i--)&#123; swap(L,1,i); /*将堆顶记录和当前未经排序子序列的最后一个记录交换*/ HeapAdjust(L,1,i-1); /*将L-&gt;r[1..i-1]重新调整为大顶堆*/&#125; 堆排序的时间复杂度为O(nlogn)，这在性能上显然要远远好过于冒泡，简单选择，直接插入的时间复杂度了 归并排序(Merging Sort)1234void MergeSort(SqList *L)&#123; MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);&#125; 123456789101112131415/*将SR[s..t]归并排序为TR1[s..t]*/void MSort(int SR[],int TR1[],int s,int t)&#123; int m; int TR2[MAXSIZE+1]; if(s==t) TR1[s]=SR[s]; else &#123; m=(s+t)/2; /*将SR[s..t]平分为SR[s..m]和SR[m+1..t]*/ MSort(SR,TR2,s,m); /*递归将SR[s..m]归并为有序的TR2[s..m]*/ MSort(SR,TR2,m+1,t); /*递归将SR[m+1..t]归并为有序TR2[m+1..t]*/ Merge(TR2,TR1,s,m,t); /*将TR2[s..m]和TR2[m+1..t]归并到TR1[s..]*/ &#125;&#125; 12345678910111213141516171819202122/*将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]*/void Merge(int SR[],int TR[],int i,int m,int n)&#123; int j,k,l; for(j=m+1,k=1;i&lt;=m &amp;&amp; j&lt;=n;k++) /*将SR中记录由小到大归并入TR*/ &#123; if(SR[i]&lt;SR[j]) TR[k]=SR[i++]; else TR[k]=SR[j++]; &#125; if(i&lt;=m) &#123; for(l=0;l&lt;=m-i;l++) TR[k+1]=SR[i+1] /*将剩余的SR[i..m]复制到TR*/ &#125; if(j&lt;=n) &#123; for(l=0;l&lt;=n-j;l++) TR[k+1]=SR[j+1]; /*将剩余的SR[j..n]复制到TR*/ &#125;&#125; 时间复杂度：一趟归并需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行(log2n)次，因此，总的时间复杂度为O(nlogn)，空间复杂度为O(n+logn) 非递归实现归并排序12345678910111213/*对顺序表L作归并非递归排序*/void MergeSort2(SqList *L)&#123; int* TR=(int*)malloc(L-&gt;length*sizeof(int)); /*申请额外空间*/ int k=1; while(k&lt;L-&gt;length) &#123; MergePass(L-&gt;r,TR,k,L-&gt;length); k=2*k; /*子序列长度加倍*/ MergePass(TR,L-&gt;r,k,L-&gt;length); k=2*k; /*子序列长度加倍*/ &#125;&#125; 从代码中，我们能感受到，非递归的迭代做法更加直接了当，从最小的序列开始归并直至完成，不需要像归并的递归算法一样，需要先拆分递归，再归并退出递归12345678910111213141516/*将SR[]中相邻长度为s的子序列两两归并到TR[]*/void MergePass(int SR[],int TR[],int s,int n)&#123; int i=1; int j; while(i &lt;= n-2*s+1) &#123; Merge(SR,TR,i,i+s-1,i+2*s-1); /*两两归并*/ i=i+2*s; &#125; if(i&lt;n-s+1) /*归并最后两个序列*/ Merge(SR,TR,i,i+s-1,n); else /*若最后只剩下单个子序列*/ for(j=1;j&lt;=n;j++) TR[j]=SR[j];&#125; 非递归的迭代方法，避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O(n)，而且避免递归也在时间性能上有一定的提升，应该说，使用归并排序时，尽量考虑非递归方法。 快速排序(Quick Sort)1234void QuickSort(SqList *L)&#123; QSort(L,1,L-&gt;length);&#125; 1234567891011/*对顺序表L中的子序列L-&gt;r[low..high]作快速排序*/void QSort(SqList *L,int low,int high)&#123; int pivot; if(low&lt;high) &#123; pivot=Partition(L,low,high); /*将L-&gt;r[low..high]一分为二，算出枢轴值pivot*/ QSort(L,low,pivot-1); /*对低子表递归排序*/ QSort(L,pivot+1,high); /*对高子表递归排序*/ &#125;&#125; Partition函数要做的，就是先选取当中一个关键字，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边值都比它大，我们将这样的关键字称为枢轴(pivot)1234567891011121314151617/*交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置*//*此时在它之前(后)的记录均不大(小)与它*/int Partition(SqList *L,int low,int high)&#123; int pivotkey; pivotkey=L-&gt;r[low]; /*用子表的第一个记录作枢轴记录*/ while(low&lt;high) /*从表的两端交替向中间扫描*/ &#123; while(low&lt;high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high--; swap(L,low,high); /*将比枢轴记录小的记录交换到低端*/ while(low&lt;high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) low++; swap(L,low,high); /*将比枢轴记录大的记录交换到高端*/ &#125; return low; /*返回枢轴所在位置*/&#125; 在最优的情况下，快速排序算法的时间复杂度为O(nlogn) 证明过程了解一下 快速排序优化 优化选取枢轴 三数取中(median-of-three)法，即选取三个关键字先进行排序，将中间数作为枢纽，一般是取左端，右端，中间三个数，也可以随机选取。这样至少这个中间数不会是最小或最大的数。 故在Partition函数代码的第3行与第4行之间增加这样一段代码 12345678910int pivotkey;int m = low + (high - low)/2; /*计算数组中间的元素下标*/if(L-&gt;r[low] &gt; L-&gt;r[high]) swap(L,low,high); /*交换左端与右端数据，保证左端较小*/if(L-&gt;r[m] &gt; L-&gt;r[high]) swap(L,high,m); /*交换中间与右端数据，保证中间较小*/if(L-&gt;r[m] &gt; L-&gt;r[low]) swap[L,m,low]; /*交换中间与左端数据，保证左端较小*//*此时L，r[low]已经为整个序列左中右三个关键字的中间值*/pivotkey = L-&gt;[low]; /*用子表的第一个记录作为枢轴记录*/ 当然三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey，但是对于非常大的待排序的序列来说还是不足以保证能够选出一个好的pivotkey，因此还有个方法叫九数取中(median-of-nine) 三次三数取中，然后再进行一次三数取中 2.优化不必要的交换123456789101112131415161718/*快速排序优化算法*/int Partition1(SqList *L,int low,int high)&#123; int pivotkey; //这里省略三数取中代码 pivotkey = L-&gt;r[low]; /*用于表的第一个记录作枢纽记录*/ L-&gt;r[0]=pivotkey; /将枢纽关键字备份到L-&gt;r[0]/ while(low&lt;high) /*从表的两端交替向中间扫描*/ &#123; while(low&lt;high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high-- L-&gt;r[low]=L-&gt;r[high]; /采用替换而不是交换的方式进行操作/ while(low&lt;high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) low++; L-&gt;r[high]=L-&gt;r[low]; /采用替换而不是交换的方式进行操作/ &#125; L-&gt;r[low]=L-&gt;r[0]; /将枢纽数值替换回L.r[low]/ return low; /*返回枢轴所在位置*/&#125; 3.优化小数组时的排序方案1234567891011121314#define MAX_LENGTH_INSERT_SORT 7 /*数组长度阀值*//*对顺序表L中的子序列L.r[low..high]作快速排序*/void QSort(SqList &amp;L,int low,int high)&#123; int pivot; if((high-low)&gt;MAX_LENGTH_INSERT_SORT) &#123;/*当high-low大于常数时用快速排序*/ pivot=Partition(L,low,high); /*将L.r[low..high]一分为二，并算出枢轴值pivot*/ QSort(L,low,pivot-1); /*第低子表递归排序*/ QSort(L,pivot+1,high); /*对高子表递归排序*/ &#125; else /*当high-low小于等于常数时用直接插入排序*/ InsertSort(L);&#125; 如果数组小还不如直接插入排序来得更快(直接插入是简单排序中性能最好的) 优化递归操作 我们对QSort实施尾递归优化123456789101112131415void QSort1(SqList *L,int low,int high)&#123; int pivot; if((high-low)&gt;MAX_LENGTH_INSERT_SORT) &#123; while(low&lt;high) &#123; pivot=Partition1(L,low,high); /*L.r[low..high]一分为二，算出枢轴值*/ QSort1(L,low,pivot-1); /*对低子表递归排序*/ low=pivot+1; /*尾递归*/ &#125; &#125; else InsertSort(L);&#125; 总结回顾从算法的简单性来看，我们将7种算法分为两类： 简单算法：冒泡，简单选择，直接插入 改进算法：希尔，堆，归并，快速 从平均情况来看，最后3种改进算法要胜过希尔算法，并远远胜于前3种简单算法 从最好情况来看，反而冒泡和直接插入排序更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法。 从最坏情况来看，堆排序和归并排序又强过快速排序以及其他简单排序。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-查找]]></title>
    <url>%2F2019-05-11%2FDataStructure-06.html</url>
    <content type="text"><![CDATA[查找，说到底也是排序思想的基础，主要是针对树的查找 前言：查找(Searching)就是根据给定的某个值，在查找表中确定一个其关键字等于定值的数据元素(或记录) 查找表(Search Table)是由同一类型的数据元素(或记录)构成的集合 关键字(Key)是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项(字段)，我们称为关键码 若此关键字可以唯一地标识一个记录，则称此关键字为主关键字(Primary Key)，注意这意味着，对不同的记录，其主关键字均不相同，主关键字所在的数据项称为主关键码 那么对于那些可以识别多个数据元素(或记录)的关键字，我们称为次关键字(Secondary Key)，次关键字可以理解为是不以唯一标识一个数据元素(或记录)的关键字，它对应的数据项就是次关键码 查找表按照操作方式分两大种： 静态查找表(Static Search Table)：只作查找操作的操作表 动态操作表(Dynamic Search Table):在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素 顺序表查找 顺序查找(Sequential Search)又叫线性查找，是最基本的查找技术。 1234567891011/*顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字*/int Sequential_Search(int *a,int n,int key)&#123; int i; for(i=1;i&lt;n;i++) &#123; if(a[i]==key) return i; &#125; return 0;&#125; 到这里并非足够完美，因为每次循环时都需要对i是否越界，即是否小于等于n进行判断，我们不妨设置一个哨兵 123456789101112/*顺序表查找优化：有哨兵顺序查找*/int Sequential_Search2(int *a,int n, int key)&#123; int i; a[0]=key; /*设置a[0]为关键字值，我们称之为“哨兵”*/ i=n; /*循环从数组尾部开始*/ while(a[i]!=key) &#123; i--; &#125; return i; /*返回0则说明查找失败*/&#125; 对于这种顺序查找算法来说，查找成功最好的情况就是第一个位置就找到了，算法时间复杂度为O(1)，最坏的情况是最后一个位置才找到，需要n次比较，时间复杂度为O(n)，当查找不成功时，需要n+1次比较，时间复杂度为O(n) 我们推导过，关键字在任何一位置的概率是相同的，所以平均查找次数为(n+1)/2，所以最终时间复杂度为O(n) 有序表查找折半查找(Binary Search) 又称为二分查找，它的前提是线性表中的记录必须是关键码有序(通常从小到大有序)，线性表必须采用顺序存储。 123456789101112131415161718/*折半查找*/int Binary_Search(int *a,int n,int key)&#123; int low,high,mid; low=1; /*定义最低下标为记录首位*/ high=n; /*定义最高下标为记录末位*/ while(low&lt;=mid) &#123; mid=(low+high)/2; /*折半*/ if(key&lt;a[mid]) /*若查找值比中值小*/ high=mid-1; /*最高下标调整到中位下标小一位*/ else if(key&gt;a[mid]) /*若查找值比中值大*/ low=mid+1; /*最低下标调整到中位下标大一位*/ else return mid; /*若相等则说明mid即为查到的位置*/ &#125; return 0;&#125; 因此最终折半算法的时间复杂度为O(logn)，它显然远远好于顺序查找的O(n)时间复杂度 插值查找(Interpolation Search) 换句话说，我们只需要在折半查找算法的代码中更改一下第8行的代码 如下 1mid = low + (high-low) * (key-a[low])/(a[high]-a[low]); /*插值*/ 我们得到了另一种有序表查找算法，差值查找法，插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法。 其核心就在于插值的计算公式，应该说，从时间复杂度来看，也是O(logn)，但是对于表长较大的，关键字分布又比较均匀的查找表来说，插值查找算法的平均性能要比折半查找好很多 斐波那契额查找(Fibonacci Search)1234567891011121314151617181920212223242526272829303132333435/*斐波那契查找*/int Fibonacci_Search(int *a,int n,int key)&#123; int low,high,mid,i,k; low=1; /*定义最低下标为记录首位*/ high=n; /*定义最高下标为记录末位*/ k=0; while(n&gt;F[k]-1) /*计算n位于斐波那契数列的位置*/ k++; for(i=n;i&lt;F[k]-1;i++) /*将不满的数值补全*/ a[i]=a[n]; while(low&lt;=high) &#123; mid=low+F[k-1]-1; /*计算当前分割的下标*/ if(key&lt;a[mid]) /*若查找记录小于当前分隔记录*/ &#123; high=mid-1; /*最高下标调整到分隔下标mid-1处*/ k=k-1; /*斐波那契数列下标减一位*/ &#125; else if(key&gt;a[mid]) /*若查找记录大于当前分隔记录*/ &#123; low=mid+1; /*最低下标调整到分隔下标mid+1处*/ k=k-2; /*斐波那契数列下标减两位*/ &#125; else &#123; if(mid&lt;=n) return mid; /*若相等则说明mid即为查找到的位置*/ else return n; /*若mid&gt;n说明是补全数值，返回n*/ &#125; &#125; return 0;&#125; 线索索引查找 索引就是把一个关键字与它对应的记录相关联的过程，所以线性索引就是将索引项集合组织为线性结构，也称为索引表，我们重点介绍三种线性索引：稠密索引，分块索引和倒排索引 二叉排序树(Binary Sort Tree) 又称为二叉寻找树。它或者是一棵空树，或者是具有下列性质的二叉树 若它的左子树不空，则左子树上所有结点的值均小于它 的根结构的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值； 它的左，右子树也分别为二叉排序树 二叉排序树查找操作 123456/*二叉树的二叉链表结点结构定义*/typedef struct BiTNode /*结点结构*/&#123; int data; /*结点数据*/ struct BiTNode *lchild,*rchild; /*左右孩子指针*/&#125;BiTNode,*BiTree; 123456789101112131415161718192021/*递归查找二叉排序树T中是否存在key*//*指针f指向T的双亲，其初始调用值为NULL*//*若查找成功，则指针p指向该数据元素结点，并返回TRUE*//*否则指针p指向查找路径上访问的最后一个结点并返回FALSE*/Status SearchBST(BiTree T,int key,BiTree f,BiTree *p)&#123; if(!T) /*查找不成功*/ &#123; *p = f; return FALSE; &#125; else if(key == T-&gt;data) /*查找成功*/ &#123; *p = T; return TRUE; &#125; else if(key&lt;T-&gt;data) return SearchBST(T-&gt;lchild,key,T,p); /*在左子树继续查找*/ else return SearchBST(T-&gt;rchild,key,T,p); /*在右子树继续查找*/&#125; 二叉排列树插入操作 123456789101112131415161718192021/*当二叉排序树T中不存在关键字等于key的数据元素时*//*插入key并返回TRUE,否则返回FALSE*/Status InsertBST(BiTree *T,int key)&#123; BiTree p,s; if(!SearchBST(*T,key,NULL,&amp;p)) /*查找不成功*/ &#123; s = (BiTree)malloc(sizeof(BiTNode)); s-&gt;data = key; s-&gt;lchild = s-&gt;rchild = NULL; if(!p) *T = s; /*输入s为新的根节点*/ else if(key&lt;p-&gt;data) p-&gt;lchild = s; /*插入s为左孩子*/ else p-&gt;rchild = s; /*插入s为右孩子*/ return TRUE; &#125; else return FALSE; /*树中已经有关键字相同的结点，不再输入*/&#125; 有了二叉排序树的插入代码，我们要实现二叉排序树的构建就非常容易了，比如 1234567int i;int a[10] = &#123;62,22,41,53,76,33,77,12,16,75&#125;BiTree T = NULL;for(i=0;i&lt;10;i++)&#123; InsertBST(&amp;T,a[i])&#125; 二叉排序树删除操作(三种情况) 叶子结点 仅有左或右子树的结点 左右子树都有的结点，我们来看代码，下面这个算法是递归方式对二叉排序树T查找key，查到是删除 123456789101112131415/*若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点*/Status DeleteBST(BiTree *T,int key)&#123; if(!*T) /*不存在关键字等于key的数据元素*/ return FALSE; else &#123; if(key == (*T)-&gt;data) /*找到关键字等于key的数据元素*/ return Delete(T); else if(key&lt;(*T)-&gt;data) return DeleteBST(&amp;(*T)-&gt;lchild,key); else return DeleteBST(&amp;(*T)-&gt;rchild,key); &#125;&#125; Let’s delete ! 12345678910111213141516171819202122232425262728/**/Status Delete(BiTree *p)&#123; BiTree q,s; if((*p)-&gt;rchild=NULL) /*右子树空则只需重接它的左子树*/ &#123; q=*p;*p=(*p)-&gt;lchild;free(q); &#125; else if((*p)-&gt;lchild==NULL) /*只需重接它的右子树*/ &#123; q=*p;*p=(*p)-&gt;rchild;free(q); &#125; else /*左右子树均不空*/ &#123; q=*p;s=(*p)-&gt;lchild; while(s-&gt;rchild) /*转左，然后向右到尽头(找待删结点的前驱)*/ &#123; q=s;s=s-&gt;rchild; &#125; (*p)-&gt;data=s-&gt;data; /*s指向被删结点的直接前驱*/ if(q!=*p) q-&gt;rchild=s-&gt;lchild; /*重接q的右子树*/ else q-&gt;lchild=s-&gt;lchild; /*重接q的左子树*/ free(s); &#125; return TRUE;&#125; 二叉排序树总结 二叉排序树是以链接的方式存储，保存了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。 二叉排序树的查找性能取决于二叉排序树的形状，也就是说我们希望二叉排序树是平衡的，即深度与完全二叉树相同，均为[log2n]+1，那么查找的时间复杂度也就为O(logn)，类似于折半查找，不平衡的最坏情况就是斜树，查找时间复杂度为O(n)，这等同于顺序查找 平衡二叉树(AVL树) 平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree),是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多为1. 顾名思义，这是一种高度平衡的二叉排序树，我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor) 距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树 平衡二叉树实现原理 当最小不平衡树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋。插入结点后，最小不平衡树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作 平衡二叉树实现算法1234567/*二叉树的二叉链表结点结构定义*/typedef struct BiTNode /*结点结构*/&#123; int data; /*结点数据*/ int bf; /*结点的平衡因子*/ struct BiTNode *lchild,*rchild; /*左右孩子指针*/&#125;BiTNode,*BiTree; 右旋操作 12345678910/*对以p为根的二叉排序树作右旋处理*//*处理之后p指向新的树根结点，即旋转处理之前的左子树的根节点*/void R_Rotate(BiTree *P)&#123; BiTree L; L=(*P)-&gt;lchild; /*L指向P的左子树根结点*/ (*P)-&gt;lchild=L-&gt;rchild; /*L的右子树挂接为P的左子树*/ L-&gt;rchild=(*P); *P=L; /*P指向新的根结点*/&#125; 左旋操作与右旋代码是对称的，不做解释 以下是左平衡旋转处理的函数代码 123456789101112131415161718192021222324252627282930313233#define LH +1 /*左高*/#define EH 0 /*等高*/#define RH -1 /*右高*//*对以指针T所指结点为根的二叉树作左平衡旋转处理*//*本算法结束时，指针T指向新的根结点*/void LeftBalance(BiTree *T)&#123; BiTree L,Lr; L=(*T)-&gt;lchild; /*L指向T的左子树根结点*/ switch(L-&gt;bf) &#123;/*检查T的左子树的平衡度，并作相应平衡处理*/ case LH: /*新结点插入在T的左孩子的左子树上，要作单右旋处理*/ (*T)-&gt;bf=L-&gt;bf=EH; R_Rotate(T); break; case RH: /*新结点插在T的左孩子的右子树商，要作双旋处理*/ Lr=L-&gt;rchild /*Lr指向T的左孩子的右子树根*/ switch(Lr-&gt;bf) /*修改T及其左孩子的平衡因子*/ &#123; case LH:(*T)-&gt;bf=RH; L-&gt;bf=EH; break; case EH:(*T)-&gt;bf=L-&gt;bf=EH; break; case RH: (*T)-&gt;bf=EH; L-&gt;bf=LH; break; &#125; Lr-&gt;bf=EH; L_Rotate(&amp;(*T)-&gt;lchild; /*对T的左子树作左旋平衡处理*/ R_Rotate(T); /*对T作右旋处理*/ &#125;&#125; 同样的，右平衡旋转处理的函数代码非常类似，有了这些准备，我们的主函数正式登场 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个数据元素为e的新结点并返回1，否则返回0*//*若因插入而使二叉排序树失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否*/Status InsertAVL(BiTree *T,int e,Status *taller)&#123; if(!*T) &#123; /*输入新结点，树“长高”，置taller为TRUE*/ *T=(BiTree)malloc(sizeof(BiTNode)); (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EN; *taller=TRUE; &#125; else &#123; if(e==(*T)-&gt;data) &#123; /*树中已存在和e有相同关键字的结点则不再输入*/ *taller=FALSE; return FALSE; &#125; if(e&lt;(*T)-&gt;data) &#123; /*应继续在T的左子树中进行搜索*/ if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /*未插入*/ return FALSE; if(taller) /*已插入到T的左子树且左子树“长高”*/ &#123; switch((*T)-&gt;bf) /*检查T的平衡度*/ &#123; case LH: /*原本左子树比右子树高，需要作左平衡处理*/ LeftBalance(T); *taller=FALSE; break; case EH: /*原本左右子树等高，现因左子树增高而树增高*/ (*T)-&gt;bf=LH; *taller=TRUE; break; case RH: /*原本右子树比左子树高，现左右子树等高*/ (*T)-&gt;bf=EH; *taller=FALSE; break; &#125; &#125; &#125; else &#123; /*应继续在T的右子树中进行搜索*/ if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /*未插入*/ return FALSE; if(*taller) /*已插入到T的右子树且右子树“长高”*/ &#123; switch((*T)-&gt;bf) /*检查T的平衡度*/ &#123; case LH: /*原本左子树比右子树高，现左，右子树等高*/ (*T)-&gt;bf=EH; *taller=FALSE; break; case EH: /*原本左右子树等高，现因右子树增高而树增高*/ (*T)-&gt;bf=RH; *taller=TRUE; break; case RH: /*原本右子树比左子树高，需要作右平衡处理*/ RightBalance(T); *taller=FALSE; break; &#125; &#125; &#125; &#125; return TRUE;&#125; 举例：生成平衡二叉树 12345678int i;int a[10]=&#123;3,2,1,4,5,6,7,10,9,8&#125;;BiTree T=NULL;Status taller;for(i=0;i&lt;10;i++)&#123; InsertAVL(&amp;T,a[i],&amp;taller);&#125; 不平衡的二叉排序树查找效率是非常低的，由此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们的查找时间复杂度就为O(logn)，而插入和删除也为O(logn)，这显然是比较理想的一种动态查找表算法 多路查找树(B树) 多路查找树(multl-way search tree)：其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。 2-3树：其中每一个结点都具有两个孩子(我们称它为2结点)或三个孩子(我们称它为3结点) 一个2结点包含一个元素和两个孩子(或没有孩子) 与二叉排序树类似，左子树包含的元素小于该元素，右子树同理 不过，这个2结点要么没有孩子，要么就有两个，不能只有一个孩子 一个3结点包含一小一大两个元素和三个孩子(或没有孩子) 一个3结点要么没有孩子，要么具有三个孩子，左最小，中介于，右最大 2-3树中所有叶子都在同一层次上 了解一下2-3树的插入实现与删除实现 2-3-4树：其实就是2-3树的概念拓展，包括了4结点的使用，一个4结点包括小中大三个元素和四个孩子(或没有孩子) B树(B-tree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order)，因此2-3树是3阶B树，2-3-4是4阶B树 对于n个关键字的m阶B树，最坏情况是要查找几次呢？ 第一层至少有1个结点，第二层至少有2个结点，由于除根结点外每个分支结点至少有(m/2)棵子树，则第三层至少有2X(m/2)个结点，….这样第k+1层至少有2X(m/2)^k-1^ B+树 散列表查找(哈希表)概述 散列技术是在记录的存储位置和它的关键字之间建立一个确立的对应关系f，使得每个关键字key对应一个存储位置f(key) 查找时，根据这个确定的对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上 这里我们把这种对应关系f称为散列函数，又称哈希(Hash)函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)，那么关键字对应的记录存储位置我们称为散列地址 散列技术既是一种存储方法，也是一种查找方法,散列技术最合适的求解问题是查找与给定值相等的记录. 我们通常会碰到两个关键字key1≠key2，但是却有f(key1)=f(key2)，这种现象我们称为冲突(collision)，并把key1和key2称为这个散列函数的同义词(synonym) 散列函数的构造方法 直接定址法 也就是说，我们可以取关键字的某个线性函数值为散列地址，即f(key)=a x key+b (a，b为常数) 数字分析法 平方取中法 折叠法 除留余数法 随机数法 处理散列冲突的方法 开放地址法 所谓的开放地址，就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 f1(key) = (f(key)+di) MOD m (di=1,2,3,….,m-1) 我们把这种解决冲突的开放地址法称为线性探测法 在解决冲突的时候，我们会碰到这种本来都不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。 另外增加平方运算的目的是为了不让关键字都聚集在某一刻区域，我们称这种方法为二次探测法 即改进di=1^2^，-1^2^，2^2^，-2^2^,… 还有一种方法是，在冲突时，对于位移量di采用随机函数计算得到，我们称之为随机探测法 这里的随机其实是伪随机数，伪随机数就是说，如果我们设置随机种子相同，则不断调用随机函数生成不会重复的数列，我们在查找时，用同样的随机种子，它每次得到的数列是相同的，相同的di也会得到相同的数列地址 随机种子了解一波？ 总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的方法 再散列函数法(事先准备多个散列函数) 链地址法 公共溢出区法(溢出表) 散列表查找实现首先是需要定义一个散列表的结构以及一些相关的常数，其中HashTable就是散列表结构，机构当中的elem为一个动态数组 12345678910#define SUCCESS 1#define UNSUCCESS 0#define HASHSIZE 12 /*定义散列表长为数组的长度*/#define NULLKEY -32768typedef struct&#123; int *elem; /*数据元素存储基址，动态分配数组*/ int count; /*当前数据元素个数*/&#125;HashTable; int m=0; /*散列表表长，全局变量*/ 有了结构的定义，我们可以对散列表进行初始化 1234567891011/*初始化散列表*/Status InitHashTable(HashTable *H)&#123; int i; m=HASHSIZE; H-&gt;count=m; H-&gt;elem=(int*)malloc(m*sizeof(int)); for(i=0;i&lt;m;i++) H-&gt;elem[i]=NULLKEY; return OK;&#125; 为了插入时计算地址，我们需要定义散列函数，散列函数可以根据不同情况更改算法。 12345/*散列函数*/int Hash(int key)&#123; ruturn key % m; /*除留余数法*/&#125; 初始化完成后，我们可以对散列表进行插入操作。 12345678/*插入关键字进散列表*/void InsertHash(HashTable *H,int key)&#123; int addr = Hash(key); /*求散列地址*/ while(H-&gt;elem[addr] != NULLKEY) /*如果不为空，则冲突*/ addr = (addr+1) % m; /*开放地址法的线性探测*/ H-&gt;elem[addr] = key; /*直到有空位后插入关键字*/&#125; 散列表存在后，我们在需要时就可以通过散列表查找要的记录 1234567891011121314/*散列表查找关键字*/Status SearchHash(HashTable H,int key,int *addr)&#123; *addr = Hash(key); /*求散列地址*/ while(H.elem[*addr] != key) /*如果不为空，则冲突*/ &#123; *addr = (*addr+1) % m; /*开放定址法的线性探测*/ if(H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123; /*如果循环回到原点*/ return UNSUCCESS; /*则说明关键字不存在*/ &#125; &#125; return SUCCESS;&#125; 查找的代码和插入的代码非常类似，只需做一个不存在关键字的判断而已 散列表查找性能分析如果没有冲突，散列查找是本章所有查找效率最高的，因为它的时间复杂度为O(1)]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图]]></title>
    <url>%2F2019-05-11%2FDataStructure-05.html</url>
    <content type="text"><![CDATA[图，让我想起被离散数学图论支配的恐惧，但是数据结构涉及到的属于图的抽象数据结构，简直比离散数学还要致命 介绍 前言: 图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合 图的定义与术语 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex) 线性表中可以没有数据元素，称为空表；树中可以没有结点，称为空树；而在图结构，不允许没有顶点，在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。 线性表中，相邻的数据元素之间有线性关系；树结构中，相邻两层的结点具有层次关系；而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的. 无向边(Edge)，用无序偶对(vi,vj)来表示 无向图(Undirected graphs) 有向边，也称为为弧(Arc) 有向图(Directed graphs)，用有序偶&lt;vi,vj&gt;来表示 连接顶点A到D的有向边就是弧，A是弧尾，D是弧头 简单图：图中若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图 无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图 有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图 稀疏图与稠密图：有很少条边或弧的图称为稀疏图，反之称为稠密图 权(Weight)：与图的边或弧相关的数叫做权 网(Network)：这种带权的图通常称为网 子图(Subgraph) 邻接点(Adjacent) 依附(incident) 度(Degree) 入度(InDegree)ID与出度(OutDegree)OD 路径(Path) 路径的长度是路径上边或弧的数目 回路或环(Cycle) 简单路径：序列中顶点不重复出现的路径称为简单路径 简单回路或简单环：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路 连通图(Connected Graph)：无向图中 连通分量：无向图中的极大连通子图 强连通图：有向图中，任意两点都有路径 强连通分量：有向图中的极大强连通子图 连通图的生成树：一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边 如果一个图有n个顶点和小于n-1条边，则是非连通图；如果它多于n-1条边，必定构成一个环 但是有n-1条边并不一定是生成树 有向树：如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树 生成森林：由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。 图的存储结构 邻接矩阵 图的邻接矩阵存储的结构12345678910typedef char VertexType; /*顶点类型应由用户定义*/typedef int EdgeType; /*边上的权值类型应全由用户定义*/#define MAXVEX 100 /*最大顶点数，由用户定义*/#define INFINITY 65535 /*用65535表示∞*/typedef struct&#123; VertexType vexs[MAXVEX]; /*顶点表*/ EdgeType arc[MAXVEX][MAXVEX]; /*邻接矩阵，可看作边表*/ int numVertexes,numEdges; /*图中当前的顶点和边数*/&#125;MGraph; 有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程12345678910111213141516171819/*建立无向网图的邻接矩阵表示*/void CreateMGraph(MGraph *G)&#123; int i,j,k,w; printf("输入顶点数和边数:\n")； scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges); /*输入顶点数和边数*/ for(i = 0;i &lt; G-&gt;numVertexes;i++) /*读入顶点信息，建立顶点表*/ scanf(&amp;G-&gt;vexs[i]); for(i = 0;i &lt; G-&gt;numVertexes;i++) for(j = 0;j &lt;G-&gt;numVertexes;j++) G-&gt;arc[i][j] = INFINITY; /*邻接矩阵初始化*/ for(k = 0;k &lt;G-&gt;numEdges;k++) /*读入numEdges条边，建立邻接矩阵*/ &#123; printf("输入边(vi,vj)上的下标i，下标j和权w:\n"); scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w); /*输入边(vi,vj)上的权*/ G-&gt;arc[i][j]=w; G-&gt;arc[j][i]=G-&gt;arc[i][j]; /*因为是无向图，矩阵对称*/ &#125;&#125; 从代码中可以得到n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n^2^+e)，其中对邻接矩阵Garc的初始化耗费了O(n^2^)的时间 邻接表123456789101112131415typedef char VertexType; /*顶点类型应由用户定义*/typedef int EdgeType; /*边上的权值类型应由用户定义*/typedef struct EdgeNode /*边表结点*/&#123; int adjvex; /*邻接点域，存储该顶点对应的下标*/ EdgeType weight; /*用于存储权值，对于非网图可以不需要*/ struct EdgeNode *next; /*链域，指向下一个临接点*/&#125;EdgeNode;typedef struct VertexNode /*顶点表结点*/&#123; AdjList adjList; /*顶点域，存储顶点信息*/ int numVertexes,numEdges; /*边表头指针*/&#125;GraphAdjList; 123456789101112131415161718192021222324252627/*建立无向图的邻接表结构*/void CreateALGraph(GraphAdjList *G)&#123; int i,j,k; EdgeNode *e; printf("输入顶点数和边数:\n"); scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges); /*输入顶点数和边数*/ for(i = 0;i &lt; G-&gt;numVertexes;i++) /*读入顶点信息，建立顶点表*/ &#123; scanf(&amp;G-&gt;adjList[i].data); /*输入顶点信息*/ G-&gt;adjList[i].firstedge=NULL; /*将边表置为空表*/ &#125; for(k = 0;k &lt; G-&gt;numEdges;k++) /*建立边表*/ &#123; printf("输入边(vi,vj)上的顶点序号:\n"); scanf("%d,%d",&amp;i,&amp;j); /*输入边上的顶点序号*/ e =(EdgeNode*)malloc(sizeof(EdgeNode)); /*向内存申请空间，生成边表结点*/ e-&gt;adjvex=j; /*邻接序号为j*/ e-&gt;next=G-&gt;adjList[i].firstedge; /*将e指针指向当前顶点指向的结点*/ G-&gt;adjList[i].firstedge=e; /*将当前顶点的指针指向e*/ e=(EdgeNode*)malloc(sizeof(EdgeNode)); /*向内存申请空间，生成边表结点*/ e-&gt;adjvex=i; /*邻接序号为i*/ e-&gt;next=G-&gt;adjList[j].firstedge; /*将e指针指向当前顶点指向的结点*/ G-&gt;adjList[j].firstedge=e; /*将当前顶点的指针指向e*/ &#125;&#125;/*后边代码用了前面讲到的单链表头插法*/ 边集数组 十字链表 邻接多重表 图的遍历深度优先遍历(Depth_First_Search)又称为深度优先搜索 12345678910111213141516171819202122typedef int Boolean; /*Boolean是布尔类型，其值是TRUE或FALSE*/Boolean visited[MAX]; /*访问标志的数组*//*邻接矩阵的深度优化递归算法*/void DFS(MGraph G, int i)&#123; int j; visited[i] = TRUE; printf("%c",G.vexs[i]); /*打印顶点，也可以其他操作*/ for(j = 0;j &lt;G.numVertexes;j++) if(G.arc[i][j]) == 1 &amp;&amp; !visited[j]) DFS(G,j); /*对为访问的邻接顶点递归调用*/&#125;/*邻接矩阵的深度遍历操作*/void DFSTraverse(MGraph G)&#123; int i; for(i = 0;i &lt; G.numVertexes;i++) visited[i] = FALSE; /*初始所有顶点状态都是未访问过状态*/ for(i = 0;i &lt; G.numVertexes;i++) if(!visited[i]) /*对未访问过的顶点调用DFS，若是连通图，只会执行一次*/ DFS(G,i);&#125; 123456789101112131415161718192021222324/*邻接表的深度优先递归算法*/void DFS(GraphAdjList GL, int i)&#123; EdgeNode *p; visited[i]=TRUE; printf("%c",GL-&gt;adjList[i].data); /*打印顶点，也可以其他操作*/ p = GL-&gt;adjList[i].firstedge; while(p) &#123; if(!visited[p-&gt;adjvex]) DFS(GL,p-&gt;adjvex); /*对为访问的邻接顶点递归调用*/ p = p-&gt;next; &#125;&#125;/*邻接表的深度遍历操作*/void DFSTraverse(GraphAdjList GL)&#123; int i; for(i = 0;i &lt; GL-&gt;numVertexes;i++) visited[i] = FALSE; /*初始所有顶点状态都是未访问过状态*/ for(i = 0;i &lt; GL-&gt;numVertexes;i++) if(!visited[i]) /*对未访问过的顶点调用DFS，若是连通图，只会执行一次*/ DFS(GL,i);&#125; 对于n个顶点e条边的图，邻接矩阵是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此需要O(n^2^)的时间；而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O(n+e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高 广度优先遍历(Breadth_First_Search)又称为广度优先搜索 1234567891011121314151617181920212223242526272829303132/*邻接矩阵的广度遍历算法*/void BFSTraverse(MGraph G)&#123; int i,j; Queue Q; for(i = 0;i &lt; G.numVertexes;i++) visited[i] = FALSE; InitQueue(&amp;Q); /*初始化一辅助用的队列*/ for(i = 0;i &lt; G.numVertexes;i++) /*对每一个顶点做循环*/ &#123; if(!visited[i]) /*若是未访问过就处理*/ &#123; visited[i]=TRUE; /*设置当前顶点访问过*/ printf("%c",G.vexs[i]); /*打印顶点，也可以其他操作*/ EnQueue(&amp;Q,i); /*将此顶点入队列*/ while(!QueueEmpty(Q)) /*若当前队列不为空*/ &#123; DeQueue(&amp;Q,&amp;i); /*将队中元素出队列，赋值给i*/ for(j=0;j&lt;G.numVertexes;j++) &#123; /*判断其他顶点若与当前顶点存在边且未访问过*/ if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j]=TRUE; /*将找到的此顶点标记为已访问*/ printf("%c",G.vexs[j]); /*打印顶点*/ EnQueue(&amp;Q,j); /*将找到的此顶点入队列*/ &#125; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031/*邻接表的广度遍历算法*/void BFSTraverse(GraphAdjList GL)&#123; int i; EdgeNode *p; Queue Q; for(i = 0; i &lt; GL-&gt;numVertexes;i++) &#123; if(!visited[i]) &#123; visited[i]=TRUE; printf("%c",GL-&gt;adjList[i].data); /*打印顶点，也可以其他操作*/ EnQueue(&amp;Q,i); while(!QueueEmpty(Q)) &#123; DeQueue(&amp;Q,&amp;i); p =GL-&gt;adjList[i].firstedge; /*找到当前顶点边表链表头指针*/ while(p) &#123; if(!visited[p-&gt;adjvex]) /*若此顶点未被访问*/ &#123; visited[p-&gt;adjvex] = TRUE; printf("%c",GL-&gt;adjList[p-&gt;adjvex].data); EnQueue(&amp;Q,p-&gt;adjvex); /*将此顶点入队列*/ &#125; p = p-&gt;next; /*指针指向下一个邻接点*/ &#125; &#125; &#125; &#125;&#125; 对比图的深度优先遍历与广度优先遍历算法，它们在时间复杂度上是一样的，不同之处仅仅在对顶点访问的顺序不同，可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。 最小生成树 普里姆算法(Prim)123456789101112131415161718192021222324252627282930313233343536373839/*Prim算法生成最小生成树*/void MiniSpanTree_Prim(MGraph G)&#123; int min,i,j,k; int adjvex[MAXVEX]; /*保存相关顶点下标*/ int lowcost[MAXVEX]; /*保存相关顶点间边的权值*/ lowcost[0] = 0; /*初始化第一个权值为0，即v0加入生成树*/ /*lowcost的值为0，在这里就是此下标的顶点已经加入生成树*/ adjvex[0] = 0; /*初始化第一个顶点下标为0*/ for(i = 1; i &lt; G.numVertexes;i++) /*循环除下标为0外的全部顶点*/ &#123; lowcost[i] = G.arc[0][i]; /*将v0顶点与之有边的权值存入数组*/ adjvex[i] = 0; /*初始化都为v0的下标*/ &#125; for(i = 1; i &lt; G.numVertexes;i++) &#123; min = INFINITY; /*初始化最小权值为∞，通常设置为不可能的大数字如32767,65535*/ j = 1;k = 0; while(j &lt;G.numVertexes) /*循环全部顶点*/ &#123; if(lowcost[j]! = 0 &amp;&amp; lowcost[j] &lt; min) &#123; /*如果权值不为0且权值小于min*/ min = lowcost[j]; /*则让当前权值成为最小值*/ k = j; /*将当且最小值的下标存入k*/ &#125; j++; &#125; printf("(%d,%d)",adjvex[k],k); /*打印当前顶点边中权值最小边*/ lowcost[k] = 0; /*将当前顶点的权值设置为0，表示此顶点已经完成任务*/ for(j = 1;j &lt;G.numVertexes;j++) /*循环所有顶点*/ &#123; if(lowcost[j]!= 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j]) &#123; /*若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值*/ lowcost[j] = G.arc[k][j]; /*将较小权值存入lowcost*/ adjvex[j] = k; /*将下标为k的顶点存入adjvex*/ &#125; &#125; &#125;&#125; 由此算法代码中的循环嵌套可得此算法的时间复杂度为O(n^2^) 克鲁斯卡尔算法(Kruskal)1234567/*对边集数组Edge结构的定义*/typedef struct&#123; int begin; int end; int weight;&#125;Edge; 123456789101112131415161718192021222324252627/*Kruskal算法生成最小生成树*/void MiniSpanTree_Kruskal(MGraph G) /*生成最小生成树*/&#123; int i,n,m; Edge edges[MAXEDGE]; /*定义边集数组*/ int parent[MAXVEX]; /*定义一数组用来判断边与边是否形成环路*/ /*此处省略将邻接表矩阵G转化为边集数组edges并按权从小到大排序的代码*/ for(i = 0; i &lt;G.numVertexes; i++) parent[i] = 0; /*初始化数组值为0*/ for(i = 0; i &lt;G.numEdges;i++) /*循环每一条边*/ &#123; n = Find(parent,edges[i].begin); m = Find(parent,edges[i].end); if(n!=m) /*假设n与m不等，说明此边没有与现有生成树形成环路*/ &#123; parent[n] = m; /*将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中*/ printf("(%d,%d) %d",edges[i].begin,edges[i].end,edges[i].weight); &#125; &#125;&#125;int Find(int *parent,int f) /*查找连线顶点的尾部下标*/&#123; while(parent[f]&gt;0) f = parent[f]; return f;&#125; 此算法的Find函数由边数e决定，时间复杂度为O(loge)，而外面有一个for循环e次，所以克鲁斯卡尔算法的时间复杂度为O(eloge) 对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，对于稀疏图有很大优势，而普里姆算法对于稠密图，即边数非常多的情况会更好一点。 最短路径 迪杰斯特拉(Dijkstra)12345678910111213141516171819202122232425262728293031323334353637383940414243#define MAXVEX 9#define INFINITY 65535typedef int Pathmatrix[MAXVEX]; /*用于存储最短路径下标的数组*/typedef int ShortPathTable[MAXVEX]; /*用于存储到各点最短路径的权值和*//*Dijkstra算法，求有向网G的v0顶点到其余顶点v最短路径P[v]及带权长度D[v]*//*P[v]的值为前驱顶点下标，D[v]表示v0到v的最短路径长度和*/void shortestPath_Dijkstra(MGraph G,int v0,Pathmatirx *p,ShortPathTable *D)&#123; int v,w,k,min; int final[MAXVEX]; /*final[w]=1表示求得顶点V0至Vw的最短路径*/ for(v=0;v&lt;G.numVertexes;v++) /*初始化数据*/ &#123; final[v] = 0; /*全部顶点初始化为未知最短路径状态*/ (*D)[v] = G.matirx[v0][v]; /*将与v0点有连线的顶点加上权值*/ (*P)[v] = 0; /*初始化路径数组为0*/ &#125; (*D)[v0] = 0; /*v0至v0路径为0*/ final[v0] = 1; /*v0至v0不需要求路径*/ /*开始主循环，每次求得v0到某个v顶点的最短路径*/ for(v=1;v&lt;G.numVertexes;w++) &#123; min=INFINITY; /*当前所知离v0顶点的最近距离*/ for(w=0;w&lt;G.numVertexes;w++) /*寻找离v0最近的顶点*/ &#123; if(!final[w] &amp;&amp; (*D)[w]&lt;min) &#123; k=w; min = (*D)[w]; /*w顶点离v0顶点更近*/ &#125; &#125; final[k] = 1; /*将目前找到的最近的顶点置为1*/ for(w=0;w&lt;G.numVertexes;w++) /*修正当前最短路径及距离*/ &#123; /*如果结果v顶点的路径比现在这条路径的长度短的话*/ if(!final[w] &amp;&amp; (min + G.matirx[k][w] &lt; (*D)[w])) &#123; /*说明找到了更短的路径，修改D[w]和P[w]*/ (*D)[w] = min + G.matirx[k][w]; /**/ (*P)[w] = k; &#125; &#125; &#125;&#125; 我们通过迪杰斯特拉(Dijkstra)算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为O(n^2^)，如果我们还需要知道其它顶点到其余所有顶点的最短路径，我们则需要再一次循环，此时整个算法的复杂度变成了O(n^3^) 弗洛伊德算法(Floyd)1234567891011121314151617181920212223242526272829typedef int Pathmatirx[MAXVEX][MAXVEX];typedef int ShortPathTable[MAXVEX][MAXVEX];/*Floyd算法，求网图G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]*/void ShortestPath_Floyd(MGraph G,Pathmatirx *P,ShortPathTable *D)&#123; int v,w,k; for(v=0;v&lt;G.numVertexes;++v) /*初始化D与P*/ &#123; for(w=0;w&lt;G.numVertexes;++w) &#123; (*D)[v][w]=G.matirx[v][w]; /*D[v][w]值即为对应点间的权值*/ (*P)[v][w]=w; /*初始化P*/ &#125; &#125; for(k=0;k&lt;G.numVertexes;++k) &#123; for(v=0;v&lt;G.numVertexes;++v) &#123; for(w=0;w&lt;G.numVertexes;++w) &#123; if((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w]) &#123; /*如果经过下标为k顶点路径比原两点间路径更短，将当前两点间权值设为更小的一个*/ (*D)[v][w]=(*D)[v][k]+(*D)[k][w]; (*P)[v][w]=(*P)[v][k]; /*路径设置经过下标为k的顶点*/ &#125; &#125; &#125; &#125;&#125; 求最短路径的显示代码可以这么写12345678910111213141516for(v=0;v&lt;G.numVertexes;++v)&#123; for(w=v+1;w&lt;G.numVertexes;w++) &#123; printf("v%d-v%d weight: %d",v,w,D[v][w]); k=P[v][w]; /*获得第一个路径顶点下标*/ printf("path:%d",v); /*打印源点*/ while(k!=w) /*如果路径顶点下标不是终点*/ &#123; printf("-&gt;%d",k); /*打印路径顶点*/ k=P[k][w]; /*获得下一个路径顶点下标*/ &#125; printf("-&gt;%d\n",w); /*打印终点*/ &#125; printf("\n");&#125; 拓扑排序 有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程是否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析除一个有向图是否存在环，如果不存在，那它的拓扑序列是？ 在拓扑排序算法中，涉及的结构代码如下12345678910111213141516171819typedef struct EdgeNode /**/&#123; int adjvex; /*邻接点域，存储该顶点对应的下标*/ int weight; /*用于存储权值，对于非网图可以不需要*/ struct EdgeNode *next; /*链域，指向下一个邻接点*/&#125;EdgeNode;typedef struct VertexNode /*顶点表结点*/&#123; int in; /*顶点入度*/ int data; /*顶点域，存储顶点信息*/ EdgeNode *firstedge; /*边表头指针*/&#125;VertexNode,AdjList[MAXVEX];typedef struct&#123; AdjList adjList; int numVertexes,numEdges; /*图中当前顶点数和边数*/&#125;graphAdjList,*GraphAdjList; 在算法中，我们还需要辅助的数据结构——栈，用来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。1234567891011121314151617181920212223242526272829/*拓扑排序，若GL无回路，则输出拓扑排序序列并返回OK，若有回路返回ERROR*/Status TopologicalSort(GraphAdList GL)&#123; EdgeNode *e; int i,k,gettop; int top=0; /*用于栈指针下标*/ int count=0; /*用于统计输出顶点的个数*/ int *stack; /*建栈存储入度为0的顶点*/ stack=(int*)malloc(GL-numVertexes*sizeof(int)); for(i = 0;i&lt;GL-&gt;numVertexes;i++) if(GL-&gt;adjList[in].in == 0) stack[++top]=i; /*将入度为0的顶点入栈*/ while(top!=0) &#123; gettop=stack[top--]; /*出栈*/ printf("%d-&gt;",GL-&gt;adjList[gettop].data); /*打印此顶点*/ count++; /*统计输出顶点数*/ for(e=GL-&gt;adjList[gettop].firstedge;e;e-&gt;next) &#123;/*对此顶点弧表遍历*/ k=e-&gt;adjvex; if(!(--GL-&gt;adjList[k].in)) /*将k号顶点邻接点的入度减一*/ stack[++top]=k; /*若为0则入栈，以便于下次循环输出*/ &#125; &#125; if(count&lt;GL-&gt;numVertexes) /*如果count小于顶点数，说明存在环*/ return ERROR; else return OK;&#125; 分析整个算法，对一个具有n个顶点e条弧的AOV网来说，将入度为0的顶点入栈的时间复杂为O(n)，而之后的while循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为O(n+e) 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex Network) 关键路径 另一方面关心的是整个工程的完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。 在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网(Activity On Edge Network) 我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点3具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动 事件的最早发生时间etv(earliest time of vertex) 事件的最晚发生时间ltv(latest time of vertex) 活动的最早开工时间ete(earliest time of edge) 活动的最晚开工时间lte(latest time of edge)我们由1和2求得3跟4，然后再根据ete[k]是否等于lte[k]来判断ak是否是关键活动 求etv的过程就是从头到尾找拓扑序列的过程，因此在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列表，为此，我们先在程序开始出声明几个全局变量123int *etv,*ltv; if /*事件最早发生时间和最迟发生时间数组*/int stack2; /*用于存储拓扑序列的栈*/int top2; /*用于stack2的指针*/ 以下是改进过的拓扑序列算法12345678910111213141516171819202122232425262728293031323334353637/*拓扑排序，用于关键路径计算*/Status TopologicalSort(GraphAdjList GL)&#123; EdgeNode *e; int i,k,gettop; int top=0; /*用于栈指针下标*/ int count=0; /*用于统计输出顶点的个数*/ int *stack; /*建栈将入度为0的顶点入栈*/ stack=(int *)malloc(GL-&gt;numVertexes *sizeof(int)); for(i = 0;i &lt; GL-&gt;numVertexes; i++) if(0 == GL-&gt;adjList[i].in) stack[++top]=i; top2=0; /初始化为0/ etv=(int*)malloc(GL-&gt;numVertexes *sizeof(int)); /事件最早发生时间/ for(i = 0;i &lt; GL-&gt;numVertexes; i++) etv[i]=0; /初始化为0/ stack2 = (int *)malloc(GL-&gt;numVertexes*sizeof(int)) /初始化/ while(top!=0) &#123; gettop=stack[top--]; count++; stack2[++top2]=gettop; /*将弹出的顶点序号压入拓扑序列的栈*/ for(e = GL-&gt;adjList[gettop].firstedge;e;e = e-&gt;next) &#123; k=e-&gt;adjvex; if(!(--GL-&gt;adjList[k].in)) stack[++top]=k; if((etv[gettop]+e-&gt;weight)&gt;etv[k]) /求各顶点事件最早发生时间值/ etv[k] = etv[gettop]+e-&gt;weight; &#125; &#125; if(count &lt; GL-&gt;numVertexes) return ERROR; else return OK;&#125; 关键路径的算法1234567891011121314151617181920212223242526272829303132/*求关键路径，GL为有向网，输出GL的各项关键活动*/void CriticalPath(GraphAdjList GL)&#123; EdgeNode *e; int i,gettop,k,j; int ete,lte; /*声明活动最早发生时间和最迟发生时间变量*/ TopologicalSort(GL); /*求拓扑序列，计算数组etv和stack2的值*/ ltv=(int*)malloc(GL-&gt;numVertexes*sizeof(int)); /*事件最晚发生时间*/ for(i=0;i&lt;GL-&gt;numVertexes;i++) ltv[i]=etv[GL-&gt;numVertexes-1]; /*初始化ltv*/ while(top2!=0) /*计算ltv*/ &#123; gettop=stack2[top--]; /*将拓扑序列出栈，后进先出*/ for(e=GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next) &#123; /*求各顶点事件的最迟发生时间ltv值*/ k=e-&gt;adjvex; if(ltv[k]-e-&gt;weight&lt;ltv[gettop]) /*求各顶点事件最晚发生时间ltv*/ ltv[gettop]=ltv[k]-e-&gt;weight; &#125; &#125; for(j=0;j&lt;GL-&gt;numVertexes;j++) /*求ete，lte和关键活动*/ &#123; for(e=GL-&gt;adjList[j].firstedge;e;e=e-&gt;next) &#123; k=e-&gt;adjvex; ete=etv[j]; /*活动最早发生时间*/ lte=ltv[k]-e-&gt;weight; /*活动最迟发生时间*/ if(ete == lte) /*两者相等即在关键路径上*/ printf("&lt;v%d,v%d&gt; length: %d,",GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight); &#125; &#125;&#125; 整个关键路径的算法，拓扑排序O(n+e)，初始化lte为O(n)…根据我们对时间复杂度的定义，所有的常数系数可以忽略，所以最终求得关键路径算法的时间复杂度仍然是O(n+e)]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2F2019-05-11%2FDataStructure-04.html</url>
    <content type="text"><![CDATA[众所周知，树一直是数据结构的重点，此处摘要不做多介绍 最近一直在循环coldplay的歌，分享一波 var ap = new APlayer({ element: document.getElementById("aplayer-WGrEmixr"), narrow: false, autoplay: false, showlrc: false, music: { title: "Viva la Vida", author: "Coldplay", url: "http://psu4sovbi.bkt.clouddn.com/Viva%20la%20Vida.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/Viva.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 介绍 前言:树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中： 有且仅有一个特定的称为根(Root)的结点 当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2…..Tm，其中每一个集合本身又是一棵树，并且称为根的子数(SubTree)结点分类 树的结点包含一个数据元素以及若干指向其子树的分支。结点拥有的字树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。 树的度是树内各结点的度的最大值结点间关系 结点的子树的根称为该结点的孩子(Child)，相应的，该结点称为孩子的双亲(Parent) 对于结点来说其父母同体，唯一的一个，所以称为双亲 同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所近分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙.树的其他相关概念 结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。 若某结点在第I层，则其子树的根就在第I+1层。 其双亲在同一层的结点互为堂兄弟。 树中结点的最大层次称为树的深度(Depth)或高度 如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树 森林(Forest)是m(m≥0)棵互不相交的树的集合 对树种的每个结点而言，其子树的集合即为森林。 对比线性表与树的结构，它们有很大的不同 线性结构：①第一个数据元素：无前驱；②最后一个数据元素：无后继；③中间元素：一个前驱一个后继 树结构：①根节点：无双亲，唯一；②叶节点：无孩子，可以多个；③中间结点：一个双亲多个孩子 树的抽象数据类型对于线性结构，树的操作就完全不同了12345678910111213141516171819ADT 树(Tree)Data 树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系.Operation InitTree(*T): DestroyTree(*T): CreateTree(*T,definition): ClearTree(*T): TreeEmpty(T): TreeDepth(T): Root(T):返回树的根节点 Value(T,cur_e):cur_e是树T中的一个结点，返回此结点的值 Assign(T,cur_e,value):给树T的结点cur_e赋值为value Parent(T,cur_e):若cur_e是树T的非根结点，则返回它的双亲，否则返回空 LeftChild(T,cur_e):若cur_e是树T的非叶节点，则返回它的最左孩子，否则返回空 RightSibling(T,cur_e):若cur_e有右兄弟，则返回它的右兄弟，否则返回空 InsertChild(*T,&amp;p,i,c):其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树 DeleteChild(*T,*p,i):其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树endADT 树的存储结构 双亲表示法(在每个结点中，附设一个指示器指示其双亲结点到链表中的位置) 每个结点除了知道自己是谁之外，还知道它的双亲在哪里,结点结构分为data(数据域，存储结点的数据信息)跟parent(指针域，存储该结点的双亲在数组的下标) 12345678910111213/*树的双亲表示法结点结构定义*/#define MAX_TREE_SIZE 100typedef int TElemType; /*树结点的数据类型，目前暂定为整型*/typedef struct PTNode /*结点结构*/&#123; TElemType data; /*结点数据*/ int parent; /*双亲位置*/&#125;PTNode;typedef struct /*树结构*/&#123; PTNode nodes[MAX_TREE_SIZE]; /*结点数组*/ int r,n;&#125;PTree; 双亲域，长子域，右兄弟域 根节点的双亲域，长子域，右兄弟域都是-1 孩子表示法每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法，不过树的每个结点的度，也就是它的孩子个数是不同的，所以我们可以设计两种反案来解决 一种是指针域的个数等于树的度(树的度是树各个结点度的最大值这种方法在树中各结点的度相差很大时，显然是浪费空间的 第二种是每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数(degree)这种方法克服了空间的浪费，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗思考：能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同？ 我们把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系.这就是所谓的孩子表示法 孩子表示法:把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中12345678910111213141516171819/*树的孩子表示法结构定义*/#define MAX_TREE_SIZE 100typedef struct CTNode /*孩子结点*/&#123; int child; struct CTNode *next;&#125;*ChildPtr;typedef struct /*表头结构*/&#123; TElemType data; ChildPtr firstchild;&#125;CTbox;typedef struct /*树结构*/&#123; CTBox nodes[MAX_TREE_SIZE]; /*结点数组*/ int r,n;&#125;CTree; 双亲孩子表示法 算是孩子表示法的改进，略过 孩子兄弟表示法 任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟 123456/*树的孩子兄弟表示法结构定义*/typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild,*rightsib;&#125;CSNode,*CSTree; 其实这个表达法最大好处就是把一棵复杂的树变成了一棵二叉树 二叉树 二叉树的五种基本形态： 空二叉树 只有一个根节点 根节点只有左子树 根节点只有右子树 根节点既有左子树又有右子树 注意：三个结点的树有两种情况，而三个结点的二叉树有五种形态 特殊二叉树 斜树(左斜树跟右斜树) 满二叉树 注意满二叉树的叶子只能出现在最下一层，单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有叶子都在同一层上 完全二叉树 二叉树的性质 在二叉树的第i层上至多有2^i-1^个结点 深度为k的二叉树至多有2^k^-1个结点 这里要看清楚，很容易把性质1跟性质2弄混 对任意一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1 具有n个结点的完全二叉树的深度为(log2n)+1 如果对一棵有n个结点的完全二叉树(其深度为(log2n)+1)的结点按层序编号，对任一节点i(1≤i≤n)有： 如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2] 如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i 如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1 二叉树的存储结构 顺序存储:二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，还原成完全二叉树的方法 考虑一种极端的情况，比如一棵深度为k的右斜树，它只有k个结点，却要分配2^k^-1个存储单元空间，这显然是对存储空间的浪费，所以顺序存储结构一般只用于完全二叉树. 二叉链表：二叉树的每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表为二叉链表123456/*二叉树的二叉链表结点结构定义*/typedef struct BiTNode /*结点结构*/&#123; TElemType data; /*结点数据*/ struct BiTNode *lchild,*rchild; /*左右孩子指针*/&#125;BiTNode,*BiTree 遍历二叉树 二叉树的遍历(traversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问一次且仅被访问一次. 前序遍历 123456789/*二叉树的前序遍历递归算法*/void PreOrderTraverse(BiTree T)&#123; if(T==NULL) return; printf("c%",T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild);&#125; 中序遍历 123456789/*二叉树的中序遍历递归算法*/void InOrderTraverse(BiTree T)&#123; if(T==NULL) return; InOrderTraverse(T-&gt;lchild); printf("c%",T-&gt;data); InOrderTraverse(T-&gt;rchild);&#125; 后序遍历 123456789/*二叉树的后序遍历递归算法*/void PostOrderTraverse(BiTree T)&#123; if(T==NULL) return; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); printf("c%",T-&gt;data); &#125; 层序遍历 推导遍历结果 已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，求这棵二叉树的后序遍历结果? CBEFDA 已知一棵二叉树的中序序列是ABCDEFG，后序序列是BDCAFGE,求前序序列? EACBDGF 重要 从这里我们可以得到两个二叉树遍历的性质 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 已知前序和后序遍历，是不能确定一棵二叉树的，例如已知前序序列ABC和后序序列CBA，我们可以确定A一定是根节点，但接下来我们无法知道哪个结点是左结点和右结点，所以有4种情况 二叉树的建立 利用扩展二叉树，比如假设二叉树的结点均为一个字符，我们把刚才前序遍历序列AB#D##C##用键盘挨个输入123456789101112131415161718/*按前序输入二叉树中结点的值(一个字符)*//* #表示空树，构造二叉链表示二叉树T */void CreateBiTree(BiTree *T)&#123; TElemType ch; scanf("%c",&amp;ch); if(ch == '#') *T=NULL; else &#123; *T=(BiTree)malloc(sizeof(BiTNode)); if(!*T) exit(OVERFLOW); (*T)-&gt;data=ch; /*生成根节点*/ CreateBiTree(&amp;(*T)-&gt;lchild); /*构造左子树*/ CreateBiTree(&amp;(*T)-&gt;rchild); /*构造右子树*/ &#125;&#125; 其实建立二叉树，也是利用了递归的原理，只不过在原来应该打印结点的地方改成了生成结点，给结点赋值的操作而已，所以如果换成中序和后序遍历的方式，只要调整一下生成结点和构造左右子树的代码顺序即可 线索二叉树 我们考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址 我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree) 对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化，我们将这棵二叉树中所有空指针域中的lchild改为指向当前结点的前驱，rchild改为指向当前结点的后继但是问题没有彻底解决，我们如何知道某一结点的lchild是指它的左孩子还是指向前驱？rchild是指向右孩子还是指向后继？ 这里我们引入两个标志域ltag和rtag，注意ltag和rtag只是存放0或1数字的布尔型变量 tag为0时指向结点的孩子，为1时指向该结点的前驱/后继 线索二叉树结构实现123456789/*二叉树的二叉线索存储结构定义*/typedef enum &#123;Link,Thread&#125; PointerTag; /*Link == 0表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索*/typedef struct BiThrNode /*二叉线索存储结点结构*/&#123; TElemType data; /*结点数据*/ struct BiThrNode *lchild,*rchild; /*左右孩子指针*/ PointerTag LTag; PointerTag RTag;&#125;BiThrNode,*BiThrTree; 线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索，由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。 中序遍历线索化的递归函数代码如下：12345678910111213141516171819BiThrTree pre; /*全局变量，始终指向刚刚访问过的结点*//*中序遍历进行中序线索化*/void InThreading(BiThrTree p)&#123; if(p) &#123; InThreading(p-&gt;lchild); /*递归左子树线索化*/ if(!p-&gt;lchild) /*没有左孩子*/ &#123; p-&gt;LTag=Thread; /*前驱线索*/ p-&gt;lchild=pre; /*左孩子指针指向前驱*/ &#125; if(!pre-&gt;rchild) /*前驱没有右孩子*/ pre-&gt;Tag=Thread; /*后继线索*/ pre-&gt;rchild=p; /*前驱右孩子指针指向后继(当前结点p)*/ &#125; pre=p; /*保持pre指向p的前驱*/ InThreading(p-&gt;rchild); /*递归右子树线索化*/&#125; 这段代码和二叉树中序遍历的递归代码几乎一样，只不过是将打印结点的功能改成了线索化的功能 有了线索二叉树后，我们对它进行遍历时发现，其实就等于操作一个双向链表结构 遍历的代码如下：12345678910111213141516171819/*T指向头结点，头结点左链lchild指向根节点，头结点右链rchild指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T*/Status InOrderTraverse_Thr(BiThrTree T)&#123; BiThrTree p; p = T-&gt;lchild; /*p指向根节点*/ while(p!=T) /*空树或遍历结束时，p==T*/ &#123; while(p-&gt;LTag==Link) /*当LTag==0时循环到中序序列第一个结点*/ p = p-&gt;lchild； printf("c%",p-&gt;data); /*显示结点数据，可以更改为其他对结点操作*/ while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild! =T) &#123; p = p-&gt;rchild; printf("%c",p-&gt;data); &#125; p = p-&gt;rchild; /*p进至其右子树根*/ &#125; return OK;&#125; 实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择. 树，森林与二叉树的转换 转换 树与森林的遍历 树的遍历分为两种形式 先根遍历 后根遍历 森林的遍历也分两种 前序遍历 后序遍历 森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同 赫夫曼树及其应用 赫夫曼树定义及原理 从树中的一个结点到另一个结点之间的分支构成的两个结点之间的路径，路径上的分支数目称为路径长度 树的路径长度就是从树根到每个结点的路径长度之和。 其中带权路径长度WPL最小的二叉树称为赫夫曼树，也称为最优二叉树. 赫夫曼编码 若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码 线索二叉树记得回顾理解一下]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-串]]></title>
    <url>%2F2019-05-11%2FDataStructure-03.html</url>
    <content type="text"><![CDATA[虽然课本已经不把串的抽象数据类型作为重点，但是毕竟有所提及，这里还是把串的相关笔记提交上来 “你将不再是道具，而是人如其名的人” 前言 串(string)是由零个或多个字符组成的有限序列，又名叫字符串,一般记为s=”a1a2a3….an”(n≥0),其中s是串的名称，用双引号括起来的字符序列是串的值，注意单引号不属于串中的内容。 串中的字符数目n称为串的长度 零个字符的串称为空串(null string)，它的长度为0，可以直接用两双引号“”表示，也可以用希腊字母Ø表示 空格串，是只包含空格的串，注意它与空串的区别，空格串是有长度的，而且可以不止一个空格 字串和主串：串中容易个数的连续字符组成的子序列称为该串的字串，相应地，包含字串的串称为主串 字串在主串中的位置就是字串的第一个字符在主串中的符号 串的比较串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。 ASCII——扩展——Unicode——UTF-8的关系了解一波? 如果我们要在c语言中比较两个串是否相等，必须是它们串的长度以及它们各自对应位置的字符都相等时，才算是相等,而对于两个不相等的串，怎么判定它们的大小呢? 给定两个串：s=“a1a2….an”，t=“b1b2b3…bn”，当满足以下条件之一时，s&lt;t. n&lt;m，且ai=bi(i=1，2…..,n) 例如当s=”hap”,t=”happy”就有s&lt;t 存在某个k≤min(m,n),使得ai=bi(i=1,2….k-1), ak&lt;bk 例如当s=”happen”,t=”happy”因为两串的前4个字母均相同，而两串第五个字母(k)值e&lt;y，所以s&lt;t 串的抽象数据类型1234567891011121314151617ADT 串(string)Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系Operation StrAssign(T,*chars)：生成一个其值等于字符串常量chars的串T StrCopy(T,S):串S存在，由串S复制得串T ClearStrng(S):串S存在，将串清空 StringEmpty(S):若串S为空，则返回true，否则返回false StrLength(S):返回串S的元素个数，即串的长度 StrCompare(S,T):若S&gt;T,返回值&gt;0，若S=T,返回0，若S&lt;T,返回值&lt;0 Concat(T,S1,S2):用T返回由S1和S2连接而成的新串 SubString(Sub,S,pos,len):串S存在，1≤pos≤StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0 Index(S,T,pos):串S和T存在，T是非空串，1≤pos≤StrLength(S)。若主串S中存在和串T值相同的字串，则返回它在主串中第pos个字符之后第一次出现的位置，否则返回0 Replace(S,T,V):串S,T和V存在，T是非空串。用V代替主串S中出现的所有与T相等的不重叠字串 StrInsert(S,pos,T):串S，T存在，1≤pos≤StrLength(S)+1,在串S的第pos个字符之前插入串T StrDelete(S,pos,len):串S存在，1≤pos≤StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串endADTs 我们来看一个操作Index的实现算法123456789101112131415161718192021/*T为非空串。若主串S中第pos个字符之后存在与T相等的子串则返回第一个这样的字串在S中的位置，否则返回0*/int Index(String S, String T, int pos)&#123; int n,m,i; String sub; if(pos &gt; 0) &#123; n = StrLength(S); m = StrLength(T); i = pos; while(i &lt;= n-m+1) &#123; SubString(sub,S,i,m);/*取主串第i个位置，长度与T相等子串给sub*/ if(StrCompare(sub,T) != 0) /*如果两串不相等*/ ++i; else return i;/*如果两串相等，则返回i值*/ &#125; &#125; return 0;/*若无子串与T相等，返回0*/&#125; 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义 既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书也会定义存储在数组的最后一个下标位置 有些是规定在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结，这个时候你要想知道串长度，遍历计算一下即可 朴素的模式匹配算法(BF算法)(Brute Force) 子串的的定位操作通常称为串的模糊匹配，应该算是串中最重要的操作之一1234567891011121314151617181920212223/*返回子串在主串S中第pos个字符之后的位置，若不存在则返回值为0。T非空，1≤pos≤StrLength(S)*/int Index(String S, String T, int pos)&#123; int i = pos; /*i用于主串S中当前位置下标，若pos不为1则从pos位置开始匹配*/ int j = 1; /*j用于子串T中当前位置下标值*/ while(i &lt;= S[0] &amp;&amp; j&lt;= T[0]) /*若i小于S长度且j小于T的长度时循环*/ &#123; if(S[i] == T[j]) /*两字母相等则继续*/ &#123; ++i; ++j; &#125; else /*指针后退重新开始匹配*/ &#123; i = i-j+2; /*i退回到上次匹配首位的下一位*/ j = 1; /*j退回到子串T的首位*/ &#125; &#125; if(j &gt; T[0]) return i-T[0]; else return 0;&#125; KMP模式匹配算法三位前辈发表一个模式匹配算法，可以大大避免重复遍历的情况，我们称之为克努特-莫里斯-普拉特算法，简称KMP算法 此处省略原理简介以及next数组的引入，自己看书，简述几个例子 abcdex———011111 abcabx———011123 ababaaaba———011234223 aaaaaaaab———012345678 KMP模式匹配算法实现12345678910111213141516171819/*通过计算返回子串T的next数组*/void get_next(String T,int *next)&#123; int i,j; i=1; j=0; next[1]=0; while(i&lt;T[0]) /*此处T[0]表示串T的长度*/ &#123; if(j==0 || T[i]==T[j]) /*T[i]表示后缀的单个字符，T[j]表示前缀的单个字符*/ &#123; ++i; ++j; next[i] = j; &#125; else j = next[j]; /*若字符不相同，则j值回溯*/ &#125;&#125; 123456789101112131415161718192021222324/*返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0.。T非空，1≤pos≤StrLength(S)*/int Index_KMP(String S, String T,int pos)&#123; int i = pos; /*i用于主串S当前位置下标值，若pos不为1，则从pos位置开始匹配*/ int j = 1; /*j用于子串T中当前位置下标值*/ int next[255]; /定义一next数组/ get_next(T,next);/对串T作分析，得到next数组/ while(i &lt;= S[0] &amp;&amp; k &lt;= T[0]) &#123; if(j==0 || S[i] == T[j]) /两字母相等则继续，与朴素算法增加了j=0判断/ &#123; ++i; ++j; &#125; else &#123; j = next[j]; /j退回合适的位置，i值不变/ &#125; &#125; if(j &gt; T[0]) return i-T[0]; else return 0;&#125; 绿色注释部分为相对于朴素匹配算法增加的代码，改动不算大，关键就是去掉了i值回溯的部分。 对于get_next函数来说，若T的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得index_KMP算法效率得到了提高 while循环的时间复杂度为O(n),因此，整个算法的时间复杂度为O(n+m)，相较于朴素算法的O((n-m+1)*m)l来说，是要好一些。 KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显 KMP模式匹配算法改进 对next函数进行了改良,假设取代的数组为nextval(String T,int *nextval),注意观察两者区别 1234567891011121314151617181920212223/*求模式串T的next函数修正值并存入数组nextval*/void get_nextval(String T,int *nextval)&#123; int i,j; i = 1; j = 0; nextval[1]=0; while(i &lt;T[0]) /*此处T[0]表示串T的长度*/ &#123; if(j==0 || T[i] == T[j]) /*T[i]表示后缀的单个字符，T[j]表示前缀的单个字符*/ &#123; ++i; ++j; /*以下则是区别之处*/ if(T[i] != T[j]) /*若当前字符与前缀字符不同*/ nextval[i] = j; /*则当前的j为nextval在i位置的值*/ else nextval[i] = nextval[j]; /*如果与前缀字符相同，则将前缀字符的nextval值赋值给nextval在i位置的值*/ &#125; else j = nextval[j]; /*若字符不相同，则j值回溯*/ &#125;&#125; 实际匹配算法，只需要将”get_next(T,next);”改为”get_nextval(t,next);”j即可，这里不再重复 nextval数组值推导 ababaaaba——011234223——010104210 aaaaaaaab——012345678——000000008 总结改进过的KMP算法，它是在计算出next值的同时,如果a位字符与它next值指向的b位字符相等，则a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己的a位的next的值。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年你见过的git操作]]></title>
    <url>%2F2019-05-11%2Fgit.html</url>
    <content type="text"><![CDATA[记录常见git操作跟面试题 到现在都还没更新的git操作~ Taylor Swift is back from reputation, and there is no snake but only butterflies now var ap = new APlayer({ element: document.getElementById("aplayer-xZmrZIky"), narrow: false, autoplay: false, showlrc: false, music: { title: "Me!!!", author: "Taylor Swift", url: "http://psu4sovbi.bkt.clouddn.com/Me.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/me.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 内容之后补充，还在整理,先听歌Σ(っ °Д °;)っ]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈与队列]]></title>
    <url>%2F2019-05-10%2FDataStructure-02.html</url>
    <content type="text"><![CDATA[数据结构与算法-栈与队列部分,栈与队列是数据结构重要思想之一，之后的抽象数据类型中诸多算法与方法会利用其特点 “花也好。星星也好。世间所有美丽的事物，都是为了比喻你而存在。” 介绍 前言： 栈(stack)是限定仅在表尾进行插入和删除操作的线性表 队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表 我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIFO结构。 首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底 栈的插入操作，叫作进栈，也称压栈,入栈 栈的删除操作，叫作出栈 最先进栈的元素，是不是就只能是最后出栈呢？ 举例:3个整型数字元素1，2，3依次进栈，会有哪些出栈次序呢？？？ 321，123，213，132，231 没有312 栈的抽象数据类型 对于栈来讲，理论上线性表的操作特性它都具备，由于它的特殊性，特别是插入和删除操作，我们改名为push和pop,英文直译的话是压和弹,我们一般叫进栈和出栈12345678910111213ADT 栈(stack)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系Operation InitStack(*S):初始化操作，建立一个空栈S DestroyStack(*S):若栈存在，则销毁它 ClearStack(*S):将栈清空 StackEmpty(S):若栈为空，返回true，否则返回false GetTop(S,*e):若栈存在且非空，用e返回S的栈顶元素 Push(*S,e):若栈存在，插入新元素e到栈S中并成为栈顶元素 Pop(*S,*e):删除栈S中栈顶元素，并用e返回其值 StackLength(S):返回栈S的元素个数endADT 同理：思考一下何时用S，S，e，e 栈的顺序存储结构及实现 若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。若栈存在一个元素时，top等于0，因此通常把空栈的判定条件定位top等于-1 栈的结构定义123456typedef int SElemType;/*SElemType类型根据实际情况而定，这里假设为int*/typedef struct&#123; SElemType data[MAXSIZE]; int top;/*用于栈顶指针*/&#125;SqStack; 进栈操作(push) 1234567891011/*插入元素e为新的栈顶元素*/Status Push(SqStack *S,SElemType e)&#123; if(S-&gt;top == MAXSIZE - 1) /*栈满*/ &#123; return ERROR; &#125; S-&gt;top++;/*栈顶指针增加一*/ S-&gt;data[S-&gt;top]=e;/*将新插入元素赋值给栈顶空闲*/ return OK;&#125; 出栈操作(pop) 123456789/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/Status Pop(SqStack *S,SElemType *e)&#123; if(S-&gt;top == -1) return ERROR; *e = S-&gt;data[S-&gt;top];/*将要删除的栈顶元素赋值给e*/ s-&gt;top--;/*栈顶指针减一*/ return OK;&#125; 两者没有涉及到任何循环语句，由此时间复杂度均是O(1) 两栈共享空间 栈的顺序存储缺陷：必须事先确定数组存储空间大小 不理解：栈1为空时，就是top1等于-1时，而当top2等于n时，即是栈2为空时；若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。 两个栈相遇之时，就是两个指针相差1之时，即top1 + 1== top2为栈满1234567/*两栈共享空间结构*/typedef struct&#123; SElemType data[MAXSIZE]; int top1;/*栈1栈顶指针*/ int top2;/*栈2栈顶指针*/&#125;SqDoubleStack; 对于两栈共享空间的push，除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber1234567891011/*插入元素e为新的栈顶元素*/Status Push(SqDoubleStack *S,SElemType e, int stackNumber)&#123; if(S-&gt;top1+1==S-&gt;top2)/*栈已满，不能再push新元素了*/ return ERROR; if(stackNumber==1)/*栈1有元素进栈*/ S-&gt;data[++S-&gt;top1]=e;/*若栈1则先top1+1后给数组元素赋值*/ else if(stackNumber==2)/*栈2有元素进栈*/ S-&gt;data[--S-&gt;top2]=e;/*若栈2则先top2-1后给数组元素赋值*/ return OK;&#125; 1234567891011121314151617/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/Status Pop(SqDoubleStack *S,SElemType *e,int stackNumber)&#123; if(stackNumber==1) &#123; if(S-&gt;top1==-1) return ERROR; *e=S-&gt;data[S-&gt;top1--]; &#125; else if(stackNumber==2) &#123; if(S-&gt;top2==MAXSIZE) return ERROR; *e=S-&gt;data[S-&gt;top2++]; &#125; return OK;&#125; 注意前提条件:两个具有相同数据类型的栈 栈的链式存储结构及实现 栈的链式存储结构简称为链栈 有栈顶在头部，那对于链栈来说，是不需要头结点的 对于链栈，基本不存在栈满的情况，除非内存已经没有可以使用的空间，对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL123456789101112/*链栈的结构代码*/typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStackPtr;/*ptr指pointer,即指针*/typedef struct LinkStack&#123; LinkStackPtr top; int count;&#125;LinkStack; 栈的链表存储结构——进栈操作 12345678910/*插入元素e为新的栈顶元素*/Status Push(LinkStack *S,SElemType e)&#123; LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data=e; s-&gt;next=S-&gt;top;/*把当前的栈顶元素赋值给新结点的直接后继*/ S-&gt;top=s;/*将新的结点s赋值给栈顶指针*/ S-&gt;count++; return OK;&#125; 栈的链式存储结构——出栈操作 12345678910111213/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR；*/Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if(StackEmpty(*S)) return ERROR; *e=S-&gt;top-&gt;data; p=S-&gt;top;/*将栈顶结点赋值给p*/ S-&gt;top=S-&gt;top-&gt;next;/*使得栈顶指针下移一位，指向后一结点*/ free(p); S-&gt;count--; return OK;&#125; 链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1) 栈的应用 递归之斐波那契数列(Fibonacci)12345678910111213141516/*迭代法实现*/int main()&#123; int i; int a[40]; a[0]=0; a[1]=1; printf("%d",a[0]); printf("%d",a[1]); for(i=2;i&lt;40;i++) &#123; a[i]=a[i-1]+a[i-2]; printf("%d",a[i]); &#125; return 0;&#125; 1234567891011121314/*斐波那契的递归函数*/int Fbi(int i)&#123; if(i&lt;2) return i == 0 ? 0 : 1; return Fbi(i-1)+Fbi(i-2);/*这里Fbi就是函数自己，它在调用自己*/&#125;int main()&#123; int i; for(int i = 0;i &lt; 40;i++) printf("%d",Fbi(i)); return 0;&#125; 我们把一个直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称作递归函数，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出 栈的应用之四则运算表达式求值逆波兰(Reverse Polish Notation,RPN):一种不需要括号的后缀表达法，这种后缀表示法，巧妙解决了程序实现四则运算的难题 例子：对于”9+(3-1)X3+10/2”如果用后缀表示法应该是”9 3 1 - 3 * + 10 2 / +” 计算规则:从左到右遍历表达式的每个数字和符号，遇到是数字就出栈，遇到是符号，就将处以栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最后获得最终结果 中缀表达式转后缀表达式规则:从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止 队列的定义 定义：队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表 队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头. 队列的抽象数据类型12345678910111213ADT 队列(Queue)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系Operation InitQueue(*Q):初始化操作，建立一个空队列Q DestroyQueue(*Q):若队列Q存在，则销毁它 ClearQueue(*Q):将队列Q清空 QueueEmpty(Q):若队列Q为空，返回true，否则返回false GetHead(Q,*e):若队列Q存在且非空，用e返回队列Q的队头元素 EnQueue(*Q,e):若队列Q存在，插入新元素e到队列Q中并成为队尾元素 DeQueue(*Q,*e):删除队列Q中队头元素，并用e返回其值 QueueLength(Q):返回队列Q的元素个数endADT 循环队列 队列顺序存储的不足 假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，数组下标为0的一端即是队头 所谓的入队列操作，就是在队尾插入一个元素，不需要移动任何元素，时间复杂度为O(1) 与栈不同的是，队列元素的出列在队头，即下标为0的地方，队列所有元素都得前移，那时间复杂度为O(n)，之后利用指针改善 这里的实现和线性表的顺序存储结构完全相同，不再详述 为了避免当只有一个元素时，队头跟队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个元素，这样当front等于rear时，此队列不是还剩一个元素，而是空队列 定义：我们把队列的这种头尾相接的顺序存储结构称为循环队列。我们刚才说，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？ 法一是设置一个标志变量flag,当front == rear，且flag=0时队列空，当flag=1时为队列满 法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。 重点讨论法二:由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，也可能相差整整一圈。若队列的最大尺寸为QueueSize，那么队列满的条件是:(rear+1)%QueueSize == front 队列长度: 当rear &gt; front时，队列长度就是rear-front。但当rear &lt; front时，队列长度分为两段，一段是Queue-front，另一段是0+rear，加在一起就是rear-front+Queue，由此通用的计算队列长度公式为: (rear-front+Queue)%Queue12345678typedef int QElemType;/*QElemType类型根据实际情况而定，这里假设为int*//*循环队列的顺序存储结构代码*/typedef struct&#123; QElemType data[MAXSIZE]; int front;/*头指针*/ int rear;/*尾指针，若队列不空，指向队列尾元素的下一个位置*/&#125;SqQueue 循环队列的初始化代码如下1234567/*初始化一个空队列Q*/Status InitQueue(SqQueue *Q)&#123; Q-&gt;front = 0; Q-&gt;rear = 0; return OK;&#125; 循环队列求队列长度代码如下：12345/*返回Q的元素个数，也就是队列的当前长度*/int QueueLength(SqQueue Q)&#123; return (Q.rear-Q.front+MAXSIZE)%MAXSIZE&#125; 循环队列的入队列操作代码123456789/*若队列未满，则插入元素e为Q新的队尾元素*/Status EnQueue(SqQueue *Q,QElemType e)&#123; if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)/*队列满的判断*/ return ERROR; Q-&gt;data[Q-&gt;rear]=e;/*将元素e赋值给队尾*/ Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/*rear指针向后移一位置,若到最后则转到数组头部*/ return OK;&#125; 循环队列的出队列操作代码123456789/*若队列不空，则删除Q中队头元素，用e返回其值*/Status DeQueue(SqQueue *Q,QElemType *e)&#123; if(Q-&gt;front = Q-&gt;rear)/*队列空的判断*/ return ERROR; *e=Q-&gt;data[Q-&gt;front]; Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;/*front指针向后移一个位置，若到最后则转到数组头部*/ return OK;&#125; 可以发现，单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临数组可能溢出的问题，所以我们需要研究一下不需要担心队列长度的链式存储结构。 队列的链式存储结构及实现 定义：队列的链式存储结构，其实就是线性表的单链表,只不过它只能尾进头出而已，我们把它简称为链队列。 重点：为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点 链队列的结构为： 1234567891011typedef int QElemType;/*QElemType类型根据实际情况而定，这里假设为int*/typedef struct QNode /*结点结构*/&#123; QElemType data; struct QNode *next;&#125;QNode,*QueuePtr;typedef struct /*队列的链表结构*/&#123; QueuePtr front,rear;/*队头，队尾指针*/&#125;LinkQueue 队列的链式存储结构——入队操作 123456789101112/*插入元素e为Q的新的队尾元素*/Status EnQueue(LinkQueue *Q,QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); if(!s) /*存储分配失败*/ exit(OVERFLOW); s-&gt;data=e; s-&gt;next=NULL; Q-&gt;rear-&gt;next=s;/*把拥有元素e新结点s赋值给原队尾结点的后继，把当前的s设置为队尾结点，rear指向s*/ Q-&gt;rear=s; return OK;&#125; 队列的链式存储结构——出队操作 1234567891011121314/*若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR*/Status DeQueue(LinkQueue *Q,QElemType *e)&#123; QueuePtr p; if(Q-&gt;front == Q-&gt;rear) return ERROR; p=Q-&gt;front-&gt;next;/*将欲删除的队头结点暂存给p*/ *e=p-&gt;data;/*将欲删除的队头结点的值赋值给e*/ Q-&gt;front-&gt;next=p-&gt;next;/*将原队头结点后继p-&gt;next赋值给头结点后继*/ if(Q-&gt;rear==p)/*若队头是队尾，则删除后将rear指向头结点*/ Q-&gt;rear=Q-&gt;front; free(p); return OK;&#125; 对于循环队列与链队列的比较，可以从两方面考虑 时间上，它们的基本操作都是常数时间，即O(1)，不过循环队列是事先申请好空间，使用期间不释放，而链队列每次申请和释放结点会存在一些时间开销，如果入队出队频繁，还是有细微差异的 空间上，循环队列必须有一个固定长度，所以就有存储元素个数和空间浪费的问题,空间上链队列更灵活 总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列长度，则用链队列. 总结回顾stack跟queue均可以用线性表的顺序存储结构来实现，但是都存在着顺序存储的一些弊端,由此它们各自有各自的技巧解决问题 对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化利用数组的空间。 对于队列来说，未来避免数组插入和删除时需要移动数据，则引入了循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)它们也可以通过链式存储结构来实现，实现原则跟线性表差不多。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <url>%2F2019-05-10%2FDataStructure-01.html</url>
    <content type="text"><![CDATA[数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习 链表练习 “即使只有一条路，也没有什么好困扰的，重要的是该怎么走那条路，对吧？” 线性表 (List)：零个或多个数据元素的有限序列 线性表元素的个数n（n≥0）定义为线性表的长度，当n=0时，称为空表。 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。 线性表的抽象数据类型12345678910111213ADT 线性表(List)Data 线性表的数据对象集合为&#123;a1，a2，....an&#125;每个元素类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an之外，每一个元素有且只有一个直接后继元素。数据元素之间是一对一的关系OperationInitList(*L):初始化操作，建立一个空的线性表LListEmpty(L):判断线性表是否为空表，若线性表为空，返回True，否则返回falseClearList(*L):将线性表清空GetElem(L,I,*e):将线性表L中的第i个位置元素返回给eLocateElem(L,e):在线性表L中查找与给定值e相等的元素如果查找成功，返回该元素在表中序号，表示成功，否则返回0，表示失败。ListInsert(*L,i,e):在线性表L的第i个位置插入新元素eListDelete(*L,i,*e):删除线性表L中第i个位置元素，并用e返回其值ListLength(L):返回线性表L的元素个数endADT 实现两个线性表集合A跟B的并集操作！1234567891011121314/*将所有的在线性表Lb但不在La的数据元素插入到La中*/void union(List *La,List Lb)&#123; int La_len,Lb_len,i; ElemType e; /*声明与La和Lb相同的数据元素e*/ La_len = ListLength(La); /*求线性表的长度*/ Lb_len = ListLength(Lb); for(i = 1;i &lt;= Lb_len;i++) &#123; GetElem(Lb,i,e);/*取Lb中第i个数据元素赋给e*/ if(!LocateElem(La,e,equal)) /*La中不存在和e相同数据元素*/ ListInsert(La, ++La_len, e); /*插入*/ &#125;&#125; 线性表的顺序存储结构 定义:指的是用一段地址连续的存储单元以此存储线性表的数据元素。 以下是线性表的顺序存储的结构代码 1234567#define MAXSIZE 20 /*存储空间的初始分配量 */typedef int ElemType； /*ElemType类型根据实际情况而定，这里假设为int*/typedef struct&#123; ElemType data[MAXSIZE]； /*数组存储数据元素，最大值为MAXSIZE*/ int length； /*线性表当前长度*/&#125;SqList； /*Sequence List*/ 数组长度和线性表长度的区别： 数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的 线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是会变化的 在任意时刻，线性表的长度应该小于等于数组的长度。 地址计算方法 线性表的第i个元素是要存储在数组下标为i-1的位置，即线性表从1开始 用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，由此分配的数组空间要大于等于当前线性表的长度 存储器中的每个存储单元都有自己的编号，这个编号称为地址 LOC(a(i+1))=LOC(ai)+c LOC(ai)=LOC(a1)+(i-1)*c 顺序存储结构的插入与删除 GetElem:将线性表L中的第i个位置元素值返回，就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。 123456789101112131415#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;/*Status（状态，身份，地位）是函数的类型，其值是函数结果状态代码，如OK*//*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*//*操作结果:用e返回L中第i个数据元素的值*/Status GetElem(SqList L,int i,ElemType *e)&#123; if(L.length==0 || i&lt;1 || i&gt;L.length) return ERROR; *e=L.data[i-1]; return OK;&#125; ==疑问：为什么是*e？== ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e 插入算法的思路： 如果插入位置不合理，抛出异常 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置 将要插入元素填入位置i处 表长加一123456789101112131415161718/*初始条件:顺序线性表L已存在,1≤i≤ListLength(L)*//*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if(L-&gt;length==MAXSIZE) /*顺序线性表已经满*/ return ERROR; if(i&lt;1 || i&gt;L-&gt;length+1) /*当i不在范围内时*/ return ERROR; if(i&lt;L-&gt;length) /*若插入数据位置不在表尾*/ &#123; for(k=L-&gt;length-1;k&gt;=i-1;k--) /*将要插入位置后数据元素向后移一位*/ L-&gt;data[k+1]=L-&gt;data[k]; &#125; L-&gt;data[i-1]=e;/*将新元素插入*/ L-&gt;length++; return OK;&#125; ListDelete 删除算法的思路: 如果删除位置不合理，抛出异常 取出删除元素 从删除元素位置开始遍历到最后一个元素，分别将它们都往前移动一个位置 表长减112345678910111213141516Status ListDelete(SqList *L,int i,ElemType *e)&#123; int k; if(L-&gt;length == 0) /*线性表为空*/ return ERROR; if(i&lt;1 || i&gt;L-&gt;length) /*删除位置不正确*/ return ERROR; *e=L-&gt;data[i-1]; if(i&lt;L-length) /*如果删除不是最后位置*/ &#123; for(k=i;k&lt;L-length;k++) /*将删除位置后继元素前移*/ L-data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; -线性表顺序存储结构的优缺点 优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间，可以快速地存取表中任一位置的元素 缺点：插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量，造成存储空间的“碎片” 线性表的链式存储结构 为了表示每个数据元素a1与其直接后继元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置).我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node) n个结点(ai的存储映像)链结成一个链表，即为线性表(a1，a2，…an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做==单链表== 我们把链表中第一个结点的存储位置叫做头指针，规定最后一个结点指针为“空”(通常用NULL或^符号表)；有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，头结点的指针域存储指向第一个结点的指针。头指针与头结点的异同 头指针 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 头指针具有标识作用，所以常用头指针冠以链表的名字 无论链表是否为空，头指针均不为空。头指针是链表的必要元素 头结点 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度) 有了头结点，对在第一元素结点前插入节点和删除第一结点，其操作与其它节点的操作就==统一==了 头结点不一定是链表必要元素 线性表链式存储结构代码描述 若线性表为空表，则头结点的指针域为“空” 单链表中，我们在C语言可用结构指针来描述 1234567/*线性表的单链表存储结构*/typedef struct Node&#123; ElemType data; struct Node *next;&#125; Node;typedef struct Node *LinkList;/*定义LinkList*/ 这波操作事后==了解==一下,翻一下结构体 结点由存放数据元素的数据域,存放后继结点地址的指针域组成 单链表的读取 获得链表第i个数据的算法思路： 声明一个结点p指向链表第一个结点，初始化j从1开始 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1 若到链表末尾p为空，则说明第i个元素不存在 否则查找成功，返回结点p的数据123456789101112131415161718/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*//*操作结果:用e返回L中的第i个数据元素的值*/Status GetElem(LinkList L,int i,ElemType *e)&#123; int j; LinkList p; /*声明一结点p*/ p = L-&gt;next; /*让p指向链表L的第一个结点*/ j = 1; /*j为计数器*/ while(p &amp;&amp; j&lt;i) /*p不为空或者计数器j还没有等于i时，循环继续*/ &#123; p = p-&gt;next; /*让p指向下一个结点*/ ++j； &#125; if( !p || j&gt;i ) return ERROR; /*第i个元素不存在*/ *e = p-&gt;data; /*取第i个元素的数据*/ return OK;&#125; 单链表的插入与删除 s-&gt;next=p-&gt;next; p-&gt;next=s这两句的顺序==不可交换==，自己想 单链表第i个数据插入结点的算法思路： 声明一结点p指向链表第一个结点，初始化j从1开始 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1 若到链表末尾p为空，则说明第i个元素不存在 否则查找成功，在系列中生成一个空结点s 将数据元素e赋值给s-&gt;data 单链表的插入标准语句s-&gt;next=p-&gt;next; p-&gt;next=s 返回成功123456789101112131415161718192021/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*//*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/Status ListInsert(LinkList *L,int i,ElemType e)&#123; int j; LinkList p,s; p = *L; j = 1; while( p &amp;&amp; j &lt; i) /*寻找第i个结点*/ &#123; p = p-&gt;next; ++j; &#125; if(!p || j &gt; i) return ERROR; /*第i个元素不存在*/ s =(LinkList)malloc(sizeof(Node));/*生成新结点(C标准函数)*/ s-&gt;data = e; s-&gt;next = p-&gt;next;/*将p的后继结点赋值给s的后继*/ p-&gt;next = s; /*将s赋值给p的后继*/ return OK;&#125; 单链表的删除实质：p-&gt;next=p-&gt;next-&gt;next 用q来取代p-&gt;next,就是q=p-&gt;next;p-&gt;next=q-&gt;next; 单链表第i个数据删除结点的算法思路: 声明一结点p指向链表的第一个节点，初始化j从1开始 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1 若到链表末尾p为空，则说明第i个元素不存在 否则查找成功，将欲删除的结点p-&gt;next赋值给q 单链表的标准删除语句p-&gt;next=q-&gt;next 将q结点中的数据赋值给e，作为返回 释放q结点 返回成功12345678910111213141516171819202122/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*//*操作结果:删除L的第i个数据元素，并用e返回其值，L的长度减1*/Status ListDelete(LinkList *L,int i, ElemType *e)&#123; int j; LinkList p,q; p = *L; j = 1; while(p-&gt;next &amp;&amp; j &lt; i) /*遍历寻找第i个元素*/ &#123; p = p-&gt;next; ++j; &#125; if(!(p-&gt;next) || j&gt;i) return ERROR;/*第i个元素不存在*/ q = p-&gt;next; p -&gt;next = q-&gt;next;/*将q的后继赋值给p的后继*/ *e=q-&gt;data;/*将q结点中的数据给e*/ free(q);/*让系统回收此结点，释放内存*/ return OK;&#125; 单链表的整表创建 创建单链表的过程就是一个动态生成链表的过程，即从”空表”的初始状态起，依次建立各元素结点，并逐个插入链表 单链表整表创建的算法思路: 声明一结点p和计数器变量i 初始化一空链表L 让L的头结点的指针指向NULL，即建立一个带头结点的单链表 循环:生成一新结点赋值给p；随机生成一数字赋值给p的数据域p-&gt;data;将p插入到头结点与前一新结点之间12345678910111213141516/*随机生成n个元素的值，建立带表头结点的单链线性表L(头插法)*/void CreateListHead(LinkList *L,int n)&#123; LinkList p; int i; srand(time(0)); /*初始化随机数种子*/ *L = ( LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; /*先建立一个带头结点的单链表*/ for(i=0;i&lt;n;i++) &#123; p = (LinkList)malloc(sizeof(Node));/*生成新结点*/ p-&gt;data = rand()%100+1; /*随机生成100以内的数字*/ p-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; /*插入到表头*/ &#125;&#125; 求问L,L,(L)的区别？ 如果要改变变量的值就用指针，不改变就用变量本身LinkList等同于Node ，所以L要加 函数rand()跟srand()1234567891011121314151617/*随机生成n个元素的值，建立带表头结点的单链线性表L(尾插法)*/void CreateListTail(LinkList *L,int n)&#123; LinkList p,r; int i; srand(time(0));/*初始化随机数种子*/ *L = (LinkList)malloc(sizeof(Node))；/*为整个线性表*/ r=*L;/*r为指向尾部的结点*/ for (i=0;i&lt;n;i++) &#123; p=(Node*)malloc(sizeof(Node));/*生成新结点*/ p-&gt;data=rand()%100+1;/*随机生成100以内的数字*/ r-&gt;next = p;/*将表尾终端结点的指针指向新结点*/ r=p; &#125; r-&gt;next=NULL;/*表示当前链表结束*/&#125; 单链表的整表删除 单链表整表删除的算法思路如下: 声明一结点p和q； 将第一个结点赋值给p 循环：将下一结点赋值给q；释放p；将q赋值给p。1234567891011121314/*初始条件：顺序线性表L已存在，操作结果：将L重置为空表*/Status ClearList(LinkList *L)&#123; LinkList p,q; p=(*L)-&gt;next; /*p指向第一个结点*/ while(p) &#123; q=p-&gt;next; free(p); p=q; &#125; (*L)-&gt;next=NULL;/*头结点指针域为空*/ return OK;&#125; 单链表结构与顺序存储结构优缺点 简单地对单链表结构和顺序存储结构做对比： 存储分配方式 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素 时间性能 查找：①顺序存储结构O(1)；②单链表O(n) 插入与删除：①顺序存储结构需要平均移动表长一半的元素，时间为O(n)； ②单链表在线出某位置的指针后，插入和删除时间仅为O(1) 空间性能 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制通过上面对比，我们可以得出一些经验性的结论 若线性表需要频繁查找，很少进行插入或删除时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。比如游戏开发，对于用户注册的个人信息，出来注册时插入数据外，绝大多数情况都是读取，所以应该考虑顺序存储结构。而游戏装备道具就用单链表结构。 当线性表元素个数变化很大或者不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，则用顺序存储结构效率会高很多。 静态链表 背景:数组代替指针描述单链表，首先让数组的元素由两个数据域组成，data和cur，也就是说，数组的每一个下标都对应一个data和一个cur.数据域data，用来存放数据元素，也就是通常我们要处理的数据，而游标cur相当于单链表的next指针，用于存放该元素后继在数组中的下标。我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。 为了方便插入数据，通常会把数组建立得大一些，以便有一些空闲空间插入不至于溢出 12345678/*线性表的静态链表存储结构*/#define MAXSIZE 1000 /*假设链表的最大长度是1000*/typedef struct&#123; ElemType data; int cur; /*游标(cursor),为0 时表示无指向*/&#125;Component,StaticLinkList[MAXSIZE]; 另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据，把未被使用的数组元素称为备用链表。 数组第一个元素，即下标为0的元素的cur存放备用链表的第一个结点的下标;而数组的最后一个元素的cur则存放第一个有数值的元素的下表，相当于单链表中的头结点，当整个链表为空时，则为012345678910/*将一维数组space中各分量链成一备用链表*//*space[0].cur为头指针，"0"表示空指针*/Status InitList(StaticLinkList space)&#123; int i; for(i=0;i&lt;MAXSIZE-1;i++) space[i].cur = i+1; space[MAXSIZE-1].cur = 0/*目前静态链表为空，最后一个元素的cur为0*/ return OK;&#125; 静态链表的插入操作 静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放 动态链表，结点的申请和释放分别借用malloc()和free()两个函数来实现，而静态链表操作的是数组，我们需要自己实现这两个函数 为了辨明数组中哪些分量未被使用，解决方法是将所有未被使用过的及被删除的分量用游标链成一个备用的链表，每当插入时，可以从备用链表上取得第一个结点作为待插入的新结点 12345678/*若备用空间链表为空，则返回分配的结点下标，否则为0*/int Malloc_SLL(StaticLinkList space)&#123; int i = space[0].cur;/*当前数组第一个元素的cur存的值就是要返回的第一个备用空闲的下标*/ if(space[0].cur) space[0].cur = space[i].cur/*由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用*/ return i;&#125; 需要找到接替者才能继续分配新的空闲分量 现在我们如果需要在乙丁之间插入丙，我们只需要让丙在7号备用位待着，把乙的cur改为7，再让丙的cur改为3即可123456789101112131415161718Status ListInsert(StaticLinkList L,int i, ElemType e)&#123; int j,k,l; k = MAX_SIZE - 1;/*注意k首先是最后一个元素的下标*/ if(i &lt; 1 || i &gt; ListLength(L) + 1) return ERROR; j = Malloc_SSL(L);/*获得空闲分量的下标*/ if(j) &#123; L[j].data = e; /*将数据赋值给此分量的data*/ for(l = 1;l &lt;= i-1;l++) /*找到第i个元素之前的位置*/ k = L[k].cur; L[j].cur = L[k].cur;/*把第i个元素之前的cur赋值给新元素的cur*/ L[k].cur = j;/*把新元素的下标赋值给第i个元素之前元素的cur*/ return OK； &#125; return ERROR；&#125; 静态链表的删除操作 和前面一样，删除元素时，原来是需要释放结点的函数free().现在我们也得自己实现它: 1234567891011121314/*删除在L中第i个数据元素e*/Status ListDelete(StaticLinkList L,int i)&#123; int j,k; if(i &lt; 1 || i &gt; LIstLength(L)) return ERROR; k = MAX_SIZE - 1; for(j = 1;j &lt;= i-1;j++) k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L,j); return OK;&#125; 而关于Free_SSL(L,j)123456/*将下列为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space,int k)&#123; space[k].cur = space[0].cur;/*把第一个元素cur赋值给要删除的分量cur*/ space[0].cur = k;/*把要删除的分量下标赋值给第一个元素的cur*/&#125; 当然，静态链表也有相应的其他操作的相关实现，比如代码中的ListLength123456789101112/*初始条件：静态链表L已存在，操作结果：返回L中的数据个数*/int ListLength(StaticLinkList L)&#123; int j = 0; int i = L[MAXSIZE-1].cur; while(i) &#123; i = L[i].cur; j++; &#125; return j;&#125; 回顾：sizeof()和strlen 静态链表优缺点 优点 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点 缺点 没有解决连续存储分配带来的表长难以确定的问题 失去了顺序存储结构随机存取的特性 总的来说，静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法。 循环链表 定义:将单链表中终端结点的指针端由空指针改为指向头结点就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list) 循环链表和单链表的主要差异在判断条件上：原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束 在单链表中，我们有了头结点，可以用O(1)的时间访问第一个结点，但对于要访问到最后一个结点，却需要O(n)时间，因为我们需要将单链表全部扫描一遍 如用O(1)的时间由链表指针访问到最后一个结点,则需改造一下循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便 终端结点用尾指针rear指示，则查找终端结点是O(1),而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂也为O(1) 举个程序的例子，要将两个循环链表合成一个表时，有了尾指针就非常简单1234p = rearA-&gt;next;/*保存A表的头结点*/rearA-&gt;next=rearB-&gt;next-&gt;next;/*将本是指向B表的第一个结点(不是头结点)赋值给rearA-&gt;next*/rearB-&gt;next=p;/*将原A表的头结点赋值给rearB-&gt;next*/free(p);/*释放p*/ 双向链表 定义：双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。1234567/*线性表的双向链表存储结构*/typedef struct DuLNode&#123; ElemType data; struct DuLNode *prior;/*直接前驱指针*/ struct DuLNode *next;/*直接后继指针*/&#125;DulNode,*DuLinkList; 既然单链表有循环链表，那么双向链表也可以是循环链表 p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next 双向链表的插入将结点s插入到结点p和p-&gt;next之间 顺序很重要，不能写反1234s-&gt;prior = p;/*将p赋值给s的前驱*/s-&gt;next = p-&gt;next;/*把p-&gt;next赋值给s的后继*/p-&gt;next-&gt;prior = s;/*把s赋值给p-&gt;next的前驱*/p-&gt;next = s;/*把s赋值给p的后继*/ 顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继 双向链表的删除123p-&gt;prior-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=p-&gt;prior;free(p); 多结合图形记忆 总结回顾 线性表 顺序存储结构 链式存储结构 单链表 静态链表 循环链表 双向链表]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构概论]]></title>
    <url>%2F2019-05-10%2FDataStructure-introduction.html</url>
    <content type="text"><![CDATA[数据结构与算法绪论,打算将当初的数据结构笔记搬上博客，主要参照《大话数据结构》，此处强烈推荐 摘要图存粹是为了美观，其次是为了推荐这首faded的remix，同一首歌不一样的感觉，在我看来，多了一种空灵的美感，强烈推荐，之后的摘要图估计也会是图文关系不大（￣︶￣）↗ var ap = new APlayer({ element: document.getElementById("aplayer-UeDmeAUE"), narrow: false, autoplay: true, showlrc: false, music: { title: "Faded (Restrung)", author: "Alan Walker", url: "http://psu4sovbi.bkt.clouddn.com/faded.mp3", pic: "http://psu4sovbi.bkt.clouddn.com/faded.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。 逻辑结构：数据对象中数据元素之间的相互关系 集合结构（平等） 线性结构（一对一） 树形结构（一对多） 图形结构（多对多） 物理结构：数据的逻辑结构在计算机中的存储方式 顺序结构 链式结构 算法（Algorithm）：对数据结构的运用 算法的特性 输入：算法具有零个或多个输入 输出：算法至少有一个或多个输出 有穷性：自动结束不会死循环 确定性：不会出现二义性 可行性：每一步都是可行的 算法设计要求 正确性 算法程序没有语法错误 算法程序对于合法的输入数据能够产生满足要求的输出结果 算法程序对于非法的输入数据能够算得出满足规格说明的结果 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果 可读性 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或者莫名其妙的结果 时间效率搞和存储量低 算法效率的度量方法 事后统计方法 事前分析估算方法 函数的渐近增长与时间复杂度 大O阶方法 用常数1取代运行时间中所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除与这个项相乘的常数，得到的结果就是大O阶。 常数阶 无论n为多少，这个常数为多少，我们都记作O（1），而不能是O（3）、O（12）等任何数字，这是初学者常常犯的错。可以理解为常数项为最高项，然后去除系数，则为1 线性阶 12345int i;for(i = 0; i &lt; n;i++)&#123; /*时间复杂度为O（1）的程序步骤序列*/&#125; 对数阶 123456int count = 1;while(count &lt; n)&#123; count = count * 2; /*时间复杂度为O（1）的程序步骤序列*/&#125; 由2^x^=n得x=log(2)n，所以这个循环的时间复杂度为O（logn） 平方阶12345678int i,j;for(i = 0; i &lt; n;i++)&#123; for(j = 0; j &lt; n;j++) &#123; /* 时间复杂度为O（1）的程序步骤序列*/ &#125;&#125; 12345678int i,j;for(i = 0;i &lt; n;i++)&#123; for(j = i;j &lt; n;j++) /*注意j = i而不是0*/ &#123; /*时间复杂度为O（1）的程序步骤序列*/ &#125;&#125; 总执行次数为：n+(n-1)+(n-2)+…+1= n^2^/2+n/2,因此这段代码的时间负责度为O(n^2^) 最坏情况与平均情况 通常，除非特殊指定，我们提到的运行时间都是最坏情况的运行时间 平均运行时间是所有情况中最有意义的，因为它是期望的云习惯时间，但是平均运行时间和难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。 一般在没有特殊说明的情况下，都是指最坏时间复杂度 算法空间复杂度]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[article]]></title>
    <url>%2F2019-05-08%2Farticle.html</url>
    <content type="text"><![CDATA[内容 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ var options = {"narrow":false,"autoplay":true,"showlrc":2,"mutex":true,"music":[{"title":"Viva la Vida","author":"Coldplay","url":"http://psu4sovbi.bkt.clouddn.com/Viva%20la%20Vida.mp3","pic":"http://psu4sovbi.bkt.clouddn.com/Viva.jpg"},{"title":"me!!!","author":"Taylor swift","pic":"http://psu4sovbi.bkt.clouddn.com/me.jpg","url":"http://psu4sovbi.bkt.clouddn.com/Me.mp3"},{"title":"奉献","author":"毛不易","pic":"http://psu4sovbi.bkt.clouddn.com/maomao.jpg","url":"http://psu4sovbi.bkt.clouddn.com/%E5%A5%89%E7%8C%AE.mp3"}]}; options.element = document.getElementById("aplayer-QFBEcbsW"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>表格</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019-05-08%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
