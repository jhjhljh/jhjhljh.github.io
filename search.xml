<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一首独特的Faded(remix)]]></title>
    <url>%2Fmusic%2F2019%2F06%2F05%2Fmusic00.html</url>
    <content type="text"><![CDATA[百听不厌fade系列，我觉得稳得不行 Fade 相信很多人都知道，只是一首特别火的 remix 音乐。 Faded 是基于这首曲子的一首音乐。原唱是个女声，这个版本感觉节奏律动都要更好一点。]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于四六级及拈算法--给易班技术服务部的你们]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%2F2019%2F05%2F26%2FE-class.html</url>
    <content type="text"><![CDATA[易班技术♂服务部，希望来年可以少一点♂，多一点♀ 天下无难事，只怕有心人，天下天易事，只怕粗心人！ ——袁枚It is dogged does it. The days of easy, but careless people. ——Yuan Mei var ap = new APlayer({ element: document.getElementById("aplayer-IqpkwcBw"), narrow: false, autoplay: true, showlrc: false, music: { title: "There's nothing holding me back (Acoustic)", author: "Shawn Mendes", url: "http://prc4nro7n.bkt.clouddn.com/There%27s%20nothing%20holding%20me%20back.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/19220562765374618.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 关于四六级考试技巧前言上学期其实说过四级的一些刷分技巧，但是正常也忘得差不多了:)，WDNMD 无论怎么样，我所言仅是蒙题技巧，英文日常优秀的人只要升级自己的词汇量即可，其中四级为4000，而六级为6000，但词汇量这种东西多多益善，而平心而论一般&gt;4000之后四六级基本可以水过，不过六级建议刷高分 这里附上词汇量测试链接：Click Me 英语高手请出门左转，或者右转 题型组成 写作 听力理解 短篇新闻 长对话 长听力篇章（六级为讲话/报道/讲座）⭐偏难 阅读理解 15选10 阅读匹配 仔细阅读（⭐重要） 翻译 刷分技巧听力理解一般而言，25个答案包括：6A+6B+6C+6D=24个选项然后+ABCD其中的任易一个，其中每五个选项中，普遍会出现ABCD 针对听力的蒙题方法只能适用于四级，少量适用于六级，而且比较佛，除非听不懂，不然不建议 听不懂说的就是你吧… 四级的听力且还行，但六级的听力我觉得不行 之前提及的重要一点：不要等到听力提问再选题，我们只能听到什么选什么 看到听力题之后，需要马上圈出选项中的异处（浏览ABCD四个选项，提取共同点，圈出异同点，这即是需要留意的地方，一般提及的时候就稳了，如果仍提及时间，最好标识上记号，那这个时候要根据提问来选题） 学会取舍放弃，不能在一棵树上挂死，对话两三个来回出一个题目选项，如果已经很久，那要往下看，在下一棵树上挂死（一个来回：一问一答） 听力中反复出现的词，高几率会答案选项 六级听力最难的题在于讲座题，长篇大论你听不到你想要的，这个时候最好打开耳朵听听得出个大意，重点在高频出现的词 阅读理解选词填空15选10，四六级难度相差很大，这道题若要精准命中，那就需要一定的词汇量积累，但对于懵题技巧，四六级都差不多，在于对主谓宾的划分，以及时态跟主被动的筛选，具体说法上个学期已经讲的很仔细了。只是六级多了很多长难句，所以这就是难点。 （切忌在这道题纠结太多时间，推荐有剩余时间再去纠结） 阅读匹配（送分题）无论四六级，这道题都是送人头的，不需要你读懂文章，你唯一需要做的仅仅是先看题目划题目特殊主谓宾，然后回去原文找即可，这道题只是考你的观察力。对你的语感能力不要求，走过路过，这题不要放过。 注意：同一段落可以多次出现在答案里，但基本不超过2次 阅读理解得阅读理解者得天下 四六级难度差异大，六级会增添一堆长难句，以及一堆陷阱 对于四级，仅需要跟高考英语一样，划主干回去文章找选项即可 对于六级，理解文意是必要的，六级阅读的选项将会出现一堆概述，这说明你从选项里找回原文，将会无从下手。 若选项中直接照搬原文，完全无增添，那样基本是陷阱，可以不考虑 写作及翻译写作龙头凤尾，这即是四六级写作的重点，字体跟字数也是重点，基本把握头尾，无出现乱涂乱划，分数不会差到哪里去，那么关于龙头凤尾怎么速成，那即是作文模板 题目类型（切记看好题目，偏题即死） 看图说话 对某句话进行议论 开放式写作 针对题目类型记忆文章 （之后会贴上一些文章模板） 模板类型 翻译翻译还是那句话：宁可直译，不可跳句，总会出现那么几句刁钻的话，那个时候追求最大相似度的翻译即可 祝语最后希望大家都能顺利过四六级，当然是没那么简单的，无论什么样的技巧，英语本身最主要在于词汇跟口语，两者不可丢。(:≡加油加油，多刷几次 拈算法关于之前 n进制的幂 约瑟夫斯–互砍算法 婚姻匹配算法 missing number 以上为部门例会所提及过的算法 可以见我的另一篇博客 Click Me 下面是之前提及到的拈算法 拈 (Nim)最有名的玩法​ 單堆遊戲是拈的遊戲中較簡單的一種。據說，拈的遊戲源自中國，經由被販賣到美洲的奴工外傳。所以這個小遊戲先在工人間流行，他們就地取材撿小石子來玩。後來流傳到上流人士，改以銅板在酒吧櫃檯上玩。最有名的玩法是將十二枚銅板分三列排成「三、四、五」的遊戲，如下圖： ​ 遊戲的規則很簡單：兩人輪流取銅板，每次需在某一列取一枚或一枚以上的銅板，但不能同時在兩列取銅板，最後將銅板拿光的人贏得此遊戲。（或是相反的情形：最後將銅板拿光的人輸。） ​ 讓我們先看二列的例子： 假設甲先取，乙後取，甲如何可取得勝利？ 我們先注意到，甲若欲取勝，就得避免將某一列完全取光，否則對方可全取剩下的一列，而拿到最後一枚銅板。 &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; 由 1~ 4，我們可以推得，甲若留下兩列枚數相同的銅板給乙，甲必可獲勝。反之乙若留下兩列枚數相同的銅板給甲，乙必可獲勝。 ​ 抓到兩列的訣竅之後，再來看看三列的情況： 假設甲先取，乙後取，甲如何可取得勝利？ &lt;由二列的情形得知，乙勝&gt; &lt;由二列的情形得知，乙勝&gt; &lt;由二列的情形得知，乙勝&gt; 由 1 ~ 3 可推得，若甲欲贏得勝利，就必需避免在留下的三列銅板中，有兩列的銅板數相同。 此外，甲取完之後三列的銅板數若分別剩下1, 2, 3，則甲勝。 &lt;甲勝&gt; (二三列相同) &lt;甲勝&gt; (一三列相同) &lt;甲勝&gt; &lt;甲勝&gt; (一二列相同) &lt;甲勝&gt; &lt;甲勝&gt; 多玩幾次之後，大家可以發現一開始若甲在第一列取二枚，可取得勝利。 &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; (一二列相同) &lt;甲勝&gt; &lt;甲勝&gt; (二三列相同) &lt;甲勝&gt; &lt;甲勝&gt; &lt;甲勝&gt; (一三列相同) &lt;甲勝&gt; 因此，一開始甲只要在第一列取2枚，就可以搶得先機而取得勝利。 一般法則與二進位​ 玩久了「三、四、五」的型態，很容易便知道勝利的關鍵是什麼，玩起來也沒什麼意思。所以可以將銅板的列數或每一列的銅板數改變，這樣要找出所有規律就不太容易了。 ​ 直到本世紀初，哈佛大學數學系副教授查理士．理昂納德．包頓 (Charles Leonard Bouton) 才利用數的二進位表示法，解出了這個遊戲的一般法則： ​ 對於任意列數，每列有任意枚數的銅板，致勝之道為何？包頓的方法很簡單。首先，將各列的銅板數化成二進位數，然後相加，但不進位。換句話說，就是 ​ 1 + 0 = 1​ 0 + 1 = 1​ 1 + 1 = 0​ 0 + 0 = 0 再看一個例子： 1 + 1 + 1 = (1 + 1) + 1 = 0 + 1 = 1 於是我們知道：偶數個1相加會得到0，奇數個1相加會得到1。 ​ 如果遊戲規則為：最後將銅板拿光的人贏得遊戲。各列的銅板數化成二進位數相加之後（不進位）的每一位數都是0的狀況為安全殘局；相反地，只要其中有任何一位數是1，就是不安全殘局。 例如「三、四、五」遊戲，一開始就是不安全殘局，先拿的人可以適當取二枚（第一列取2枚）而造成安全殘局。 一般情形之下，將不安全殘局轉變成安全殘局的方法常常不只一種，如下： ​ 為什麼安全殘局和不安全殘局可以利用上述的方法判定呢？這可以分成幾個部分來看： 若你留下上述所謂的安全殘局，即總和的每一位數都是0，由於不論對方取那一列的多少枚銅板，該列銅板數所對應的二進位數中，必定至少有一位數會由0變成1或者由1變成0，於是其總和的相對位數也會由0變成1。例如，{1,4,5}這個安全殘局，從第二列的4枚銅板中取走2枚，則 相反的，如果總和的某一位數是1，我們總有辦法在適當的列取走適當枚數的銅板，使得新總和的每一位數都是0。 首先，找出總和中所有是1的位數{n1,n2,…,nk}其中n1&lt;n2&lt;…&lt;nk；在之前提到的例子{ 14, 15, 18, 22 }中，{n1,n2}={ 1, 3}；也就是說，總和的第1位與第3位都是1。 找出一列其銅板數之（二進位表示法）第nk位數（也就是最左邊的一位，本例中是第3位）剛好是1；本例中，14（第一列）、15（第二列）、22（第三列）皆是。 接著改變該列二進位數中的所有ni位數值，亦即將0變為1，將1變為0。如此，我們會得到一個新數；以14（第一列）為例，14 = 1110，將其第1位與第3位改變，便得到1011 = 11枚銅板。 ​ 利用上面的方法，我們可以在該列中取走適當的銅板，使剩下的銅板數二進位總和的每一位數都是0；例如，在第一列取走14 – 11 = 3枚銅板。 ​ 反過來，若規定取走最後一枚銅板的人輸，也就是變成取完後的銅板數為0的人輸。之前的安全殘局現在變成了不安全殘局，而之前的不安全殘局也變成了安全殘局。所以若欲贏，就得讓取完後的二進位總和中至少有一位數是1。再來看看3, 4, 5的例子： ​ &lt;甲勝&gt; ​ 從以上的例子，你應該可以發現，前面幾步中，甲乙都可以留下自己的安全殘局，直到後來出現有某一列的銅板數大於1，而其他列都只剩一枚的情況。這時輪到甲來取，甲如何取就是勝負的關鍵：甲可以選擇將較多枚銅板的那一列拿光，或拿到只剩一枚。在這個例子中，甲選擇將該列拿到只剩一枚，因為這樣才能使剩下的列數為“奇數”，當然每一列均只有一枚銅板。顯而易見的是，以後一人取一列，到最後拿的一定是乙，於是甲必勝。 以上内容搬运自书籍《数学游戏》，拈游戏可以视作为单堆游戏的拓展包，而关于单堆游戏玩法多样，就不放在这里，之后会另开一篇]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>四六级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ppt的“代码”收录]]></title>
    <url>%2Fppt%2F2019%2F05%2F24%2Fppt-code.html</url>
    <content type="text"><![CDATA[连续两天折腾powerpoint后，才发现里面含有开发工具，对某些功能的实现提供了方便 “你不必生来勇敢、天赋过人，只要能投入勤奋，诚诚恳恳” 第一次听见这首歌，是在雨夜，配合着雨声，莫名被这首歌勾住了魂( •̀ ω •́ )✧ 抽奖代码实现关于抽奖关于抽奖的流程，主要是两种途径，一种是在ppt里加上此功能，第二种是使用第三方软件或者网页。 第一种实在是找不到什么比较贴切的主题，多半比较low，而且有一点就是如果自己设置的话略微麻烦 第二种的话会给人一种违和感，需要切出ppt的操作感，会给观众一种莫名的不舒适感，所以个人是比较排斥这种方法。 ⭐然后就有了第三种方法，就是通过代码动态生成 必备品powerpoint一般是不会将开发工具这一tab栏打开，需要用户自行设置 设置方法：文件-设置-开发工具√ 加载代码的ppt似乎需要将原格式（ppt或者pptx）更改为另存为适用宏定义的格式，比如pptm，详细可以见右键另存为，格式列表讲的很清楚了 代码1234567891011121314151617181920212223Public a, b As IntegerPrivate Sub Label1_Click()End SubPrivate Sub 结束抽奖_Click()b = 1Label1.Caption = aEnd SubPrivate Sub 开始抽奖_Click()b = 0Do While Truea = 1 + Int(Rnd() * 100)Label1.Caption = aDim Savetime As SingleSavetime = TimerWhile Timer &lt; Savetime + 0.005DoEventsWendIf b = 1 Then Exit DoEnd IfLoopEnd Sub 效果图（略）(≧︶≦))(￣▽￣ )ゞ]]></content>
      <categories>
        <category>ppt</category>
      </categories>
      <tags>
        <tag>powerpoint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechatVote脚本探讨]]></title>
    <url>%2F%E7%88%AC%E8%99%AB%2F2019%2F05%2F20%2FwechatVote.html</url>
    <content type="text"><![CDATA[对之前班级评比“被”微信刷票的事情耿耿于怀￣へ￣ 对wechatVote的兴趣，主要是来自班级里的“拉拉队投票事件”，希望wechat早点修复这块存在的漏洞，不然以后如果再遭遇这种不正当待遇，只能大家一起刷一起爽了……正所谓“谈，大门敞开；打奉陪到底”，最近真的痴迷于新闻联播这句话~(￣▽￣)” var ap = new APlayer({ element: document.getElementById("aplayer-IaqPKYAm"), narrow: false, autoplay: true, showlrc: false, music: { title: "Faded (Restrung)", author: "Alan Walker", url: "http://prc4nro7n.bkt.clouddn.com/faded.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/faded.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); WechatVote对于之前遭遇的微信拉票事件，闲来无事研究了一下，确实发现这个活动是可以刷票的，简要的记录一下写刷票脚本的过程。实际上，这种爬虫代码的实现永远都是小问题的，重要的是你要知道别人的页面的逻辑，如何去分析和爬取才是难点。 打开微信的投票页面，将屏幕往下拉会发现屏幕顶端显示为”本网页由XXX提供”，需要注意的是，这里的”XXX”并不是”mp.weixin.qq.com”，而是活动举办方的域名。也就是说，这个投票活动的程序是运行在S商城的服务器上面的。这里就涉及到微信公众平台OpenID的概念了，官方对OpenID的解释是：加密后的微信号，每个用户对每个公众号的OpenID是唯一的。也就是一个用户对一个公众号有一个唯一的OpenId。 投票的逻辑是用户在投票请求时，会在POST参数中提供用户的OpenID；S商城服务器在接收到投票的POST请求后，通过查询当前OpenID是否在4小时已经投过票，就可以阻止单一用户重复投票的行为了。 然而，这里面却存在一个很大的漏洞！ S商城只能判断OpenID是否出现了重复，但是却无法校验OpenID的有效性，因为它是无法调用微信服务器来对这个OpenID进行校验的。 那么我们只需要生成符合格式OpenId然后发送post请求就可以了。 但是一次投票也很奇怪，实际上是分两步完成的。第一次是一个get请求（图片中被打码的部分设计到隐私，只需要知道一次投票是通过两个请求来完成的就行了 当我看到第一个请求的名字的时候，我以为是这次请求就完成了，但当使用爬虫访问这个接口时，并不能使得票数增加。仔细观察后发现是有另外一个请求。 这个请求的path很奇怪，是一串乱码，而且每次不一样。只触发了第一个请求之后没有再进行其余的操作，这时我就能我就能确定，一次投票是通过第一个请求得到一些随机生成的参数，然后再第二次请求带上这些参数来保证第二次请求的合法性，这样来完成一次投票过程。所以第一个请求的页面中一定有地方调用了第二个请求。这个时候查看源代码时发现在页面中有一串这样的代码 当在页面中发现乱码的时候，往往是代码被加密了 其中有两个参数是第二个请求的path，可以看出这串乱码是和第二个请求有关联的，而那一串颜文字是对js代码的加密。虽然我们看不懂这串乱码是什么意思，但我们可以按分号（；）将这串乱码格式化之后直接在chrome控制台中跑，发现这串颜文字代码的效果就是执行第二个请求。（这个地方应该是可以还原代码的，有知道的可以讲解一下） 总结到这里基本上就算做完了，剩下的就是代码实现，总的来说，就是访问第一个请求，用正则在页面中爬取参数，将参数作为第二个请求的path进行对第二个请求的访问。当然还有ip代理，访问的随机的时间间隔，最好能动态模拟不同的设备，即修改User-Agent这些常见问题就不做说明，如果对这些有什么问题可以发邮件。 总的来说，使用python进行代码实现并没有多大的难度，难度在于一步步的分析，掌握网站的逻辑，并不断的尝试。这点只有多做才有效果。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197import randomimport reimport stringimport timefrom bs4 import BeautifulSoupimport requestsclass Ip_List: """ ip代理池 """ def __init__(self): self.ip_list = [] self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36' &#125; self.proxy = &#123; "http":"60.191.201.38:45461" &#125; def get_ip_list(self): """ 从网站爬取ip_list :return: """ for page in range(1, 20): url = "http://www.xicidaili.com/nn/" + str(page) web_data = requests.get(url=url, headers=self.headers,proxies = self.proxy) print(web_data) soup = BeautifulSoup(web_data.text, "lxml") ips = soup.find_all('tr') print(ips) for i in range(2, len(ips)): ip_info = ips[i] print(ip_info) tds = ip_info.find_all('td') self.ip_list.append(( tds[5].text,tds[1].text + ":" + tds[2].text)) return self.ip_list def get_random_ip(self): """ :return: 1.http还是https 2.ip """ random_one = random.choice(self.ip_list) return random_one[0].lower(), random_one[1]class Vote: def __init__(self): self.activityId = self.playerId = self.number = self.activityName = self.isGift = self.success_url = self.vote_url = @staticmethod def random_sleep_time(digits_length): """ 随机睡眠 :param digits_length: :return: """ digits_char = string.digits need_sleep_time = '' for i in range(digits_length): need_sleep_time += random.choice(digits_char) return int(need_sleep_time) + 2 def get_open_id(self): def getRandomString(id_length): charSeq = string.ascii_letters + string.digits randString = '' for i in range(id_length): randString += random.choice(charSeq) return randString return getRandomString(16) + "-" + getRandomString(11) def success(self, open_id, ip_t): """ 访问第一个页面，得到参数 :param open_id: open_id :param ip_t: ip状态和ip地址 :return: 返回得到的两个钩子参数 """ url = self.success_url proxy = &#123; ip_t[0]: ip_t[1] &#125; params = &#123; "activityId": self.activityId, "openId": open_id, "playerId": self.playerId, "number": self.number, "activityName": self.activityName, "isGift": self.isGift &#125; headers = &#123; # "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", # "Accept-Encoding": "gzip, deflate", # "Accept-Language": "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7", # "Connection": "keep-alive", # "Cookie": "JSESSIONID=BEDA66485B52B1FB4C916C39499EA081", # "Upgrade-Insecure-Requests": "1", "User-Agent": "Mozilla/5.0 (Linux; U; zh-cn; GT-S5660 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 MicroMessenger" &#125; # params = parse.urlencode(params) # print(params) r = requests.get(url=url, params=params, headers=headers, proxies=proxy) html = r.text # soup = BeautifulSoup(html,"html.parser") # 正则找出埋的钩子参数 pattern1 = re.compile(r'var _0sdfad="(.*?)"', re.MULTILINE | re.DOTALL) pattern2 = re.compile(r'var _0ees88="(.*?)"', re.MULTILINE | re.DOTALL) index1 = re.search(pattern1, html) index2 = re.search(pattern2, html) res1 = index1.group().replace(r'var _0sdfad="', "").replace('"', '') res2 = index2.group().replace(r'var _0ees88="', "").replace('"', '') # print(soup) return res1, res2 def vote_real(self, open_id, ip_t): index1, index2 = self.success(open_id, ip_t) url = self.vote_url +"/"+ index2 + "/" + index1 proxy = &#123; ip_t[0]: ip_t[1] &#125; params = &#123; "activityId": self.activityId, "openId": open_id, "playerId": self.playerId &#125; headers = &#123; # "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", # "Accept-Encoding": "gzip, deflate", # "Accept-Language": "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7", # "Connection": "keep-alive", # "Cookie": "JSESSIONID=BEDA66485B52B1FB4C916C39499EA081", # "Upgrade-Insecure-Requests": "1", "User-Agent": "Mozilla/5.0 (Linux; U; zh-cn; GT-S5660 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 MicroMessenger" &#125; r = requests.post(url=url, params=params, headers=headers, proxies=proxy) print(r) def do(self, ip_t): open_id = self.get_open_id() self.vote_real(open_id, ip_t)class FileWriter(object): def writer(self, text): with open('ip_list.txt', 'a', encoding='utf-8') as f: f.write(text + '\n')if __name__ == "__main__": ipList = Ip_List() ipList.get_ip_list() vote = Vote() file_writer = FileWriter() success_count, error_count = 0, 0 ip_useful_list = [] for i in range(5): try: ip_t = ipList.get_random_ip() print(ip_t) vote.do(ip_t=ip_t) random_wait_time = vote.random_sleep_time(1) time.sleep(random_wait_time) except Exception: error_count += 1 print("error_count: ",error_count) else: print("success_count: ",success_count) success_count += 1 if ip_useful_list.count(ip_t)==0: ip_useful_list.append(ip_t) print("---") for ip_t in ip_useful_list: file_writer.writer(ip_t[0]+" "+ip_t[1])]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>刷票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《宠物坟场》--观影有感]]></title>
    <url>%2F%E8%A7%82%E5%BD%B1%E6%9C%89%E6%84%9F%2F2019%2F05%2F18%2Fmovie-01.html</url>
    <content type="text"><![CDATA[期待了很久的《宠物坟场》终于在考完概率论后补完，借此利用博客记录一波电影感想 一部让人在观影后对猫产生“反感”的电影 既然是微恐怖片，那先来首惊悚配乐先，而网易云这类曲子生成外链也基本没有版权分享障碍，那就不借助aplayer插件来配置背景音乐了，也懒得上传到七牛(￣y▽￣)╭ Ohohoho….. 关于去年大火的《IT》说到恐怖片，一定少不了斯蒂芬·金，提到他那就不得不提到去年改编自其原小说的一度引起烂番茄9.0的高分恐怖片《IT》，没错，是IT，小丑惊魂（今年将会推出续作，所谓大咖云集，想必可以在这部大作见识到）。作为题外话，我个人倒是对小丑惊魂不是很有feel，整体给我一种美剧《怪奇物语》的感觉，但是毕竟是电影，讲述故事的程度不如美剧丰满，所以我也不是很能懂老外对这类电影的审美要求。虽然观影下来也不赖就是了，今年IT2出炉后估计又会引出一波狂潮……大概吧 小丑惊魂第二篇的预告片 看完会觉得绝佳有木有，不得不提19年真是大片云集的一年，撇去妇联4不说，恐怖片这一类型今年简直疯狂输出，而且题材都是让人看得心痒痒的。 下面贴出19年我比较期待的恐怖片 寂静之地 宠物坟场 污秽的房间 遗孀秘闻（友谊永固） 鬼眨眼 她 网诱惊魂 爬行 我们 亮光 爬行 哭泣女人的诅咒 在黑暗中讲述的恐怖的故事 安娜贝尔3：回家 小丑回魂2 仲夏夜惊魂 贞子 电影观感 电影中的主角(误)——起死回生的猫，满满的萌点有木有 又是一部看完让人“万能钥匙”的电影，不过随着阅历的增长，倒是觉得这类结局也没什么。19年的宠物坟场作为翻拍，导演又自己增加恐怖要素，比如脊骨扭曲的女主姐姐跟车祸毁去半边脸的学生，这两个倒是确实瘆人，但是跟剧情不是很沾边，姐姐那边的剧情倒还行，但是学生的穿插还是有点莫名其妙的，最后搞得整部电影前面趋于平淡（虽然平淡，但是剧情还是挺有看点的），电影转折点莫过于就在于女儿被猫所引导车祸死（在我看来就是如此，━┳━ ━┳━），这一段的长镜头先点个赞先，还是给边吃外卖边看电影的我一定震撼感的，惊呆了呀！ 最后真的想打死男主的冲动，以为是残血反杀的烂作，但是竟然大家都入了宠物坟场，那就给个好评吧~ 那接下来还是好好期待今年第二部改编自斯蒂芬·金小说的恐怖片《小丑惊魂2》吧 电影资源这里给上电影的资源，#号后面为提取码，welcome to Pet Sematary https://pan.baidu.com/s/1zY3oTAIRNwu8HdkQo13sfA#w125]]></content>
      <categories>
        <category>观影有感</category>
      </categories>
      <tags>
        <tag>恐怖片</tag>
        <tag>猫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多想在平庸的生活拥抱你]]></title>
    <url>%2F%E5%90%B9%E6%B0%B4%2F2019%2F05%2F15%2Fbbforfun-1.html</url>
    <content type="text"><![CDATA[“时间无言 如此这般 直到看见平凡才是唯一的答案 ——————记与师弟谈心的一日” var ap = new APlayer({ element: document.getElementById("aplayer-jgOLosIU"), narrow: false, autoplay: false, showlrc: false, music: { title: "平凡之路", author: "华晨宇", url: "http://prc4nro7n.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/109951163911444882.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); “我想用半年彻底放空自己，什么都不想” 来自师弟的感谢文 “学长，真的谢谢你这段时间的帮助和关心，结果还是有点小遗憾，但是还是要再道声谢谢” 诸多师弟中，这位师弟是我比较希望能够转成功的18级新生，虽说失败在所难免，但是似乎对转专业这条路有所误解，作为大一新生，本身对毕业出路本就了解甚少，今天道出来的丧气话愣是让我想到了那个早年那天那时刻–我鼓起勇气尝试去转专业 那年转专业的那些事转专业是否是就业计算机的唯一出路呢？ 关于这个问题，其实谁心中都有所答案，都会说出像：“就业跟你的专业无关，看个人能力”，这句话愣是动摇了不少要转专业的新生们，但作为一个大一新生，对这类话语的理解又能是多少呢？多半会认为是自我安慰罢了，没错，这也是我当初的真实写照，当初我打算无论成败都尝试看看咯，我的大一，并不会像这位师弟那般充满着对转专业的憧憬，相反，我是时刻抱着转专业失败的心情，告诉自己：“未来的道路你能走多远，从你高考失利的那一年开始就已经决定了”，我否认了自己，但却不打算屈服于自己，所以大一那年抽空把C语言给入门了一波，借着在部门所学的片面知识打算冲一波工作室。 随着转专业资格名单公布时间的推进，心里越是波折，辗转反侧，难以入眠，焦虑，害怕，恐惧，紧张…… 可是我又能怎么办？这种事情避免不了…… 随着时间推移，就越发否认自己的能力。所以我决定好：转专业必定不是就业的唯一出路，我要在资格公布之前规划好另一个平行时空的我的学习计划：综合即是在学好环境本科的前提下深造计算机，即使对环境的热爱为0，也不能耽误自己的本科学习，因为这就是这一个平行时空的你应该遭受的待遇，你只能如此…… 随着规划的全面，自己的心也渐渐稳定下来，虽然对转专业的期待并不少，但至少不会把它当成大学四年的唯一稻草了，我开始做二手准备：学习C语言准备转专业考试的同时，准备工作室面试考核，学习web开发。 当天平趋近于平衡的时候，人们的心也会明明平缓下来，对自己的否认程度也会降低，对未来不会特别迷茫 终于那一天到了。 紧张兮兮点开官网，下载转专业考试资格表，一行一行仔仔细细生怕错过自己的名字，前面十六位究竟有无我的名字，1.2.3….10.11.12.13.14.15!!! 明明还没有开始转专业考试，只是一个名单，我就乐得笑不出声，因为点开的那一瞬间已经做好各种失败的想法了，是另一个平行时空的绝望？堕落？或是按照二手准备那样好好安排自己？ 另一个平行时空的自己另一个平行时空的自己时隔一年出现了，这位师弟的所言所行即是当年的我脑子所想的画面 “我开始相信命运会有上限，这一次我真的疲倦了，我不想再做一个充满危机感和焦虑感的大学生了” 这句话很扎心，是堕落感跟赤裸裸的绝望，可想而知，师弟也经历过同样的波折，辗转反侧，难以入眠，焦虑，害怕，恐惧，紧张……而且经历过这些后经历的惨痛的失败，惨痛痛在一年之久的准备，痛在自责，痛在开始怨天尤人，表面上能笑着说：“谢谢师兄，我之后会继续努力的”，但是心理上的刺痛，其实我也模拟过，所以很心疼他，一言一行很想让我多在平庸的生活多多关怀安慰，但是这种时候最重要的还是自己的自我排解。 看到他真的仿佛看到自己本人，或许转专业顺利成功的我没多大资格去安慰他，但是至少可以提供当初自己二手准备所铺好的路，加油吧，小师弟，也献给另一个平行时空的自己。 多想在平庸的生活拥抱你 var ap = new APlayer({ element: document.getElementById("aplayer-rHRxpiyq"), narrow: false, autoplay: false, showlrc: false, music: { title: "多想在平庸的生活拥抱你", author: "隔壁老樊", url: "http://prc4nro7n.bkt.clouddn.com/%E5%A4%9A%E6%83%B3%E5%9C%A8%E5%B9%B3%E5%BA%B8%E7%9A%84%E7%94%9F%E6%B4%BB%E6%8B%A5%E6%8A%B1%E4%BD%A0.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/109951163911444882.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 仅以此曲希望师弟早日摆脱阴霾，成为不平凡的自己]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode（持续更新）]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F13%2Fleetcode-01.html</url>
    <content type="text"><![CDATA[收录一些见到的比较耐人寻味的leetcode上的算法题(⓿_⓿) (●’◡’●) 希望一周至少更新两次 按照算法题类型会逐步更新 var ap = new APlayer({ element: document.getElementById("aplayer-qHoqbior"), narrow: false, autoplay: false, showlrc: false, music: { title: "Viva la Vida", author: "Coldplay", url: "http://prc4nro7n.bkt.clouddn.com/Viva%20la%20Vida.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/Viva.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); n的幂问题LeetCode 第 231 号问题：2 的幂题目描述给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 123输入: 1输出: true解释: 20 = 1 示例 2: 123输入: 16输出: true解释: 24 = 16 示例 3: 12输入: 218输出: false 题目解析首先，先来分析一下 2 的次方数的二进制写法： 仔细观察，可以看出 2 的次方数都只有一个 1 ，剩下的都是 0 。根据这个特点，只需要每次判断最低位是否为 1 ，然后向右移位，最后统计 1 的个数即可判断是否是 2 的次方数。 代码很简单： 1234567891011class Solution &#123;public: bool isPowerOfTwo(int n) &#123; int cnt = 0; while (n &gt; 0) &#123; cnt += (n &amp; 1); n &gt;&gt;= 1; &#125; return cnt == 1; &#125; &#125;; 该题还有一种巧妙的解法。再观察上面的表格，如果一个数是 2 的次方数的话，那么它的二进数必然是最高位为1，其它都为 0 ，那么如果此时我们减 1 的话，则最高位会降一位，其余为 0 的位现在都为变为 1，那么我们把两数相与，就会得到 0。 比如 2 的 3 次方为 8，二进制位 1000 ，那么 8 - 1 = 7，其中 7 的二进制位 0111。 图片描述 代码实现利用这个性质，只需一行代码就可以搞定。 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return (n &gt; 0) &amp;&amp; (!(n &amp; (n - 1))); &#125; &#125;; LeetCode 第 326 号问题：3 的幂题目描述给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 12输入: 27输出: true 示例 2: 12输入: 0输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 题目解析正常的思路是不停地去除以 3，看最后的迭代商是否为 1。这种思路的代码使用到了循环，逼格不够高。 这里取巧的方法 用到了数论的知识：3 的幂次的质因子只有 3。 题目要求输入的是 int 类型，正数范围是 0 - 231，在此范围中允许的最大的 3 的次方数为 319 = 1162261467 ，那么只要看这个数能否被 n 整除即可。 动画描述待补充 代码实现12345class Solution &#123; public boolean isPowerOfThree(int n) &#123; return n &gt; 0 &amp;&amp; 1162261467 % n == 0; &#125;&#125; LeetCode 第 342 号问题：4 的幂题目描述给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。 示例 1: 12输入: 16输出: true 示例 2: 12输入: 5输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 题目解析这道题最直接的方法就是不停的去除以 4 ，看最终结果是否为 1 ，参见代码如下： 12345678class Solution &#123; public boolean isPowerOfFour(int num) &#123; while ( (num != 0) &amp;&amp; (num % 4 == 0)) &#123; num /= 4; &#125; return num == 1; &#125;&#125; 不过这段代码使用了 循环 ，逼格不够高。 对于一个整数而言，如果这个数是 4 的幂次方，那它必定也是 2 的幂次方。 我们先将 2 的幂次方列出来找一下其中哪些数是 4 的幂次方。 十进制 二进制 2 10 4 100 （1 在第 3 位） 8 1000 16 10000（1 在第 5 位） 32 100000 64 1000000（1 在第 7 位） 128 10000000 256 100000000（1 在第 9 位） 512 1000000000 1024 10000000000（1 在第 11 位） 找一下规律： 4 的幂次方的数的二进制表示 1 的位置都是在奇数位。 之前在小吴的文章中判断一个是是否是 2 的幂次方数使用的是位运算 n &amp; ( n - 1 )。同样的，这里依旧可以使用位运算：将这个数与特殊的数做位运算。 这个特殊的数有如下特点： 足够大，但不能超过 32 位，即最大为 1111111111111111111111111111111（ 31 个 1） 它的二进制表示中奇数位为 1 ，偶数位为 0 符合这两个条件的二进制数是： 11010101010101010101010101010101 如果用一个 4 的幂次方数和它做与运算，得到的还是 4 的幂次方数。 将这个二进制数转换成 16 进制表示：0x55555555 。有没有感觉逼格更高点。。。 图片描述 代码实现12345678910111213class Solution &#123; public boolean isPowerOfFour(int num) &#123; if (num &lt;= 0) return false; //先判断是否是 2 的幂 if ((num &amp; num - 1) != 0) return false; //如果与运算之后是本身则是 4 的幂 if ((num &amp; 0x55555555) == num) return true; return false; &#125;&#125; 有趣的动态规划题目 稳定婚姻算法（Stable Matching Problem）问题的引出有N男N女，每个人都按照他对异性的喜欢程度排名。现在需要写出一个算法安排这N个男的、N个女的结婚，要求两个人的婚姻应该是稳定的。 何为稳定？ 有两对夫妻M1 F2，M2 F1。M1心目中更喜欢F1，但是他和F2结婚了，M2心目中更喜欢F2，但是命运（￣︶￣）↗ 却让他和F1结婚了，显然这样的婚姻是不稳定的，随时都可能发生M1和F1私奔或者M2和F2私奔的情况。所以在做出匹配选择的时候（也就是结婚的时候），我们需要做出稳定的选择，以防这种情况的发生。 算法步骤算法中采用了男生主动追求女孩的形式。 第一轮，每个男人都选择自己名单上排在首位的女人，并向她表白。 这种时候会出现两种情况： （1）该女士还没有被男生追求过，则该女士接受该男生的请求。 （2）若该女生已经接受过其他男生的追求，那么该女生会将该男士与她的现任男友进行比较，若更喜欢她的男友，那么拒绝这个人的追求，否则，抛弃其男友(´▽`ʃ♡ƪ)…… 第一轮结束后，有些男人已经有女朋友了，有些男人仍然是单身。 在第二轮追女行动中，每个单身男都从所有还没拒绝过他的女孩中选出自己最中意的那一个，并向她表白，不管她现在是否是单身。这种时候还是会遇到上面所说的两种情况，还是同样的解决方案。直到所有人都不在是单身。 算法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define NUM 4#define NIL -1int GetPositionFromLaday(int ladayArray[][NUM], int laday, int man)&#123; for(int i=0; i&lt;NUM; i++) if(ladayArray[laday][i] == man) return i; return NIL;&#125;void ChoosePartener(stack&lt;int&gt;&amp; manStack, int manPos, int manArray[][NUM], int ladayArray[][NUM], int manPerfer[], int manStartPos[], int ladayNow[])&#123; //选择自己名单上排在首位的女人 int perferLaday = manArray[manPos][manStartPos[manPos]]; //如果该女孩没有接受过表白，则接受该男孩的表白 if(ladayNow[perferLaday] == NIL) &#123; ladayNow[perferLaday] = manPos; manPerfer[manPos] = perferLaday; &#125; //如果已经有人向她表白，则判断其现在拥有的有没有现在追求的好 else &#123; int oldPos = GetPositionFromLaday(ladayArray, perferLaday, ladayNow[perferLaday]); int newPos = GetPositionFromLaday(ladayArray, perferLaday, manPos); if(oldPos &lt; newPos) &#123; manStartPos[manPos]++;//说明该女生更喜欢现在拥有的，选心目中第二位 //加入单身行列 manStack.push(manPos); &#125; else //换男友 &#123; //被甩的男友恢复自由身份 manStartPos[ladayNow[perferLaday]]++; //加入单身行列 manStack.push(ladayNow[perferLaday]); //将追求的男士改为现任男友 ladayNow[perferLaday] = manPos; manPerfer[manPos] = perferLaday; &#125; &#125;&#125;int main()&#123; int manArray[NUM][NUM] =&#123;&#123;2,3,1,0&#125;,&#123;2,1,3,0&#125;,&#123;0,2,3,1&#125;,&#123;1,3,2,0&#125;&#125;; int ladayArray[NUM][NUM] = &#123;&#123;0,3,2,1&#125;,&#123;0,1,2,3&#125;,&#123;0,2,3,1&#125;,&#123;1,0,3,2&#125;&#125;;&#125; 算法总结祝大家早日找到自己的婚姻匹配 杨辉三角(Pascal Triangle) 前些天看了杨永乐老师的视频，其中提到了杨辉三角，有兴趣的可以去看看。 问题的引出(●’◡’●) 老师所提到的生活中的弹珠抽奖模型 杨辉三角应该是大家很早就接触到的一个数学知识，它有很多有趣的性质： 每个数字等于上一行的左右两个数字之和，即 C(n+1,i) = C(n,i) + C(n,i-1) 每行数字左右对称，由 1 开始逐渐变大 第 n 行的数字有 n 项 第 n 行的第 m 个数和第 n - m + 1 个数相等 ，为组合数性质之一 ( a + b )n的展开式中的各项系数依次对应杨辉三角的第 ( n + 1 ) 行中的每一项 。。。 题目来源于 LeetCode 上第 118 号问题：杨辉三角。题目难度为 Easy，目前通过率为 61.8% 。 题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题目解析 这道题目在各大高校的习题中经常出现。 对于本题而言，利用性质 1 ：每一行的首个和结尾一个数字都是 1，从第三行开始，中间的每个数字都是上一行的左右两个数字之和。 代码实现1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (numRows &lt; 1) return result; for (int i = 0; i &lt; numRows; ++i) &#123; //扩容 List&lt;Integer&gt; list = Arrays.asList(new Integer[i+1]); list.set(0, 1); list.set(i, 1); for (int j = 1; j &lt; i; ++j) &#123; //等于上一行的左右两个数字之和 list.set(j, result.get(i-1).get(j-1) + result.get(i-1).get(j)); &#125; result.add(list); &#125; return result; &#125;&#125; 杨辉三角II题目来源于 LeetCode 上第 119 号问题：杨辉三角II。题目难度为 Easy，目前通过率为 55.5% 。 题目描述给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 题目解析这道题目的难点与思考点在于题目有额外限制条件，程序只能使用 O(k) 的额外空间，因此无法通过累加的方式将每一行都输出打印。 这里依旧使用杨辉三角的规律，很隐藏的规律：对于杨辉三角的同一行，第 ( i + 1) 项是第 i 项的( k - i ) /( i + 1 ) 倍。 比如： 第 k 索引行的第 0 项：1 第 k 索引行的第 1 项：1 * k 第 k 索引行的第 2 项：1 k ( k - 1) / 2 第 k 索引行的第 3 项：[1 k ( k - 1) / 2 ] * ( k - 2 ) / 3 代码实现1234567891011class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(rowIndex + 1); long index = 1; for (int i = 0; i &lt;= rowIndex; i++) &#123; res.add((int) index); index = index * ( rowIndex - i ) / ( i + 1 ); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈回家安顿的一周]]></title>
    <url>%2F%E5%90%B9%E6%B0%B4%2F2019%2F05%2F11%2Fbbforfun.html</url>
    <content type="text"><![CDATA[既然生活多有不堪，那就更应花费时间在自己喜欢的事情上面，随之拥抱生活 “其实孤独并不可怕，只要你学会了自己与自己对话。” var ap = new APlayer({ element: document.getElementById("aplayer-lpyosjvc"), narrow: false, autoplay: false, showlrc: false, music: { title: "长子", author: "杨坤", url: "http://prc4nro7n.bkt.clouddn.com/%E9%95%BF%E5%AD%90.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/ykun.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 花费三天时间搭建自己的博客曾经自己老是觉得也感叹自己对于编程类学习的无力感，这种感觉不知道什么时候飘离了自己，但是有个朋友说到心坎上了：“做自己喜欢的事情，从而带动兴趣，挖掘自己的潜能”，这几天脱离了学习的功课，而去尝试全心投入于搭建博客，这是之前自己一直想做却又不敢去做的事情。事实证明，我做到了，在参考hexo的next主题，而且也“云拜访”各家博主的博客，最终找到了自己希望的风格，一直不喜欢文章的我，在搭建完博客完，居然会沉迷于写文，像是现在也不想停手，然而明天就要离去前往大学继续上课了~╯︿╰ 关于概率论这位大叔哇，谁能想到，假期刚结束的周末就要开始概率论考试了，接下来要回去好好刷题练习了，争取&gt;=90,然后再继续研究完成easySale的项目吧，希望能够从这个项目找到自己的属性。 拥抱生活吧愿你即使生活在泥泞之中，也不要放弃仰望星空，有一天，你将如浩瀚星河，在平凡的生活里发出最耀眼的光。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构课程设计-平衡二叉树]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F11%2FDataStructureAssign.html</url>
    <content type="text"><![CDATA[当年的数据结构课程设计-平衡二叉树，想了想还是放上来吧，当初费尽心思，怕是如今都已看不懂了இ௰இ “那片笑声让我想起我的那些花儿，在我生命每个角落静静为我开着~” var ap = new APlayer({ element: document.getElementById("aplayer-EVXOpkVF"), narrow: false, autoplay: false, showlrc: false, music: { title: "那些花儿", author: "吴青峰", url: "http://prc4nro7n.bkt.clouddn.com/%E9%82%A3%E4%BA%9B%E8%8A%B1%E5%84%BF+%E6%9C%9B%E6%98%A5%E9%A3%8E.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 需求分析“平衡二叉树操作演示”系统是利用平衡二叉树实现一个动态查找表的三种基本功能：查找、插入和删除，同时，还能拓展实现新的功能：初始化、求深度、求最大最小结点、先中后序及层序遍历、打印平衡二叉树、判空、合并和分裂平衡二叉树等功能，并通过括号表示方法和凹入表表示方法将动态查找表和平衡二叉树的详细信息展示给用户知晓；同时，还要求系统界面设计简洁明了、用户操作简单方便，提高系统实用性与运行效率。 说明：使用anyview或者codeblock运行；输入值形式是数字，无论对功能的选则还是对数据的录入，都是以数字的形式进行输入，如若超过规定范围程序将直接结束。 概要设计接口设计Status InitBBST(BBSTree &amp;T) 初始化平衡二叉树 void DestroyBBSTree(BBSTree &amp;T) 销毁平衡二叉树 Status BBSTreeEmpty(BBSTree T) 判空平衡二叉树 void PrintTree(BBSTree &amp;T) 打印平衡二叉树 void CreateBBST(BBSTree &amp;T) 输入结点数目，动态创建一棵平衡二叉树 Status InsertAVL(BBSTree &amp;T, RcdType e, Status &amp;taller) 平衡二叉树的插入操作，将e插入到T中 插入成功返回TRUE，失败返回FALSE Status DeleteAVL(BBSTree &amp;t, RcdType e, Status &amp;shorter) 平衡二叉树的删除操作，将e从T中删除 删除成功返回TRUE，失败返回FALSE void L_Rotate(BBSTree &amp;p) 对p左旋操作 void R_Rotate(BBSTree &amp;p) 对p右旋操作 void LeftBalance(BBSTree &amp;T) 对T左平衡操作 void RightBalance(BBSTree &amp;T) 对T右平衡操作 Status PreOrder(BBSTree T) 递归先序遍历输出 Status InOrder(BBSTree T) 递归中序遍历输出 Status PostOrder(BBSTree T) 递归后序遍历输出 void PreOrderTravese_I(BBSTree T) 非递归先序遍历输出 void InOrderTraverse_I(BBSTree T) 非递归中序遍历输出 void LastOrderTravese_I(BBSTree T) 非递归后序遍历输出 void LevelOrederTraverse_Print(BBSTree T) 层次遍历输出 BBSTree SearchBBST(BBSTree T,RcdType key) 二叉平衡树查找的递归实现 BBSTree SearchBBST_I(BBSTree T,RcdType e) 二叉平衡树查找的非递归实现 BBSTree FindMin(BBSTree T) 寻找平衡二叉树最小元素所在结点地址 BBSTree FindMax(BBSTree T) 寻找平衡二叉树最大元素所在结点地址 int BBSTreeDepth(BBSTree T) 求平衡二叉树的深度 void MergeBBST(BBSTree &amp;T1, BBSTree T2) 合并两棵平衡二叉树 void SpiltBBST(BBSTree T, RcdType key, BBSTree &amp;T1, BBSTree &amp;T2) 按关键值key分裂T成两棵二叉树 主程序与各接口函数的调用int main(){ ​ BBSTree T = NULL; ​ int choice; ​ printf(“================================================\n”); ​ printf(“*平衡二叉树*\n”); ​ printf(“================================================\n”); ​ printf(“ 1：创建一棵平衡二叉树\n”); ​ printf(“ 2：平衡二叉树的插入\n”); ​ printf(“ 3：平衡二叉树的删除\n”); ​ printf(“ 4：平衡二叉树的查找\n”); ​ printf(“ 5：平衡二叉树的遍历\n”); ​ printf(“ 6：求平衡二叉树的深度\n”); ​ printf(“ 7：合并平衡二叉树\n”); ​ printf(“ 8：分裂平衡二叉树\n”); ​ printf(“ 请根据上述说明选择所需操作1-8: “); ​ scanf(“%d”,&amp;choice); ​ while(choice &gt; 0 &amp;&amp; choice &lt;= 3) ​ { ​ if(choice == 1) ​ { ​ if(OK == InitBBST(T)); ​ CreateBBST(T); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T,0); ​ printf(“\n”); ​ PrintTree1(T); ​ printf(“\n请重新输入你的选择: “); ​ scanf(“%d”,&amp;choice); ​ } ​ if(choice == 2) ​ { ​ int num; ​ RcdType s; ​ Status taller = TRUE; ​ printf(“请输入要插入的元素：”); ​ scanf(“%d”,&amp;num); ​ s = num; ​ InsertAVL(T,s,taller); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T,0); ​ PrintTree1(T); ​ printf(“\n请重新输入你的选择: “); ​ scanf(“%d”,&amp;choice); ​ } ​ if(choice == 3){ ​ RcdType e; ​ Status shorter = TRUE; ​ printf(“请输入要删除的元素：”); ​ scanf(“%d”,&amp;e); ​ DeleteAVL(T, e, shorter); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T,0); ​ PrintTree1(T); ​ printf(“\n请重新输入你的选择: “); ​ scanf(“%d”,&amp;choice); ​ } ​ } ​ if(choice == 4){ ​ int choice2; ​ printf(“40:递归查找\n41:非递归查找\n”); ​ printf(“42:查找最小元素\n43:查找最大元素\n”); ​ printf(“请选择一种查找方式：”); ​ scanf(“%d”,&amp;choice2); ​ switch(choice2){ ​ case 40: ​ int key1; ​ printf(“\n请输入欲查找元素：”); ​ scanf(“%d”,&amp;key1); ​ if(NULL != SearchBBST(T,key1)) ​ printf(“\n查找成功”); ​ else ​ printf(“\n查找失败”); ​ break; ​ case 41: ​ int key2; ​ printf(“\n请输入欲查找元素：”); ​ scanf(“%d”,&amp;key2); ​ if(NULL != SearchBBST_I(T,key2)) ​ printf(“\n查找成功”); ​ else ​ printf(“\n查找失败”); ​ break; ​ case 42: ​ BBSTree T1 = FindMin(T); ​ if(T1) ​ printf(“\n查找成功，且为%d”,T1-&gt;data); ​ break; ​ // case 43: ​ BBSTree T2 = FindMax(T); ​ if(T2) ​ printf(“\n查找成功，且为%d”,T2-&gt;data); ​ break; ​ } ​ } ​ if(choice == 5){ ​ int choice2; ​ printf(“50:递归先序\n51:递归中序\n52:递归后序\n”); ​ printf(“53:非递归先序\n54:非递归中序\n55:非递归后序\n56:层次遍历\n”); ​ printf(“请选择一种遍历方式：”); ​ scanf(“%d”,&amp;choice2); ​ switch(choice2){ ​ case 50: ​ printf(“\n递归先序遍历输出：”); ​ PreOrder(T); break; ​ case 51: ​ printf(“\n递归中序遍历输出：”); ​ InOrder(T); break; ​ case 52: ​ printf(“\n递归后序遍历输出：”); ​ PostOrder(T);break; ​ case 53: ​ printf(“\n非递归先序遍历输出：”); ​ PreOrderTravese_I(T);break; ​ case 54: ​ printf(“\n非递归中序遍历输出：”); ​ InOrderTraverse_I(T); break; ​ case 55: ​ printf(“\n非递归后序遍历输出：”); ​ LastOrderTravese_I(T); ​ printf(“\n”); break; ​ case 56: ​ printf(“\n层次遍历输出：”); ​ LevelOrederTraverse_Print(T); ​ printf(“\n”); break; ​ } ​ } ​ if(choice == 6) ​ { ​ printf(“深度为：%d\n”,BBSTreeDepth(T)); ​ } ​ if(choice == 7) ​ { ​ BBSTree T1,T2,T3; ​ if(OK == (InitBBST(T1))&amp;&amp;(InitBBST(T2))&amp;&amp;(InitBBST(T))) ​ { ​ printf(“请构造第一棵子树\n”); ​ CreateBBST(T1); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T1,0); ​ PrintTree1(T1); ​ printf(“\n”); ​ printf(“请构造第二棵子树\n”); ​ CreateBBST(T2); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T2,0); ​ PrintTree1(T2); ​ printf(“\n”); ​ printf(“合并后为：”); ​ MergeBBST(T,T1); ​ MergeBBST(T,T2); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T,0); ​ PrintTree1(T); ​ } ​ } ​ if(choice == 8) ​ { ​ BBSTree T1,T2; ​ if(OK == (InitBBST(T1))&amp;&amp;(InitBBST(T2))) ​ { ​ int x; ​ printf(“请输入要分裂时作为参照的关键字：”); ​ scanf(“%d”,&amp;x); ​ SpiltBBST(T,x,T1,T2); ​ printf(“分裂后的第一棵树为：”); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T1,0); ​ PrintTree1(T1); ​ printf(“\n”); ​ printf(“分裂后的第二棵树为：”); ​ printf(“平衡二叉树表示为：\n”); ​ PrintTree(T2,0); ​ PrintTree1(T2); ​ } ​ } } 详细设计 以下高能代码段，慎看吧(╯‵□′)╯炸弹！•••*～● 重要变量和存储结构定义#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define LH +1 //左高 #define EH 0 //等高 #define RH -1 //右高 #define FALSE 0 #define TRUE 1 #define OK 1 #define ERROR 0 #define OVERFLOW -1 typedef int Status; typedef int RcdType; /平衡二叉树结构体/ typedef struct BBSTNode { ​ RcdType data; ​ int bf; ​ struct BBSTNode lchild, rchild; }*BBSTree; 算法设计/初始化平衡二叉树/Status InitBBST(BBSTree &amp;T){ ​ T = NULL; ​ return OK; } /销毁平衡二叉树/void DestroyBBSTree(BBSTree &amp;T){ ​ if(T != NULL){ ​ DestroyBBSTree(T -&gt; lchild); ​ DestroyBBSTree(T -&gt; rchild); ​ free(T); ​ T = NULL; ​ } } /判空平衡二叉树/Status BBSTreeEmpty(BBSTree T){ ​ if(!T){ ​ return TRUE; ​ } ​ else{ ​ return FALSE; ​ } } /创建一棵平衡二叉树/void CreateBBST(BBSTree &amp;T) { ​ RcdType e; ​ int num; ​ Status taller = TRUE; ​ printf(“\n请输入平衡二叉树的结点个数:”); ​ scanf(“%d”, &amp;num); ​ getchar(); ​ printf(“请顺序输入元素(按’回车键’结束):”); ​ for (int i = 0; i &lt; num; i++) { ​ scanf(“%d”, &amp;e); ​ InsertAVL(T, e, taller); ​ } } /输出平衡二叉树/void PrintTree(BBSTree T, int nLayer){ ​ if(T == NULL) { ​ return; ​ } ​ PrintTree(T-&gt;rchild, nLayer + 4); ​ for(int i = 0; i &lt; nLayer; i++) { ​ printf(“ “); ​ } ​ printf(“%d\n”, T-&gt;data); ​ PrintTree(T-&gt;lchild, nLayer + 4); } /输出平衡二叉树/void PrintTree1(BBSTree &amp;T) { ​ if(T) ​ { ​ printf(“%d”,T-&gt;data); ​ if(T-&gt;lchild || T-&gt;rchild) ​ { ​ printf(“(“); ​ PrintTree1(T-&gt;lchild); ​ if(T-&gt;rchild) ​ printf(“,”); ​ PrintTree1(T-&gt;rchild); ​ printf(“)”); ​ } ​ } } /平衡二叉树的插入操作//若平衡二叉树中不存在值为e的结点，则插入到T/ Status InsertAVL(BBSTree &amp;T, RcdType e, Status &amp;taller){ ​ if(NULL==T){ ​ T = (BBSTree)malloc(sizeof(BBSTNode)); ​ T-&gt;data = e; ​ T-&gt;bf = EH; ​ T-&gt;lchild = NULL; ​ T-&gt;rchild = NULL; ​ }else if(e==T-&gt;data){ //书中已存在和e相等的结点 ​ taller = FALSE; return FALSE; ​ }else if(edata){ ​ if(FALSE==InsertAVL(T-&gt;lchild, e, taller)) return FALSE; ​ if(TRUE==taller){ ​ switch(T-&gt;bf){ ​ case LH: LeftBalance(T); taller = FALSE; break; ​ case EH: T-&gt;bf = LH; taller = TRUE; break; ​ case RH: T-&gt;bf = EH; taller = FALSE; break; ​ } ​ } ​ }else{ ​ if(FALSE==InsertAVL(T-&gt;rchild, e, taller)) return FALSE; ​ if(TRUE==taller){ ​ switch(T-&gt;bf){ ​ case LH: T-&gt;bf = EH; taller = FALSE; break; ​ case EH: T-&gt;bf = RH; taller = TRUE; break; ​ case RH: RightBalance(T); taller = FALSE; break; ​ } ​ } ​ } ​ return TRUE; } /左旋调整（右旋与之类似，不再列出）/void L_Rotate(BBSTree &amp;p) { ​ BBSTree rc = p -&gt; rchild; ​ p -&gt; rchild = rc -&gt; lchild; ​ rc -&gt; lchild = p; ​ p = rc; } /左平衡处理操作（右平衡与之类似，不再列出）/void LeftBalance(BBSTree &amp;T){ ​ BBSTree lc, rd; ​ lc = T-&gt;lchild; ​ switch(lc-&gt;bf){ ​ case LH: ​ T-&gt;bf = lc-&gt;bf = EH; R_Rotate(T); break; ​ case RH: ​ rd = lc-&gt;rchild; ​ switch(rd-&gt;bf){ ​ case LH: T-&gt;bf = RH; lc-&gt;bf = EH; break; ​ case EH: T-&gt;bf = lc-&gt;bf = EH; break; ​ case RH: T-&gt;bf = EH; lc-&gt;bf = LH; break; ​ } ​ rd-&gt;bf = EH; ​ L_Rotate(T-&gt;lchild); ​ R_Rotate(T); ​ break; ​ } } /平衡二叉树的删除操作//平衡二叉树中存在值为key的结点，则删除/Status DeleteAVL(BBSTree &amp;T, RcdType e, Status &amp;shorter){ //当被删结点是有两个孩子，且其前驱结点是左孩子时，tag=1 ​ int tag = 0; ​ if(T == NULL){ ​ return FALSE; //如果不存在元素，返回失败 ​ }else if(e==T-&gt;data){ ​ BBSTNode *q = NULL; ​ //如果该结点只有一个孩子，则将自子树取代该结点 ​ if(T-&gt;lchild == NULL){ ​ q = T; ​ T = T-&gt;rchild; ​ free(q); ​ shorter = TRUE; ​ } ​ else if(T-&gt;rchild == NULL){ ​ q = T; ​ T = T-&gt;lchild; ​ free(q); ​ shorter = TRUE; ​ } ​ //如果被删结点有两个孩子，则找到结点的前驱结点， ​ //并将前驱结点的值赋给该结点，然后删除前驱结点 ​ else{ ​ q = T-&gt;lchild; ​ while(q-&gt;rchild){ ​ q = q-&gt;rchild; ​ } ​ T-&gt;data = q-&gt;data; ​ if(T-&gt;lchild-&gt;data==q-&gt;data){ ​ tag = 1; ​ } ​ DeleteAVL(T-&gt;lchild, q-&gt;data, shorter); ​ if(tag==1){ ​ BBSTree r = T-&gt;rchild; ​ if(NULL==r) T-&gt;bf = 0; ​ else{ ​ switch(r-&gt;bf){ ​ case EH: T-&gt;bf=-1;break; ​ default: RightBalance(T);break; ​ } ​ } ​ } ​ } ​ }else if(edata){ //左子树中继续查找 ​ if(!DeleteAVL(T-&gt;lchild, e, shorter)){ ​ return FALSE; ​ } ​ //删除完结点之后，调整结点的平衡因子 ​ if(shorter&amp;&amp;(tag==0)) { ​ switch(T-&gt;bf){ ​ case LH: ​ T-&gt;bf = EH; ​ shorter = TRUE; ​ break; ​ case EH: ​ T-&gt;bf = RH; ​ shorter = FALSE; ​ break; ​ //如果本来就是右子树较高，删除之后就不平衡，需要做右平衡操作 ​ case RH: ​ RightBalance(T); //右平衡处理 ​ if(T-&gt;rchild-&gt;bf == EH) ​ shorter = FALSE; ​ else ​ shorter = TRUE; ​ break; ​ } ​ } ​ }else if(e&gt;T-&gt;data){ //右子树中继续查找 ​ if(!DeleteAVL(T-&gt;rchild, e, shorter)){ ​ return FALSE; ​ } ​ //删除完结点之后，调整结点的平衡因子 ​ if(shorter&amp;&amp;(tag==0)) { ​ switch(T-&gt;bf){ ​ case LH: ​ LeftBalance(T); //左平衡处理 ​ if(T-&gt;lchild-&gt;bf == EH) ​ shorter = FALSE; ​ else ​ shorter = TRUE; ​ break; ​ case EH: ​ T-&gt;bf = LH; ​ shorter = FALSE; ​ break; ​ case RH: ​ T-&gt;bf = EH; ​ shorter = TRUE; ​ break; ​ } ​ } ​ if(tag==1){ ​ int depthLeft = BBSTreeDepth(T-&gt;lchild); ​ int depthRight = BBSTreeDepth(T-&gt;rchild); ​ T-&gt;bf = depthLeft - depthRight; ​ } ​ } ​ return TRUE; } /二叉平衡树查找的递归实现//若平衡二叉树中存在值为key的结点，则返回该结点指针，否则返回NULL/ BBSTree SearchBBST(BBSTree T,RcdType key) { ​ if(NULL == T) ​ return NULL; ​ if(T -&gt; data == key) ​ return T; ​ if(T -&gt; data &gt; key) ​ return SearchBBST(T -&gt; lchild,key); ​ return SearchBBST(T -&gt; rchild,key); } /二叉平衡树查找的非递归实现//若平衡二叉树中存在值为key的结点，则返回该结点指针，否则返回NULL*/ BBSTree SearchBBST_I(BBSTree T,RcdType e) { ​ while(T) { ​ if(e &lt; T -&gt; data) ​ T = T -&gt; lchild; ​ else if(e &gt; T -&gt; data) ​ T = T -&gt; rchild; ​ else ​ return T; ​ } ​ return NULL; } /寻找平衡二叉树最小元素所在结点地址（寻找最大元素类似不再列出）/BBSTree FindMin(BBSTree T){ ​ if(T) ​ while(T -&gt; lchild) ​ T = T -&gt; lchild; ​ return T; } /递归先序遍历（中序、后序遍历类似不再列出）/Status PreOrder(BBSTree T){ ​ if(T) { ​ printf(“%5d”,T-&gt;data); ​ PreOrder(T -&gt; lchild); ​ PreOrder(T -&gt; rchild); ​ } ​ return OK; } /非递归中序遍历/void InOrderTraverse_I(BBSTree T){ ​ LStack S; ​ InitStack_LS(S); ​ BBSTree p = NULL; ​ p = GoFarLeft(T, S); ​ while(p!=NULL){ ​ printf(“%d “,p-&gt;data); ​ if(p-&gt;rchild!=NULL){ ​ p = GoFarLeft(p-&gt;rchild, S); ​ } ​ else if(StackEmpty_LS(S)!=TRUE) Pop_LS(S, p); ​ else p = NULL; ​ } } /非递归先序遍历/void PreOrderTravese_I(BBSTree T){ ​ LStack S; ​ InitStack_LS(S); ​ BBSTree p; ​ p = VisitFarLeft(T, S); //先将左边的数据先序读取 ​ while(p!=NULL){ ​ if(p-&gt;rchild!=NULL) //如果最左下结点的右子树不为空 ​ p = VisitFarLeft(p-&gt;rchild, S); //执行遍历该结点的左子树 ​ else if(StackEmpty_LS(S)!=TRUE) Pop_LS(S,p); //如果S不为空栈，出栈 ​ else p = NULL; //如果为空栈，p赋予空 ​ } } /非递归后序遍历/void LastOrderTravese_I(BBSTree root){ ​ BBSTree p = root; ​ BBSTree stack[30]; ​ int num=0; ​ BBSTree have_visited = NULL; ​ while(NULL!=p||num&gt;0){ ​ while(NULL!=p){ ​ stack[num++]=p; ​ p=p-&gt;lchild; ​ } ​ p=stack[num-1]; ​ if(NULL==p-&gt;rchild||have_visited==p-&gt;rchild){ ​ printf(“%d “,p-&gt;data); ​ num–; ​ have_visited=p; ​ p=NULL; ​ } ​ else{ ​ p=p-&gt;rchild; ​ } ​ } ​ printf(“\n”); } /层次遍历/void LevelOrederTraverse_Print(BBSTree T){ ​ if(T==NULL){ ​ printf(“这是一棵空树!”); ​ } ​ if(T!=NULL){ ​ LQueue Q; ​ InitQueue_LQ(Q); ​ BBSTree p = T; ​ printf(“%d “,p-&gt;data); EnQueue_LQ(Q,p);//首先访问根结点，并将根节点入队 ​ while(DeQueue_LQ(Q,p)){ //队非空时重复操作，出队 ​ if(p-&gt;lchild!=NULL){ //访问左孩子并入队 ​ printf(“%d “, p-&gt;lchild-&gt;data); ​ EnQueue_LQ(Q, p-&gt;lchild); ​ } ​ if(p-&gt;rchild!=NULL){ //访问右孩子并入队 ​ printf(“%d “, p-&gt;rchild-&gt;data); ​ EnQueue_LQ(Q, p-&gt;rchild); ​ } ​ } ​ } } /求平衡二叉树的深度/int BBSTreeDepth(BBSTree T){ ​ int depthLeft, depthRight; ​ if(NULL==T) return 0; ​ else{ ​ depthLeft = BBSTreeDepth(T-&gt;lchild); ​ depthRight = BBSTreeDepth(T-&gt;rchild); ​ return 1+(depthLeft &gt; depthRight ? depthLeft : depthRight); ​ } } /合并平衡二叉树/void MergeBBST(BBSTree &amp;T1, BBSTree T2) { ​ Status taller = FALSE; ​ if (T2 != NULL) { ​ MergeBBST(T1, T2-&gt;lchild); ​ InsertAVL(T1, T2-&gt;data, taller); ​ MergeBBST(T1, T2-&gt;rchild); ​ } } /分裂平衡二叉树/void SpiltBBST(BBSTree T, RcdType key, BBSTree &amp;T1, BBSTree &amp;T2) { ​ Status taller = FALSE; ​ if (T != NULL) { ​ SpiltBBST(T-&gt;lchild, key, T1, T2); // 递归访问左子树 ​ if(T-&gt;data &gt; key) { ​ InsertAVL(T1, T-&gt;data, taller); ​ } else { ​ InsertAVL(T2, T-&gt;data, taller); ​ } ​ SpiltBBST(T-&gt;rchild, key, T1, T2); ​ } } 调试分析调试过程中遇到的问题及处理方法一开始运行过程中程序停止运行。遇到这个情况一开始我以为是编译器有问题，但是换了个编译器还是同样的问题，后来我上网查询了有关资料，大概明白了是自己的代码出现了问题。所以只能将新增的代码注释掉，一条一条测试，调试过程很漫长，最后才发现是内存泄露和空指针异常，将指针不适用之后指向为 NULL，才把问题解决了。 算法改进与设想在对动态查找表的查找方式上，课程设计选择的是平衡二叉树，那么当查找的结点元素与关键字数量庞大的时候，就会造成平衡二叉树的高度过高，查找、添加、删除等操作的时候效率就会变得很低，而且输入后的排序与整合平衡二叉树T所需要用到的时间就会很长，所以，如果动态查找表中的元素数量庞大的时候可以优先选择B树和B+树等，可以有效降低查找树的高度，提高查找处理效率。 经验与体会本次课程设计主要实现平衡二叉树的查找，插入和删除，增加合并和分裂的功能。许多接口的实现都是基于之前二叉树等的操作，根据平衡二叉树的特性进行改动和完善，删除的难点在于找待删除点的前驱结点和删除后对失衡情况的调节.合并和分裂平衡二叉树，一开始我是想用一个数组先把元素汇总再进行创建新的平衡二叉树，但查阅资料后，觉得这一种方法有些死板，不及直接递归访问结点元素并进行插入操作。总结来说，平衡二叉树是一种基于二叉树的抽象数据类型，平衡这一特性，给一些基本操作增加了不小的难度，值得去思考和研究。 在做一个比较大的程序过程中，应该学会边编写程序边运行，即当你完成了一个比较小的功能时便对其调试， 这样有助于我们高效地完成项目，而且在调试 BUG 的过程也可以大大减小其难度。必须要有良好的编程习惯。首先编码风格一定要规范，这样不仅有利于读者和编程者对代码的阅读，更有利于对代码的维护。其次要对代码要细心，比较一些指针的初始化和不需要时指为空，这些都是可以极大减少我们出现 BUG 的几率]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>课设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas学习笔记]]></title>
    <url>%2Fcanvas%2F2019%2F05%2F11%2Fcanvas.html</url>
    <content type="text"><![CDATA[canvas画布，不容小觑的“标签”，得有一定的数学几何底子，虽然目前我还是没用到就是了，但是以后总该会用到的，有想过利用canvas制作小游戏_〆(´Д｀ ) canvas画布，顾名思义即是如图所示绘图的“工具”，然而并不简单(lll￢ω￢)~ 最近毛毛的《奉献》特别耐人寻味，有跟原版不一样的感觉~ var ap = new APlayer({ element: document.getElementById("aplayer-kQXtJtyG"), narrow: false, autoplay: false, showlrc: false, music: { title: "奉献", author: "毛不易", url: "http://prc4nro7n.bkt.clouddn.com/%E5%A5%89%E7%8C%AE.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/maomao.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); canvas简介什么是canvas？（了解） 是HTML5提供的一种新标签 12&lt;canvas&gt;&lt;/canvas&gt; 英 ['kænvəs] 美 ['kænvəs] 帆布 画布 Canvas是一个矩形区域的画布，可以用JavaScript在上面绘画。控制其每一个像素。 canvas 标签使用 JavaScript 在网页上绘制图像，本身不具备绘图功能。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 HTML5之前的web页面只能用一些固定样式的标签：比如p、div、h1等 canvas主要应用的领域（了解） 游戏：canvas在基于Web的图像显示方面比Flash更加立体、更加精巧，canvas游戏在流畅度和跨平台方面更牛。25 超棒的 HTML5 Canvas 游戏 可视化数据.数据图表话，比如:百度的echart banner广告：Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。 未来=&gt; 模拟器：无论从视觉效果还是核心功能方面来说，模拟器产品可以完全由JavaScript来实现。 未来=&gt; 远程计算机控制：Canvas可以让开发者更好地实现基于Web的数据传输，构建一个完美的可视化控制界面。 未来=&gt; 图形编辑器：Photoshop图形编辑器将能够100%基于Web实现。 其他可嵌入网站的内容(多用于活动页面、特效)：类似图表、音频、视频，还有许多元素能够更好地与Web融合，并且不需要任何插件。 完整的canvas移动化应用 我们课程的目标 我们不是主要做游戏开发的 要求必须会做基本的用canvas绘制的特效页面：比如，传智前端官网。 会用canvas做一些简单的广告、活动页面 我们课程的案例和项目演示 canvas的标准： 最新标准：http://www.w3.org/TR/2dcontext/ 稳定版本的标准：http://www.w3.org/TR/2013/CR-2dcontext-20130806/ 目前来说，标准还在完善中。先用早期的api足够完成所有的应用 canvas绘图基础sublime配置canvas插件（推荐）1234推荐： 安装插件：AndyJS2 github地址： https://github.com/malun666/AndyJS2 直接下载到：X:\Users\用户名\AppData\Roaming\Sublime Text 3\Packages Canvas标签canvas标签语法和属性 （重点） canvas：画布油布的意思 ==英 [‘kænvəs] 美 [‘kænvəs] == 标签名canvas，需要进行闭合。就是一普通的html标签。 可以设置width和height属性，但是属性值单位必须是px，否则忽略。 width和hegiht：默认300*150像素 注意： 不要用CSS控制它的宽和高,会走出图片拉伸， 重新设置canvas标签的宽高属性会让画布擦除所有的内容。 可以给canvas画布设置背景色 浏览器不兼容处理（重点） ie9以上才支持canvas, 其他chrome、ff、苹果浏览器等都支持 只要浏览器兼容canvas，那么就会支持绝大部分api(个别最新api除外) 移动端的兼容情况非常理想，基本上随便使用 2d的支持的都非常好，3d（webgl）ie11才支持，其他都支持 如果浏览器不兼容，最好进行友好提示 1234例如： &lt;canvas id="cavsElem"&gt; 你的浏览器不支持canvas，请升级浏览器.浏览器不支持，显示此行文本&lt;/canvas&gt; 浏览器不兼容，可以使用flash等手段进行优雅降级 canvas绘图上下文contextContext：Canvas的上下文、绘制环境。（重点掌握） 上下文：上知天文，下知地理。是所有的绘制操作api的入口或者集合。 Canvas自身无法绘制任何内容。Canvas的绘图是使用JavaScript操作的。 Context对象就是JavaScript操作Canvas的接口。*使用[CanvasElement].getContext(‘2d’)来获取2D绘图上下文。 12var canvas = document.getElementById( 'cavsElem' ); //获得画布var ctx = canvas.getContext( '2d' );//注意：2d小写， 3d：webgl 基本的绘制路径（重点）canvas坐标系1canvas坐标系，从最左上角0,0开始。x向右增大， y向下增大 设置绘制起点(moveTo)1234* 语法：ctx.moveTo(x, y); * 解释：设置上下文绘制路径的起点。相当于移动画笔到某个位置* 参数：x,y 都是相对于 canvas盒子的最左上角。* 注意：**绘制线段前必须先设置起点，不然绘制无效。** 绘制直线(lineTo)123* 语法：ctx.lineTo(x, y);* 解释：从x,y的位置绘制一条直线到起点或者上一个线头点。* 参数：x,y 线头点坐标。 路径开始和闭合12345* 开始路径：ctx.beginPath();* 闭合路径：ctx.closePath();* 解释：如果复杂路径绘制，必须使用路径开始和结束。闭合路径会自动把最后的线头和开始的线头连在一起。* beginPath: 核心的作用是将 不同绘制的形状进行隔离， 每次执行此方法，表示重新绘制一个路径,跟之前的绘制的墨迹可以进行分开样式设置和管理。 描边(stroke)1234* 语法：ctx.stroke();* 解释：根据路径绘制线。路径只是草稿，真正绘制线必须执行stroke* stroke: （用笔等）画；轻抚；轻挪；敲击；划尾桨；划掉；（打字时）击打键盘 英 [strəʊk] 美 [strok] canvas绘制的基本步骤： 第一步：获得上下文 =&gt;canvasElem.getContext(‘2d’); 第二步：开始路径规划 =&gt;ctx.beginPath() 第三步：移动起始点 =&gt;ctx.moveTo(x, y) 第四步：绘制线(矩形、圆形、图片…) =&gt;ctx.lineTo(x, y) 第五步：闭合路径 =&gt;ctx.closePath(); 第六步：绘制描边 =&gt;ctx.stroke(); 1234567891011121314151617181920212223html部分： &lt;canvas id="cavsElem"&gt; 你的浏览器不支持canvas，请升级浏览器 &lt;/canvas&gt;javascript部分：//===============基本绘制api====================//获得画布var canvas = document.querySelector('#cavsElem');var ctx = canvas.getContext('2d'); //获得上下文canvas.width = 900; //设置标签的属性宽高canvas.height = 600; //千万不要用 canvas.style.heightcanvas.style.border = "1px solid #000";//绘制三角形ctx.beginPath(); //开始路径ctx.moveTo(100,100); //三角形，左顶点ctx.lineTo(300, 100); //右顶点ctx.lineTo(300, 300); //底部的点ctx.closePath(); //结束路径ctx.stroke(); //描边路径 综合案例：02绘制定位表格.html 综合案例：03画画板.html 填充(fill)12* 语法：ctx.fill(); * 解释：填充，是将闭合的路径的内容填充具体的颜色。默认黑色。 12345678910111213* 注意：交叉路径的填充问题，“非零环绕原则”，顺逆时针穿插次数决定是否填充。 以下是非0环绕原则的原理：（了解即可，非常少会用到复杂的路径） “非零环绕规则”是这么来判断有自我交叉情况的路径的：对于路径中的任意给定区域，从该区域内部画一条足够长的线段， 使此线段的终点完全落在路径范围之外。 图2-14中的那三个箭头所描述的就是上面这个步骤。 接下来，将计数器初始化为0， 然后，每当这条线段与路径上的直线或曲线相交时， 就改变计数器的值。如果是与路径的顺时针部分相交，则加1， 如果是与路径的逆时针部分相交，则减1。若计数器的最终值不是0，那么此区域就在路径里面，在调用fill()方法时， 浏览器就会对其进行填充。 如果最终值是0，那么此区域就不在路径内部，浏览器也就不会对其进行填充了* 案例： 04填充矩形.html 快速创建矩形rect()方法12345* 语法：ctx.rect(x, y, width, height);* 解释：x, y是矩形左上角坐标， width和height都是以像素计* rect方法只是规划了矩形的路径，并没有填充和描边。* 改造案例：04填充矩形.html*rect: abbr. 矩形（rectangular）；收据（receipt） 快速创建描边矩形和填充矩形1234* 语法： ctx.strokeRect(x, y, width, height); - 参数跟2.3.8相同，注意此方法绘制完路径后立即进行stroke绘制* 语法：ctx.fillRect(x, y, width, height); - 参数跟2.3.8相同， 此方法执行完成后。立即对当前矩形进行fill填充。 清除矩形(clearRect)12* 语法：ctx.clearRect(x, y, width, hegiht);* 解释：清除某个矩形内的绘制的内容，相当于橡皮擦。 绘制圆形（arc) 概述：arc() 方法创建弧/曲线（用于创建圆或部分圆）。 语法：ctx.arc(x,y,r,sAngle,eAngle,counterclockwise); arc: 弧（度）弧形物；天穹 英 [ɑːk] 美 [ɑrk] counter 反击，还击；反向移动，对着干；反驳，回答 [‘kaʊntə] 美 [‘kaʊntɚ] 解释： x,y：圆心坐标。 r：半径大小。 sAngle:绘制开始的角度。 圆心到最右边点是0度，顺时针方向弧度增大。 eAngel:结束的角度，注意是弧度。π counterclockwise：是否是逆时针。true是逆时针，false：顺时针 弧度和角度的转换公式： rad = deg*Math.PI/180; 在Math提供的方法中sin、cos等都使用的弧度 案例：05绘制圆形.html 案例：06绘制饼状图.html 绘制文字（会使用就可以了）绘制上下文的文字属性 （有印象就行了） font 设置或返回文本内容的当前字体属性 font 属性使用的语法与 CSS font 属性相同。 1例如：ctx.font = "18px '微软雅黑'"; textAlign 设置或返回文本内容的当前对齐方式 start : 默认。文本在指定的位置开始。 end : 文本在指定的位置结束。 center: 文本的中心被放置在指定的位置。 left : 文本左对齐。 right : 文本右对齐。 1* 例如：ctx.textAlign = 'left'; textBaseline 设置或返回在绘制文本时使用的当前文本基线 alphabetic ： 默认。文本基线是普通的字母基线。 top ： 文本基线是 em 方框的顶端。。 hanging ： 文本基线是悬挂基线。 middle ： 文本基线是 em 方框的正中。 ideographic： 文本基线是em基线。 bottom ： 文本基线是 em 方框的底端。 1234例如： ctx.textBaseline = 'top';单词: alphabetic: 字母的；照字母次序的 [,ælfə'bɛtɪk] ideographic：表意的；表意字构成的 英 [,ɪdɪəʊ'ɡræfɪk] 美 [,ɪdɪə'græfɪk] ​ 上下文绘制文字方法1234* ctx.fillText() 在画布上绘制“被填充的”文本* ctx.strokeText() 在画布上绘制文本（无填充）* ctx.measureText() 返回包含指定文本宽度的对象* 单词：measure 测量；估量；权衡 英 ['meʒə] 美 ['mɛʒɚ] 12345678//综合案例代码：ctx.moveTo( 300, 300 );ctx.fillStyle = "purple"; //设置填充颜色为紫色ctx.font = '20px "微软雅黑"'; //设置字体ctx.textBaseline = "bottom"; //设置字体底线对齐绘制基线ctx.textAlign = "left"; //设置字体对齐的方式//ctx.strokeText( "left", 450, 400 );ctx.fillText( "Top-g", 100, 300 ); //填充文字 绘制图片（drawImage） （重点）基本绘制图片的方式12context.drawImage(img,x,y);参数说明： x,y 绘制图片左上角的坐标， img是绘制图片的dom对象。 在画布上绘制图像，并规定图像的宽度和高度12345context.drawImage(img,x,y,width,height); 参数说明：width 绘制图片的宽度， height：绘制图片的高度如果指定宽高，最好成比例，不然图片会被拉伸&lt;/em&gt; 等比公式： toH = Height * toW / Width; //等比 设置高 = 原高度 * 设置宽/ 原宽度; 图片裁剪，并在画布上定位被剪切的部分12345context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);参数说明： sx,sy 裁剪的左上角坐标， swidth：裁剪图片的高度。 sheight:裁剪的高度 其他同上 用JavaScript创建img对象123456789第一种方式： var img = document.getElementById("imgId");第二种方式： var img = new Image();//这个就是 img标签的dom对象 img.src = "imgs/arc.gif"; img.alt = "文本信息"; img.onload = function() &#123; //图片加载完成后，执行此方法 &#125; 面向对象基础复习补充： 创建对象的方式： 123* var o = &#123; name: '123', age: 18 &#125;; //json方式创建* var o = new Object(); //通过new的方式创建* var o = new Persion(); //通过类的构造函数创建 JS中对象的属性创建方式 12345* json的方式： var o = &#123; age: 19 &#125;;* 直接添加属性：var o = &#123;&#125;; o.age = 19;//太分散了，不利于管理* 由于js动态语言的特性，如果属性不存在的时候，直接添加属性。* 构造函数添加属性* 原型添加公共的属性 JS的构造函数的原型构造函数的原型就是：构造对象的模板，构造函数原型里面的所有的属性和方法都会共享给所有的 构造函数构造出来的所有实例。 案例： 08绘制图片.html 案例： 09绘制图片裁剪.html 案例： 10序列帧动画.html 案例： 11面向对象版本的动画帧.html 重点 补充 sublime制作代码段（推荐–已结讲过了）第一步：sublime菜单栏→ 工具 → 制作代码段 第二步：修改输出的sublime代码段文本 1234567891011&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[1、这里放要tab键 输出的内容2、 $&#123;1:this&#125; 占位符，tab可以进行切换，数字是切换的索引。 ：后面的是默认的文本。]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;简写的字母&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;&lt;/snippet&gt; 第三步：保存到插件的文件夹中，后缀名为：.sublime-snippet比如我存放的位置： C:\Users\malunmac\AppData\Roaming\Sublime Text 3\Packages\User\snippetssnippets是我自己新建的文件夹。 canvas进阶Canvas颜色样式和阴影设置填充和描边的颜色（掌握） fillStyle : 设置或返回用于填充绘画的颜色 strokeStyle: 设置或返回用于笔触的颜色 以上两个值都可以接受颜色名,16进制数据，rgb值，甚至rgba.一般先进行设置样式然后进行绘制。 12345例如：ctx.strokeStyle = "red"; ctx.strokeStyle = "#ccc"; ctx.strokeStyle = "rgb(255,0,0)"; ctx.strokeStyle = "rgba(255,0,0,6)"; 设置阴影（了解，少用，性能差） 类比于CSS3的阴影。 shadowColor ： 设置或返回用于阴影的颜色 shadowBlur ： 设置或返回用于阴影的模糊级别,大于1的正整数，数值越高，模糊程度越大 shadowOffsetX： 设置或返回阴影距形状的水平距离 shadowOffsetY： 设置或返回阴影距形状的垂直距离 123456ctx.fillStyle = "rgba(255,0,0, .9)"ctx.shadowColor = "teal";ctx.shadowBlur = 10;ctx.shadowOffsetX = 10;ctx.shadowOffsetY = 10;ctx.fillRect(100, 100, 100, 100); 例如： 案例： 12设置box盒子阴影.html 设置png图片的阴影，图片透明部分不会被投影。 复杂样式（了解）创建线性渐变的样式（了解） 一般不用，都是用图片代替，canvas绘制图片效率更高。 线性渐变可以用于 矩形、圆形、文字等颜色样式 线性渐变是一个对象 语法：ctx.createLinearGradient(x0,y0,x1,y1); //参数：x0,y0起始坐标，x1,y1结束坐标 123456例如：//创建线性渐变的对象，var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,"black"); //添加一个渐变颜色，第一个参数介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。grd.addColorStop(1,"white"); //添加一个渐变颜色ctx.fillStyle =grd; //关键点，把渐变设置到 填充的样式 案例13设置线性渐变.html 设置圆形渐变（径向渐变） 了解 创建放射状/圆形渐变对象。可以填充文本、形状等 context.createRadialGradient(x0,y0,r0,x1,y1,r1); radial 半径的；放射状的；光线的；光线状的 英 [‘reɪdɪəl] 美 [‘redɪəl] 参数详解： x0: 渐变的开始圆的 x 坐标 y0: 渐变的开始圆的 y 坐标 r0: 开始圆的半径 x1: 渐变的结束圆的 x 坐标 y1: 渐变的结束圆的 y 坐标 r1: 结束圆的半径 123456var rlg = ctx.createRadialGradient(300,300,10,300,300,200);rlg.addColorStop(0, 'teal'); //添加一个渐变颜色rlg.addColorStop(.4, 'navy');rlg.addColorStop(1, 'purple');ctx.fillStyle = rlg;//设置 填充样式为延续渐变的样式ctx.fillRect(100, 100, 500, 500); 案例14圆形渐变.html 绘制背景图（了解） ctx.createPattern(img,repeat) 方法在指定的方向内重复指定的元素了解 pattern：n. 模式；图案；样品 英 [‘pæt(ə)n] 美 [‘pætɚn] 第一参数：设置平铺背景的图片，第二个背景平铺的方式。 image ： 规定要使用的图片、画布或视频元素。 repeat ： 默认。该模式在水平和垂直方向重复。 repeat-x ： 该模式只在水平方向重复。 repeat-y ： 该模式只在垂直方向重复。 no-repeat： 该模式只显示一次（不重复）。 123456var ctx=c.getContext("2d");var img=document.getElementById("lamp");var pat=ctx.createPattern(img,"repeat");ctx.rect(0,0,150,100);ctx.fillStyle=pat;// 把背景图设置给填充的样式ctx.fill(); 案例15背景图填充.html 变换（重点）缩放（重点） scale() 方法缩放当前绘图，更大或更小 语法：context.scale(scalewidth,scaleheight) scalewidth : 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) scaleheight : 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.)+注意：缩放的是整个画布，缩放后，继续绘制的图形会被放大或缩小。 案例16缩放案例.html 位移画布（重点） ctx.translate(x,y) 方法重新映射画布上的 (0,0) 位置 参数说明： x： 添加到水平坐标（x）上的值 y： 添加到垂直坐标（y）上的值 发生位移后，相当于把画布的0,0坐标 更换到新的x,y的位置，所有绘制的新元素都被影响。 位移画布一般配合缩放和旋转等。 案例： 17位移画布.html 旋转（重点） context.rotate(angle); 方法旋转当前的绘图 注意参数是弧度（PI） 如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。 案例：18旋转画布.html 绘制环境保存和还原（重要） ctx.save() 保存当前环境的状态 可以把当前绘制环境进行保存到缓存中。 ctx.restore() 返回之前保存过的路径状态和属性 获取最近缓存的ctx 一般配合位移画布使用。 案例： 19矩形旋转案例.html 设置绘制环境的透明度（了解） context.globalAlpha=number; number:透明值。必须介于 0.0（完全透明） 与 1.0（不透明） 之间。 设置透明度是全局的透明度的样式。注意是全局的。 画布限定区域绘制（了解） ctx.clip(); 方法从原始画布中剪切任意形状和尺寸 一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域） 一般配合绘制环境的保存和还原。 画布保存base64编码内容（重要） 把canvas绘制的内容输出成base64内容。 语法：canvas.toDataURL(type, encoderOptions); 例如：canvas.toDataURL(“image/jpg”,1); 参数说明： type，设置输出的类型，比如 image/png image/jpeg等 encoderOptions： 0-1之间的数字，用于标识输出图片的质量，1表示无损压缩，类型为： image/jpeg 或者image/webp才起作用。 123456789案例1：var canvas = document.getElementById("canvas");var dataURL = canvas.toDataURL();console.log(dataURL);// "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC"var img = document.querySelector("#img-demo");//拿到图片的dom对象img.src = canvas.toDataURL("image/png"); //将画布的内容给图片标签显示 画布渲染画布（重要） context.drawImage(img,x,y); img参数也可以是画布，也就是把一个画布整体的渲染到另外一个画布上。 1234567var canvas1 = document.querySelector('#cavsElem1');var canvas2 = document.querySelector('#cavsElem2');var ctx1 = canvas1.getContext('2d');var ctx2 = canvas2.getContext('2d');ctx1.fillRect(20, 20, 40, 40); //在第一个画布上绘制矩形ctx2.drawImage(canvas1, 10, 10); //将第一个画布整体绘制到第二个画布上 了解：线条样式（了解） lineCap 设置或返回线条的结束端点(线头、线冒)样式 butt ： 默认。向线条的每个末端添加平直的边缘。 翻译.：屁股；烟头；笑柄；靶垛；粗大的一端 英 [bʌt] 美 [bʌt] round ： 向线条的每个末端添加圆形线帽。 square： 向线条的每个末端添加正方形线帽。 参考：23线的样式.html lineJoin 设置或返回两条线相交时，所创建的拐角类型 bevel: 创建斜角。 翻译. 斜角；斜面；[测] 斜角规 英 [‘bev(ə)l] 美 [‘bɛvl] round: 创建圆角。 miter: 默认。创建尖角 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 意思: 斜接 英 [‘maɪtə] 斜接长度指的是在两条线交汇处内角和外角之间的距离。 一般用默认值：10就可以了。除非需要特别长的尖角时，使用此属性。 了解贝塞尔曲线（知道有）绘制一条二次方曲线。 微软的画图板中的曲线的颜色。 quadratic：二次方的意思， 英 [kwɒ’drætɪk] 美 [kwɑ’drætɪk] Curve：曲线的意思， 英 [kɜːv] 美 [kɝv] 语法： context.quadraticCurveTo(cpx,cpy,x,y); 参数： cpx： 贝塞尔控制点的 x 坐标 cpy： 贝塞尔控制点的 y 坐标 x ： 结束点的 x 坐标 y ： 结束点的 y 坐标 12345ctx.beginPath();ctx.moveTo(20,20);//绘制2次方曲线，贝赛尔曲线ctx.quadraticCurveTo(20,100,200,20);ctx.stroke(); 绘制贝塞尔曲线（知道有） 绘制一条三次贝塞尔曲线 语法：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); 提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 参数说明： cp1x： 第一个贝塞尔控制点的 x 坐标 cp1y： 第一个贝塞尔控制点的 y 坐标 cp2x： 第二个贝塞尔控制点的 x 坐标 cp2y： 第二个贝塞尔控制点的 y 坐标 x: 结束点的 x 坐标 y: 结束点的 y 坐标 123456789101112//绘制复杂的贝塞尔曲线ctx.beginPath();ctx.moveTo(400,400);//参数说明：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);// cp1x： 第一个贝塞尔控制点的 x 坐标// cp1y： 第一个贝塞尔控制点的 y 坐标// cp2x： 第二个贝塞尔控制点的 x 坐标// cp2y： 第二个贝塞尔控制点的 y 坐标// x: 结束点的 x 坐标// y: 结束点的 y 坐标ctx.bezierCurveTo(500, 200, 600, 600, 700, 300);ctx.stroke(); 案例：25绘制贝塞尔曲线.html 了解创建两条切线的弧（知道有） 在画布上创建介于当前起点和两个点形成的夹角的切线之间的弧 语法： context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。 例如： ctx.arcTo(240, 100, 240, 110, 40); 参数： x1: 弧的端点1的 x 坐标 y1: 弧的端点1的 y 坐标 x2: 弧的端点2(终点)的 x 坐标 y2: 弧的端点2(终点)的 y 坐标 r : 弧的半径 12345678//代码demo：ctx.beginPath();ctx.moveTo(100,100);ctx.lineTo(200,100);//context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。ctx.arcTo(240, 100, 240, 110, 40);ctx.lineTo(240, 300);ctx.stroke(); 了解判断点是否在路径中（知道有）123context.isPointInPath(x,y);//isPointInPath() 方法返回 true，如果指定的点位于当前路径中；否则返回 false。//判断x,y坐标的点是否在当前的路径中。 了解文本宽度计算（知道有）1context.measureText(text).width; 如果以后做canvas游戏方向开发深入学习可以扩展内以下容： setTransform() 将当前转换重置为单位矩阵。然后运行 transform() transform() 替换绘图的当前转换矩阵 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 像素操作 Canvas开发库封装封装常用的绘制函数封装一个矩形123456789101112131415161718192021222324252627282930313233343536373839//思考：我们用到的矩形需要哪些绘制的东西呢？1、矩形的 x、y坐标2、矩形的宽高3、矩形的边框的线条样式、线条宽度4、矩形填充的样式5、矩形的旋转角度6、矩形的缩小放大//下面是把上面所有的功能进行封装的代码：function ItcastRect( option ) &#123;//矩形构造函数 this._init(option);&#125;ItcastRect.prototype = &#123; //矩形的原型对象 _init: function( option ) &#123; //初始化方法 option = option || &#123;&#125;; this.x = option.x === 0 ? 0 : option.x || 100; this.y = option.y === 0 ? 0 : option.y || 100; this.w = option.w || 100; this.h = option.h || 100; this.angle = option.angle === 0 ? 0 : option.angle || 0; this.fillStyle = option.fillStyle || 'silver'; this.strokeStyle = option.strokeStyle || 'red'; this.strokeWidth = option.strokeWidth || 4; this.scaleX = option.scaleX || 1; this.scaleY = option.Y || 1; &#125;, render: function( ctx ) &#123;//把矩形渲染到canvas中 ctx.save(); ctx.translate( this.x, this.y );//位移画布 ctx.rotate( this.angle * Math.PI / 180 );//旋转角度 ctx.scale( this.scaleX, this.scaleY );//缩放 ctx.fillStyle = this.fillStyle; ctx.fillRect( 0, 0, this.w, this.h ); //填充矩形 ctx.lineWidth = this.strokeWidth; //线宽 ctx.strokeStyle = this.strokeStyle; //填充样式 ctx.strokeRect( 0,0,this.w,this.h ); //描边样式 ctx.restore(); &#125;, constructor: ItcastRect&#125;; 4.1.2作业：尝试着封装一个圆形？ 123456789101112131415161718192021222324252627282930313233343536373839404142//封装圆形的代码的答案：不要偷看function ItcastCircle( option ) &#123; this._init( option );&#125;ItcastCircle.prototype = &#123; _init: function( option ) &#123; option = option || &#123;&#125;; this.x = option.x === 0 ? 0 : option.x || 100; this.y = option.y === 0 ? 0 : option.y || 100; this.w = option.w || 100; this.h = option.h || 100; this.angle = option.angle === 0 ? 0 : option.angle || 0; this.fillStyle = option.fillStyle || 'silver'; this.strokeStyle = option.strokeStyle || 'red'; this.strokeWidth = option.strokeWidth || 4; this.scaleX = option.scaleX || 1; this.scaleY = option.Y || 1; this.opactity = option.opactity || 1; this.counterclockwise = option.counterclockwise === true ? true : option.counterclockwise || false; this.startAngle = option.startAngle == 0 ? 0 : option.startAngle || 0; this.endAngle = option.endAngle == 0 ? 0 : option.endAngle || 0; this.startAngle = this.startAngle * Math.PI/180; this.endAngle = this.endAngle * Math.PI / 180; this.r = option.r || 100; &#125;, render: function( ctx ) &#123; ctx.save(); ctx.translate( this.x, this.y); ctx.scale( this.scaleX, this.scaleY ); ctx.rotate( this.agnle * Math.PI / 180 ); ctx.globalAlpha = this.opacity; ctx.fillStyle = this.fillStyle; ctx.strokeStyle = this.strokeStyle; ctx.moveTo(0, 0); ctx.arc( 0, 0, this.r, this.startAngle, this.endAngle, this.counterclockwise); ctx.fill(); ctx.stroke(); ctx.restore(); &#125;, constructor: ItcastCircle&#125;; 第三方库使用 Rgraph vs 百度的echart 1https://roopons.com.au/wp-content/plugins/viral-optins/js/rgraph/ 国产的egret引擎 1http://www.egret-labs.org/ 比较火的3d引擎：treejs 1http://threejs.org/ Konva 12345678官网：http://konvajs.github.io/ 特点： * 小巧、使用方便、适合移动端和pc端 * 支持丰富的事件处理操作 * 支持类似JQuery的操作方式（顺带能复习jQueyr） * 开源，可以随意更改 * 社区更新比较活跃，github托管源码 * 性能也不错 其他的还有很多，希望以后能用到你们的库。 Konva的使用快速上手Konva的整体理念 舞台的概念的引入。整个视图看做是一个舞台 stage 舞台中可以绘制很多个层 layer layer下面可以有很多的group group下面可以有 矩形、图片、其他形状等 参看：快速上手文档—查看翻译文档 1234567891011121314151617 Stage | +------+------+ | | Layer Layer | | +-----+-----+ Shape | | Group Group | | + +---+---+ | | |Shape Group Shape | + | Shape Konva矩形案例创建一个矩形： Konva.Rect(option);12345678910111213141516171819202122232425262728293031323334353637383940//Konva使用的基本案例//第一步：创建舞台var stage = new Konva.Stage(&#123; container: 'container', //需要存放舞台的Dom容器 width: window.innerWidth, //设置全屏 height: window.innerHeight&#125;);//第二步：创建层var layer = new Konva.Layer(); //创建一个层stage.add(layer); //把层添加到舞台//第三步： 创建矩形var rect = new Konva.Rect(&#123; //创建一个矩形 x: 100, //矩形的x坐标，相对其父容器的坐标 y: 100, width: 100, //矩形的宽度 height: 100, //矩形高度 fill: 'gold', //矩形填充的颜色 stroke: 'navy', //矩形描边的颜色 strokeWidth: 4, //填充宽度 opactity: .2, //矩形的透明度 scale: 1.2, //矩形的缩放 1：原来大小 rotation: 30, //旋转的角度，是deg不是弧度。 cornerRadius: 10, //圆角的大小（像素） id: 'rect1', //id属性，类似dom的id属性 name: 'rect', draggable: true //是否可以进行拖拽&#125;);//创建一个组var group = new Konva.Group(&#123; x: 40, y: 40,&#125;);group.add( rect ); //把矩形添加到组中//第四步： 把形状放到层中layer.add( group ); //把组添加到层中layer.draw(); //绘制层到舞台上 Konva的动画系统tween对象(重点) tween，英文意思：两者之间， 英 [twiːn] 美 [twin] tween是控制Konva对象进行动画的核心对象。 tween可以控制所有数字类型的属性进行动画处理，比如：x, y, rotation,width, height, radius, strokeWidth, opacity, scaleX等 1234567891011121314//案例：var tween = new Konva.Tween(&#123; node: rect, //要进行动画的Konva对象 x: 300, //要进行动画的属性 opacity: .8, duration: 1, //持续时间 easing: Konva.Easings.EaseIn, //动画的动画效果 yoyo: true, //是否进行循环播放的设置 onFinish: function() &#123; //动画执行结束后，执行此方法 &#125;&#125;);tween.play(); //启动动画 tween的控制方法 tween.play(), //播放动画 tween.pause(), //暂停动画 tween.reverse(), //动画逆播放 tween.reset(), //重置动画 tween.finish(), //立即结束动画 seek：英文：寻找 英 [siːk] 美 [sik] tween的缓动控制选项 Konva.Easings.Linear //线性 Konva.Easings.EaseIn //缓动，先慢后快 Konva.Easings.EaseOut //先快后慢 Konva.Easings.EaseInOut //两头慢，中间快 Konva.Easings.BackEaseIn //往回来一点，然后往前冲，汽车启动类似… Konva.Easings.BackEaseOut Konva.Easings.BackEaseInOut Konva.Easings.ElasticEaseIn //橡皮筋 英 [ɪ’læstɪk] 美 [ɪ’læstɪk] Konva.Easings.ElasticEaseOut Konva.Easings.ElasticEaseInOut Konva.Easings.BounceEaseIn //弹跳；弹起，反跳；弹回 英 [baʊns] 美 [baʊns] Konva.Easings.BounceEaseOut Konva.Easings.BounceEaseInOut Konva.Easings.StrongEaseIn //强力 Konva.Easings.StrongEaseOut Konva.Easings.StrongEaseInOut 动画效果参考： 29Konva动画缓动效果案例.html 动画to的使用 to就是对tween的封装，比较简单好用。 1234567891011121314151617181920212223//案例：var rect = new Konva.Rect(&#123; x: 10, y: 10, width: 100, height: 100, fill: 'red'&#125;);layer.add(rect);layer.draw();//动画系统rect.to(&#123; x: 100, y: 100, opactity: .1, duration: 3, onFinish: function() &#123; &#125;&#125;);//to: 就是对tween的简单应用。 Animate的应用 Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间 12345678910111213var anim = new Konva.Animation(function(frame) &#123; //动画系统提供的frame有三个属性可以使用： var time = frame.time, // 动画执行的总时间 timeDiff = frame.timeDiff, // 距离上一帧的时间 frameRate = frame.frameRate; // 帧率（既1000/间隔时间） //动画的动作&#125;, layer);anim.start();//启动动画//anim.stop();//结束动画 循环播放动画的实现12345678910111213//总体思路，使用tween 配合onFinish事件中重新播放动画，达到循环播放的效果var loopTween = new Konva.Tween(&#123; node: star, //设置要表现动画的 Konva对象 rotation: 360, //旋转360度 duration: 2, //动画持续时间 easing: Konva.Easings.Linear, onFinish: function() &#123; // this === loopTween //true this.reset();//重置动画 this.play(); //重新播放动画 &#125;&#125;);loopTween.play(); 回放且循环播放动画 yoyo属性可以进行对动画进行播放完后，回放当前动画，并持续循环来回切换播放。 12345rect.to(&#123; duration: 2, scale: 1.5, yoyo: true// 此设置也可以用于 tween&#125;); 进度条案例传智官网案例 三角函数的补充 Math.sin(弧度); //夹角对面的边 和 斜边的比值 Math.cos(弧度); //夹角侧边 与斜边的比值 圆形上面的点的坐标的计算公式 x =x0 + Math.cos(rad) * R;//x0和y0是圆心点坐标 y =y0 + Math.sin(rad) * R;//注意都是弧度 group的灵活运用 konva的group很灵活，每个group都有自己的坐标系 group可以包含其他的group，可以对group做整个组的动画 group可以通过getChidren();//可以拿到直接子级元素。 12345var group = new Konva.Group(&#123; x: 0, y: 0&#125;);group.add(rect); Konva的事件（重要）123456789101112131415161718192021222324252627282930var rect = new Konva.Rect(&#123; x: 100, y: 100, fill: 'red', width: 200, height: 200&#125;);//绑定事件 Konva支持事件：mouseover, mouseout, mouseenter, mouseleave, mousemove, mousedown, mouseup, mousewheel, click, dblclick, dragstart, dragmove, and dragendrect.on('click', function()&#123; //jQuery一模一样！！ console.log('^_^ ^_^');&#125;);//绑定多个事件rect.on('click mousemove',function(e)&#123;&#125;);//解除绑定事件rect.off('click'); //这不是jQuery吗？//触发事件rect.fire('click');//取消事件冒泡rect.on('click', function(evt) &#123; alert('You clicked the circle!'); evt.cancelBubble = true; //取消事件冒泡&#125;); Konva的选择器 选择方法。 ID选择法：stage.find(‘#id’); //此方法返回的是一个数组 name选择法：group.findOne(‘.name’);//返回一个Konva对象 type选择法： group.find(‘Circle’);//查找所有的圆形Konva对象 1234//组中查找圆形的Konva对象groupCircle.find('Circle').each(function( circle, index )&#123; circle.setZIndex( 3 - index );&#125;); 饼状图案例 wedge: 楔形 柱状图案例 histogram n. [统计] 直方图；柱状图 英 [‘hɪstəgræm] 美 [‘hɪstəɡræm] Canvas项目实战Canvas优化]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap开发实例]]></title>
    <url>%2Fweb%E5%BC%80%E5%8F%91%2F2019%2F05%2F11%2Fweb-bootstrap.html</url>
    <content type="text"><![CDATA[去年参照Bootstrap文档测试尝试的微金所项目实战，搬到博客上来看看 让我累觉不爱的前端项目之一 代码之余让人有点想玩幻想魔录了 微金所项目实战搭建Bootstrap页面骨架及项目目录结构12345678├─ /weijinsuo/ ··················· 项目所在目录└─┬─ /css/ ······················· 我们自己的CSS文件 ├─ /font/ ······················ 使用到的字体文件 ├─ /img/ ······················· 使用到的图片文件 ├─ /js/ ························ 自己写的JS脚步 ├─ /lib/ ······················· 从第三方下载回来的库【只用不改】 ├─ /favicon.ico ················ 站点图标 └─ /index.html ················· 入口文件 约定编码规范HTML约定 在head中引入必要的CSS文件，优先引用第三方的CSS，方便我们自己的样式覆盖 在body末尾引入必要的JS文件，优先引用第三方的JS，注意JS文件之间的依赖关系，比如bootstrap.js依赖jQuery，那就应该先引用jquery.js 然后引用bootstrap.js CSS约定 除了公共级别样式，其余样式全部由 模块前缀 尽量使用 直接子代选择器， 少用间接子代 避免错杀 HTML5文档结构12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; Viewport设置1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"&gt; html中插入视口设置，可以通过emmet meta:vp 插入 浏览器兼容模式1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; html中插入兼容模式设置，可以通过emmet meta:compat 插入 favicon（站点图标）1&lt;link rel="shortcut icon" type="image/x-icon" href="favicon.ico"&gt; html中插入图标链接，可以通过emmet link:favicon 插入 引入相应的第三方文件123456&lt;link rel="stylesheet" href="bootstrap.css"&gt;&lt;link rel="stylesheet" href="my.css"&gt;...&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap.js"&gt;&lt;/script&gt;&lt;script src="my.js"&gt;&lt;/script&gt; 在我们默认的样式表中将默认字体设置为：12345678body&#123; font-family: "Helvetica Neue", Helvetica, Microsoft Yahei, Hiragino Sans GB, WenQuanYi Micro Hei, sans-serif;&#125; 完成页面空结构 先划分好页面中的大容器，然后在具体看每一个容器中单独的情况 1234567891011121314151617181920212223242526&lt;body&gt; &lt;!-- 头部区域 --&gt; &lt;header&gt;&lt;/header&gt; &lt;!-- /头部区域 --&gt; &lt;!-- 广告轮播 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /广告轮播 --&gt; &lt;!-- 特色介绍 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /特色介绍 --&gt; &lt;!-- 立即预约 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /立即预约 --&gt; &lt;!-- 产品推荐 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /产品推荐 --&gt; &lt;!-- 新闻列表 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /新闻列表 --&gt; &lt;!-- 合作伙伴 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /合作伙伴 --&gt; &lt;!-- 脚注区域 --&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!-- /脚注区域 --&gt;&lt;/body&gt; 构建顶部通栏123&lt;header&gt; &lt;div class="topbar"&gt;&lt;/div&gt;&lt;/header&gt; container类 用于定义一个固定宽度且居中的版心 12345678&lt;div class="topbar"&gt; &lt;div class="container"&gt; &lt;!-- 此处的代码会显示在一个固定宽度且居中的容器中 该容器的宽度会跟随屏幕的变化而变化 --&gt; &lt;/div&gt;&lt;/div&gt; 栅格系统 Bootstrap中定义了一套响应式的网格系统， 其使用方式就是将一个容器划分成12列， 然后通过col-xx-xx的类名控制每一列的占比 row类 因为每一个列默认有一个15px的左右外边距 row类的一个作用就是通过左右-15px屏蔽掉这个边距 123&lt;div class="container"&gt; &lt;div class="row"&gt;&lt;/div&gt;&lt;/div&gt; col-\-*类 col-xs-[列数]：在超小屏幕下展示几份 col-sm-[列数]：在小屏幕下展示几份 col-md-[列数]：在中等屏幕下展示几份 col-lg-[列数]：在大屏幕下展示几份 xs : 超小屏幕 手机 (&lt;768px) sm : 小屏幕 平板 (≥768px) md : 中等屏幕 桌面显示器 (≥992px) lg : 大屏幕 大桌面显示器 (≥1200px) 123456&lt;div class="row"&gt; &lt;div class="col-md-2 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-5 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-2 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-3 text-center"&gt;&lt;/div&gt;&lt;/div&gt; 此处顶部通栏已经被划分成四列text-center的作用就是让内部内容居中显示 字体图标12345678910111213141516@font-face &#123; font-family: 'itcast'; src: url('../font/MiFie-Web-Font.eot') format('embedded-opentype'), url('../font/MiFie-Web-Font.svg') format('svg'), url('../font/MiFie-Web-Font.ttf') format('truetype'), url('../font/MiFie-Web-Font.woff') format('woff');&#125;[class^="icon-"],[class*=" icon-"] &#123; /*注意上面选择器中间的空格*/ /*我们使用的名为itcast的字体就是上面的@font-face的方式声明的*/ font-family: itcast; font-style: normal;&#125;.icon-mobilephone::before&#123; content: '\e908';&#125; 123456789&lt;div class="col-md-2 text-center"&gt; &lt;a class="mobile-link" href="#"&gt; &lt;i class="icon-mobile"&gt;&lt;/i&gt; &lt;span&gt;手机微金所&lt;/span&gt; &lt;!-- 这里使用的是bootstrap中的字体图标 --&gt; &lt;i class="glyphicon glyphicon-chevron-down"&gt;&lt;/i&gt; &lt;img src="..." alt=""&gt; &lt;/a&gt;&lt;/div&gt; 字体文件格式 eot : embedded-opentype svg : svg ttf : truetype woff : woff hover图片展示123.mobile-link:hover &gt; img &#123; display: block;&#125; 按钮样式生成 http://blog.koalite.com/bbg/ 可以通过界面生成一个新的按钮样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445.btn-itcast &#123; color: #ffffff; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast:hover,.btn-itcast:focus,.btn-itcast:active,.btn-itcast.active,.open .dropdown-toggle.btn-itcast &#123; color: #ffffff; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast:active,.btn-itcast.active,.open .dropdown-toggle.btn-itcast &#123; background-image: none;&#125;.btn-itcast.disabled,.btn-itcast[disabled],fieldset[disabled] .btn-itcast,.btn-itcast.disabled:hover,.btn-itcast[disabled]:hover,fieldset[disabled] .btn-itcast:hover,.btn-itcast.disabled:focus,.btn-itcast[disabled]:focus,fieldset[disabled] .btn-itcast:focus,.btn-itcast.disabled:active,.btn-itcast[disabled]:active,fieldset[disabled] .btn-itcast:active,.btn-itcast.disabled.active,.btn-itcast[disabled].active,fieldset[disabled] .btn-itcast.active &#123; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast .badge &#123; color: #E92322; background-color: #ffffff;&#125; 小屏幕隐藏1&lt;div class="topbar hidden-xs hidden-sm"&gt;&lt;/div&gt; 或者 1&lt;div class="topbar visible-md visible-lg"&gt;&lt;/div&gt; hidden-xx : 在某种屏幕下隐藏 visible-xx : 在某种屏幕尺寸下显示 导航通栏 在使用了boostrap过后，大多数界面元素都是通过bootstrap提供好的界面组件修改得来 1234567891011121314151617181920212223242526272829&lt;nav class="navbar navbar-itcast navbar-static-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button id="btn" type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav_list" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;切换菜单&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt; &lt;i class="icon-icon"&gt;&lt;/i&gt; &lt;i class="icon-logo"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;div id="nav_list" class="collapse navbar-collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;我要投资&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;我要借款&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;平台介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新手专区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;最新动态&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;微论坛&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right hidden-sm"&gt; &lt;li&gt;&lt;a href="#"&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; Bootstrap扩展 通过bootstrap文档对导航条样式的设置发现，其实本身是有一个类似于主题的概念 navbar-default：默认的外观 navbar-inverse：暗色背景的样式 所以我们希望可以通过自定义一套完整的风格： navbar-itcast 1234.navbar-itcast&#123; ...&#125;...具体代码参考navbar-default实现即可 品牌logo 任然使用字体图标 菜单行高调整 默认样式中菜单的行高为20px，我们可以调整为自己想要的高度 一般都是通过自己的样式去覆盖 轮播图Bootstrap JS插件使用 对于Bootstrap的JS插件，我们只需要将文档实例中的代码粘到我们自己的代码中让后作出相应的样式调整 Bootstrap中轮播图插件叫作Carousel基本的轮播图实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 以下容器就是整个轮播图组件的整体， 注意该盒子必须加上 class="carousel slide" data-ride="carousel" 表示当前是一个轮播图 bootstrap.js会自动为当前元素添加图片轮播的特效--&gt;&lt;div id="轮播图的ID" class="carousel slide" data-ride="carousel"&gt; &lt;!-- ol标签是图片轮播的控制点 --&gt; &lt;ol class="carousel-indicators"&gt; &lt;!-- 每一个li就是一个单独的控制点 data-target属性就是指定当前控制点控制的是哪一个轮播图，其目的是如果界面上有多个轮播图，便于区分到底控制哪一个 data-slide-to属性是指当前的li元素绑定的是第几个轮播项 注意，默认必须给其中某个li加上active，展示的时候就是焦点项目 --&gt; &lt;li data-target="#轮播图的ID" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#轮播图的ID" data-slide-to="1"&gt;&lt;/li&gt; &lt;!-- ...更多的 --&gt; &lt;/ol&gt; &lt;!-- .carousel-inner是所有轮播项的容器盒子， 注意role="listbox"代表当前div是一个列表盒子，作用就是给当前div添加一个语义 --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;!-- 每一个.item就是单个轮播项目，注意默认要给第一个轮播项目加上active，表示为焦点 --&gt; &lt;div class="item active"&gt; &lt;!-- 轮播项目中展示的图片 --&gt; &lt;img src="example.jpg" alt="示例图片"&gt; &lt;div class="carousel-caption"&gt; &lt;!-- 标题或说明性文字，如果不需要，直接删除当前div.carousel-caption --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;!-- ... --&gt; &lt;/div&gt; &lt;!-- ... --&gt; &lt;/div&gt; &lt;!-- 图片轮播上左右两个控制按钮，分别点击可以滚动到上一张和下一张 --&gt; &lt;!-- 此处需要注意的是 该a链接的href属性必须指向需要控制的轮播图ID --&gt; &lt;!-- 另外a链接中的data-slide="prev"代表点击该链接会滚到上一张，如果设置为next的话则相反 --&gt; &lt;a class="left carousel-control" href="#轮播图的ID" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;上一张&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#轮播图的ID" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;下一张&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 由于轮播图片超宽造成的影响 美工为了在不同屏幕下更好地展示将图片两边做的非常宽，但是我们大多数情况的页面宽度都无法满足这样的图片宽度 而且Bootstrap的样式中默认将图片的max-width设置为100%； 造成界面图片缩放 想在一个较小屏幕下展示一个超宽的图片，并让图片居中显示 两种办法： 换用背景图的方式，background-position: center center; 使img元素绝对定位，left:50%，margin-left: -width/2 background使用 将容器的高度固定（410px） 将轮播图改为背景显示 由于可能图片的高度不一定是410px 所以需要设置css3中的background-size background-size length 如 background-size: 100px 100px，将背景图固定到多大尺寸 percentage 如 background-size: 90% 90%，以百分比的形式设置背景大小 cover 1.背景图片等比例缩放 2.让背景图相对较小边放大到目标容器大小结束 如：一张100*200的背景图放到一个300*400的盒子中，最终背景图片的大小是300*600 因为背景图的较小边为100，将100放大到目标容器300的宽度，放大了3倍，最终结果300*600 contain 1.背景图片等比例缩放 2.让背景图相对较大边放大到目标容器大小结束 如：一张100*200的背景图放到一个300*400的盒子中，最终背景图片的大小是200*400 因为背景图的较大边为200，将200放大到目标容器400的高度，放大了2倍，最终结果200*400 democover contain 图片响应式 目的 各种终端都需要正常显示图片 移动端应该使用更小（体积）的图片 实现方式 将元素中直接设置的图片背景删除，换成两个data-属性（如：data-img-sm=”小图路径”，data-img-lg=”大图路径”） 通过JS的方式获取屏幕的宽度； 判断屏幕宽度是否小于一定的值（如：768） 根据判断情况决定使用具体的大图还是小图 12345678910111213141516// 获取屏幕宽度var windowWidth = $(window).width();// 判断屏幕属于大还是小var isSmallScreen = windowWidth &lt; 768;// 根据大小为界面上的每一张轮播图设置背景// $('#main_ad &gt; .carousel-inner &gt; .item') // 获取到的是一个DOM数组（多个元素）$('#main_ad &gt; .carousel-inner &gt; .item').each(function(i, item) &#123; // 因为拿到是DOM对象 需要转换 var $item = $(item); // var imgSrc = $item.data(isSmallScreen ? 'image-xs' : 'image-lg'); var imgSrc = isSmallScreen ? $item.data('image-xs') : $item.data('image-lg'); // 设置背景图片 $item.css('backgroundImage', 'url("' + imgSrc + '")');&#125;); window resize事件 由于上一步我们实现的过程是指在页面加载完成判断一次， 当用户手动调整页面宽度过后没有及时发生变化， 所以我们可以通过window的resize事件中重新完成以上操作来解决这个问题 1234function 窗口变化后执行的函数名()&#123; // 具体的操作&#125;$(window).on('resize', 窗口变化后执行的函数名); 这个事件只会在窗口尺寸发生变化后执行，但是我们需要一开始时执行一次 12...$(window).on('resize', 窗口变化后执行的函数名).trigger('resize'); 小图片不需要使用背景的方式 小图如果还是使用背景的方式，当屏幕特别小时，效果很差 所以当使用小图时，改用img的方式 123456// 因为我们需要小图时 尺寸等比例变化，所以小图时我们使用img方式if (isSmallScreen) &#123; $item.html('&lt;img src="' + imgSrc + '" alt="" /&gt;');&#125; else &#123; $item.empty();&#125; 按照目前的情况，如果是小图展示则不需要给容器加上410px的固定高度 所以我们可以通过CSS媒体查询的方式解决 12345678910111213#main_ad &gt; .carousel-inner &gt; .item &#123; background-repeat: no-repeat; background-position: center center; background-size: cover;&#125;@media (min-width: 768px) &#123; #main_ad &gt; .carousel-inner &gt; .item &#123; height: 410px; &#125;&#125;#main_ad &gt; .carousel-inner &gt; .item &gt; img &#123; width: 100%;&#125; 网站特性网格系统 该板块当屏幕为中等尺寸时分为3列，较小屏幕是分为2列 所以使用网格系统划分 1234&lt;div class="col-sm-6 col-md-4"&gt; &lt;!-- ... --&gt;&lt;/div&gt;&lt;!-- ... --&gt; 媒体对象样式 每一个小块的样式可以通过Bootstrap中的媒体对象样式实现 1234567891011&lt;a href="#"&gt; &lt;div class="media"&gt; &lt;div class="media-left"&gt; &lt;i class="icon-uniE907"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;支付交易保障&lt;/h4&gt; &lt;p&gt;银联支付全称保证支付安全&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/a&gt; 响应式辅助类型 整个板块在超小屏幕下是隐藏起来的 只需要给当前板块加上hidden-xs的class 预约投标pull-left 左边文字段落 pull-right 右边文字段落 投资产品Tab选项卡 选项卡功能可以通过Bootstrap中提供的相应组件实现http://v3.bootcss.com/javascript/#tabs 1234567891011121314151617181920&lt;div class="container"&gt; &lt;!-- 所有的选项卡标签，每个标签点击分别对应面板展示出来 --&gt; &lt;ul class="nav nav-tabs" role="tablist"&gt; &lt;!-- 下面的li定义了一个选项卡的标签，其中a标签的href属性指向的就是对应要展开的面板ID aria-controls属性是说当前a链接控制的是哪个元素（注意此属性和功能无关，只是语义） 注意一定要给a标签加上data-toggle="tab"，如果不加则boostrap无法知道这是一个选项卡标签，也就不会有相应的效果 --&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#第一个标签的ID" aria-controls="第一个标签的ID" role="tab" data-toggle="tab"&gt;标签页1&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#第二个标签的ID" aria-controls="第二个标签的ID" role="tab" data-toggle="tab"&gt;标签页2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- Tab panes --&gt; &lt;div class="tab-content"&gt; &lt;!-- .tab-pane定义当前是一个tab面板，通过id和选项卡标签关联起来 --&gt; &lt;div role="tabpanel" class="tab-pane active" id="第一个标签的ID"&gt; &lt;!-- 标签展开后的内容 --&gt; &lt;/div&gt; &lt;div role="tabpanel" class="tab-pane" id="第二个标签的ID"&gt;...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 网格系统 和网站特色板块的网格系统定义一样 ::before ::after1234567891011121314151617181920.panel-czbk &gt; .panel-heading::before,.panel-czbk &gt; .panel-heading::after &#123; content: ' '; width: 16px; height: 16px; border-radius: 8px; background-color: #f0f0f0; position: absolute;&#125;.panel-czbk &gt; .panel-heading::before &#123; top: -8px; left: -8px;&#125;.panel-czbk &gt; .panel-heading::after &#123; bottom: -8px; left: -8px; box-shadow: 0 2px 1px #ccc inset;&#125; tooltip插件 注意，bootstrap中的tooltip插件必须通过js方式初始化 选项卡标签横向滚动 要给ul加一个容器，这个容器有横向滚动条 动态设置ul的宽度，宽度是根据内容大小决定的width= sum (li.width) 新闻资讯Tab选项卡响应式偏移合作伙伴相邻兄弟选择器登录对话框模态框表单样式导航吸顶affix组件深度自定义http://v3.bootcss.com/customize通过 Less 文件修改version 4http://www.cnblogs.com/micua/p/bootstrap-version4-alpha.html]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day6]]></title>
    <url>%2FVue-js%2F2019%2F05%2F11%2FVue-Day6.html</url>
    <content type="text"><![CDATA[继续介绍webpack以及Element饿了么组件 Vue.js - day6注意：有时候使用npm i node-sass -D装不上，这时候，就必须使用 cnpm i node-sass -D 在普通页面中使用render函数渲染组件在webpack中配置.vue组件页面的解析 运行cnpm i vue -S将vue安装为运行依赖； 运行cnpm i vue-loader vue-template-compiler -D将解析转换vue的包安装为开发依赖； 运行cnpm i style-loader css-loader -D将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式； 在webpack.config.js中，添加如下module规则： 123456789101112module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.vue$/, use: 'vue-loader' &#125; ] &#125; 创建App.js组件页面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt; &lt;div&gt; &lt;h1&gt;这是APP组件 - &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h3&gt;我是h3&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象export default &#123; data() &#123; return &#123; msg: 'OK' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1 &#123; color: red;&#125;&lt;/style&gt; 创建main.js入口文件： 12345678910111213141516171819202122// 导入 Vue 组件import Vue from 'vue'// 导入 App组件import App from './components/App.vue'// 创建一个 Vue 实例，使用 render 函数，渲染指定的组件var vm = new Vue(&#123; el: '#app', render: c =&gt; c(App)&#125;); 在使用webpack构建的Vue项目中使用模板对象？ 在webpack.config.js中添加resolve属性：12345resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125; &#125; ES6中语法使用总结 使用 export default 和 export 导出模块中的成员; 对应ES5中的 module.exports 和 export 使用 import ** from ** 和 import &#39;路径&#39; 还有 import {a, b} from &#39;模块标识&#39; 导入其他模块 使用箭头函数：(a, b)=&gt; { return a-b; } 在vue组件页面中，集成vue-router路由模块vue-router官网 导入路由模块： 12import VueRouter from 'vue-router' 安装路由模块： 12Vue.use(VueRouter); 导入需要展示的组件: 1234import login from './components/account/login.vue'import register from './components/account/register.vue' 创建路由对象: 1234567891011121314var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;); 将路由对象，挂载到 Vue 实例上: 12345678910111213141516var vm = new Vue(&#123; el: '#app', // render: c =&gt; &#123; return c(App) &#125; render(c) &#123; return c(App); &#125;, router // 将路由对象，挂载到 Vue 实例上&#125;); 改造App.vue组件，在 template 中，添加router-link和router-view： 12345678&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 组件中的css作用域问题抽离路由为单独的模块使用 饿了么的 MintUI 组件Github 仓储地址 Mint-UI官方文档 导入所有MintUI组件： 12import MintUI from 'mint-ui' 导入样式表： 12import 'mint-ui/lib/style.css' 在 vue 中使用 MintUI： 12Vue.use(MintUI) 使用的例子： 12&lt;mt-button type="primary" size="large"&gt;primary&lt;/mt-button&gt; 使用 MUI 组件官网首页 文档地址 导入 MUI 的样式表： 12import '../lib/mui/css/mui.min.css' 在webpack.config.js中添加新的loader规则： 12&#123; test: /\.(png|jpg|gif|ttf)$/, use: 'url-loader' &#125; 根据官方提供的文档和example，尝试使用相关的组件 将项目源码托管到oschina中 点击头像 -&gt; 修改资料 -&gt; SSH公钥 如何生成SSH公钥 创建自己的空仓储，使用 git config --global user.name &quot;用户名&quot; 和 git config --global user.email ***@**.com 来全局配置提交时用户的名称和邮箱 使用 git init 在本地初始化项目 使用 touch README.md 和 touch .gitignore 来创建项目的说明文件和忽略文件； 使用 git add . 将所有文件托管到 git 中 使用 git commit -m &quot;init project&quot; 将项目进行本地提交 使用 git remote add origin 仓储地址将本地项目和远程仓储连接，并使用origin最为远程仓储的别名 使用 git push -u origin master 将本地代码push到仓储中 App.vue 组件的基本设置 头部的固定导航栏使用 Mint-UI 的 Header 组件； 底部的页签使用 mui 的 tabbar; 购物车的图标，使用 icons-extra 中的 mui-icon-extra mui-icon-extra-cart，同时，应该把其依赖的字体图标文件 mui-icons-extra.ttf，复制到 fonts 目录下！ 将底部的页签，改造成 router-link 来实现单页面的切换； Tab Bar 路由激活时候设置高亮的两种方式： 全局设置样式如下： 123456.router-link-active&#123; color:#007aff !important; &#125; 或者在 new VueRouter 的时候，通过 linkActiveClass 来指定高亮的类： 1234567891011121314// 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/home' &#125; ], linkActiveClass: 'mui-active' &#125;); 实现 tabbar 页签不同组件页面的切换 将 tabbar 改造成 router-link 形式，并指定每个连接的 to 属性； 在入口文件中导入需要展示的组件，并创建路由对象： 12345678910111213141516171819202122232425262728293031323334// 导入需要展示的组件import Home from './components/home/home.vue'import Member from './components/member/member.vue'import Shopcar from './components/shopcar/shopcar.vue'import Search from './components/search/search.vue'// 创建路由对象var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/home' &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/member', component: Member &#125;, &#123; path: '/shopcar', component: Shopcar &#125;, &#123; path: '/search', component: Search &#125; ], linkActiveClass: 'mui-active'&#125;); 使用 mt-swipe 轮播图组件 假数据： 12345678910lunbo: [ 'http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg', 'http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg', 'http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg' ] 引入轮播图组件： 123456789101112131415161718&lt;!-- Mint-UI 轮播图组件 --&gt; &lt;div class="home-swipe"&gt; &lt;mt-swipe :auto="4000"&gt; &lt;mt-swipe-item v-for="(item, i) in lunbo" :key="i"&gt; &lt;img :src="item" alt=""&gt; &lt;/mt-swipe-item&gt; &lt;/mt-swipe&gt; &lt;/div&gt; &lt;/div&gt; 在.vue组件中使用vue-resource获取数据 运行cnpm i vue-resource -S安装模块 导入 vue-resource 组件 12import VueResource from 'vue-resource' 在vue中使用 vue-resource 组件 12Vue.use(VueResource);]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day5]]></title>
    <url>%2FVue-js%2F2019%2F05%2F11%2FVue-Day5.html</url>
    <content type="text"><![CDATA[本文介绍babel以及Webpack的使用方式，之后会补上具体操作 Webpack以及babel的配置 Vue.js - Day5 - Webpack在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack官网 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑： 1234567// 导入jquery类库 import $ from 'jquery' // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor','lightblue'); // 设置奇数行背景色 $('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理：1webpack src/js/main.js dist/bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：1234567891011// 导入处理路径的模块var path = require('path');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;&#125; 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：1"dev": "webpack-dev-server --contentBase src" 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： 123456789101112131415161718// 导入处理路径的模块var path = require('path');// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 &#125;) ]&#125; 修改package.json中script节点中的dev指令如下： 1"dev": "webpack-dev-server" 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：1"dev": "webpack-dev-server --hot --port 4321 --open" 方式2： 修改webpack.config.js文件，新增devServer节点如下： 12345devServer:&#123; hot:true, open:true, port:4321 &#125; 在头部引入webpack模块： 1var webpack = require('webpack'); 在plugins节点下新增： 1new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件： 12345module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;//处理css文件的规则 ] &#125; 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：1&#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：1&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块： 1&#123; test: /\.(png|jpg|gif)$/, use: 'url-loader' &#125; 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码： 1&#123; test: /\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' &#125;, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： 1&#123; test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下： 1234&#123; "presets":["es2015", "stage-0"], "plugins":["transform-runtime"]&#125; 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法； 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day4]]></title>
    <url>%2FVue-js%2F2019%2F05%2F11%2FVue-Day4.html</url>
    <content type="text"><![CDATA[本文主要介绍父子组件的调用方式，以及Vue.js中重要的路由思想 Vue.js - Day4父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', props: ['finfo'] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func="getMsg"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 组件中data和props的区别评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则 &#125;); 使用tag属性指定router-link渲染的标签类型设置路由重定向设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: '/register/:id', component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;' &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: "/login", component: login &#125;, &#123; path: "/register", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是 npm 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day3]]></title>
    <url>%2FVue-js%2F2019%2F05%2F11%2FVue-Day3.html</url>
    <content type="text"><![CDATA[主要介绍组件化，组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可； Vue.js - Day3定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend(&#123; template: '&lt;h1&gt;登录&lt;/h1&gt;' &#125;); Vue.component('login', login); 直接使用 Vue.component 方法： 123Vue.component('register', &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125;); 将模板字符串，定义到script标签种： 123&lt;script id="tmpl" type="x-template"&gt; &lt;div&gt;&lt;a href="#"&gt;登录&lt;/a&gt; | &lt;a href="#"&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt; 同时，需要使用 Vue.component 来定义组件：123Vue.component('account', &#123; template: '#tmpl' &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 12345678910111213Vue.component('account', &#123; template: '#tmpl', data() &#123; return &#123; msg: '大家好！' &#125; &#125;, methods:&#123; login()&#123; alert('点击了登录按钮'); &#125; &#125; &#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示 使用components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // 定义子组件 account: &#123; // account 组件 template: '&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;', // 在这里使用定义的子组件 components: &#123; // 定义子组件的子组件 login: &#123; // login 组件 template: "&lt;h3&gt;这是登录组件&lt;/h3&gt;" &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt; 引用组件： 123&lt;div id="app"&gt; &lt;account&gt;&lt;/account&gt; &lt;/div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 12345&lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;my-com1 v-if="flag"&gt;&lt;/my-com1&gt; &lt;my-com2 v-else="flag"&gt;&lt;/my-com2&gt; &lt;/div&gt; Vue实例定义： 123456789101112131415161718&lt;script&gt; Vue.component('myCom1', &#123; template: '&lt;h3&gt;奔波霸&lt;/h3&gt;' &#125;) Vue.component('myCom2', &#123; template: '&lt;h3&gt;霸波奔&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819202122// 登录组件 const login = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component('login', login); // 注册组件 const register = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;注册组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component('register', register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' &#125;, methods: &#123;&#125; &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 12345678&lt;div id="app"&gt; &lt;a href="#" @click.prevent="comName='login'"&gt;登录&lt;/a&gt; &lt;a href="#" @click.prevent="comName='register'"&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;transition mode="out-in"&gt; &lt;component :is="comName"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt; 添加切换样式： 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;/style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', props: ['finfo'] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func="getMsg"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则 &#125;); 设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: '/register/:id', component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;' &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: "/login", component: login &#125;, &#123; path: "/register", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day2]]></title>
    <url>%2FVue-js%2F2019%2F05%2F11%2FVue-Day2.html</url>
    <content type="text"><![CDATA[Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） Vue.js - Day2品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end('404'); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log('server running at http://127.0.0.1:3000');&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构： 1234567&lt;div id="app"&gt; &lt;input type="button" value="动起来" @click="myAnimate"&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name="fade"&gt; &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例： 123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;); 定义两组类样式： 12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt; 定义 transition 及属性： 123456&lt;transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="&#123; enter: 500, leave: 800 &#125;"&gt; &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数： 123456789&lt;div id="app"&gt; &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125; 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式： 123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： 1234567&lt;div id="app"&gt; &lt;input type="text" v-model="txt" @keyup.enter="add"&gt; &lt;transition-group tag="ul" name="list"&gt; &lt;li v-for="(item, i) in list" :key="i"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构： 1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; txt: '', list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = ''; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJs学习笔记-Day1]]></title>
    <url>%2FVue-js%2F2019%2F05%2F11%2FVue-Day1.html</url>
    <content type="text"><![CDATA[Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架,本文主要讨论Vue基本的语法和概念 Vue.js - Day1什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 12345678910&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type="button" value="开启" v-on:click="go"&gt; &lt;input type="button" value="停止" v-on:click="stop"&gt; &lt;/div&gt; Vue实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; info: '猥琐发育，别浪~！', intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;input type="text" v-model="n1"&gt; &lt;select v-model="opt"&gt; &lt;option value="0"&gt;+&lt;/option&gt; &lt;option value="1"&gt;-&lt;/option&gt; &lt;option value="2"&gt;*&lt;/option&gt; &lt;option value="3"&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"&gt; &lt;input type="button" value="=" v-on:click="getResult"&gt; &lt;input type="text" v-model="result"&gt;&lt;/div&gt; Vue实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '0' &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class="['red', 'thin']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class="['red', 'thin', isactive?'active':'']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class="['red', 'thin', &#123;'active': isactive&#125;]"&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class="&#123;red:true, italic:true, active:true, thin:true&#125;"&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style="&#123;color: 'red', 'font-size': '40px'&#125;"&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="h1StyleObj"&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;, h1StyleObj2: &#123; fontStyle: 'italic' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="[h1StyleObj, h1StyleObj2]"&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for="(item, i) in list"&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for="(val, key, i) in userInfo"&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 12&lt;p v-for="i in 10"&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-排序]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F11%2FDataStructure-07.html</url>
    <content type="text"><![CDATA[提到排序，鸡皮疙瘩都起来了，排序思想固然是好玩的，但是代码的实现也是无比蛋疼，记忆起来噩梦级别，之后会在这里补充一些排序算法相关的练习题 排序习题 听首歌先，缓解接下来乏味的过程，Lantern是我很喜欢的挪威剧中的配乐 前言我们根据待排序记录是否全部被放置在内存中，将排序分为内排序和外排序两种，外排序需要在内外存之间多次交换数据才能进行。我们本章主要讲的是内排序的算法 我们根据排序过程中借助的主要操作，将内排序分为： 插入排序类 包括直接插入排序跟希尔排序 选择排序类 包括简单选择排序和堆排序 交换排序类 包括冒泡排序跟快速排序 归并排序类 包括归并排序 排序的基本概念与分类 内排序与外排序 内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行 对于内排序来说，排序算法的性能主要是受3个方面影响 时间性能 辅助空间 算法的复杂度 我们根据排序过程中借助的主要操作，将内排序分为：插入排序，交换排序，选择排序，归并排序排序用到的结构与函数123456#define MAXSIZE 10 /*用于要排序数组个数的最大值，可根据需要修改*/typedef struct&#123; int r[MAXSIZE+1]; /*用于存储要排序数组，r[0]用于哨兵或临时变量*/ int length; /*用于记录顺序表的长度*/&#125;SqList; 另外，由于排序最常用的操作是数组两元素的交换，我们将它写成函数1234567/*交换L中数组r的下标为i和j的值*/void swap(SqList *L,int i,int j)&#123; int temp = L-&gt;r[i]; L-&gt;r[i]=L-&gt;[j]; L-&gt;r[j]=temp;&#125; 冒泡排序(Bubble Sort) 冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止 冒泡实现在细节上可以有多种变化，我们将分别就3种不同的冒泡实现代码。 123456789101112131415/*对顺序表L作交换排序(冒泡排序初级版)*/void BubbleSort0(SqList *L)&#123; int i,j; for(i=1;i&lt;L-&gt;length;i++) &#123; for(j=i+1;i&lt;L-&gt;length;j++) &#123; if(L-&gt;r[i] &gt; L-&gt;r[j]) &#123; swap(L,i,j); &#125; &#125; &#125;&#125; 这段代码严格意义上，不算是标准的冒泡排序算法，因为它不满足两两比较相邻记录的冒泡排序思想，它更应该是最最简单的交换排序而已，而且效率很低 以下是正宗的冒泡排序1234567891011121314void BubbleSort(SqList *L)&#123; int i,j; for(i=1;i&lt;L-&gt;length;i++) &#123; for(j=L-&gt;length-1;j&gt;=i;j--) /*注意j是从后往前循环*/ &#123; if(L-&gt;r[j] &gt; L-&gt;r[j+1]) /*若前者大于后者(注意与前者的差异)*/ &#123; swap(L,j,j+1); &#125; &#125; &#125;&#125; 冒泡排序优化123456789101112131415161718/*对顺序表L作改进冒泡算法*/void BubbleSort2(SqList *L)&#123; int i,j; Status flag=TRUE; /*flag用来作为标记*/ for(i=1;i&lt;L-&gt;length &amp;&amp; flag;i++) /*若flag为false则退出循环*/ &#123; flag = FALSE; /*初始为false*/ for(j=L-&gt;length-1;j&gt;=i;j--) &#123; if(L-&gt;r[j] &gt; L-&gt;r[j+1]) &#123; swap(L,j,j+1); flag=TRUE; /*若有数据交换，则flag为true*/ &#125; &#125; &#125;&#125; 冒泡排序法复杂度分析，总时间复杂度为O(n^2^) 简单选择排序(Simple Selection Sort) 简单选择排序法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和i个记录交换之123456789101112131415void SelectSort(SqList *L)&#123; int i,j; for(i=1;i&lt;L-&gt;length;i++) &#123; min = i; /*将当前下标定义为最小值下标*/ for(j=i+1;j&lt;=L-&gt;length;j++) /*循环之后的数据*/ &#123; if(L-&gt;r[min]&gt;L-&gt;r[j]) /*如果有小于当前最小值的关键字*/ min=j; /*将此关键字的下标赋值给min*/ &#125; if(i!=min) /*若min不等于i，说明找到最小值，交换*/ swap(L,i,min); &#125;&#125; 简单选择排序复杂度仍然为O(n^2^)，尽管如此，但是性能上还是要略优于冒泡排序 直接插入排序(Straight Insertion Sort) 直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表1234567891011121314void InsertSort(SqList *L)&#123; int i,j; for(i=2;i&lt;=L-&gt;length;i++) &#123; if(L-&gt;r[i] &lt; L-&gt;r[i-1]) /*需将L-&gt;r[i]插入有序子表*/ &#123; L-&gt;r[0]=L-&gt;r[i]; /*设置哨兵*/ for(j=i-1;L-&gt;r[j] &gt; L-&gt;r[0];j--) L-&gt;r[j+1]=L-&gt;r[j]; /*记录后移*/ L-&gt;r[j+1]=L-&gt;r[0]; /*插入到正确位置*/ &#125; &#125;&#125; 直接插入排序法的时间复杂度还是O(n^2^)，但是直接插入排序法比冒泡和简单选择排序的性能更好一些. 希尔排序(Shell Sort)1234567891011121314151617181920void ShellSort(SqList *L)&#123; int i,j; int increment=L-&gt;length; do &#123; increment=increment/3 + 1; /*增量序列*/ for(i=increment+1;i&lt;=L-&gt;length;i++) &#123; if(L-&gt;r[i] &lt; L-&gt;r[i-increment]) &#123; /*需将L-&gt;r[i]插入有序增量子表*/ L-&gt;r[0]=L-&gt;r[i]; /*暂存在L-&gt;r[0]*/ for(j=i-increment;j&gt;0 &amp;&amp; L-&gt;r[0] &lt; L-&gt;r[j];j-=increment) L-&gt;r[j+increment]=L-&gt;r[j]; /*记录后移，查找插入位置*/ L-&gt;r[j+increment]=L-&gt;r[0] /*插入*/ &#125; &#125; &#125; while(increment&gt;1);&#125; “增量”的选取非常关键，需要注意增量序列的最后一个增量必须等于1才行 希尔排序的时间复杂度为O(n^3/2^)，终于突破了慢速排序的时代(超越了时间复杂度为O(n^2^) 堆排序(Heap Sort) 堆是具有下列性质的完全二叉树 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆 或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 故根结点一定是堆中所有的结点的最大(小)者 12345678910111213/*对顺序表L进行堆排序*/void HeapSort(SqList *L)&#123; int i; for(i=L-&gt;length/2;i&gt;0;i--) /*把L中的r构建成一个大顶堆*/ HeapAdjust(L,i,L-&gt;length); for(i=L-&gt;length;i&gt;1;i--) &#123; swap(L,1,i); /*将堆顶记录和当前未经排序子序列的最后一个记录交换*/ HeapAdjust(L,1,i-1); /*将L-&gt;r[1..i-1]重新调整未大顶堆*/ &#125;&#125; 弄清楚i的变化是在调整哪些元素后，可以看关键的HeapAdjust(堆调整)函数是如何实现的1234567891011121314151617/*已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义*//*本函数调整L-&gt;r[s]的关键字，使L-&gt;r[s..m]成为一个大顶堆*/void HeapAdjust(SqList *L,int s,int m)&#123; int temp,j; temp=L-&gt;r[s]; for(j=2*s;j&lt;=m;j*=2) /*沿关键字较大的孩子结点向下筛选*/ &#123; if(j&lt;m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j+1]) ++j; /*j为关键字中较大的记录的下标*/ if(temp&gt;=L-&gt;r[j]) break; /*rc应插入在位置s上*/ L-&gt;r[s]=L-&gt;r[j]; s=j; &#125; L-&gt;r[s]=temp; /*插入*/&#125; 12345for(i=L-&gt;length;i&gt;1;i--)&#123; swap(L,1,i); /*将堆顶记录和当前未经排序子序列的最后一个记录交换*/ HeapAdjust(L,1,i-1); /*将L-&gt;r[1..i-1]重新调整为大顶堆*/&#125; 堆排序的时间复杂度为O(nlogn)，这在性能上显然要远远好过于冒泡，简单选择，直接插入的时间复杂度了 归并排序(Merging Sort)1234void MergeSort(SqList *L)&#123; MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);&#125; 123456789101112131415/*将SR[s..t]归并排序为TR1[s..t]*/void MSort(int SR[],int TR1[],int s,int t)&#123; int m; int TR2[MAXSIZE+1]; if(s==t) TR1[s]=SR[s]; else &#123; m=(s+t)/2; /*将SR[s..t]平分为SR[s..m]和SR[m+1..t]*/ MSort(SR,TR2,s,m); /*递归将SR[s..m]归并为有序的TR2[s..m]*/ MSort(SR,TR2,m+1,t); /*递归将SR[m+1..t]归并为有序TR2[m+1..t]*/ Merge(TR2,TR1,s,m,t); /*将TR2[s..m]和TR2[m+1..t]归并到TR1[s..]*/ &#125;&#125; 12345678910111213141516171819202122/*将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]*/void Merge(int SR[],int TR[],int i,int m,int n)&#123; int j,k,l; for(j=m+1,k=1;i&lt;=m &amp;&amp; j&lt;=n;k++) /*将SR中记录由小到大归并入TR*/ &#123; if(SR[i]&lt;SR[j]) TR[k]=SR[i++]; else TR[k]=SR[j++]; &#125; if(i&lt;=m) &#123; for(l=0;l&lt;=m-i;l++) TR[k+1]=SR[i+1] /*将剩余的SR[i..m]复制到TR*/ &#125; if(j&lt;=n) &#123; for(l=0;l&lt;=n-j;l++) TR[k+1]=SR[j+1]; /*将剩余的SR[j..n]复制到TR*/ &#125;&#125; 时间复杂度：一趟归并需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行(log2n)次，因此，总的时间复杂度为O(nlogn)，空间复杂度为O(n+logn) 非递归实现归并排序12345678910111213/*对顺序表L作归并非递归排序*/void MergeSort2(SqList *L)&#123; int* TR=(int*)malloc(L-&gt;length*sizeof(int)); /*申请额外空间*/ int k=1; while(k&lt;L-&gt;length) &#123; MergePass(L-&gt;r,TR,k,L-&gt;length); k=2*k; /*子序列长度加倍*/ MergePass(TR,L-&gt;r,k,L-&gt;length); k=2*k; /*子序列长度加倍*/ &#125;&#125; 从代码中，我们能感受到，非递归的迭代做法更加直接了当，从最小的序列开始归并直至完成，不需要像归并的递归算法一样，需要先拆分递归，再归并退出递归12345678910111213141516/*将SR[]中相邻长度为s的子序列两两归并到TR[]*/void MergePass(int SR[],int TR[],int s,int n)&#123; int i=1; int j; while(i &lt;= n-2*s+1) &#123; Merge(SR,TR,i,i+s-1,i+2*s-1); /*两两归并*/ i=i+2*s; &#125; if(i&lt;n-s+1) /*归并最后两个序列*/ Merge(SR,TR,i,i+s-1,n); else /*若最后只剩下单个子序列*/ for(j=1;j&lt;=n;j++) TR[j]=SR[j];&#125; 非递归的迭代方法，避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O(n)，而且避免递归也在时间性能上有一定的提升，应该说，使用归并排序时，尽量考虑非递归方法。 快速排序(Quick Sort)1234void QuickSort(SqList *L)&#123; QSort(L,1,L-&gt;length);&#125; 1234567891011/*对顺序表L中的子序列L-&gt;r[low..high]作快速排序*/void QSort(SqList *L,int low,int high)&#123; int pivot; if(low&lt;high) &#123; pivot=Partition(L,low,high); /*将L-&gt;r[low..high]一分为二，算出枢轴值pivot*/ QSort(L,low,pivot-1); /*对低子表递归排序*/ QSort(L,pivot+1,high); /*对高子表递归排序*/ &#125;&#125; Partition函数要做的，就是先选取当中一个关键字，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边值都比它大，我们将这样的关键字称为枢轴(pivot)1234567891011121314151617/*交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置*//*此时在它之前(后)的记录均不大(小)与它*/int Partition(SqList *L,int low,int high)&#123; int pivotkey; pivotkey=L-&gt;r[low]; /*用子表的第一个记录作枢轴记录*/ while(low&lt;high) /*从表的两端交替向中间扫描*/ &#123; while(low&lt;high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high--; swap(L,low,high); /*将比枢轴记录小的记录交换到低端*/ while(low&lt;high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) low++; swap(L,low,high); /*将比枢轴记录大的记录交换到高端*/ &#125; return low; /*返回枢轴所在位置*/&#125; 在最优的情况下，快速排序算法的时间复杂度为O(nlogn) 证明过程了解一下 快速排序优化 优化选取枢轴 三数取中(median-of-three)法，即选取三个关键字先进行排序，将中间数作为枢纽，一般是取左端，右端，中间三个数，也可以随机选取。这样至少这个中间数不会是最小或最大的数。 故在Partition函数代码的第3行与第4行之间增加这样一段代码 12345678910int pivotkey;int m = low + (high - low)/2; /*计算数组中间的元素下标*/if(L-&gt;r[low] &gt; L-&gt;r[high]) swap(L,low,high); /*交换左端与右端数据，保证左端较小*/if(L-&gt;r[m] &gt; L-&gt;r[high]) swap(L,high,m); /*交换中间与右端数据，保证中间较小*/if(L-&gt;r[m] &gt; L-&gt;r[low]) swap[L,m,low]; /*交换中间与左端数据，保证左端较小*//*此时L，r[low]已经为整个序列左中右三个关键字的中间值*/pivotkey = L-&gt;[low]; /*用子表的第一个记录作为枢轴记录*/ 当然三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey，但是对于非常大的待排序的序列来说还是不足以保证能够选出一个好的pivotkey，因此还有个方法叫九数取中(median-of-nine) 三次三数取中，然后再进行一次三数取中 2.优化不必要的交换123456789101112131415161718/*快速排序优化算法*/int Partition1(SqList *L,int low,int high)&#123; int pivotkey; //这里省略三数取中代码 pivotkey = L-&gt;r[low]; /*用于表的第一个记录作枢纽记录*/ L-&gt;r[0]=pivotkey; /将枢纽关键字备份到L-&gt;r[0]/ while(low&lt;high) /*从表的两端交替向中间扫描*/ &#123; while(low&lt;high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high-- L-&gt;r[low]=L-&gt;r[high]; /采用替换而不是交换的方式进行操作/ while(low&lt;high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) low++; L-&gt;r[high]=L-&gt;r[low]; /采用替换而不是交换的方式进行操作/ &#125; L-&gt;r[low]=L-&gt;r[0]; /将枢纽数值替换回L.r[low]/ return low; /*返回枢轴所在位置*/&#125; 3.优化小数组时的排序方案1234567891011121314#define MAX_LENGTH_INSERT_SORT 7 /*数组长度阀值*//*对顺序表L中的子序列L.r[low..high]作快速排序*/void QSort(SqList &amp;L,int low,int high)&#123; int pivot; if((high-low)&gt;MAX_LENGTH_INSERT_SORT) &#123;/*当high-low大于常数时用快速排序*/ pivot=Partition(L,low,high); /*将L.r[low..high]一分为二，并算出枢轴值pivot*/ QSort(L,low,pivot-1); /*第低子表递归排序*/ QSort(L,pivot+1,high); /*对高子表递归排序*/ &#125; else /*当high-low小于等于常数时用直接插入排序*/ InsertSort(L);&#125; 如果数组小还不如直接插入排序来得更快(直接插入是简单排序中性能最好的) 优化递归操作 我们对QSort实施尾递归优化123456789101112131415void QSort1(SqList *L,int low,int high)&#123; int pivot; if((high-low)&gt;MAX_LENGTH_INSERT_SORT) &#123; while(low&lt;high) &#123; pivot=Partition1(L,low,high); /*L.r[low..high]一分为二，算出枢轴值*/ QSort1(L,low,pivot-1); /*对低子表递归排序*/ low=pivot+1; /*尾递归*/ &#125; &#125; else InsertSort(L);&#125; 总结回顾从算法的简单性来看，我们将7种算法分为两类： 简单算法：冒泡，简单选择，直接插入 改进算法：希尔，堆，归并，快速 从平均情况来看，最后3种改进算法要胜过希尔算法，并远远胜于前3种简单算法 从最好情况来看，反而冒泡和直接插入排序更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法。 从最坏情况来看，堆排序和归并排序又强过快速排序以及其他简单排序。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-查找]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F11%2FDataStructure-06.html</url>
    <content type="text"><![CDATA[查找，说到底也是排序思想的基础，主要是针对树的查找 前言：查找(Searching)就是根据给定的某个值，在查找表中确定一个其关键字等于定值的数据元素(或记录) 查找表(Search Table)是由同一类型的数据元素(或记录)构成的集合 关键字(Key)是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项(字段)，我们称为关键码 若此关键字可以唯一地标识一个记录，则称此关键字为主关键字(Primary Key)，注意这意味着，对不同的记录，其主关键字均不相同，主关键字所在的数据项称为主关键码 那么对于那些可以识别多个数据元素(或记录)的关键字，我们称为次关键字(Secondary Key)，次关键字可以理解为是不以唯一标识一个数据元素(或记录)的关键字，它对应的数据项就是次关键码 查找表按照操作方式分两大种： 静态查找表(Static Search Table)：只作查找操作的操作表 动态操作表(Dynamic Search Table):在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素 顺序表查找 顺序查找(Sequential Search)又叫线性查找，是最基本的查找技术。 1234567891011/*顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字*/int Sequential_Search(int *a,int n,int key)&#123; int i; for(i=1;i&lt;n;i++) &#123; if(a[i]==key) return i; &#125; return 0;&#125; 到这里并非足够完美，因为每次循环时都需要对i是否越界，即是否小于等于n进行判断，我们不妨设置一个哨兵 123456789101112/*顺序表查找优化：有哨兵顺序查找*/int Sequential_Search2(int *a,int n, int key)&#123; int i; a[0]=key; /*设置a[0]为关键字值，我们称之为“哨兵”*/ i=n; /*循环从数组尾部开始*/ while(a[i]!=key) &#123; i--; &#125; return i; /*返回0则说明查找失败*/&#125; 对于这种顺序查找算法来说，查找成功最好的情况就是第一个位置就找到了，算法时间复杂度为O(1)，最坏的情况是最后一个位置才找到，需要n次比较，时间复杂度为O(n)，当查找不成功时，需要n+1次比较，时间复杂度为O(n) 我们推导过，关键字在任何一位置的概率是相同的，所以平均查找次数为(n+1)/2，所以最终时间复杂度为O(n) 有序表查找折半查找(Binary Search) 又称为二分查找，它的前提是线性表中的记录必须是关键码有序(通常从小到大有序)，线性表必须采用顺序存储。 123456789101112131415161718/*折半查找*/int Binary_Search(int *a,int n,int key)&#123; int low,high,mid; low=1; /*定义最低下标为记录首位*/ high=n; /*定义最高下标为记录末位*/ while(low&lt;=mid) &#123; mid=(low+high)/2; /*折半*/ if(key&lt;a[mid]) /*若查找值比中值小*/ high=mid-1; /*最高下标调整到中位下标小一位*/ else if(key&gt;a[mid]) /*若查找值比中值大*/ low=mid+1; /*最低下标调整到中位下标大一位*/ else return mid; /*若相等则说明mid即为查到的位置*/ &#125; return 0;&#125; 因此最终折半算法的时间复杂度为O(logn)，它显然远远好于顺序查找的O(n)时间复杂度 插值查找(Interpolation Search) 换句话说，我们只需要在折半查找算法的代码中更改一下第8行的代码 如下 1mid = low + (high-low) * (key-a[low])/(a[high]-a[low]); /*插值*/ 我们得到了另一种有序表查找算法，差值查找法，插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法。 其核心就在于插值的计算公式，应该说，从时间复杂度来看，也是O(logn)，但是对于表长较大的，关键字分布又比较均匀的查找表来说，插值查找算法的平均性能要比折半查找好很多 斐波那契额查找(Fibonacci Search)1234567891011121314151617181920212223242526272829303132333435/*斐波那契查找*/int Fibonacci_Search(int *a,int n,int key)&#123; int low,high,mid,i,k; low=1; /*定义最低下标为记录首位*/ high=n; /*定义最高下标为记录末位*/ k=0; while(n&gt;F[k]-1) /*计算n位于斐波那契数列的位置*/ k++; for(i=n;i&lt;F[k]-1;i++) /*将不满的数值补全*/ a[i]=a[n]; while(low&lt;=high) &#123; mid=low+F[k-1]-1; /*计算当前分割的下标*/ if(key&lt;a[mid]) /*若查找记录小于当前分隔记录*/ &#123; high=mid-1; /*最高下标调整到分隔下标mid-1处*/ k=k-1; /*斐波那契数列下标减一位*/ &#125; else if(key&gt;a[mid]) /*若查找记录大于当前分隔记录*/ &#123; low=mid+1; /*最低下标调整到分隔下标mid+1处*/ k=k-2; /*斐波那契数列下标减两位*/ &#125; else &#123; if(mid&lt;=n) return mid; /*若相等则说明mid即为查找到的位置*/ else return n; /*若mid&gt;n说明是补全数值，返回n*/ &#125; &#125; return 0;&#125; 线索索引查找 索引就是把一个关键字与它对应的记录相关联的过程，所以线性索引就是将索引项集合组织为线性结构，也称为索引表，我们重点介绍三种线性索引：稠密索引，分块索引和倒排索引 二叉排序树(Binary Sort Tree) 又称为二叉寻找树。它或者是一棵空树，或者是具有下列性质的二叉树 若它的左子树不空，则左子树上所有结点的值均小于它 的根结构的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值； 它的左，右子树也分别为二叉排序树 二叉排序树查找操作 123456/*二叉树的二叉链表结点结构定义*/typedef struct BiTNode /*结点结构*/&#123; int data; /*结点数据*/ struct BiTNode *lchild,*rchild; /*左右孩子指针*/&#125;BiTNode,*BiTree; 123456789101112131415161718192021/*递归查找二叉排序树T中是否存在key*//*指针f指向T的双亲，其初始调用值为NULL*//*若查找成功，则指针p指向该数据元素结点，并返回TRUE*//*否则指针p指向查找路径上访问的最后一个结点并返回FALSE*/Status SearchBST(BiTree T,int key,BiTree f,BiTree *p)&#123; if(!T) /*查找不成功*/ &#123; *p = f; return FALSE; &#125; else if(key == T-&gt;data) /*查找成功*/ &#123; *p = T; return TRUE; &#125; else if(key&lt;T-&gt;data) return SearchBST(T-&gt;lchild,key,T,p); /*在左子树继续查找*/ else return SearchBST(T-&gt;rchild,key,T,p); /*在右子树继续查找*/&#125; 二叉排列树插入操作 123456789101112131415161718192021/*当二叉排序树T中不存在关键字等于key的数据元素时*//*插入key并返回TRUE,否则返回FALSE*/Status InsertBST(BiTree *T,int key)&#123; BiTree p,s; if(!SearchBST(*T,key,NULL,&amp;p)) /*查找不成功*/ &#123; s = (BiTree)malloc(sizeof(BiTNode)); s-&gt;data = key; s-&gt;lchild = s-&gt;rchild = NULL; if(!p) *T = s; /*输入s为新的根节点*/ else if(key&lt;p-&gt;data) p-&gt;lchild = s; /*插入s为左孩子*/ else p-&gt;rchild = s; /*插入s为右孩子*/ return TRUE; &#125; else return FALSE; /*树中已经有关键字相同的结点，不再输入*/&#125; 有了二叉排序树的插入代码，我们要实现二叉排序树的构建就非常容易了，比如 1234567int i;int a[10] = &#123;62,22,41,53,76,33,77,12,16,75&#125;BiTree T = NULL;for(i=0;i&lt;10;i++)&#123; InsertBST(&amp;T,a[i])&#125; 二叉排序树删除操作(三种情况) 叶子结点 仅有左或右子树的结点 左右子树都有的结点，我们来看代码，下面这个算法是递归方式对二叉排序树T查找key，查到是删除 123456789101112131415/*若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点*/Status DeleteBST(BiTree *T,int key)&#123; if(!*T) /*不存在关键字等于key的数据元素*/ return FALSE; else &#123; if(key == (*T)-&gt;data) /*找到关键字等于key的数据元素*/ return Delete(T); else if(key&lt;(*T)-&gt;data) return DeleteBST(&amp;(*T)-&gt;lchild,key); else return DeleteBST(&amp;(*T)-&gt;rchild,key); &#125;&#125; Let’s delete ! 12345678910111213141516171819202122232425262728/**/Status Delete(BiTree *p)&#123; BiTree q,s; if((*p)-&gt;rchild=NULL) /*右子树空则只需重接它的左子树*/ &#123; q=*p;*p=(*p)-&gt;lchild;free(q); &#125; else if((*p)-&gt;lchild==NULL) /*只需重接它的右子树*/ &#123; q=*p;*p=(*p)-&gt;rchild;free(q); &#125; else /*左右子树均不空*/ &#123; q=*p;s=(*p)-&gt;lchild; while(s-&gt;rchild) /*转左，然后向右到尽头(找待删结点的前驱)*/ &#123; q=s;s=s-&gt;rchild; &#125; (*p)-&gt;data=s-&gt;data; /*s指向被删结点的直接前驱*/ if(q!=*p) q-&gt;rchild=s-&gt;lchild; /*重接q的右子树*/ else q-&gt;lchild=s-&gt;lchild; /*重接q的左子树*/ free(s); &#125; return TRUE;&#125; 二叉排序树总结 二叉排序树是以链接的方式存储，保存了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。 二叉排序树的查找性能取决于二叉排序树的形状，也就是说我们希望二叉排序树是平衡的，即深度与完全二叉树相同，均为[log2n]+1，那么查找的时间复杂度也就为O(logn)，类似于折半查找，不平衡的最坏情况就是斜树，查找时间复杂度为O(n)，这等同于顺序查找 平衡二叉树(AVL树) 平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree),是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多为1. 顾名思义，这是一种高度平衡的二叉排序树，我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor) 距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树 平衡二叉树实现原理 当最小不平衡树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋。插入结点后，最小不平衡树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作 平衡二叉树实现算法1234567/*二叉树的二叉链表结点结构定义*/typedef struct BiTNode /*结点结构*/&#123; int data; /*结点数据*/ int bf; /*结点的平衡因子*/ struct BiTNode *lchild,*rchild; /*左右孩子指针*/&#125;BiTNode,*BiTree; 右旋操作 12345678910/*对以p为根的二叉排序树作右旋处理*//*处理之后p指向新的树根结点，即旋转处理之前的左子树的根节点*/void R_Rotate(BiTree *P)&#123; BiTree L; L=(*P)-&gt;lchild; /*L指向P的左子树根结点*/ (*P)-&gt;lchild=L-&gt;rchild; /*L的右子树挂接为P的左子树*/ L-&gt;rchild=(*P); *P=L; /*P指向新的根结点*/&#125; 左旋操作与右旋代码是对称的，不做解释 以下是左平衡旋转处理的函数代码 123456789101112131415161718192021222324252627282930313233#define LH +1 /*左高*/#define EH 0 /*等高*/#define RH -1 /*右高*//*对以指针T所指结点为根的二叉树作左平衡旋转处理*//*本算法结束时，指针T指向新的根结点*/void LeftBalance(BiTree *T)&#123; BiTree L,Lr; L=(*T)-&gt;lchild; /*L指向T的左子树根结点*/ switch(L-&gt;bf) &#123;/*检查T的左子树的平衡度，并作相应平衡处理*/ case LH: /*新结点插入在T的左孩子的左子树上，要作单右旋处理*/ (*T)-&gt;bf=L-&gt;bf=EH; R_Rotate(T); break; case RH: /*新结点插在T的左孩子的右子树商，要作双旋处理*/ Lr=L-&gt;rchild /*Lr指向T的左孩子的右子树根*/ switch(Lr-&gt;bf) /*修改T及其左孩子的平衡因子*/ &#123; case LH:(*T)-&gt;bf=RH; L-&gt;bf=EH; break; case EH:(*T)-&gt;bf=L-&gt;bf=EH; break; case RH: (*T)-&gt;bf=EH; L-&gt;bf=LH; break; &#125; Lr-&gt;bf=EH; L_Rotate(&amp;(*T)-&gt;lchild; /*对T的左子树作左旋平衡处理*/ R_Rotate(T); /*对T作右旋处理*/ &#125;&#125; 同样的，右平衡旋转处理的函数代码非常类似，有了这些准备，我们的主函数正式登场 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个数据元素为e的新结点并返回1，否则返回0*//*若因插入而使二叉排序树失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否*/Status InsertAVL(BiTree *T,int e,Status *taller)&#123; if(!*T) &#123; /*输入新结点，树“长高”，置taller为TRUE*/ *T=(BiTree)malloc(sizeof(BiTNode)); (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EN; *taller=TRUE; &#125; else &#123; if(e==(*T)-&gt;data) &#123; /*树中已存在和e有相同关键字的结点则不再输入*/ *taller=FALSE; return FALSE; &#125; if(e&lt;(*T)-&gt;data) &#123; /*应继续在T的左子树中进行搜索*/ if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /*未插入*/ return FALSE; if(taller) /*已插入到T的左子树且左子树“长高”*/ &#123; switch((*T)-&gt;bf) /*检查T的平衡度*/ &#123; case LH: /*原本左子树比右子树高，需要作左平衡处理*/ LeftBalance(T); *taller=FALSE; break; case EH: /*原本左右子树等高，现因左子树增高而树增高*/ (*T)-&gt;bf=LH; *taller=TRUE; break; case RH: /*原本右子树比左子树高，现左右子树等高*/ (*T)-&gt;bf=EH; *taller=FALSE; break; &#125; &#125; &#125; else &#123; /*应继续在T的右子树中进行搜索*/ if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /*未插入*/ return FALSE; if(*taller) /*已插入到T的右子树且右子树“长高”*/ &#123; switch((*T)-&gt;bf) /*检查T的平衡度*/ &#123; case LH: /*原本左子树比右子树高，现左，右子树等高*/ (*T)-&gt;bf=EH; *taller=FALSE; break; case EH: /*原本左右子树等高，现因右子树增高而树增高*/ (*T)-&gt;bf=RH; *taller=TRUE; break; case RH: /*原本右子树比左子树高，需要作右平衡处理*/ RightBalance(T); *taller=FALSE; break; &#125; &#125; &#125; &#125; return TRUE;&#125; 举例：生成平衡二叉树 12345678int i;int a[10]=&#123;3,2,1,4,5,6,7,10,9,8&#125;;BiTree T=NULL;Status taller;for(i=0;i&lt;10;i++)&#123; InsertAVL(&amp;T,a[i],&amp;taller);&#125; 不平衡的二叉排序树查找效率是非常低的，由此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们的查找时间复杂度就为O(logn)，而插入和删除也为O(logn)，这显然是比较理想的一种动态查找表算法 多路查找树(B树) 多路查找树(multl-way search tree)：其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。 2-3树：其中每一个结点都具有两个孩子(我们称它为2结点)或三个孩子(我们称它为3结点) 一个2结点包含一个元素和两个孩子(或没有孩子) 与二叉排序树类似，左子树包含的元素小于该元素，右子树同理 不过，这个2结点要么没有孩子，要么就有两个，不能只有一个孩子 一个3结点包含一小一大两个元素和三个孩子(或没有孩子) 一个3结点要么没有孩子，要么具有三个孩子，左最小，中介于，右最大 2-3树中所有叶子都在同一层次上 了解一下2-3树的插入实现与删除实现 2-3-4树：其实就是2-3树的概念拓展，包括了4结点的使用，一个4结点包括小中大三个元素和四个孩子(或没有孩子) B树(B-tree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order)，因此2-3树是3阶B树，2-3-4是4阶B树 对于n个关键字的m阶B树，最坏情况是要查找几次呢？ 第一层至少有1个结点，第二层至少有2个结点，由于除根结点外每个分支结点至少有(m/2)棵子树，则第三层至少有2X(m/2)个结点，….这样第k+1层至少有2X(m/2)^k-1^ B+树 散列表查找(哈希表)概述 散列技术是在记录的存储位置和它的关键字之间建立一个确立的对应关系f，使得每个关键字key对应一个存储位置f(key) 查找时，根据这个确定的对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上 这里我们把这种对应关系f称为散列函数，又称哈希(Hash)函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)，那么关键字对应的记录存储位置我们称为散列地址 散列技术既是一种存储方法，也是一种查找方法,散列技术最合适的求解问题是查找与给定值相等的记录. 我们通常会碰到两个关键字key1≠key2，但是却有f(key1)=f(key2)，这种现象我们称为冲突(collision)，并把key1和key2称为这个散列函数的同义词(synonym) 散列函数的构造方法 直接定址法 也就是说，我们可以取关键字的某个线性函数值为散列地址，即f(key)=a x key+b (a，b为常数) 数字分析法 平方取中法 折叠法 除留余数法 随机数法 处理散列冲突的方法 开放地址法 所谓的开放地址，就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 f1(key) = (f(key)+di) MOD m (di=1,2,3,….,m-1) 我们把这种解决冲突的开放地址法称为线性探测法 在解决冲突的时候，我们会碰到这种本来都不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。 另外增加平方运算的目的是为了不让关键字都聚集在某一刻区域，我们称这种方法为二次探测法 即改进di=1^2^，-1^2^，2^2^，-2^2^,… 还有一种方法是，在冲突时，对于位移量di采用随机函数计算得到，我们称之为随机探测法 这里的随机其实是伪随机数，伪随机数就是说，如果我们设置随机种子相同，则不断调用随机函数生成不会重复的数列，我们在查找时，用同样的随机种子，它每次得到的数列是相同的，相同的di也会得到相同的数列地址 随机种子了解一波？ 总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的方法 再散列函数法(事先准备多个散列函数) 链地址法 公共溢出区法(溢出表) 散列表查找实现首先是需要定义一个散列表的结构以及一些相关的常数，其中HashTable就是散列表结构，机构当中的elem为一个动态数组 12345678910#define SUCCESS 1#define UNSUCCESS 0#define HASHSIZE 12 /*定义散列表长为数组的长度*/#define NULLKEY -32768typedef struct&#123; int *elem; /*数据元素存储基址，动态分配数组*/ int count; /*当前数据元素个数*/&#125;HashTable; int m=0; /*散列表表长，全局变量*/ 有了结构的定义，我们可以对散列表进行初始化 1234567891011/*初始化散列表*/Status InitHashTable(HashTable *H)&#123; int i; m=HASHSIZE; H-&gt;count=m; H-&gt;elem=(int*)malloc(m*sizeof(int)); for(i=0;i&lt;m;i++) H-&gt;elem[i]=NULLKEY; return OK;&#125; 为了插入时计算地址，我们需要定义散列函数，散列函数可以根据不同情况更改算法。 12345/*散列函数*/int Hash(int key)&#123; ruturn key % m; /*除留余数法*/&#125; 初始化完成后，我们可以对散列表进行插入操作。 12345678/*插入关键字进散列表*/void InsertHash(HashTable *H,int key)&#123; int addr = Hash(key); /*求散列地址*/ while(H-&gt;elem[addr] != NULLKEY) /*如果不为空，则冲突*/ addr = (addr+1) % m; /*开放地址法的线性探测*/ H-&gt;elem[addr] = key; /*直到有空位后插入关键字*/&#125; 散列表存在后，我们在需要时就可以通过散列表查找要的记录 1234567891011121314/*散列表查找关键字*/Status SearchHash(HashTable H,int key,int *addr)&#123; *addr = Hash(key); /*求散列地址*/ while(H.elem[*addr] != key) /*如果不为空，则冲突*/ &#123; *addr = (*addr+1) % m; /*开放定址法的线性探测*/ if(H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123; /*如果循环回到原点*/ return UNSUCCESS; /*则说明关键字不存在*/ &#125; &#125; return SUCCESS;&#125; 查找的代码和插入的代码非常类似，只需做一个不存在关键字的判断而已 散列表查找性能分析如果没有冲突，散列查找是本章所有查找效率最高的，因为它的时间复杂度为O(1)]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F11%2FDataStructure-05.html</url>
    <content type="text"><![CDATA[图，让我想起被离散数学图论支配的恐惧，但是数据结构涉及到的属于图的抽象数据结构，简直比离散数学还要致命 介绍 前言: 图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合 图的定义与术语 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex) 线性表中可以没有数据元素，称为空表；树中可以没有结点，称为空树；而在图结构，不允许没有顶点，在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。 线性表中，相邻的数据元素之间有线性关系；树结构中，相邻两层的结点具有层次关系；而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的. 无向边(Edge)，用无序偶对(vi,vj)来表示 无向图(Undirected graphs) 有向边，也称为为弧(Arc) 有向图(Directed graphs)，用有序偶&lt;vi,vj&gt;来表示 连接顶点A到D的有向边就是弧，A是弧尾，D是弧头 简单图：图中若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图 无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图 有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图 稀疏图与稠密图：有很少条边或弧的图称为稀疏图，反之称为稠密图 权(Weight)：与图的边或弧相关的数叫做权 网(Network)：这种带权的图通常称为网 子图(Subgraph) 邻接点(Adjacent) 依附(incident) 度(Degree) 入度(InDegree)ID与出度(OutDegree)OD 路径(Path) 路径的长度是路径上边或弧的数目 回路或环(Cycle) 简单路径：序列中顶点不重复出现的路径称为简单路径 简单回路或简单环：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路 连通图(Connected Graph)：无向图中 连通分量：无向图中的极大连通子图 强连通图：有向图中，任意两点都有路径 强连通分量：有向图中的极大强连通子图 连通图的生成树：一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边 如果一个图有n个顶点和小于n-1条边，则是非连通图；如果它多于n-1条边，必定构成一个环 但是有n-1条边并不一定是生成树 有向树：如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树 生成森林：由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。 图的存储结构 邻接矩阵 图的邻接矩阵存储的结构12345678910typedef char VertexType; /*顶点类型应由用户定义*/typedef int EdgeType; /*边上的权值类型应全由用户定义*/#define MAXVEX 100 /*最大顶点数，由用户定义*/#define INFINITY 65535 /*用65535表示∞*/typedef struct&#123; VertexType vexs[MAXVEX]; /*顶点表*/ EdgeType arc[MAXVEX][MAXVEX]; /*邻接矩阵，可看作边表*/ int numVertexes,numEdges; /*图中当前的顶点和边数*/&#125;MGraph; 有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程12345678910111213141516171819/*建立无向网图的邻接矩阵表示*/void CreateMGraph(MGraph *G)&#123; int i,j,k,w; printf("输入顶点数和边数:\n")； scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges); /*输入顶点数和边数*/ for(i = 0;i &lt; G-&gt;numVertexes;i++) /*读入顶点信息，建立顶点表*/ scanf(&amp;G-&gt;vexs[i]); for(i = 0;i &lt; G-&gt;numVertexes;i++) for(j = 0;j &lt;G-&gt;numVertexes;j++) G-&gt;arc[i][j] = INFINITY; /*邻接矩阵初始化*/ for(k = 0;k &lt;G-&gt;numEdges;k++) /*读入numEdges条边，建立邻接矩阵*/ &#123; printf("输入边(vi,vj)上的下标i，下标j和权w:\n"); scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w); /*输入边(vi,vj)上的权*/ G-&gt;arc[i][j]=w; G-&gt;arc[j][i]=G-&gt;arc[i][j]; /*因为是无向图，矩阵对称*/ &#125;&#125; 从代码中可以得到n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n^2^+e)，其中对邻接矩阵Garc的初始化耗费了O(n^2^)的时间 邻接表123456789101112131415typedef char VertexType; /*顶点类型应由用户定义*/typedef int EdgeType; /*边上的权值类型应由用户定义*/typedef struct EdgeNode /*边表结点*/&#123; int adjvex; /*邻接点域，存储该顶点对应的下标*/ EdgeType weight; /*用于存储权值，对于非网图可以不需要*/ struct EdgeNode *next; /*链域，指向下一个临接点*/&#125;EdgeNode;typedef struct VertexNode /*顶点表结点*/&#123; AdjList adjList; /*顶点域，存储顶点信息*/ int numVertexes,numEdges; /*边表头指针*/&#125;GraphAdjList; 123456789101112131415161718192021222324252627/*建立无向图的邻接表结构*/void CreateALGraph(GraphAdjList *G)&#123; int i,j,k; EdgeNode *e; printf("输入顶点数和边数:\n"); scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges); /*输入顶点数和边数*/ for(i = 0;i &lt; G-&gt;numVertexes;i++) /*读入顶点信息，建立顶点表*/ &#123; scanf(&amp;G-&gt;adjList[i].data); /*输入顶点信息*/ G-&gt;adjList[i].firstedge=NULL; /*将边表置为空表*/ &#125; for(k = 0;k &lt; G-&gt;numEdges;k++) /*建立边表*/ &#123; printf("输入边(vi,vj)上的顶点序号:\n"); scanf("%d,%d",&amp;i,&amp;j); /*输入边上的顶点序号*/ e =(EdgeNode*)malloc(sizeof(EdgeNode)); /*向内存申请空间，生成边表结点*/ e-&gt;adjvex=j; /*邻接序号为j*/ e-&gt;next=G-&gt;adjList[i].firstedge; /*将e指针指向当前顶点指向的结点*/ G-&gt;adjList[i].firstedge=e; /*将当前顶点的指针指向e*/ e=(EdgeNode*)malloc(sizeof(EdgeNode)); /*向内存申请空间，生成边表结点*/ e-&gt;adjvex=i; /*邻接序号为i*/ e-&gt;next=G-&gt;adjList[j].firstedge; /*将e指针指向当前顶点指向的结点*/ G-&gt;adjList[j].firstedge=e; /*将当前顶点的指针指向e*/ &#125;&#125;/*后边代码用了前面讲到的单链表头插法*/ 边集数组 十字链表 邻接多重表 图的遍历深度优先遍历(Depth_First_Search)又称为深度优先搜索 12345678910111213141516171819202122typedef int Boolean; /*Boolean是布尔类型，其值是TRUE或FALSE*/Boolean visited[MAX]; /*访问标志的数组*//*邻接矩阵的深度优化递归算法*/void DFS(MGraph G, int i)&#123; int j; visited[i] = TRUE; printf("%c",G.vexs[i]); /*打印顶点，也可以其他操作*/ for(j = 0;j &lt;G.numVertexes;j++) if(G.arc[i][j]) == 1 &amp;&amp; !visited[j]) DFS(G,j); /*对为访问的邻接顶点递归调用*/&#125;/*邻接矩阵的深度遍历操作*/void DFSTraverse(MGraph G)&#123; int i; for(i = 0;i &lt; G.numVertexes;i++) visited[i] = FALSE; /*初始所有顶点状态都是未访问过状态*/ for(i = 0;i &lt; G.numVertexes;i++) if(!visited[i]) /*对未访问过的顶点调用DFS，若是连通图，只会执行一次*/ DFS(G,i);&#125; 123456789101112131415161718192021222324/*邻接表的深度优先递归算法*/void DFS(GraphAdjList GL, int i)&#123; EdgeNode *p; visited[i]=TRUE; printf("%c",GL-&gt;adjList[i].data); /*打印顶点，也可以其他操作*/ p = GL-&gt;adjList[i].firstedge; while(p) &#123; if(!visited[p-&gt;adjvex]) DFS(GL,p-&gt;adjvex); /*对为访问的邻接顶点递归调用*/ p = p-&gt;next; &#125;&#125;/*邻接表的深度遍历操作*/void DFSTraverse(GraphAdjList GL)&#123; int i; for(i = 0;i &lt; GL-&gt;numVertexes;i++) visited[i] = FALSE; /*初始所有顶点状态都是未访问过状态*/ for(i = 0;i &lt; GL-&gt;numVertexes;i++) if(!visited[i]) /*对未访问过的顶点调用DFS，若是连通图，只会执行一次*/ DFS(GL,i);&#125; 对于n个顶点e条边的图，邻接矩阵是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此需要O(n^2^)的时间；而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O(n+e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高 广度优先遍历(Breadth_First_Search)又称为广度优先搜索 1234567891011121314151617181920212223242526272829303132/*邻接矩阵的广度遍历算法*/void BFSTraverse(MGraph G)&#123; int i,j; Queue Q; for(i = 0;i &lt; G.numVertexes;i++) visited[i] = FALSE; InitQueue(&amp;Q); /*初始化一辅助用的队列*/ for(i = 0;i &lt; G.numVertexes;i++) /*对每一个顶点做循环*/ &#123; if(!visited[i]) /*若是未访问过就处理*/ &#123; visited[i]=TRUE; /*设置当前顶点访问过*/ printf("%c",G.vexs[i]); /*打印顶点，也可以其他操作*/ EnQueue(&amp;Q,i); /*将此顶点入队列*/ while(!QueueEmpty(Q)) /*若当前队列不为空*/ &#123; DeQueue(&amp;Q,&amp;i); /*将队中元素出队列，赋值给i*/ for(j=0;j&lt;G.numVertexes;j++) &#123; /*判断其他顶点若与当前顶点存在边且未访问过*/ if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j]=TRUE; /*将找到的此顶点标记为已访问*/ printf("%c",G.vexs[j]); /*打印顶点*/ EnQueue(&amp;Q,j); /*将找到的此顶点入队列*/ &#125; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031/*邻接表的广度遍历算法*/void BFSTraverse(GraphAdjList GL)&#123; int i; EdgeNode *p; Queue Q; for(i = 0; i &lt; GL-&gt;numVertexes;i++) &#123; if(!visited[i]) &#123; visited[i]=TRUE; printf("%c",GL-&gt;adjList[i].data); /*打印顶点，也可以其他操作*/ EnQueue(&amp;Q,i); while(!QueueEmpty(Q)) &#123; DeQueue(&amp;Q,&amp;i); p =GL-&gt;adjList[i].firstedge; /*找到当前顶点边表链表头指针*/ while(p) &#123; if(!visited[p-&gt;adjvex]) /*若此顶点未被访问*/ &#123; visited[p-&gt;adjvex] = TRUE; printf("%c",GL-&gt;adjList[p-&gt;adjvex].data); EnQueue(&amp;Q,p-&gt;adjvex); /*将此顶点入队列*/ &#125; p = p-&gt;next; /*指针指向下一个邻接点*/ &#125; &#125; &#125; &#125;&#125; 对比图的深度优先遍历与广度优先遍历算法，它们在时间复杂度上是一样的，不同之处仅仅在对顶点访问的顺序不同，可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。 最小生成树 普里姆算法(Prim)123456789101112131415161718192021222324252627282930313233343536373839/*Prim算法生成最小生成树*/void MiniSpanTree_Prim(MGraph G)&#123; int min,i,j,k; int adjvex[MAXVEX]; /*保存相关顶点下标*/ int lowcost[MAXVEX]; /*保存相关顶点间边的权值*/ lowcost[0] = 0; /*初始化第一个权值为0，即v0加入生成树*/ /*lowcost的值为0，在这里就是此下标的顶点已经加入生成树*/ adjvex[0] = 0; /*初始化第一个顶点下标为0*/ for(i = 1; i &lt; G.numVertexes;i++) /*循环除下标为0外的全部顶点*/ &#123; lowcost[i] = G.arc[0][i]; /*将v0顶点与之有边的权值存入数组*/ adjvex[i] = 0; /*初始化都为v0的下标*/ &#125; for(i = 1; i &lt; G.numVertexes;i++) &#123; min = INFINITY; /*初始化最小权值为∞，通常设置为不可能的大数字如32767,65535*/ j = 1;k = 0; while(j &lt;G.numVertexes) /*循环全部顶点*/ &#123; if(lowcost[j]! = 0 &amp;&amp; lowcost[j] &lt; min) &#123; /*如果权值不为0且权值小于min*/ min = lowcost[j]; /*则让当前权值成为最小值*/ k = j; /*将当且最小值的下标存入k*/ &#125; j++; &#125; printf("(%d,%d)",adjvex[k],k); /*打印当前顶点边中权值最小边*/ lowcost[k] = 0; /*将当前顶点的权值设置为0，表示此顶点已经完成任务*/ for(j = 1;j &lt;G.numVertexes;j++) /*循环所有顶点*/ &#123; if(lowcost[j]!= 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j]) &#123; /*若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值*/ lowcost[j] = G.arc[k][j]; /*将较小权值存入lowcost*/ adjvex[j] = k; /*将下标为k的顶点存入adjvex*/ &#125; &#125; &#125;&#125; 由此算法代码中的循环嵌套可得此算法的时间复杂度为O(n^2^) 克鲁斯卡尔算法(Kruskal)1234567/*对边集数组Edge结构的定义*/typedef struct&#123; int begin; int end; int weight;&#125;Edge; 123456789101112131415161718192021222324252627/*Kruskal算法生成最小生成树*/void MiniSpanTree_Kruskal(MGraph G) /*生成最小生成树*/&#123; int i,n,m; Edge edges[MAXEDGE]; /*定义边集数组*/ int parent[MAXVEX]; /*定义一数组用来判断边与边是否形成环路*/ /*此处省略将邻接表矩阵G转化为边集数组edges并按权从小到大排序的代码*/ for(i = 0; i &lt;G.numVertexes; i++) parent[i] = 0; /*初始化数组值为0*/ for(i = 0; i &lt;G.numEdges;i++) /*循环每一条边*/ &#123; n = Find(parent,edges[i].begin); m = Find(parent,edges[i].end); if(n!=m) /*假设n与m不等，说明此边没有与现有生成树形成环路*/ &#123; parent[n] = m; /*将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中*/ printf("(%d,%d) %d",edges[i].begin,edges[i].end,edges[i].weight); &#125; &#125;&#125;int Find(int *parent,int f) /*查找连线顶点的尾部下标*/&#123; while(parent[f]&gt;0) f = parent[f]; return f;&#125; 此算法的Find函数由边数e决定，时间复杂度为O(loge)，而外面有一个for循环e次，所以克鲁斯卡尔算法的时间复杂度为O(eloge) 对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，对于稀疏图有很大优势，而普里姆算法对于稠密图，即边数非常多的情况会更好一点。 最短路径 迪杰斯特拉(Dijkstra)12345678910111213141516171819202122232425262728293031323334353637383940414243#define MAXVEX 9#define INFINITY 65535typedef int Pathmatrix[MAXVEX]; /*用于存储最短路径下标的数组*/typedef int ShortPathTable[MAXVEX]; /*用于存储到各点最短路径的权值和*//*Dijkstra算法，求有向网G的v0顶点到其余顶点v最短路径P[v]及带权长度D[v]*//*P[v]的值为前驱顶点下标，D[v]表示v0到v的最短路径长度和*/void shortestPath_Dijkstra(MGraph G,int v0,Pathmatirx *p,ShortPathTable *D)&#123; int v,w,k,min; int final[MAXVEX]; /*final[w]=1表示求得顶点V0至Vw的最短路径*/ for(v=0;v&lt;G.numVertexes;v++) /*初始化数据*/ &#123; final[v] = 0; /*全部顶点初始化为未知最短路径状态*/ (*D)[v] = G.matirx[v0][v]; /*将与v0点有连线的顶点加上权值*/ (*P)[v] = 0; /*初始化路径数组为0*/ &#125; (*D)[v0] = 0; /*v0至v0路径为0*/ final[v0] = 1; /*v0至v0不需要求路径*/ /*开始主循环，每次求得v0到某个v顶点的最短路径*/ for(v=1;v&lt;G.numVertexes;w++) &#123; min=INFINITY; /*当前所知离v0顶点的最近距离*/ for(w=0;w&lt;G.numVertexes;w++) /*寻找离v0最近的顶点*/ &#123; if(!final[w] &amp;&amp; (*D)[w]&lt;min) &#123; k=w; min = (*D)[w]; /*w顶点离v0顶点更近*/ &#125; &#125; final[k] = 1; /*将目前找到的最近的顶点置为1*/ for(w=0;w&lt;G.numVertexes;w++) /*修正当前最短路径及距离*/ &#123; /*如果结果v顶点的路径比现在这条路径的长度短的话*/ if(!final[w] &amp;&amp; (min + G.matirx[k][w] &lt; (*D)[w])) &#123; /*说明找到了更短的路径，修改D[w]和P[w]*/ (*D)[w] = min + G.matirx[k][w]; /**/ (*P)[w] = k; &#125; &#125; &#125;&#125; 我们通过迪杰斯特拉(Dijkstra)算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为O(n^2^)，如果我们还需要知道其它顶点到其余所有顶点的最短路径，我们则需要再一次循环，此时整个算法的复杂度变成了O(n^3^) 弗洛伊德算法(Floyd)1234567891011121314151617181920212223242526272829typedef int Pathmatirx[MAXVEX][MAXVEX];typedef int ShortPathTable[MAXVEX][MAXVEX];/*Floyd算法，求网图G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]*/void ShortestPath_Floyd(MGraph G,Pathmatirx *P,ShortPathTable *D)&#123; int v,w,k; for(v=0;v&lt;G.numVertexes;++v) /*初始化D与P*/ &#123; for(w=0;w&lt;G.numVertexes;++w) &#123; (*D)[v][w]=G.matirx[v][w]; /*D[v][w]值即为对应点间的权值*/ (*P)[v][w]=w; /*初始化P*/ &#125; &#125; for(k=0;k&lt;G.numVertexes;++k) &#123; for(v=0;v&lt;G.numVertexes;++v) &#123; for(w=0;w&lt;G.numVertexes;++w) &#123; if((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w]) &#123; /*如果经过下标为k顶点路径比原两点间路径更短，将当前两点间权值设为更小的一个*/ (*D)[v][w]=(*D)[v][k]+(*D)[k][w]; (*P)[v][w]=(*P)[v][k]; /*路径设置经过下标为k的顶点*/ &#125; &#125; &#125; &#125;&#125; 求最短路径的显示代码可以这么写12345678910111213141516for(v=0;v&lt;G.numVertexes;++v)&#123; for(w=v+1;w&lt;G.numVertexes;w++) &#123; printf("v%d-v%d weight: %d",v,w,D[v][w]); k=P[v][w]; /*获得第一个路径顶点下标*/ printf("path:%d",v); /*打印源点*/ while(k!=w) /*如果路径顶点下标不是终点*/ &#123; printf("-&gt;%d",k); /*打印路径顶点*/ k=P[k][w]; /*获得下一个路径顶点下标*/ &#125; printf("-&gt;%d\n",w); /*打印终点*/ &#125; printf("\n");&#125; 拓扑排序 有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程是否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析除一个有向图是否存在环，如果不存在，那它的拓扑序列是？ 在拓扑排序算法中，涉及的结构代码如下12345678910111213141516171819typedef struct EdgeNode /**/&#123; int adjvex; /*邻接点域，存储该顶点对应的下标*/ int weight; /*用于存储权值，对于非网图可以不需要*/ struct EdgeNode *next; /*链域，指向下一个邻接点*/&#125;EdgeNode;typedef struct VertexNode /*顶点表结点*/&#123; int in; /*顶点入度*/ int data; /*顶点域，存储顶点信息*/ EdgeNode *firstedge; /*边表头指针*/&#125;VertexNode,AdjList[MAXVEX];typedef struct&#123; AdjList adjList; int numVertexes,numEdges; /*图中当前顶点数和边数*/&#125;graphAdjList,*GraphAdjList; 在算法中，我们还需要辅助的数据结构——栈，用来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。1234567891011121314151617181920212223242526272829/*拓扑排序，若GL无回路，则输出拓扑排序序列并返回OK，若有回路返回ERROR*/Status TopologicalSort(GraphAdList GL)&#123; EdgeNode *e; int i,k,gettop; int top=0; /*用于栈指针下标*/ int count=0; /*用于统计输出顶点的个数*/ int *stack; /*建栈存储入度为0的顶点*/ stack=(int*)malloc(GL-numVertexes*sizeof(int)); for(i = 0;i&lt;GL-&gt;numVertexes;i++) if(GL-&gt;adjList[in].in == 0) stack[++top]=i; /*将入度为0的顶点入栈*/ while(top!=0) &#123; gettop=stack[top--]; /*出栈*/ printf("%d-&gt;",GL-&gt;adjList[gettop].data); /*打印此顶点*/ count++; /*统计输出顶点数*/ for(e=GL-&gt;adjList[gettop].firstedge;e;e-&gt;next) &#123;/*对此顶点弧表遍历*/ k=e-&gt;adjvex; if(!(--GL-&gt;adjList[k].in)) /*将k号顶点邻接点的入度减一*/ stack[++top]=k; /*若为0则入栈，以便于下次循环输出*/ &#125; &#125; if(count&lt;GL-&gt;numVertexes) /*如果count小于顶点数，说明存在环*/ return ERROR; else return OK;&#125; 分析整个算法，对一个具有n个顶点e条弧的AOV网来说，将入度为0的顶点入栈的时间复杂为O(n)，而之后的while循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为O(n+e) 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex Network) 关键路径 另一方面关心的是整个工程的完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。 在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网(Activity On Edge Network) 我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点3具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动 事件的最早发生时间etv(earliest time of vertex) 事件的最晚发生时间ltv(latest time of vertex) 活动的最早开工时间ete(earliest time of edge) 活动的最晚开工时间lte(latest time of edge)我们由1和2求得3跟4，然后再根据ete[k]是否等于lte[k]来判断ak是否是关键活动 求etv的过程就是从头到尾找拓扑序列的过程，因此在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列表，为此，我们先在程序开始出声明几个全局变量123int *etv,*ltv; if /*事件最早发生时间和最迟发生时间数组*/int stack2; /*用于存储拓扑序列的栈*/int top2; /*用于stack2的指针*/ 以下是改进过的拓扑序列算法12345678910111213141516171819202122232425262728293031323334353637/*拓扑排序，用于关键路径计算*/Status TopologicalSort(GraphAdjList GL)&#123; EdgeNode *e; int i,k,gettop; int top=0; /*用于栈指针下标*/ int count=0; /*用于统计输出顶点的个数*/ int *stack; /*建栈将入度为0的顶点入栈*/ stack=(int *)malloc(GL-&gt;numVertexes *sizeof(int)); for(i = 0;i &lt; GL-&gt;numVertexes; i++) if(0 == GL-&gt;adjList[i].in) stack[++top]=i; top2=0; /初始化为0/ etv=(int*)malloc(GL-&gt;numVertexes *sizeof(int)); /事件最早发生时间/ for(i = 0;i &lt; GL-&gt;numVertexes; i++) etv[i]=0; /初始化为0/ stack2 = (int *)malloc(GL-&gt;numVertexes*sizeof(int)) /初始化/ while(top!=0) &#123; gettop=stack[top--]; count++; stack2[++top2]=gettop; /*将弹出的顶点序号压入拓扑序列的栈*/ for(e = GL-&gt;adjList[gettop].firstedge;e;e = e-&gt;next) &#123; k=e-&gt;adjvex; if(!(--GL-&gt;adjList[k].in)) stack[++top]=k; if((etv[gettop]+e-&gt;weight)&gt;etv[k]) /求各顶点事件最早发生时间值/ etv[k] = etv[gettop]+e-&gt;weight; &#125; &#125; if(count &lt; GL-&gt;numVertexes) return ERROR; else return OK;&#125; 关键路径的算法1234567891011121314151617181920212223242526272829303132/*求关键路径，GL为有向网，输出GL的各项关键活动*/void CriticalPath(GraphAdjList GL)&#123; EdgeNode *e; int i,gettop,k,j; int ete,lte; /*声明活动最早发生时间和最迟发生时间变量*/ TopologicalSort(GL); /*求拓扑序列，计算数组etv和stack2的值*/ ltv=(int*)malloc(GL-&gt;numVertexes*sizeof(int)); /*事件最晚发生时间*/ for(i=0;i&lt;GL-&gt;numVertexes;i++) ltv[i]=etv[GL-&gt;numVertexes-1]; /*初始化ltv*/ while(top2!=0) /*计算ltv*/ &#123; gettop=stack2[top--]; /*将拓扑序列出栈，后进先出*/ for(e=GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next) &#123; /*求各顶点事件的最迟发生时间ltv值*/ k=e-&gt;adjvex; if(ltv[k]-e-&gt;weight&lt;ltv[gettop]) /*求各顶点事件最晚发生时间ltv*/ ltv[gettop]=ltv[k]-e-&gt;weight; &#125; &#125; for(j=0;j&lt;GL-&gt;numVertexes;j++) /*求ete，lte和关键活动*/ &#123; for(e=GL-&gt;adjList[j].firstedge;e;e=e-&gt;next) &#123; k=e-&gt;adjvex; ete=etv[j]; /*活动最早发生时间*/ lte=ltv[k]-e-&gt;weight; /*活动最迟发生时间*/ if(ete == lte) /*两者相等即在关键路径上*/ printf("&lt;v%d,v%d&gt; length: %d,",GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight); &#125; &#125;&#125; 整个关键路径的算法，拓扑排序O(n+e)，初始化lte为O(n)…根据我们对时间复杂度的定义，所有的常数系数可以忽略，所以最终求得关键路径算法的时间复杂度仍然是O(n+e)]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F11%2FDataStructure-04.html</url>
    <content type="text"><![CDATA[众所周知，树一直是数据结构的重点，此处摘要不做多介绍 最近一直在循环coldplay的歌，分享一波 var ap = new APlayer({ element: document.getElementById("aplayer-oFoySkps"), narrow: false, autoplay: false, showlrc: false, music: { title: "Viva la Vida", author: "Coldplay", url: "http://prc4nro7n.bkt.clouddn.com/Viva%20la%20Vida.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/Viva.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 介绍 前言:树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中： 有且仅有一个特定的称为根(Root)的结点 当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2…..Tm，其中每一个集合本身又是一棵树，并且称为根的子数(SubTree)结点分类 树的结点包含一个数据元素以及若干指向其子树的分支。结点拥有的字树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。 树的度是树内各结点的度的最大值结点间关系 结点的子树的根称为该结点的孩子(Child)，相应的，该结点称为孩子的双亲(Parent) 对于结点来说其父母同体，唯一的一个，所以称为双亲 同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所近分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙.树的其他相关概念 结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。 若某结点在第I层，则其子树的根就在第I+1层。 其双亲在同一层的结点互为堂兄弟。 树中结点的最大层次称为树的深度(Depth)或高度 如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树 森林(Forest)是m(m≥0)棵互不相交的树的集合 对树种的每个结点而言，其子树的集合即为森林。 对比线性表与树的结构，它们有很大的不同 线性结构：①第一个数据元素：无前驱；②最后一个数据元素：无后继；③中间元素：一个前驱一个后继 树结构：①根节点：无双亲，唯一；②叶节点：无孩子，可以多个；③中间结点：一个双亲多个孩子 树的抽象数据类型对于线性结构，树的操作就完全不同了12345678910111213141516171819ADT 树(Tree)Data 树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系.Operation InitTree(*T): DestroyTree(*T): CreateTree(*T,definition): ClearTree(*T): TreeEmpty(T): TreeDepth(T): Root(T):返回树的根节点 Value(T,cur_e):cur_e是树T中的一个结点，返回此结点的值 Assign(T,cur_e,value):给树T的结点cur_e赋值为value Parent(T,cur_e):若cur_e是树T的非根结点，则返回它的双亲，否则返回空 LeftChild(T,cur_e):若cur_e是树T的非叶节点，则返回它的最左孩子，否则返回空 RightSibling(T,cur_e):若cur_e有右兄弟，则返回它的右兄弟，否则返回空 InsertChild(*T,&amp;p,i,c):其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树 DeleteChild(*T,*p,i):其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树endADT 树的存储结构 双亲表示法(在每个结点中，附设一个指示器指示其双亲结点到链表中的位置) 每个结点除了知道自己是谁之外，还知道它的双亲在哪里,结点结构分为data(数据域，存储结点的数据信息)跟parent(指针域，存储该结点的双亲在数组的下标) 12345678910111213/*树的双亲表示法结点结构定义*/#define MAX_TREE_SIZE 100typedef int TElemType; /*树结点的数据类型，目前暂定为整型*/typedef struct PTNode /*结点结构*/&#123; TElemType data; /*结点数据*/ int parent; /*双亲位置*/&#125;PTNode;typedef struct /*树结构*/&#123; PTNode nodes[MAX_TREE_SIZE]; /*结点数组*/ int r,n;&#125;PTree; 双亲域，长子域，右兄弟域 根节点的双亲域，长子域，右兄弟域都是-1 孩子表示法每个结点有多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法，不过树的每个结点的度，也就是它的孩子个数是不同的，所以我们可以设计两种反案来解决 一种是指针域的个数等于树的度(树的度是树各个结点度的最大值这种方法在树中各结点的度相差很大时，显然是浪费空间的 第二种是每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数(degree)这种方法克服了空间的浪费，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗思考：能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同？ 我们把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系.这就是所谓的孩子表示法 孩子表示法:把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中12345678910111213141516171819/*树的孩子表示法结构定义*/#define MAX_TREE_SIZE 100typedef struct CTNode /*孩子结点*/&#123; int child; struct CTNode *next;&#125;*ChildPtr;typedef struct /*表头结构*/&#123; TElemType data; ChildPtr firstchild;&#125;CTbox;typedef struct /*树结构*/&#123; CTBox nodes[MAX_TREE_SIZE]; /*结点数组*/ int r,n;&#125;CTree; 双亲孩子表示法 算是孩子表示法的改进，略过 孩子兄弟表示法 任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟 123456/*树的孩子兄弟表示法结构定义*/typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild,*rightsib;&#125;CSNode,*CSTree; 其实这个表达法最大好处就是把一棵复杂的树变成了一棵二叉树 二叉树 二叉树的五种基本形态： 空二叉树 只有一个根节点 根节点只有左子树 根节点只有右子树 根节点既有左子树又有右子树 注意：三个结点的树有两种情况，而三个结点的二叉树有五种形态 特殊二叉树 斜树(左斜树跟右斜树) 满二叉树 注意满二叉树的叶子只能出现在最下一层，单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有叶子都在同一层上 完全二叉树 二叉树的性质 在二叉树的第i层上至多有2^i-1^个结点 深度为k的二叉树至多有2^k^-1个结点 这里要看清楚，很容易把性质1跟性质2弄混 对任意一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1 具有n个结点的完全二叉树的深度为(log2n)+1 如果对一棵有n个结点的完全二叉树(其深度为(log2n)+1)的结点按层序编号，对任一节点i(1≤i≤n)有： 如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2] 如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i 如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1 二叉树的存储结构 顺序存储:二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，还原成完全二叉树的方法 考虑一种极端的情况，比如一棵深度为k的右斜树，它只有k个结点，却要分配2^k^-1个存储单元空间，这显然是对存储空间的浪费，所以顺序存储结构一般只用于完全二叉树. 二叉链表：二叉树的每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表为二叉链表123456/*二叉树的二叉链表结点结构定义*/typedef struct BiTNode /*结点结构*/&#123; TElemType data; /*结点数据*/ struct BiTNode *lchild,*rchild; /*左右孩子指针*/&#125;BiTNode,*BiTree 遍历二叉树 二叉树的遍历(traversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问一次且仅被访问一次. 前序遍历 123456789/*二叉树的前序遍历递归算法*/void PreOrderTraverse(BiTree T)&#123; if(T==NULL) return; printf("c%",T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild);&#125; 中序遍历 123456789/*二叉树的中序遍历递归算法*/void InOrderTraverse(BiTree T)&#123; if(T==NULL) return; InOrderTraverse(T-&gt;lchild); printf("c%",T-&gt;data); InOrderTraverse(T-&gt;rchild);&#125; 后序遍历 123456789/*二叉树的后序遍历递归算法*/void PostOrderTraverse(BiTree T)&#123; if(T==NULL) return; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); printf("c%",T-&gt;data); &#125; 层序遍历 推导遍历结果 已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，求这棵二叉树的后序遍历结果? CBEFDA 已知一棵二叉树的中序序列是ABCDEFG，后序序列是BDCAFGE,求前序序列? EACBDGF 重要 从这里我们可以得到两个二叉树遍历的性质 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 已知前序和后序遍历，是不能确定一棵二叉树的，例如已知前序序列ABC和后序序列CBA，我们可以确定A一定是根节点，但接下来我们无法知道哪个结点是左结点和右结点，所以有4种情况 二叉树的建立 利用扩展二叉树，比如假设二叉树的结点均为一个字符，我们把刚才前序遍历序列AB#D##C##用键盘挨个输入123456789101112131415161718/*按前序输入二叉树中结点的值(一个字符)*//* #表示空树，构造二叉链表示二叉树T */void CreateBiTree(BiTree *T)&#123; TElemType ch; scanf("%c",&amp;ch); if(ch == '#') *T=NULL; else &#123; *T=(BiTree)malloc(sizeof(BiTNode)); if(!*T) exit(OVERFLOW); (*T)-&gt;data=ch; /*生成根节点*/ CreateBiTree(&amp;(*T)-&gt;lchild); /*构造左子树*/ CreateBiTree(&amp;(*T)-&gt;rchild); /*构造右子树*/ &#125;&#125; 其实建立二叉树，也是利用了递归的原理，只不过在原来应该打印结点的地方改成了生成结点，给结点赋值的操作而已，所以如果换成中序和后序遍历的方式，只要调整一下生成结点和构造左右子树的代码顺序即可 线索二叉树 我们考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址 我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree) 对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化，我们将这棵二叉树中所有空指针域中的lchild改为指向当前结点的前驱，rchild改为指向当前结点的后继但是问题没有彻底解决，我们如何知道某一结点的lchild是指它的左孩子还是指向前驱？rchild是指向右孩子还是指向后继？ 这里我们引入两个标志域ltag和rtag，注意ltag和rtag只是存放0或1数字的布尔型变量 tag为0时指向结点的孩子，为1时指向该结点的前驱/后继 线索二叉树结构实现123456789/*二叉树的二叉线索存储结构定义*/typedef enum &#123;Link,Thread&#125; PointerTag; /*Link == 0表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索*/typedef struct BiThrNode /*二叉线索存储结点结构*/&#123; TElemType data; /*结点数据*/ struct BiThrNode *lchild,*rchild; /*左右孩子指针*/ PointerTag LTag; PointerTag RTag;&#125;BiThrNode,*BiThrTree; 线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索，由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。 中序遍历线索化的递归函数代码如下：12345678910111213141516171819BiThrTree pre; /*全局变量，始终指向刚刚访问过的结点*//*中序遍历进行中序线索化*/void InThreading(BiThrTree p)&#123; if(p) &#123; InThreading(p-&gt;lchild); /*递归左子树线索化*/ if(!p-&gt;lchild) /*没有左孩子*/ &#123; p-&gt;LTag=Thread; /*前驱线索*/ p-&gt;lchild=pre; /*左孩子指针指向前驱*/ &#125; if(!pre-&gt;rchild) /*前驱没有右孩子*/ pre-&gt;Tag=Thread; /*后继线索*/ pre-&gt;rchild=p; /*前驱右孩子指针指向后继(当前结点p)*/ &#125; pre=p; /*保持pre指向p的前驱*/ InThreading(p-&gt;rchild); /*递归右子树线索化*/&#125; 这段代码和二叉树中序遍历的递归代码几乎一样，只不过是将打印结点的功能改成了线索化的功能 有了线索二叉树后，我们对它进行遍历时发现，其实就等于操作一个双向链表结构 遍历的代码如下：12345678910111213141516171819/*T指向头结点，头结点左链lchild指向根节点，头结点右链rchild指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T*/Status InOrderTraverse_Thr(BiThrTree T)&#123; BiThrTree p; p = T-&gt;lchild; /*p指向根节点*/ while(p!=T) /*空树或遍历结束时，p==T*/ &#123; while(p-&gt;LTag==Link) /*当LTag==0时循环到中序序列第一个结点*/ p = p-&gt;lchild； printf("c%",p-&gt;data); /*显示结点数据，可以更改为其他对结点操作*/ while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild! =T) &#123; p = p-&gt;rchild; printf("%c",p-&gt;data); &#125; p = p-&gt;rchild; /*p进至其右子树根*/ &#125; return OK;&#125; 实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择. 树，森林与二叉树的转换 转换 树与森林的遍历 树的遍历分为两种形式 先根遍历 后根遍历 森林的遍历也分两种 前序遍历 后序遍历 森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同 赫夫曼树及其应用 赫夫曼树定义及原理 从树中的一个结点到另一个结点之间的分支构成的两个结点之间的路径，路径上的分支数目称为路径长度 树的路径长度就是从树根到每个结点的路径长度之和。 其中带权路径长度WPL最小的二叉树称为赫夫曼树，也称为最优二叉树. 赫夫曼编码 若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码 线索二叉树记得回顾理解一下]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-串]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F11%2FDataStructure-03.html</url>
    <content type="text"><![CDATA[虽然课本已经不把串的抽象数据类型作为重点，但是毕竟有所提及，这里还是把串的相关笔记提交上来 “你将不再是道具，而是人如其名的人” 前言 串(string)是由零个或多个字符组成的有限序列，又名叫字符串,一般记为s=”a1a2a3….an”(n≥0),其中s是串的名称，用双引号括起来的字符序列是串的值，注意单引号不属于串中的内容。 串中的字符数目n称为串的长度 零个字符的串称为空串(null string)，它的长度为0，可以直接用两双引号“”表示，也可以用希腊字母Ø表示 空格串，是只包含空格的串，注意它与空串的区别，空格串是有长度的，而且可以不止一个空格 字串和主串：串中容易个数的连续字符组成的子序列称为该串的字串，相应地，包含字串的串称为主串 字串在主串中的位置就是字串的第一个字符在主串中的符号 串的比较串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。 ASCII——扩展——Unicode——UTF-8的关系了解一波? 如果我们要在c语言中比较两个串是否相等，必须是它们串的长度以及它们各自对应位置的字符都相等时，才算是相等,而对于两个不相等的串，怎么判定它们的大小呢? 给定两个串：s=“a1a2….an”，t=“b1b2b3…bn”，当满足以下条件之一时，s&lt;t. n&lt;m，且ai=bi(i=1，2…..,n) 例如当s=”hap”,t=”happy”就有s&lt;t 存在某个k≤min(m,n),使得ai=bi(i=1,2….k-1), ak&lt;bk 例如当s=”happen”,t=”happy”因为两串的前4个字母均相同，而两串第五个字母(k)值e&lt;y，所以s&lt;t 串的抽象数据类型1234567891011121314151617ADT 串(string)Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系Operation StrAssign(T,*chars)：生成一个其值等于字符串常量chars的串T StrCopy(T,S):串S存在，由串S复制得串T ClearStrng(S):串S存在，将串清空 StringEmpty(S):若串S为空，则返回true，否则返回false StrLength(S):返回串S的元素个数，即串的长度 StrCompare(S,T):若S&gt;T,返回值&gt;0，若S=T,返回0，若S&lt;T,返回值&lt;0 Concat(T,S1,S2):用T返回由S1和S2连接而成的新串 SubString(Sub,S,pos,len):串S存在，1≤pos≤StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0 Index(S,T,pos):串S和T存在，T是非空串，1≤pos≤StrLength(S)。若主串S中存在和串T值相同的字串，则返回它在主串中第pos个字符之后第一次出现的位置，否则返回0 Replace(S,T,V):串S,T和V存在，T是非空串。用V代替主串S中出现的所有与T相等的不重叠字串 StrInsert(S,pos,T):串S，T存在，1≤pos≤StrLength(S)+1,在串S的第pos个字符之前插入串T StrDelete(S,pos,len):串S存在，1≤pos≤StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串endADTs 我们来看一个操作Index的实现算法123456789101112131415161718192021/*T为非空串。若主串S中第pos个字符之后存在与T相等的子串则返回第一个这样的字串在S中的位置，否则返回0*/int Index(String S, String T, int pos)&#123; int n,m,i; String sub; if(pos &gt; 0) &#123; n = StrLength(S); m = StrLength(T); i = pos; while(i &lt;= n-m+1) &#123; SubString(sub,S,i,m);/*取主串第i个位置，长度与T相等子串给sub*/ if(StrCompare(sub,T) != 0) /*如果两串不相等*/ ++i; else return i;/*如果两串相等，则返回i值*/ &#125; &#125; return 0;/*若无子串与T相等，返回0*/&#125; 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义 既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书也会定义存储在数组的最后一个下标位置 有些是规定在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结，这个时候你要想知道串长度，遍历计算一下即可 朴素的模式匹配算法(BF算法)(Brute Force) 子串的的定位操作通常称为串的模糊匹配，应该算是串中最重要的操作之一1234567891011121314151617181920212223/*返回子串在主串S中第pos个字符之后的位置，若不存在则返回值为0。T非空，1≤pos≤StrLength(S)*/int Index(String S, String T, int pos)&#123; int i = pos; /*i用于主串S中当前位置下标，若pos不为1则从pos位置开始匹配*/ int j = 1; /*j用于子串T中当前位置下标值*/ while(i &lt;= S[0] &amp;&amp; j&lt;= T[0]) /*若i小于S长度且j小于T的长度时循环*/ &#123; if(S[i] == T[j]) /*两字母相等则继续*/ &#123; ++i; ++j; &#125; else /*指针后退重新开始匹配*/ &#123; i = i-j+2; /*i退回到上次匹配首位的下一位*/ j = 1; /*j退回到子串T的首位*/ &#125; &#125; if(j &gt; T[0]) return i-T[0]; else return 0;&#125; KMP模式匹配算法三位前辈发表一个模式匹配算法，可以大大避免重复遍历的情况，我们称之为克努特-莫里斯-普拉特算法，简称KMP算法 此处省略原理简介以及next数组的引入，自己看书，简述几个例子 abcdex———011111 abcabx———011123 ababaaaba———011234223 aaaaaaaab———012345678 KMP模式匹配算法实现12345678910111213141516171819/*通过计算返回子串T的next数组*/void get_next(String T,int *next)&#123; int i,j; i=1; j=0; next[1]=0; while(i&lt;T[0]) /*此处T[0]表示串T的长度*/ &#123; if(j==0 || T[i]==T[j]) /*T[i]表示后缀的单个字符，T[j]表示前缀的单个字符*/ &#123; ++i; ++j; next[i] = j; &#125; else j = next[j]; /*若字符不相同，则j值回溯*/ &#125;&#125; 123456789101112131415161718192021222324/*返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0.。T非空，1≤pos≤StrLength(S)*/int Index_KMP(String S, String T,int pos)&#123; int i = pos; /*i用于主串S当前位置下标值，若pos不为1，则从pos位置开始匹配*/ int j = 1; /*j用于子串T中当前位置下标值*/ int next[255]; /定义一next数组/ get_next(T,next);/对串T作分析，得到next数组/ while(i &lt;= S[0] &amp;&amp; k &lt;= T[0]) &#123; if(j==0 || S[i] == T[j]) /两字母相等则继续，与朴素算法增加了j=0判断/ &#123; ++i; ++j; &#125; else &#123; j = next[j]; /j退回合适的位置，i值不变/ &#125; &#125; if(j &gt; T[0]) return i-T[0]; else return 0;&#125; 绿色注释部分为相对于朴素匹配算法增加的代码，改动不算大，关键就是去掉了i值回溯的部分。 对于get_next函数来说，若T的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得index_KMP算法效率得到了提高 while循环的时间复杂度为O(n),因此，整个算法的时间复杂度为O(n+m)，相较于朴素算法的O((n-m+1)*m)l来说，是要好一些。 KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显 KMP模式匹配算法改进 对next函数进行了改良,假设取代的数组为nextval(String T,int *nextval),注意观察两者区别 1234567891011121314151617181920212223/*求模式串T的next函数修正值并存入数组nextval*/void get_nextval(String T,int *nextval)&#123; int i,j; i = 1; j = 0; nextval[1]=0; while(i &lt;T[0]) /*此处T[0]表示串T的长度*/ &#123; if(j==0 || T[i] == T[j]) /*T[i]表示后缀的单个字符，T[j]表示前缀的单个字符*/ &#123; ++i; ++j; /*以下则是区别之处*/ if(T[i] != T[j]) /*若当前字符与前缀字符不同*/ nextval[i] = j; /*则当前的j为nextval在i位置的值*/ else nextval[i] = nextval[j]; /*如果与前缀字符相同，则将前缀字符的nextval值赋值给nextval在i位置的值*/ &#125; else j = nextval[j]; /*若字符不相同，则j值回溯*/ &#125;&#125; 实际匹配算法，只需要将”get_next(T,next);”改为”get_nextval(t,next);”j即可，这里不再重复 nextval数组值推导 ababaaaba——011234223——010104210 aaaaaaaab——012345678——000000008 总结改进过的KMP算法，它是在计算出next值的同时,如果a位字符与它next值指向的b位字符相等，则a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己的a位的next的值。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Fgit%2F2019%2F05%2F11%2Fgit.html</url>
    <content type="text"><![CDATA[Taylor Swift is back from reputation, and there is no snake but only butterflies now var ap = new APlayer({ element: document.getElementById("aplayer-kKhkLDxq"), narrow: false, autoplay: false, showlrc: false, music: { title: "Me!!!", author: "Taylor Swift", url: "http://prc4nro7n.bkt.clouddn.com/Me.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/me.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 内容之后补充，还在整理,先听歌Σ(っ °Д °;)っ]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈与队列]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F10%2FDataStructure-02.html</url>
    <content type="text"><![CDATA[数据结构与算法-栈与队列部分,栈与队列是数据结构重要思想之一，之后的抽象数据类型中诸多算法与方法会利用其特点 “花也好。星星也好。世间所有美丽的事物，都是为了比喻你而存在。” 介绍 前言： 栈(stack)是限定仅在表尾进行插入和删除操作的线性表 队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表 我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIFO结构。 首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底 栈的插入操作，叫作进栈，也称压栈,入栈 栈的删除操作，叫作出栈 最先进栈的元素，是不是就只能是最后出栈呢？ 举例:3个整型数字元素1，2，3依次进栈，会有哪些出栈次序呢？？？ 321，123，213，132，231 没有312 栈的抽象数据类型 对于栈来讲，理论上线性表的操作特性它都具备，由于它的特殊性，特别是插入和删除操作，我们改名为push和pop,英文直译的话是压和弹,我们一般叫进栈和出栈12345678910111213ADT 栈(stack)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系Operation InitStack(*S):初始化操作，建立一个空栈S DestroyStack(*S):若栈存在，则销毁它 ClearStack(*S):将栈清空 StackEmpty(S):若栈为空，返回true，否则返回false GetTop(S,*e):若栈存在且非空，用e返回S的栈顶元素 Push(*S,e):若栈存在，插入新元素e到栈S中并成为栈顶元素 Pop(*S,*e):删除栈S中栈顶元素，并用e返回其值 StackLength(S):返回栈S的元素个数endADT 同理：思考一下何时用S，S，e，e 栈的顺序存储结构及实现 若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。若栈存在一个元素时，top等于0，因此通常把空栈的判定条件定位top等于-1 栈的结构定义123456typedef int SElemType;/*SElemType类型根据实际情况而定，这里假设为int*/typedef struct&#123; SElemType data[MAXSIZE]; int top;/*用于栈顶指针*/&#125;SqStack; 进栈操作(push) 1234567891011/*插入元素e为新的栈顶元素*/Status Push(SqStack *S,SElemType e)&#123; if(S-&gt;top == MAXSIZE - 1) /*栈满*/ &#123; return ERROR; &#125; S-&gt;top++;/*栈顶指针增加一*/ S-&gt;data[S-&gt;top]=e;/*将新插入元素赋值给栈顶空闲*/ return OK;&#125; 出栈操作(pop) 123456789/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/Status Pop(SqStack *S,SElemType *e)&#123; if(S-&gt;top == -1) return ERROR; *e = S-&gt;data[S-&gt;top];/*将要删除的栈顶元素赋值给e*/ s-&gt;top--;/*栈顶指针减一*/ return OK;&#125; 两者没有涉及到任何循环语句，由此时间复杂度均是O(1) 两栈共享空间 栈的顺序存储缺陷：必须事先确定数组存储空间大小 不理解：栈1为空时，就是top1等于-1时，而当top2等于n时，即是栈2为空时；若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。 两个栈相遇之时，就是两个指针相差1之时，即top1 + 1== top2为栈满1234567/*两栈共享空间结构*/typedef struct&#123; SElemType data[MAXSIZE]; int top1;/*栈1栈顶指针*/ int top2;/*栈2栈顶指针*/&#125;SqDoubleStack; 对于两栈共享空间的push，除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber1234567891011/*插入元素e为新的栈顶元素*/Status Push(SqDoubleStack *S,SElemType e, int stackNumber)&#123; if(S-&gt;top1+1==S-&gt;top2)/*栈已满，不能再push新元素了*/ return ERROR; if(stackNumber==1)/*栈1有元素进栈*/ S-&gt;data[++S-&gt;top1]=e;/*若栈1则先top1+1后给数组元素赋值*/ else if(stackNumber==2)/*栈2有元素进栈*/ S-&gt;data[--S-&gt;top2]=e;/*若栈2则先top2-1后给数组元素赋值*/ return OK;&#125; 1234567891011121314151617/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/Status Pop(SqDoubleStack *S,SElemType *e,int stackNumber)&#123; if(stackNumber==1) &#123; if(S-&gt;top1==-1) return ERROR; *e=S-&gt;data[S-&gt;top1--]; &#125; else if(stackNumber==2) &#123; if(S-&gt;top2==MAXSIZE) return ERROR; *e=S-&gt;data[S-&gt;top2++]; &#125; return OK;&#125; 注意前提条件:两个具有相同数据类型的栈 栈的链式存储结构及实现 栈的链式存储结构简称为链栈 有栈顶在头部，那对于链栈来说，是不需要头结点的 对于链栈，基本不存在栈满的情况，除非内存已经没有可以使用的空间，对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL123456789101112/*链栈的结构代码*/typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStackPtr;/*ptr指pointer,即指针*/typedef struct LinkStack&#123; LinkStackPtr top; int count;&#125;LinkStack; 栈的链表存储结构——进栈操作 12345678910/*插入元素e为新的栈顶元素*/Status Push(LinkStack *S,SElemType e)&#123; LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data=e; s-&gt;next=S-&gt;top;/*把当前的栈顶元素赋值给新结点的直接后继*/ S-&gt;top=s;/*将新的结点s赋值给栈顶指针*/ S-&gt;count++; return OK;&#125; 栈的链式存储结构——出栈操作 12345678910111213/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR；*/Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if(StackEmpty(*S)) return ERROR; *e=S-&gt;top-&gt;data; p=S-&gt;top;/*将栈顶结点赋值给p*/ S-&gt;top=S-&gt;top-&gt;next;/*使得栈顶指针下移一位，指向后一结点*/ free(p); S-&gt;count--; return OK;&#125; 链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1) 栈的应用 递归之斐波那契数列(Fibonacci)12345678910111213141516/*迭代法实现*/int main()&#123; int i; int a[40]; a[0]=0; a[1]=1; printf("%d",a[0]); printf("%d",a[1]); for(i=2;i&lt;40;i++) &#123; a[i]=a[i-1]+a[i-2]; printf("%d",a[i]); &#125; return 0;&#125; 1234567891011121314/*斐波那契的递归函数*/int Fbi(int i)&#123; if(i&lt;2) return i == 0 ? 0 : 1; return Fbi(i-1)+Fbi(i-2);/*这里Fbi就是函数自己，它在调用自己*/&#125;int main()&#123; int i; for(int i = 0;i &lt; 40;i++) printf("%d",Fbi(i)); return 0;&#125; 我们把一个直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称作递归函数，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出 栈的应用之四则运算表达式求值逆波兰(Reverse Polish Notation,RPN):一种不需要括号的后缀表达法，这种后缀表示法，巧妙解决了程序实现四则运算的难题 例子：对于”9+(3-1)X3+10/2”如果用后缀表示法应该是”9 3 1 - 3 * + 10 2 / +” 计算规则:从左到右遍历表达式的每个数字和符号，遇到是数字就出栈，遇到是符号，就将处以栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最后获得最终结果 中缀表达式转后缀表达式规则:从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止 队列的定义 定义：队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表 队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头. 队列的抽象数据类型12345678910111213ADT 队列(Queue)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系Operation InitQueue(*Q):初始化操作，建立一个空队列Q DestroyQueue(*Q):若队列Q存在，则销毁它 ClearQueue(*Q):将队列Q清空 QueueEmpty(Q):若队列Q为空，返回true，否则返回false GetHead(Q,*e):若队列Q存在且非空，用e返回队列Q的队头元素 EnQueue(*Q,e):若队列Q存在，插入新元素e到队列Q中并成为队尾元素 DeQueue(*Q,*e):删除队列Q中队头元素，并用e返回其值 QueueLength(Q):返回队列Q的元素个数endADT 循环队列 队列顺序存储的不足 假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，数组下标为0的一端即是队头 所谓的入队列操作，就是在队尾插入一个元素，不需要移动任何元素，时间复杂度为O(1) 与栈不同的是，队列元素的出列在队头，即下标为0的地方，队列所有元素都得前移，那时间复杂度为O(n)，之后利用指针改善 这里的实现和线性表的顺序存储结构完全相同，不再详述 为了避免当只有一个元素时，队头跟队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个元素，这样当front等于rear时，此队列不是还剩一个元素，而是空队列 定义：我们把队列的这种头尾相接的顺序存储结构称为循环队列。我们刚才说，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？ 法一是设置一个标志变量flag,当front == rear，且flag=0时队列空，当flag=1时为队列满 法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。 重点讨论法二:由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，也可能相差整整一圈。若队列的最大尺寸为QueueSize，那么队列满的条件是:(rear+1)%QueueSize == front 队列长度: 当rear &gt; front时，队列长度就是rear-front。但当rear &lt; front时，队列长度分为两段，一段是Queue-front，另一段是0+rear，加在一起就是rear-front+Queue，由此通用的计算队列长度公式为: (rear-front+Queue)%Queue12345678typedef int QElemType;/*QElemType类型根据实际情况而定，这里假设为int*//*循环队列的顺序存储结构代码*/typedef struct&#123; QElemType data[MAXSIZE]; int front;/*头指针*/ int rear;/*尾指针，若队列不空，指向队列尾元素的下一个位置*/&#125;SqQueue 循环队列的初始化代码如下1234567/*初始化一个空队列Q*/Status InitQueue(SqQueue *Q)&#123; Q-&gt;front = 0; Q-&gt;rear = 0; return OK;&#125; 循环队列求队列长度代码如下：12345/*返回Q的元素个数，也就是队列的当前长度*/int QueueLength(SqQueue Q)&#123; return (Q.rear-Q.front+MAXSIZE)%MAXSIZE&#125; 循环队列的入队列操作代码123456789/*若队列未满，则插入元素e为Q新的队尾元素*/Status EnQueue(SqQueue *Q,QElemType e)&#123; if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)/*队列满的判断*/ return ERROR; Q-&gt;data[Q-&gt;rear]=e;/*将元素e赋值给队尾*/ Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/*rear指针向后移一位置,若到最后则转到数组头部*/ return OK;&#125; 循环队列的出队列操作代码123456789/*若队列不空，则删除Q中队头元素，用e返回其值*/Status DeQueue(SqQueue *Q,QElemType *e)&#123; if(Q-&gt;front = Q-&gt;rear)/*队列空的判断*/ return ERROR; *e=Q-&gt;data[Q-&gt;front]; Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;/*front指针向后移一个位置，若到最后则转到数组头部*/ return OK;&#125; 可以发现，单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临数组可能溢出的问题，所以我们需要研究一下不需要担心队列长度的链式存储结构。 队列的链式存储结构及实现 定义：队列的链式存储结构，其实就是线性表的单链表,只不过它只能尾进头出而已，我们把它简称为链队列。 重点：为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点 链队列的结构为： 1234567891011typedef int QElemType;/*QElemType类型根据实际情况而定，这里假设为int*/typedef struct QNode /*结点结构*/&#123; QElemType data; struct QNode *next;&#125;QNode,*QueuePtr;typedef struct /*队列的链表结构*/&#123; QueuePtr front,rear;/*队头，队尾指针*/&#125;LinkQueue 队列的链式存储结构——入队操作 123456789101112/*插入元素e为Q的新的队尾元素*/Status EnQueue(LinkQueue *Q,QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); if(!s) /*存储分配失败*/ exit(OVERFLOW); s-&gt;data=e; s-&gt;next=NULL; Q-&gt;rear-&gt;next=s;/*把拥有元素e新结点s赋值给原队尾结点的后继，把当前的s设置为队尾结点，rear指向s*/ Q-&gt;rear=s; return OK;&#125; 队列的链式存储结构——出队操作 1234567891011121314/*若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR*/Status DeQueue(LinkQueue *Q,QElemType *e)&#123; QueuePtr p; if(Q-&gt;front == Q-&gt;rear) return ERROR; p=Q-&gt;front-&gt;next;/*将欲删除的队头结点暂存给p*/ *e=p-&gt;data;/*将欲删除的队头结点的值赋值给e*/ Q-&gt;front-&gt;next=p-&gt;next;/*将原队头结点后继p-&gt;next赋值给头结点后继*/ if(Q-&gt;rear==p)/*若队头是队尾，则删除后将rear指向头结点*/ Q-&gt;rear=Q-&gt;front; free(p); return OK;&#125; 对于循环队列与链队列的比较，可以从两方面考虑 时间上，它们的基本操作都是常数时间，即O(1)，不过循环队列是事先申请好空间，使用期间不释放，而链队列每次申请和释放结点会存在一些时间开销，如果入队出队频繁，还是有细微差异的 空间上，循环队列必须有一个固定长度，所以就有存储元素个数和空间浪费的问题,空间上链队列更灵活 总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列长度，则用链队列. 总结回顾stack跟queue均可以用线性表的顺序存储结构来实现，但是都存在着顺序存储的一些弊端,由此它们各自有各自的技巧解决问题 对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化利用数组的空间。 对于队列来说，未来避免数组插入和删除时需要移动数据，则引入了循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)它们也可以通过链式存储结构来实现，实现原则跟线性表差不多。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F10%2FDataStructure-01.html</url>
    <content type="text"><![CDATA[数据结构与算法-线性表部分,线性表较为基础，其中对链表的操作需要熟悉，之后我会补上链表操作练习 链表练习 “即使只有一条路，也没有什么好困扰的，重要的是该怎么走那条路，对吧？” 线性表 (List)：零个或多个数据元素的有限序列 线性表元素的个数n（n≥0）定义为线性表的长度，当n=0时，称为空表。 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。 线性表的抽象数据类型12345678910111213ADT 线性表(List)Data 线性表的数据对象集合为&#123;a1，a2，....an&#125;每个元素类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an之外，每一个元素有且只有一个直接后继元素。数据元素之间是一对一的关系OperationInitList(*L):初始化操作，建立一个空的线性表LListEmpty(L):判断线性表是否为空表，若线性表为空，返回True，否则返回falseClearList(*L):将线性表清空GetElem(L,I,*e):将线性表L中的第i个位置元素返回给eLocateElem(L,e):在线性表L中查找与给定值e相等的元素如果查找成功，返回该元素在表中序号，表示成功，否则返回0，表示失败。ListInsert(*L,i,e):在线性表L的第i个位置插入新元素eListDelete(*L,i,*e):删除线性表L中第i个位置元素，并用e返回其值ListLength(L):返回线性表L的元素个数endADT 实现两个线性表集合A跟B的并集操作！1234567891011121314/*将所有的在线性表Lb但不在La的数据元素插入到La中*/void union(List *La,List Lb)&#123; int La_len,Lb_len,i; ElemType e; /*声明与La和Lb相同的数据元素e*/ La_len = ListLength(La); /*求线性表的长度*/ Lb_len = ListLength(Lb); for(i = 1;i &lt;= Lb_len;i++) &#123; GetElem(Lb,i,e);/*取Lb中第i个数据元素赋给e*/ if(!LocateElem(La,e,equal)) /*La中不存在和e相同数据元素*/ ListInsert(La, ++La_len, e); /*插入*/ &#125;&#125; 线性表的顺序存储结构 定义:指的是用一段地址连续的存储单元以此存储线性表的数据元素。 以下是线性表的顺序存储的结构代码 1234567#define MAXSIZE 20 /*存储空间的初始分配量 */typedef int ElemType； /*ElemType类型根据实际情况而定，这里假设为int*/typedef struct&#123; ElemType data[MAXSIZE]； /*数组存储数据元素，最大值为MAXSIZE*/ int length； /*线性表当前长度*/&#125;SqList； /*Sequence List*/ 数组长度和线性表长度的区别： 数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的 线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是会变化的 在任意时刻，线性表的长度应该小于等于数组的长度。 地址计算方法 线性表的第i个元素是要存储在数组下标为i-1的位置，即线性表从1开始 用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，由此分配的数组空间要大于等于当前线性表的长度 存储器中的每个存储单元都有自己的编号，这个编号称为地址 LOC(a(i+1))=LOC(ai)+c LOC(ai)=LOC(a1)+(i-1)*c 顺序存储结构的插入与删除 GetElem:将线性表L中的第i个位置元素值返回，就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。 123456789101112131415#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;/*Status（状态，身份，地位）是函数的类型，其值是函数结果状态代码，如OK*//*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*//*操作结果:用e返回L中第i个数据元素的值*/Status GetElem(SqList L,int i,ElemType *e)&#123; if(L.length==0 || i&lt;1 || i&gt;L.length) return ERROR; *e=L.data[i-1]; return OK;&#125; ==疑问：为什么是*e？== ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e 插入算法的思路： 如果插入位置不合理，抛出异常 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置 将要插入元素填入位置i处 表长加一123456789101112131415161718/*初始条件:顺序线性表L已存在,1≤i≤ListLength(L)*//*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if(L-&gt;length==MAXSIZE) /*顺序线性表已经满*/ return ERROR; if(i&lt;1 || i&gt;L-&gt;length+1) /*当i不在范围内时*/ return ERROR; if(i&lt;L-&gt;length) /*若插入数据位置不在表尾*/ &#123; for(k=L-&gt;length-1;k&gt;=i-1;k--) /*将要插入位置后数据元素向后移一位*/ L-&gt;data[k+1]=L-&gt;data[k]; &#125; L-&gt;data[i-1]=e;/*将新元素插入*/ L-&gt;length++; return OK;&#125; ListDelete 删除算法的思路: 如果删除位置不合理，抛出异常 取出删除元素 从删除元素位置开始遍历到最后一个元素，分别将它们都往前移动一个位置 表长减112345678910111213141516Status ListDelete(SqList *L,int i,ElemType *e)&#123; int k; if(L-&gt;length == 0) /*线性表为空*/ return ERROR; if(i&lt;1 || i&gt;L-&gt;length) /*删除位置不正确*/ return ERROR; *e=L-&gt;data[i-1]; if(i&lt;L-length) /*如果删除不是最后位置*/ &#123; for(k=i;k&lt;L-length;k++) /*将删除位置后继元素前移*/ L-data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; -线性表顺序存储结构的优缺点 优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间，可以快速地存取表中任一位置的元素 缺点：插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量，造成存储空间的“碎片” 线性表的链式存储结构 为了表示每个数据元素a1与其直接后继元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置).我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node) n个结点(ai的存储映像)链结成一个链表，即为线性表(a1，a2，…an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做==单链表== 我们把链表中第一个结点的存储位置叫做头指针，规定最后一个结点指针为“空”(通常用NULL或^符号表)；有时，为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，头结点的指针域存储指向第一个结点的指针。头指针与头结点的异同 头指针 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 头指针具有标识作用，所以常用头指针冠以链表的名字 无论链表是否为空，头指针均不为空。头指针是链表的必要元素 头结点 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度) 有了头结点，对在第一元素结点前插入节点和删除第一结点，其操作与其它节点的操作就==统一==了 头结点不一定是链表必要元素 线性表链式存储结构代码描述 若线性表为空表，则头结点的指针域为“空” 单链表中，我们在C语言可用结构指针来描述 1234567/*线性表的单链表存储结构*/typedef struct Node&#123; ElemType data; struct Node *next;&#125; Node;typedef struct Node *LinkList;/*定义LinkList*/ 这波操作事后==了解==一下,翻一下结构体 结点由存放数据元素的数据域,存放后继结点地址的指针域组成 单链表的读取 获得链表第i个数据的算法思路： 声明一个结点p指向链表第一个结点，初始化j从1开始 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1 若到链表末尾p为空，则说明第i个元素不存在 否则查找成功，返回结点p的数据123456789101112131415161718/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*//*操作结果:用e返回L中的第i个数据元素的值*/Status GetElem(LinkList L,int i,ElemType *e)&#123; int j; LinkList p; /*声明一结点p*/ p = L-&gt;next; /*让p指向链表L的第一个结点*/ j = 1; /*j为计数器*/ while(p &amp;&amp; j&lt;i) /*p不为空或者计数器j还没有等于i时，循环继续*/ &#123; p = p-&gt;next; /*让p指向下一个结点*/ ++j； &#125; if( !p || j&gt;i ) return ERROR; /*第i个元素不存在*/ *e = p-&gt;data; /*取第i个元素的数据*/ return OK;&#125; 单链表的插入与删除 s-&gt;next=p-&gt;next; p-&gt;next=s这两句的顺序==不可交换==，自己想 单链表第i个数据插入结点的算法思路： 声明一结点p指向链表第一个结点，初始化j从1开始 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1 若到链表末尾p为空，则说明第i个元素不存在 否则查找成功，在系列中生成一个空结点s 将数据元素e赋值给s-&gt;data 单链表的插入标准语句s-&gt;next=p-&gt;next; p-&gt;next=s 返回成功123456789101112131415161718192021/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*//*操作结果:在L中第i个位置之前插入新的数据元素e，L的长度加1*/Status ListInsert(LinkList *L,int i,ElemType e)&#123; int j; LinkList p,s; p = *L; j = 1; while( p &amp;&amp; j &lt; i) /*寻找第i个结点*/ &#123; p = p-&gt;next; ++j; &#125; if(!p || j &gt; i) return ERROR; /*第i个元素不存在*/ s =(LinkList)malloc(sizeof(Node));/*生成新结点(C标准函数)*/ s-&gt;data = e; s-&gt;next = p-&gt;next;/*将p的后继结点赋值给s的后继*/ p-&gt;next = s; /*将s赋值给p的后继*/ return OK;&#125; 单链表的删除实质：p-&gt;next=p-&gt;next-&gt;next 用q来取代p-&gt;next,就是q=p-&gt;next;p-&gt;next=q-&gt;next; 单链表第i个数据删除结点的算法思路: 声明一结点p指向链表的第一个节点，初始化j从1开始 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1 若到链表末尾p为空，则说明第i个元素不存在 否则查找成功，将欲删除的结点p-&gt;next赋值给q 单链表的标准删除语句p-&gt;next=q-&gt;next 将q结点中的数据赋值给e，作为返回 释放q结点 返回成功12345678910111213141516171819202122/*初始条件:顺序线性表L已存在，1≤i≤ListLength(L)*//*操作结果:删除L的第i个数据元素，并用e返回其值，L的长度减1*/Status ListDelete(LinkList *L,int i, ElemType *e)&#123; int j; LinkList p,q; p = *L; j = 1; while(p-&gt;next &amp;&amp; j &lt; i) /*遍历寻找第i个元素*/ &#123; p = p-&gt;next; ++j; &#125; if(!(p-&gt;next) || j&gt;i) return ERROR;/*第i个元素不存在*/ q = p-&gt;next; p -&gt;next = q-&gt;next;/*将q的后继赋值给p的后继*/ *e=q-&gt;data;/*将q结点中的数据给e*/ free(q);/*让系统回收此结点，释放内存*/ return OK;&#125; 单链表的整表创建 创建单链表的过程就是一个动态生成链表的过程，即从”空表”的初始状态起，依次建立各元素结点，并逐个插入链表 单链表整表创建的算法思路: 声明一结点p和计数器变量i 初始化一空链表L 让L的头结点的指针指向NULL，即建立一个带头结点的单链表 循环:生成一新结点赋值给p；随机生成一数字赋值给p的数据域p-&gt;data;将p插入到头结点与前一新结点之间12345678910111213141516/*随机生成n个元素的值，建立带表头结点的单链线性表L(头插法)*/void CreateListHead(LinkList *L,int n)&#123; LinkList p; int i; srand(time(0)); /*初始化随机数种子*/ *L = ( LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; /*先建立一个带头结点的单链表*/ for(i=0;i&lt;n;i++) &#123; p = (LinkList)malloc(sizeof(Node));/*生成新结点*/ p-&gt;data = rand()%100+1; /*随机生成100以内的数字*/ p-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; /*插入到表头*/ &#125;&#125; 求问L,L,(L)的区别？ 如果要改变变量的值就用指针，不改变就用变量本身LinkList等同于Node ，所以L要加 函数rand()跟srand()1234567891011121314151617/*随机生成n个元素的值，建立带表头结点的单链线性表L(尾插法)*/void CreateListTail(LinkList *L,int n)&#123; LinkList p,r; int i; srand(time(0));/*初始化随机数种子*/ *L = (LinkList)malloc(sizeof(Node))；/*为整个线性表*/ r=*L;/*r为指向尾部的结点*/ for (i=0;i&lt;n;i++) &#123; p=(Node*)malloc(sizeof(Node));/*生成新结点*/ p-&gt;data=rand()%100+1;/*随机生成100以内的数字*/ r-&gt;next = p;/*将表尾终端结点的指针指向新结点*/ r=p; &#125; r-&gt;next=NULL;/*表示当前链表结束*/&#125; 单链表的整表删除 单链表整表删除的算法思路如下: 声明一结点p和q； 将第一个结点赋值给p 循环：将下一结点赋值给q；释放p；将q赋值给p。1234567891011121314/*初始条件：顺序线性表L已存在，操作结果：将L重置为空表*/Status ClearList(LinkList *L)&#123; LinkList p,q; p=(*L)-&gt;next; /*p指向第一个结点*/ while(p) &#123; q=p-&gt;next; free(p); p=q; &#125; (*L)-&gt;next=NULL;/*头结点指针域为空*/ return OK;&#125; 单链表结构与顺序存储结构优缺点 简单地对单链表结构和顺序存储结构做对比： 存储分配方式 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素 时间性能 查找：①顺序存储结构O(1)；②单链表O(n) 插入与删除：①顺序存储结构需要平均移动表长一半的元素，时间为O(n)； ②单链表在线出某位置的指针后，插入和删除时间仅为O(1) 空间性能 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制通过上面对比，我们可以得出一些经验性的结论 若线性表需要频繁查找，很少进行插入或删除时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。比如游戏开发，对于用户注册的个人信息，出来注册时插入数据外，绝大多数情况都是读取，所以应该考虑顺序存储结构。而游戏装备道具就用单链表结构。 当线性表元素个数变化很大或者不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，则用顺序存储结构效率会高很多。 静态链表 背景:数组代替指针描述单链表，首先让数组的元素由两个数据域组成，data和cur，也就是说，数组的每一个下标都对应一个data和一个cur.数据域data，用来存放数据元素，也就是通常我们要处理的数据，而游标cur相当于单链表的next指针，用于存放该元素后继在数组中的下标。我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。 为了方便插入数据，通常会把数组建立得大一些，以便有一些空闲空间插入不至于溢出 12345678/*线性表的静态链表存储结构*/#define MAXSIZE 1000 /*假设链表的最大长度是1000*/typedef struct&#123; ElemType data; int cur; /*游标(cursor),为0 时表示无指向*/&#125;Component,StaticLinkList[MAXSIZE]; 另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据，把未被使用的数组元素称为备用链表。 数组第一个元素，即下标为0的元素的cur存放备用链表的第一个结点的下标;而数组的最后一个元素的cur则存放第一个有数值的元素的下表，相当于单链表中的头结点，当整个链表为空时，则为012345678910/*将一维数组space中各分量链成一备用链表*//*space[0].cur为头指针，"0"表示空指针*/Status InitList(StaticLinkList space)&#123; int i; for(i=0;i&lt;MAXSIZE-1;i++) space[i].cur = i+1; space[MAXSIZE-1].cur = 0/*目前静态链表为空，最后一个元素的cur为0*/ return OK;&#125; 静态链表的插入操作 静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放 动态链表，结点的申请和释放分别借用malloc()和free()两个函数来实现，而静态链表操作的是数组，我们需要自己实现这两个函数 为了辨明数组中哪些分量未被使用，解决方法是将所有未被使用过的及被删除的分量用游标链成一个备用的链表，每当插入时，可以从备用链表上取得第一个结点作为待插入的新结点 12345678/*若备用空间链表为空，则返回分配的结点下标，否则为0*/int Malloc_SLL(StaticLinkList space)&#123; int i = space[0].cur;/*当前数组第一个元素的cur存的值就是要返回的第一个备用空闲的下标*/ if(space[0].cur) space[0].cur = space[i].cur/*由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用*/ return i;&#125; 需要找到接替者才能继续分配新的空闲分量 现在我们如果需要在乙丁之间插入丙，我们只需要让丙在7号备用位待着，把乙的cur改为7，再让丙的cur改为3即可123456789101112131415161718Status ListInsert(StaticLinkList L,int i, ElemType e)&#123; int j,k,l; k = MAX_SIZE - 1;/*注意k首先是最后一个元素的下标*/ if(i &lt; 1 || i &gt; ListLength(L) + 1) return ERROR; j = Malloc_SSL(L);/*获得空闲分量的下标*/ if(j) &#123; L[j].data = e; /*将数据赋值给此分量的data*/ for(l = 1;l &lt;= i-1;l++) /*找到第i个元素之前的位置*/ k = L[k].cur; L[j].cur = L[k].cur;/*把第i个元素之前的cur赋值给新元素的cur*/ L[k].cur = j;/*把新元素的下标赋值给第i个元素之前元素的cur*/ return OK； &#125; return ERROR；&#125; 静态链表的删除操作 和前面一样，删除元素时，原来是需要释放结点的函数free().现在我们也得自己实现它: 1234567891011121314/*删除在L中第i个数据元素e*/Status ListDelete(StaticLinkList L,int i)&#123; int j,k; if(i &lt; 1 || i &gt; LIstLength(L)) return ERROR; k = MAX_SIZE - 1; for(j = 1;j &lt;= i-1;j++) k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L,j); return OK;&#125; 而关于Free_SSL(L,j)123456/*将下列为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space,int k)&#123; space[k].cur = space[0].cur;/*把第一个元素cur赋值给要删除的分量cur*/ space[0].cur = k;/*把要删除的分量下标赋值给第一个元素的cur*/&#125; 当然，静态链表也有相应的其他操作的相关实现，比如代码中的ListLength123456789101112/*初始条件：静态链表L已存在，操作结果：返回L中的数据个数*/int ListLength(StaticLinkList L)&#123; int j = 0; int i = L[MAXSIZE-1].cur; while(i) &#123; i = L[i].cur; j++; &#125; return j;&#125; 回顾：sizeof()和strlen 静态链表优缺点 优点 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点 缺点 没有解决连续存储分配带来的表长难以确定的问题 失去了顺序存储结构随机存取的特性 总的来说，静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法。 循环链表 定义:将单链表中终端结点的指针端由空指针改为指向头结点就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list) 循环链表和单链表的主要差异在判断条件上：原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束 在单链表中，我们有了头结点，可以用O(1)的时间访问第一个结点，但对于要访问到最后一个结点，却需要O(n)时间，因为我们需要将单链表全部扫描一遍 如用O(1)的时间由链表指针访问到最后一个结点,则需改造一下循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便 终端结点用尾指针rear指示，则查找终端结点是O(1),而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂也为O(1) 举个程序的例子，要将两个循环链表合成一个表时，有了尾指针就非常简单1234p = rearA-&gt;next;/*保存A表的头结点*/rearA-&gt;next=rearB-&gt;next-&gt;next;/*将本是指向B表的第一个结点(不是头结点)赋值给rearA-&gt;next*/rearB-&gt;next=p;/*将原A表的头结点赋值给rearB-&gt;next*/free(p);/*释放p*/ 双向链表 定义：双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。1234567/*线性表的双向链表存储结构*/typedef struct DuLNode&#123; ElemType data; struct DuLNode *prior;/*直接前驱指针*/ struct DuLNode *next;/*直接后继指针*/&#125;DulNode,*DuLinkList; 既然单链表有循环链表，那么双向链表也可以是循环链表 p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next 双向链表的插入将结点s插入到结点p和p-&gt;next之间 顺序很重要，不能写反1234s-&gt;prior = p;/*将p赋值给s的前驱*/s-&gt;next = p-&gt;next;/*把p-&gt;next赋值给s的后继*/p-&gt;next-&gt;prior = s;/*把s赋值给p-&gt;next的前驱*/p-&gt;next = s;/*把s赋值给p的后继*/ 顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继 双向链表的删除123p-&gt;prior-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=p-&gt;prior;free(p); 多结合图形记忆 总结回顾 线性表 顺序存储结构 链式存储结构 单链表 静态链表 循环链表 双向链表]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构概论]]></title>
    <url>%2FDataStructure%2F2019%2F05%2F10%2FDataStructure-introduction.html</url>
    <content type="text"><![CDATA[数据结构与算法绪论,打算将当初的数据结构笔记搬上博客，主要参照《大话数据结构》，此处强烈推荐 摘要图存粹是为了美观，其次是为了推荐这首faded的remix，同一首歌不一样的感觉，在我看来，多了一种空灵的美感，强烈推荐，之后的摘要图估计也会是图文关系不大（￣︶￣）↗ var ap = new APlayer({ element: document.getElementById("aplayer-hMWifQgf"), narrow: false, autoplay: true, showlrc: false, music: { title: "Faded (Restrung)", author: "Alan Walker", url: "http://prc4nro7n.bkt.clouddn.com/faded.mp3", pic: "http://prc4nro7n.bkt.clouddn.com/faded.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。 逻辑结构：数据对象中数据元素之间的相互关系 集合结构（平等） 线性结构（一对一） 树形结构（一对多） 图形结构（多对多） 物理结构：数据的逻辑结构在计算机中的存储方式 顺序结构 链式结构 算法（Algorithm）：对数据结构的运用 算法的特性 输入：算法具有零个或多个输入 输出：算法至少有一个或多个输出 有穷性：自动结束不会死循环 确定性：不会出现二义性 可行性：每一步都是可行的 算法设计要求 正确性 算法程序没有语法错误 算法程序对于合法的输入数据能够产生满足要求的输出结果 算法程序对于非法的输入数据能够算得出满足规格说明的结果 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果 可读性 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或者莫名其妙的结果 时间效率搞和存储量低 算法效率的度量方法 事后统计方法 事前分析估算方法 函数的渐近增长与时间复杂度 大O阶方法 用常数1取代运行时间中所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除与这个项相乘的常数，得到的结果就是大O阶。 常数阶 无论n为多少，这个常数为多少，我们都记作O（1），而不能是O（3）、O（12）等任何数字，这是初学者常常犯的错。可以理解为常数项为最高项，然后去除系数，则为1 线性阶 12345int i;for(i = 0; i &lt; n;i++)&#123; /*时间复杂度为O（1）的程序步骤序列*/&#125; 对数阶 123456int count = 1;while(count &lt; n)&#123; count = count * 2; /*时间复杂度为O（1）的程序步骤序列*/&#125; 由2^x^=n得x=log(2)n，所以这个循环的时间复杂度为O（logn） 平方阶12345678int i,j;for(i = 0; i &lt; n;i++)&#123; for(j = 0; j &lt; n;j++) &#123; /* 时间复杂度为O（1）的程序步骤序列*/ &#125;&#125; 12345678int i,j;for(i = 0;i &lt; n;i++)&#123; for(j = i;j &lt; n;j++) /*注意j = i而不是0*/ &#123; /*时间复杂度为O（1）的程序步骤序列*/ &#125;&#125; 总执行次数为：n+(n-1)+(n-2)+…+1= n^2^/2+n/2,因此这段代码的时间负责度为O(n^2^) 最坏情况与平均情况 通常，除非特殊指定，我们提到的运行时间都是最坏情况的运行时间 平均运行时间是所有情况中最有意义的，因为它是期望的云习惯时间，但是平均运行时间和难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。 一般在没有特殊说明的情况下，都是指最坏时间复杂度 算法空间复杂度]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[article]]></title>
    <url>%2F%E7%BB%83%E4%B9%A0%2F2019%2F05%2F08%2Farticle.html</url>
    <content type="text"><![CDATA[内容 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ var options = {"narrow":false,"autoplay":true,"showlrc":2,"mutex":true,"music":[{"title":"Viva la Vida","author":"Coldplay","url":"http://prc4nro7n.bkt.clouddn.com/Viva%20la%20Vida.mp3","pic":"http://prc4nro7n.bkt.clouddn.com/Viva.jpg"},{"title":"me!!!","author":"Taylor swift","pic":"http://prc4nro7n.bkt.clouddn.com/me.jpg","url":"http://prc4nro7n.bkt.clouddn.com/Me.mp3"},{"title":"奉献","author":"毛不易","pic":"http://prc4nro7n.bkt.clouddn.com/maomao.jpg","url":"http://prc4nro7n.bkt.clouddn.com/%E5%A5%89%E7%8C%AE.mp3"}]}; options.element = document.getElementById("aplayer-QvzPTNmH"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>表格</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2F2019%2F05%2F08%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
