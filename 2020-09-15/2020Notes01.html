<!doctype html>


  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://jhjhljh.github.io"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="39EeAhjsZOkXpt8PcowvLUrmgQkkCB0cBcMU65Rhxbk">









  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">


<link href="https://fonts.loli.net/css?family=EB+Garamond:500,500i,700,700i|Noto+Serif+SC:400,500,700&display=swap" rel="stylesheet">



  

<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Vue,前端,双向绑定,消息通信,">





  <link rel="alternate" href="/atom.xml" title="Abo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.3">






<meta name="description" content="整理自掘金大佬(寻找海蓝96)面试官系列">
<meta name="keywords" content="Vue,前端,双向绑定,消息通信">
<meta property="og:type" content="article">
<meta property="og:title" content="面试官系列-框架相关篇">
<meta property="og:url" content="https://linjiahong.top/2020-09-15/2020Notes01.html">
<meta property="og:site_name" content="Abo">
<meta property="og:description" content="整理自掘金大佬(寻找海蓝96)面试官系列">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://images.linjiahong.top/financial-2860753_1280.jpg">
<meta property="og:image" content="c:/Users/fchxh/AppData/Roaming/Typora/typora-user-images/1599611058336.png">
<meta property="og:image" content="https://images.linjiahong.top/Note1.png">
<meta property="og:image" content="https://images.linjiahong.top/Note2.png">
<meta property="og:image" content="https://images.linjiahong.top/Note3.png">
<meta property="og:image" content="https://images.linjiahong.top/Note4.png">
<meta property="og:image" content="https://images.linjiahong.top/Note5.png">
<meta property="og:image" content="https://images.linjiahong.top/Note6.png">
<meta property="og:image" content="https://images.linjiahong.top/Note7.png">
<meta property="og:image" content="https://images.linjiahong.top/Note8.png">
<meta property="og:image" content="https://images.linjiahong.top/Note9.png">
<meta property="og:image" content="https://images.linjiahong.top/Note10.png">
<meta property="og:image" content="https://images.linjiahong.top/Note11.png">
<meta property="og:image" content="https://images.linjiahong.top/Note12.png">
<meta property="og:image" content="https://images.linjiahong.top/Note13.png">
<meta property="og:image" content="https://images.linjiahong.top/Note14.png">
<meta property="og:image" content="https://images.linjiahong.top/Note15.png">
<meta property="og:image" content="https://images.linjiahong.top/Note16.png">
<meta property="og:updated_time" content="2020-11-27T06:08:13.280Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试官系列-框架相关篇">
<meta name="twitter:description" content="整理自掘金大佬(寻找海蓝96)面试官系列">
<meta name="twitter:image" content="https://images.linjiahong.top/financial-2860753_1280.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"display":"hide","offset":12,"b2t":false,"onmobile":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="https://linjiahong.top/2020-09-15/2020Notes01.html">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


  <title> 面试官系列-框架相关篇 | Abo </title>
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>

  	 <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("W0twhOKHT901IOCEADaiuynP-gzGzoHsz", "zQfRdGCiWzVvsSpXKOJsbvHe");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = $(document.getElementById(url)).text() + ': 0';
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = $(document.getElementById(url)).text() + ': ' + object.get('time');
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content = $(document.getElementById(url)).text() + ': ' + counter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = $(document.getElementById(url)).text() + ': ' + newcounter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
});
</script>
  


<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-140429748-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4f040a6ebf9ae0c7337c462df961942c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  
  
  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Abo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">林加鸿</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-futbol-o"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-top">
          <a href="/top" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-signal"></i> <br>
            
            排行
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://linjiahong.top/2020-09-15/2020Notes01.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="林加鸿">
    <meta itemprop="description" content>
    <meta itemprop="image" content="https://images.linjiahong.top/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Abo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Abo" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                面试官系列-框架相关篇
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-15T13:45:02+08:00">
                2020-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
		  
			 
          
          
             <span id="/2020-09-15/2020Notes01.html" class="leancloud_visitors" data-flag-title="面试官系列-框架相关篇">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度 </span>
               
                 <span class="leancloud-visitors-count"></span>
				 <span>℃</span>
             </span>
          
		   
          

		  
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  26.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  108
                </span>
              
            </div>
          
		  
          
 
        


        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p></p><p class="description">整理自掘金大佬(寻找海蓝96)面试官系列</p><br><img src="https://images.linjiahong.top/financial-2860753_1280.jpg" alt="blonde-801985_1280"><p></p>
<a id="more"></a>
<p><blockquote class="question">内容有点多，↘打开导航条</blockquote><br>
        <div id="aplayer-WWcJxnJX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-WWcJxnJX"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "exile",
              author: "Taylor Swift,Bon Iver",
              url: "https://images.linjiahong.top/Taylor%20Swift%2CBon%20Iver%20-%20exile.mp3",
              pic: "https://images.linjiahong.top/folklore.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script></p>
<h2 id="实现EVENTBUS（⭐⭐⭐）"><a href="#实现EVENTBUS（⭐⭐⭐）" class="headerlink" title="实现EVENTBUS（⭐⭐⭐）"></a>实现EVENTBUS（⭐⭐⭐）</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vue组件非常常见的有父子组件通信，兄弟组件通信。而父子组件通信就很简单，父组件会通过 <code>props</code> 向下传数据给子组件，当子组件有事情要告诉父组件时会通过 <code>$emit</code> 事件告诉父组件。今天就来说说如果两个页面没有任何引入和被引入关系，该如何通信了？如果咱们的应用程序不需要类似Vuex这样的库来处理组件之间的数据通信，就可以考虑Vue中的 <code>事件总线</code> ，即 <strong><code>EventBus</code></strong>来通信。</p>
<p><code>EventBus</code> 又称为事件总线。在Vue中可以使用 <code>EventBus</code> 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。</p>
<h4 id="使用EventBus"><a href="#使用EventBus" class="headerlink" title="使用EventBus"></a>使用EventBus</h4><p><strong>一、初始化</strong><br>首先需要创建事件总线并将其导出，以便其它模块可以使用或者监听它。我们可以通过两种方式来处理。先来看第一种，新创建一个 .js 文件，比如 <code>event-bus.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// event-bus.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">export const EventBus = new Vue()</span><br></pre></td></tr></table></figure>
<p>实质上<code>EventBus</code>是一个不具备 <code>DOM</code> 的组件，它具有的仅仅只是它实例方法而已，因此它非常的轻便。</p>
<p>另外一种方式，可以直接在项目中的 <code>main.js</code> 初始化 <code>EventBus</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">Vue.prototype.$EventBus = new Vue()</span><br></pre></td></tr></table></figure>
<p>注意，这种方式初始化的<code>EventBus</code>是一个<code>全局的事件总线</code>。稍后再来聊一聊全局的事件总线。</p>
<p>现在我们已经创建了 <code>EventBus</code> ，接下来你需要做到的就是在你的组件中加载它，并且调用同一个方法，就如你在父子组件中互相传递消息一样。</p>
<p><strong>二、发送事件</strong></p>
<p>假设你有两个Vue页面需要通信： A 和 B ，A页面 在按钮上面绑定了点击事件，发送一则消息，想=通知 B页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- A.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsg()&quot;&gt;-&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt; </span><br><span class="line">import &#123; EventBus &#125; from &quot;../event-bus.js&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMsg() &#123;</span><br><span class="line">      EventBus.$emit(&quot;aMsg&quot;, &apos;来自A页面的消息&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要在 B页面 中接收这则消息。</p>
<p><strong>三、接收事件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- IncrementCount.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt; </span><br><span class="line">import &#123; </span><br><span class="line">  EventBus </span><br><span class="line">&#125; from &quot;../event-bus.js&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    EventBus.$on(&quot;aMsg&quot;, (msg) =&gt; &#123;</span><br><span class="line">      // A发送来的消息</span><br><span class="line">      this.msg = msg;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>同理我们也可以在 B页面 向 A页面 发送消息。这里主要用到的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 发送消息</span><br><span class="line">EventBus.$emit(channel: string, callback(payload1,…))</span><br><span class="line"></span><br><span class="line">// 监听接收消息</span><br><span class="line">EventBus.$on(channel: string, callback(payload1,…))</span><br></pre></td></tr></table></figure>
<p>前面提到过，如果使用不善，<code>EventBus</code>会是一种灾难，到底是什么样的<code>“灾难”</code>了？大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的<code>EventBus</code>会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，<code>EventBus</code>在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理<code>EventBus</code>在项目中的关系。通常会用到，在vue页面销毁时，同时移除<code>EventBus</code>事件监听。</p>
<p><strong>移除事件监听者</strong></p>
<p>如果想移除事件的监听，可以像下面这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; </span><br><span class="line">  eventBus </span><br><span class="line">&#125; from &apos;./event-bus.js&apos;</span><br><span class="line">EventBus.$off(&apos;aMsg&apos;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>EventBus.$off(&#39;aMsg&#39;)</code> 来移除应用内所有对此某个事件的监听。或者直接调用 <code>EventBus.$off()</code> 来移除所有事件频道，不需要添加任何参数 。</p>
<p>上面就是 <code>EventBus</code> 的使用方法，是不是很简单。上面的示例中我们也看到了，每次使用 <code>EventBus</code> 时都需要在各组件中引入 <code>event-bus.js</code> 。事实上，我们还可以通过别的方式，让事情变得简单一些。那就是创建一个全局的 <code>EventBus</code> 。接下来的示例向大家演示如何在Vue项目中创建一个全局的 <code>EventBus</code> 。</p>
<p><strong>全局EventBus</strong></p>
<p>它的工作原理是发布/订阅方法，通常称为 <code>Pub/Sub</code> 。</p>
<p><strong>创建全局EventBus</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var EventBus = new Vue();</span><br><span class="line"></span><br><span class="line">Object.defineProperties(Vue.prototype, &#123;</span><br><span class="line">  $bus: &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return EventBus</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在这个特定的总线中使用两个方法<code>$on</code>和<code>$emit</code>。一个用于创建发出的事件，它就是<code>$emit</code>；另一个用于订阅<code>$on</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var EventBus = new Vue();</span><br><span class="line"></span><br><span class="line">this.$bus.$emit(&apos;nameOfEvent&apos;, &#123; ... pass some event data ...&#125;);</span><br><span class="line"></span><br><span class="line">this.$bus.$on(&apos;nameOfEvent&apos;,($event) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后我们可以在某个Vue页面使用<code>this.$bus.$emit(&quot;sendMsg&quot;, &#39;我是web秀&#39;);</code>，另一个Vue页面使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$bus.$on(&apos;updateMessage&apos;, function(value) &#123;</span><br><span class="line">  console.log(value); // 我是web秀</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>同时也可以使用<code>this.$bus.$off(&#39;sendMsg&#39;)</code>来移除事件监听。</p>
<p><strong>总结</strong></p>
<p>本文主要通过简单的实例学习了Vue中有关于 <code>EventBus</code> 相关的知识点。主要涉及了 <code>EventBus</code> 如何实例化，又是如何通过 <code>$emit</code> 发送频道信号，又是如何通过 <code>$on</code> 来接收频道信号。最后简单介绍了如何创建全局的 <code>EventBus</code> 。从实例中我们可以了解到， <code>EventBus</code> 可以较好的实现兄弟组件之间的数据通讯。</p>
<h4 id="React-Vue不同组件之间是怎么通信的"><a href="#React-Vue不同组件之间是怎么通信的" class="headerlink" title="React/Vue不同组件之间是怎么通信的?"></a>React/Vue不同组件之间是怎么通信的?</h4><p><strong>Vue</strong></p>
<ol>
<li>父子组件用Props通信</li>
<li>非父子组件用Event Bus通信</li>
<li>如果项目够复杂,可能需要Vuex等全局状态管理库通信</li>
<li><code>$dispatch</code>(已经废除)和<code>$broadcast</code>(已经废除)</li>
</ol>
<p><strong>React</strong></p>
<ol>
<li>父子组件,父-&gt;子直接用Props,子-&gt;父用callback回调</li>
<li>非父子组件,用发布订阅模式的Event模块</li>
<li>项目复杂的话用Redux、Mobx等全局状态管理管库</li>
<li>用新的<a href="https://juejin.im/post/6844903560988082184" target="_blank" rel="noopener">Context Api</a></li>
</ol>
<p>我们大体上都会有以上回答,接下来很可能会问到如何实现<code>Event(Bus)</code>,因为这个东西太重要了,几乎所有的模块通信都是基于类似的模式,包括安卓开发中的<code>Event Bus</code>, Node.js中的<code>Event</code>模块(Node中几乎所有的模块都依赖于Event,包括不限于<code>http、stream、buffer、fs</code>等).</p>
<h3 id="基本构造"><a href="#基本构造" class="headerlink" title="基本构造"></a>基本构造</h3><h4 id="初始化class"><a href="#初始化class" class="headerlink" title="初始化class"></a>初始化class</h4><p>我们利用ES6的<code>class</code>关键字对<code>Event</code>进行初始化,包括<code>Event</code>的事件清单和监听者上限.</p>
<p>我们选择了<code>Map</code>作为储存事件的结构,因为作为键值对的储存方式<code>Map</code>比一般对象更加适合,我们操作起来也更加简洁,可以先看一下Map的<a href="http://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">基本用法与特点</a>.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="keyword">this</span>._events || new Map(); <span class="comment">// 储存事件/回调键值对</span></span><br><span class="line">    <span class="keyword">this</span>._maxListeners = <span class="keyword">this</span>._maxListeners || <span class="number">10</span>; <span class="comment">// 设立监听上限</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="监听与触发"><a href="#监听与触发" class="headerlink" title="监听与触发"></a>监听与触发</h4><p>触发监听函数我们可以用<code>apply</code>与<code>call</code>两种方法,在少数参数时<code>call</code>的性能更好,多个参数时<code>apply</code>性能更好,当年Node的Event模块就在三个参数以下用<code>call</code>否则用<code>apply</code>.</p>
<p>当然当Node全面拥抱ES6+之后,相应的<code>call/apply</code>操作用<code>Reflect</code>新关键字重写了,但是我们不想写的那么复杂,就做了一个简化版.</p>
<h5 id="关于js反射"><a href="#关于js反射" class="headerlink" title="关于js反射"></a>关于js反射</h5><p>在国内的技术文章中你去搜索”JS 反射”得到的大部分的内容都是在说“利用JS的for(…in…)语句实现反射机制”，但其实反射机制在如今的ES6中可以得到更大的延伸以及运用。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span>(obj[p]==<span class="string">"function"</span>)&#123;</span><br><span class="line">             obj[p]();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             alert(obj[p]);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这段语句遍历obj对象的所有属性和方法，遇到属性则弹出它的值，遇到方法则立刻执行。在后面可以看到，在面向对象的JavaScript程序设计中，反射机制是很重要的一种技术，它在实现类的继承中发挥了很大的作用。</p>
<p>再看一组例子</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStyle</span><span class="params">(_style)</span></span>&#123;</span><br><span class="line">      <span class="comment">//得到要改变样式的界面对象</span></span><br><span class="line">      <span class="keyword">var</span> element=getElement();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> _style)&#123;</span><br><span class="line">            element.style[p]=_style[p];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="关于Reflect-反射"><a href="#关于Reflect-反射" class="headerlink" title="关于Reflect(反射)"></a>关于Reflect(反射)</h5><blockquote>
<p>反射机制指的是程序在运行时能够获取自身的信息</p>
</blockquote>
<p><strong>Reflect</strong> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener">proxy handlers</a>的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。Reflect的所有属性和方法都是静态的，Reflect的所有属性和方法都是静态的，Reflect的所有属性和方法都是静态的。</p>
<p>与大多数全局对象不同<code>Reflect</code>并非一个构造函数，所以不能通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">new运算符</a>对其进行调用，或者将<code>Reflect</code>对象作为一个函数来调用。<code>Reflect</code>的所有属性和方法都是静态的（就像<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="noopener"><code>Math</code></a>对象）。</p>
<h6 id="那么为什么需要Reflect对象？"><a href="#那么为什么需要Reflect对象？" class="headerlink" title="那么为什么需要Reflect对象？"></a><strong>那么为什么需要Reflect对象？</strong></h6><p><code>Reflect</code> 对象提供了以下静态方法，这些方法与<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener">proxy handler methods</a>的命名相同.</p>
<p>其中的一些方法与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener"><code>Object</code></a>相同, 尽管二者之间存在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods" target="_blank" rel="noopener">某些细微上的差别</a> .</p>
<p><code>Reflect</code>对象一共有 13 个静态方法（匹配<code>Proxy</code>的13种拦截行为）。</p>
<ul>
<li><p>Reflect.apply(target, thisArg, args)</p>
</li>
<li><p>Reflect.construct(target, args)</p>
</li>
<li><p>Reflect.get(target, name, receiver)</p>
</li>
<li><p>Reflect.set(target, name, value, receiver)</p>
</li>
<li><p>Reflect.defineProperty(target, name, desc)</p>
</li>
<li><p>Reflect.deleteProperty(target, name)</p>
</li>
<li><p>Reflect.has(target, name)</p>
</li>
<li><p>Reflect.ownKeys(target)</p>
</li>
<li><p>Reflect.isExtensible(target)</p>
</li>
<li><p>Reflect.preventExtensions(target)</p>
</li>
<li><p>Reflect.getOwnPropertyDescriptor(target, name)</p>
</li>
<li><p>Reflect.getPrototypeOf(target)</p>
</li>
<li><p>Reflect.setPrototypeOf(target, prototype)</p>
<p>大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。</p>
</li>
</ul>
<p>众所周知， ES6 新增了一个全局、内建、不可构造的 <code>Reflect</code> 对象，并提供了其下一系列可被拦截的操作方法。其中一个便是 <code>Reflect.apply()</code> 了。下面探究下它与传统 ES5 的 <code>Function.prototype.apply()</code> 之间有什么异同。</p>
<p>MDN 上两者的函数签名分别如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(target, thisArgument, argumentsList)</span><br><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">apply</span>(<span class="params">thisArg, [argsArray]</span>)</span></span><br></pre></td></tr></table></figure>
<p>可以最直观看到的是， <code>function.apply()</code> 给函数的第二个传参「参数数组」是可选的，当不需要传递参数给被调用的函数时，可以不传或传递 <code>null</code> 、 <code>undefined</code> 值。而由于 <code>function.apply()</code> 只有两个参数，所以实践中连第一个参数也可以一起不传，原理上可以在实现中获得 <code>undefined</code> 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test1'</span>) &#125;).apply()</span><br><span class="line"><span class="comment">// test1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test2'</span>) &#125;).apply(<span class="literal">undefined</span>, [])</span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test3'</span>) &#125;).apply(<span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// test3</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123; <span class="built_in">console</span>.log(text) &#125;).apply(<span class="literal">undefined</span>, [<span class="string">'test4'</span>])</span><br><span class="line"><span class="comment">// test4</span></span><br></pre></td></tr></table></figure>
<p>而 <code>Reflect.apply()</code> 则要求所有参数都必传，如果希望不传参数给被调用的函数，则必须填一个空数组或者空的类数组对象（纯 JavaScript 下空对象也可以，若是 TypeScript 则需带上 <code>length: 0</code> 的键值对以通过类型检查）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test1'</span>) &#125;, <span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// Thrown:</span></span><br><span class="line"><span class="comment">// TypeError: CreateListFromArrayLike called on non-object</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test2'</span>) &#125;, <span class="literal">undefined</span>, [])</span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test3'</span>) &#125;, <span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// test3</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123; <span class="built_in">console</span>.log(text) &#125;, <span class="literal">undefined</span>, [<span class="string">'test4'</span>])</span><br><span class="line"><span class="comment">// test4</span></span><br></pre></td></tr></table></figure>
<p><strong>Reflect.get()</strong></p>
<p>Reflect.get() 方法与从 对象 (<code>target[propertyKey]</code>) 中读取属性类似，但它是通过一个函数执行来操作的。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reflect.get(<span class="keyword">target</span>, propertyKey[, receiver])</span><br><span class="line"><span class="keyword">target</span>  需要取值的目标对象</span><br><span class="line">propertyKey  需要获取的值的键值</span><br><span class="line">receiver  如果<span class="keyword">target</span>对象中指定了getter，receiver则为getter调用时的<span class="keyword">this</span>值。</span><br></pre></td></tr></table></figure>
<p><strong>使用例子</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.get(obj, <span class="string">"x"</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="built_in">Reflect</span>.get([<span class="string">"zero"</span>, <span class="string">"one"</span>], <span class="number">1</span>); <span class="comment">// "one"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy with a get handler</span></span><br><span class="line"><span class="keyword">var</span> x = &#123;<span class="attr">p</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(x, &#123;</span><br><span class="line">  <span class="keyword">get</span>(t, k, r) &#123; <span class="keyword">return</span> k + <span class="string">"bar"</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Reflect</span>.get(obj, <span class="string">"foo"</span>); <span class="comment">// "foobar"</span></span><br></pre></td></tr></table></figure>
<p>get() 方法可以继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="comment">// 实现私有属性读取保护</span></span><br><span class="line">      <span class="keyword">if</span>(propKey[<span class="number">0</span>] === <span class="string">'_'</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Erro(<span class="string">`Invalid attempt to get private     "<span class="subst">$&#123;propKey&#125;</span>"`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Getting '</span> + propKey);</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.name</span><br><span class="line"><span class="comment">// Getting name</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exam =&#123;</span><br><span class="line">    name: <span class="string">"Tom"</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(exam, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting '</span> + propKey);</span><br><span class="line">    <span class="keyword">return</span> target[propKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.name </span><br><span class="line"><span class="comment">// Getting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br></pre></td></tr></table></figure>
<h5 id="关于Object-create"><a href="#关于Object-create" class="headerlink" title="关于Object.create()"></a>关于Object.create()</h5><p><strong>Object.create()</strong>方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</p>
<p>Proxy直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于<code>Object.defineProperty</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="keyword">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">'Matthew'</span>; <span class="comment">// "name" is a property set on "me", but not on "person"</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; <span class="comment">// inherited properties can be overwritten</span></span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="comment">// expected output: "My name is Matthew. Am I human? true"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.create</span>(<span class="selector-tag">proto</span><span class="selector-attr">[, propertiesObject]</span>)</span><br><span class="line"><span class="selector-tag">proto</span>  新创建对象的原型对象。</span><br><span class="line"><span class="selector-tag">propertiesObject</span></span><br><span class="line">可选。如果没有指定为 <span class="selector-tag">undefined</span>，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应<span class="selector-tag">Object</span><span class="selector-class">.defineProperties</span>()的第二个参数。</span><br></pre></td></tr></table></figure>
<p>所以注意 ：new proxy是可以作为原型对象被object.create所参考</p>
<p>对set也同样理解，也是四个参数(target, propKey, value, receiver)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">set</span>: function(obj, prop, value, receiver) &#123;</span><br><span class="line">        obj[prop] = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.name= <span class="string">'Tom'</span>;</span><br><span class="line">proxy.name=== proxy <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> exam = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(exam, proxy)</span><br><span class="line">exam.name = <span class="string">"Tom"</span></span><br><span class="line">exam.name === exam <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发名为type的事件</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span><span class="params">(type, <span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">  let handler;</span><br><span class="line">  <span class="comment">// 从储存事件键值对的this._events中获取对应事件回调函数</span></span><br><span class="line">  handler = <span class="keyword">this</span>._events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    handler.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听名为type的事件</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span><span class="params">(type, fn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将type事件以及对应的fn函数放入this._events中储存</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events.get(type)) &#123;</span><br><span class="line">    <span class="keyword">this</span>._events.set(type, fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们实现了触发事件的<code>emit</code>方法和监听事件的<code>addListener</code>方法,至此我们就可以进行简单的实践了.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听一个名为arson的事件对应一个回调函数</span></span><br><span class="line">emitter.addListener(<span class="string">'arson'</span>, <span class="function"><span class="params">man</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`expel <span class="subst">$&#123;man&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们触发arson事件,发现回调成功执行</span></span><br><span class="line">emitter.emit(<span class="string">'arson'</span>, <span class="string">'low-end'</span>); <span class="comment">// expel low-end</span></span><br></pre></td></tr></table></figure>
<p>似乎不错,我们实现了基本的触发/监听,但是如果有多个监听者呢?</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重复监听同一个事件名</span></span><br><span class="line">emitter.addListener(<span class="string">'arson'</span>, <span class="function"><span class="params">man</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`expel <span class="subst">$&#123;man&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.addListener(<span class="string">'arson'</span>, <span class="function"><span class="params">man</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`save <span class="subst">$&#123;man&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'arson'</span>, <span class="string">'low-end'</span>); <span class="comment">// expel low-end</span></span><br></pre></td></tr></table></figure>
<p>是的,只会触发第一个,因此我们需要进行改造.</p>
<h3 id="升级改造"><a href="#升级改造" class="headerlink" title="升级改造"></a>升级改造</h3><p><strong>监听/触发器升级</strong></p>
<p>我们的<code>addListener</code>实现方法还不够健全,在绑定第一个监听者之后,我们就无法对后续监听者进行绑定了,因此我们需要将后续监听者与第一个监听者函数放到一个数组里.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发名为type的事件</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span><span class="params">(type, <span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">  let handler;</span><br><span class="line">  handler = <span class="keyword">this</span>._events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(handler)) &#123;</span><br><span class="line">    <span class="comment">// 如果是一个数组说明有多个监听者,需要依次此触发里面的函数</span></span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        handler[i].apply(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler[i].call(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 单个函数的情况我们直接触发即可</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      handler.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler.call(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听名为type的事件</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span><span class="params">(type, fn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="keyword">this</span>._events.get(type); <span class="comment">// 获取对应事件名称的函数清单</span></span><br><span class="line">  <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">    <span class="keyword">this</span>._events.set(type, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> handler === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果handler是函数说明只有一个监听者</span></span><br><span class="line">    <span class="keyword">this</span>._events.set(type, [handler, fn]); <span class="comment">// 多个监听者我们需要用数组储存</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler.push(fn); <span class="comment">// 已经有多个监听者,那么直接往数组里push函数即可</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>是的,从此以后可以愉快的触发多个监听者的函数了.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听同一个事件名</span></span><br><span class="line">emitter.addListener(<span class="string">'arson'</span>, <span class="function"><span class="params">man</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`expel <span class="subst">$&#123;man&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.addListener(<span class="string">'arson'</span>, <span class="function"><span class="params">man</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`save <span class="subst">$&#123;man&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.addListener(<span class="string">'arson'</span>, <span class="function"><span class="params">man</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`kill <span class="subst">$&#123;man&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">emitter.emit(<span class="string">'arson'</span>, <span class="string">'low-end'</span>);</span><br><span class="line"><span class="comment">//expel low-end</span></span><br><span class="line"><span class="comment">//save low-end</span></span><br><span class="line"><span class="comment">//kill low-end</span></span><br></pre></td></tr></table></figure>
<p><strong>移除监听</strong></p>
<p>我们会用<code>removeListener</code>函数移除监听函数,但是匿名函数是无法移除的.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span>, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="keyword">this</span>._events.get(<span class="keyword">type</span>); <span class="comment">// 获取对应事件名称的函数清单</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是函数,说明只被监听了一次</span></span><br><span class="line">  <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> handler === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._events.delete(<span class="keyword">type</span>, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> postion;</span><br><span class="line">    <span class="comment">// 如果handler是数组,说明被监听多次要找到对应的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (handler[i] === fn) &#123;</span><br><span class="line">        postion = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postion = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找到匹配的函数,从数组中清除</span></span><br><span class="line">    <span class="keyword">if</span> (postion !== <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 找到数组对应的位置,直接清除此回调</span></span><br><span class="line">      handler.splice(postion, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果清除后只有一个函数,那么取消数组,以函数形式保存</span></span><br><span class="line">      <span class="keyword">if</span> (handler.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._events.set(<span class="keyword">type</span>, handler[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><p>我们已经基本完成了<code>Event</code>最重要的几个方法,也完成了升级改造,可以说一个<code>Event</code>的骨架是被我们开发出来了,但是它仍然有不足和需要补充的地方.</p>
<blockquote>
<ol>
<li>鲁棒性不足: 我们没有对参数进行充分的判断,没有完善的报错机制.</li>
<li>模拟不够充分: 除了<code>removeAllListeners</code>这些方法没有实现以外,例如监听时间后会触发<code>newListener</code>事件,我们也没有实现,另外最开始的监听者上限我们也没有利用到.</li>
</ol>
</blockquote>
<p>当然,这在面试中现场写一个Event已经是很够意思了,主要是体现出来对<strong>发布-订阅</strong>模式的理解,以及针对多个监听状况下的处理,不可能现场撸几百行写一个完整Event.</p>
<p>附上Event库源码：<a href="https://github.com/Gozala/events/blob/master/events.js" target="_blank" rel="noopener">https://github.com/Gozala/events/blob/master/events.js</a></p>
<h2 id="前端路由的实现（⭐⭐）"><a href="#前端路由的实现（⭐⭐）" class="headerlink" title="前端路由的实现（⭐⭐）"></a>前端路由的实现（⭐⭐）</h2><p><strong>前端路由</strong>是现代SPA应用必备的功能,每个现代前端框架都有对应的实现,例如vue-router、react-router。</p>
<p>我们不想探究vue-router或者react-router们的实现，因为不管是哪种路由无外乎用兼容性更好的hash实现或者是H5 History实现，与框架几个只需要做相应的封装即可。</p>
<p><img src="C:\Users\fchxh\AppData\Roaming\Typora\typora-user-images\1599611058336.png" alt="1599611058336"></p>
<h3 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h3><h4 id="初始化class-1"><a href="#初始化class-1" class="headerlink" title="初始化class"></a>初始化class</h4><p>我们用<code>Class</code>关键字初始化一个路由.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 以键值对的形式储存路由</span></span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 当前路由的URL</span></span><br><span class="line">    <span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现路由hash储存与执行"><a href="#实现路由hash储存与执行" class="headerlink" title="实现路由hash储存与执行"></a>实现路由hash储存与执行</h4><p>在初始化完毕后我们需要思考两个问题:</p>
<ol>
<li>将路由的hash以及对应的callback函数储存</li>
<li>触发路由hash变化后,执行对应的callback函数</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将path路径与对应的callback函数储存</span></span><br><span class="line">  route(path, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes[path] = callback || function() &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新</span></span><br><span class="line">  refresh() &#123;</span><br><span class="line">    <span class="comment">// 获取当前URL中的hash路径</span></span><br><span class="line">    <span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">    <span class="comment">// 执行当前hash路径的callback函数</span></span><br><span class="line">    <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="监听对应事件"><a href="#监听对应事件" class="headerlink" title="监听对应事件"></a>监听对应事件</h4><p>那么我们只需要在实例化<code>Class</code>的时候监听上面的事件即可.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.refresh = <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>);</span><br><span class="line">    window.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>);</span><br><span class="line">    window.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  route(path, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes[path] = callback || function() &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  refresh() &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应效果如下:</p>
<p><img src="https://images.linjiahong.top/Note1.png" alt="1597650071918"></p>
<p><img src="https://images.linjiahong.top/Note2.png" alt="1597650077765"></p>
<p><img src="https://images.linjiahong.top/Note3.png" alt="1597650091822"></p>
<h3 id="增加回退功能"><a href="#增加回退功能" class="headerlink" title="增加回退功能"></a>增加回退功能</h3><p>上一节我们只实现了简单的路由功能,没有我们常用的<strong>回退</strong>与<strong>前进</strong>功能,所以我们需要进行改造</p>
<h4 id="实现后退功能"><a href="#实现后退功能" class="headerlink" title="实现后退功能"></a>实现后退功能</h4><p>我们在需要创建一个数组<code>history</code>来储存过往的hash路由例如<code>/blue</code>,并且创建一个指针<code>currentIndex</code>来随着<em>后退</em>和<em>前进</em>功能移动来指向不同的hash路由。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 储存hash与callback键值对</span></span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 当前hash</span></span><br><span class="line">    <span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 记录出现过的hash</span></span><br><span class="line">    <span class="keyword">this</span>.history = [];</span><br><span class="line">    <span class="comment">// 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="keyword">this</span>.history.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.refresh = <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.backOff = <span class="keyword">this</span>.backOff.bind(<span class="keyword">this</span>);</span><br><span class="line">    window.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>);</span><br><span class="line">    window.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  route(path, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes[path] = callback || function() &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  refresh() &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">    <span class="comment">// 将当前hash路由推入数组储存</span></span><br><span class="line">    <span class="keyword">this</span>.history.push(<span class="keyword">this</span>.currentUrl);</span><br><span class="line">    <span class="comment">// 指针向前移动</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex++;</span><br><span class="line">    <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后退功能</span></span><br><span class="line">  backOff() &#123;</span><br><span class="line">    <span class="comment">// 如果指针小于0的话就不存在对应hash路由了,因此锁定指针为0即可</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex &lt;= <span class="number">0</span></span><br><span class="line">      ? (<span class="keyword">this</span>.currentIndex = <span class="number">0</span>)</span><br><span class="line">      : (<span class="keyword">this</span>.currentIndex = <span class="keyword">this</span>.currentIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 随着后退,location.hash也应该随之变化</span></span><br><span class="line">    location.hash = `#$&#123;<span class="keyword">this</span>.history[<span class="keyword">this</span>.currentIndex]&#125;`;</span><br><span class="line">    <span class="comment">// 执行指针目前指向hash路由对应的callback</span></span><br><span class="line">    <span class="keyword">this</span>.routes[<span class="keyword">this</span>.history[<span class="keyword">this</span>.currentIndex]]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看起来实现的不错,可是出现了Bug,在后退的时候我们往往需要点击两下。</p>
<p>问题在于,我们每次在后退都会执行相应的callback,这会触发<code>refresh()</code>执行,因此每次我们后退,<code>history</code>中都会被<code>push</code>新的路由hash,<code>currentIndex</code>也会向前移动,这显然不是我们想要的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  refresh() &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">    <span class="comment">// 将当前hash路由推入数组储存</span></span><br><span class="line">    <span class="keyword">this</span>.history.push(<span class="keyword">this</span>.currentUrl);</span><br><span class="line">    <span class="comment">// 指针向前移动</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex++;</span><br><span class="line">    <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如图所示,我们每次点击后退,对应的指针位置和数组被打印出来 </p>
<p><img src="https://images.linjiahong.top/Note4.png" alt="1597650297622"></p>
<blockquote>
<p>第一次currentIndex-1，然后更改hash值，此时触发hashchange到refresh函数，则进行push操作以及currentIndex++，所以就结果来看currentIndex没有正常的发生-1，除此之外不要忘记立马执行路由函数，即绑定的回调函数，第二次点击回退的时候，hash值是相同的并没有触发hashchange所以不会进行refresh，才能正常currentIndex-1</p>
</blockquote>
<h4 id="完整实现hash-Router"><a href="#完整实现hash-Router" class="headerlink" title="完整实现hash Router"></a>完整实现hash Router</h4><p>我们必须做一个判断,如果是后退的话,我们只需要执行回调函数,不需要添加数组和移动指针。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 储存hash与callback键值对</span></span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 当前hash</span></span><br><span class="line">    <span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 记录出现过的hash</span></span><br><span class="line">    <span class="keyword">this</span>.history = [];</span><br><span class="line">    <span class="comment">// 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="keyword">this</span>.history.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.refresh = <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.backOff = <span class="keyword">this</span>.backOff.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 默认不是后退操作</span></span><br><span class="line">    <span class="keyword">this</span>.isBack = <span class="literal">false</span>;</span><br><span class="line">    window.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>);</span><br><span class="line">    window.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  route(path, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes[path] = callback || function() &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  refresh() &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isBack) &#123;</span><br><span class="line">      <span class="comment">// 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来</span></span><br><span class="line">      <span class="comment">// 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由</span></span><br><span class="line">      <span class="comment">// 避免再次造成指针的不匹配,我们直接截取指针之前的数组</span></span><br><span class="line">      <span class="comment">// 此操作同时与浏览器自带后退功能的行为保持一致</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.currentIndex &lt; <span class="keyword">this</span>.history.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">this</span>.history = <span class="keyword">this</span>.history.slice(<span class="number">0</span>, <span class="keyword">this</span>.currentIndex + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">this</span>.history.push(<span class="keyword">this</span>.currentUrl);</span><br><span class="line">      <span class="keyword">this</span>.currentIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span><br><span class="line">    console.log(<span class="string">'指针:'</span>, <span class="keyword">this</span>.currentIndex, <span class="string">'history:'</span>, <span class="keyword">this</span>.history);</span><br><span class="line">    <span class="keyword">this</span>.isBack = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后退功能</span></span><br><span class="line">  backOff() &#123;</span><br><span class="line">    <span class="comment">// 后退操作设置为true</span></span><br><span class="line">    <span class="keyword">this</span>.isBack = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentIndex &lt;= <span class="number">0</span></span><br><span class="line">      ? (<span class="keyword">this</span>.currentIndex = <span class="number">0</span>)</span><br><span class="line">      : (<span class="keyword">this</span>.currentIndex = <span class="keyword">this</span>.currentIndex - <span class="number">1</span>);</span><br><span class="line">    location.hash = `#$&#123;<span class="keyword">this</span>.history[<span class="keyword">this</span>.currentIndex]&#125;`;</span><br><span class="line">    <span class="keyword">this</span>.routes[<span class="keyword">this</span>.history[<span class="keyword">this</span>.currentIndex]]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前进的部分就不实现了,思路我们已经讲得比较清楚了,可以看出来,hash路由这种方式确实有点繁琐,所以HTML5标准提供了History API供我们使用。</p>
<h3 id="HTML5新路由方案"><a href="#HTML5新路由方案" class="headerlink" title="HTML5新路由方案"></a>HTML5新路由方案</h3><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><p>我们可以直接在浏览器中查询出History API的方法和属性。</p>
<p><img src="https://images.linjiahong.top/Note5.png" alt="1597650904011"></p>
<p>我们只简单看一下常用的API</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.back();       <span class="comment">// 后退</span></span><br><span class="line"><span class="built_in">window</span>.history.forward();    <span class="comment">// 前进</span></span><br><span class="line"><span class="built_in">window</span>.history.go(<span class="number">-3</span>);       <span class="comment">// 后退三个页面</span></span><br></pre></td></tr></table></figure>
<p><code>history.pushState</code>用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数，依次为：</p>
<blockquote>
<p><code>state</code>:一个与指定网址相关的状态对象，<code>popstate</code>事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填<code>null</code>。<br><code>title</code>：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填<code>null</code>。<br><code>url</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</p>
</blockquote>
<p><code>history.replaceState</code>方法的参数与<code>pushState</code>方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。</p>
<p><code>popstate</code>事件,每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。</p>
<p>需要注意的是，仅仅调用<code>pushState</code>方法或<code>replaceState</code>方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用<code>back</code>、<code>forward</code>、<code>go</code>方法时才会触发。</p>
<p>另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p>
<h4 id="新标准下路由的实现"><a href="#新标准下路由的实现" class="headerlink" title="新标准下路由的实现"></a>新标准下路由的实现</h4><p>上一节我们介绍了新标准的History API,相比于我们在Hash 路由实现的那些操作,很显然新标准让我们的实现更加方便和可读。</p>
<p>所以一个mini路由实现起来其实很简单</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 在初始化时监听popstate事件</span></span><br><span class="line">    <span class="keyword">this</span>._bindPopState();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化路由</span></span><br><span class="line">  <span class="keyword">init</span>(path) &#123;</span><br><span class="line">    history.replaceState(&#123;path: path&#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="keyword">this</span>.routes[path] &amp;&amp; <span class="keyword">this</span>.routes[path]();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将路径和对应回调函数加入hashMap储存</span></span><br><span class="line">  route(path, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes[path] = callback || function() &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发路由对应回调</span></span><br><span class="line">  go(path) &#123;</span><br><span class="line">    history.pushState(&#123;path: path&#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="keyword">this</span>.routes[path] &amp;&amp; <span class="keyword">this</span>.routes[path]();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听popstate事件</span></span><br><span class="line">  _bindPopState() &#123;</span><br><span class="line">    window.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> path = e.state &amp;&amp; e.state.path;</span><br><span class="line">      <span class="keyword">this</span>.routes[path] &amp;&amp; <span class="keyword">this</span>.routes[path]();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.linjiahong.top/Note6.png" alt="1597651623798"></p>
<p><img src="https://images.linjiahong.top/Note7.png" alt="1597651633538"></p>
<blockquote>
<p>附上Vue-Router代码：<a href="https://github.com/vuejs/vue-router/blob/dev/src/index.js" target="_blank" rel="noopener">https://github.com/vuejs/vue-router/blob/dev/src/index.js</a></p>
</blockquote>
<h2 id="实现双向绑定Proxy比defineproperty优劣如何-（⭐⭐⭐⭐⭐）"><a href="#实现双向绑定Proxy比defineproperty优劣如何-（⭐⭐⭐⭐⭐）" class="headerlink" title="实现双向绑定Proxy比defineproperty优劣如何?（⭐⭐⭐⭐⭐）"></a>实现双向绑定Proxy比defineproperty优劣如何?（⭐⭐⭐⭐⭐）</h2><h3 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h3><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<ul>
<li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li>
<li>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li>
<li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li>
<li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li>
</ul>
<p><img src="https://images.linjiahong.top/Note8.png" alt="1597652421202"></p>
<p>那 Vue3 将会用 <code>Proxy</code> 替换 <code>Object.defineProperty()</code> ，<code>proxy</code> 有什么优点？</p>
<h3 id="关于defineProperty"><a href="#关于defineProperty" class="headerlink" title="关于defineProperty"></a>关于defineProperty</h3><p>对象是由多个名/值对组成的无序的集合。对象中每个属性对应任意类型的值。<br>定义对象可以使用构造函数或字面量的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>;  <span class="comment">//obj = &#123;&#125;</span></span><br><span class="line">obj.name = <span class="string">"张三"</span>;  <span class="comment">//添加描述</span></span><br><span class="line">obj.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;  <span class="comment">//添加行为</span></span><br></pre></td></tr></table></figure>
<p>除了以上添加属性的方式，还可以使用<strong>Object.defineProperty</strong>定义新属性或修改原有的属性。</p>
<p>语法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, <span class="keyword">prop</span>, descriptor)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<blockquote>
<p>obj：必需。目标对象<br>prop：必需。需定义或修改的属性的名字<br>descriptor：必需。目标属性所拥有的特性</p>
</blockquote>
<p>返回值：</p>
<blockquote>
<p>传入函数的对象。即第一个参数obj</p>
</blockquote>
<p>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被<em>for..in</em>或<em>Object.keys()</em>遍历。</p>
<p>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。</p>
<h4 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h4><p>当修改或定义对象的某个属性的时候，给这个属性添加一些特性：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    test:</span><span class="string">"hello"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//对象已有的属性添加特性描述</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,"test",&#123;</span></span><br><span class="line"><span class="attr">    configurable:</span><span class="literal">true</span> <span class="string">| false,</span></span><br><span class="line"><span class="string"></span><span class="attr">    enumerable:</span><span class="literal">true</span> <span class="string">| false,</span></span><br><span class="line"><span class="string"></span><span class="attr">    value:</span><span class="string">任意类型的值,</span></span><br><span class="line"><span class="attr">    writable:</span><span class="literal">true</span> <span class="string">| false</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">//对象新添加的属性的特性描述</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,"newKey",&#123;</span></span><br><span class="line"><span class="string"></span><span class="attr">    configurable:</span><span class="literal">true</span> <span class="string">| false,</span></span><br><span class="line"><span class="string"></span><span class="attr">    enumerable:</span><span class="literal">true</span> <span class="string">| false,</span></span><br><span class="line"><span class="string"></span><span class="attr">    value:</span><span class="string">任意类型的值,</span></span><br><span class="line"><span class="attr">    writable:</span><span class="literal">true</span> <span class="string">| false</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>VALUE: 属性对应的值,可以使任意类型的值，默认为undefined</p>
<p>WRITABLE: 属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。（并不会报错，只是修改不生效）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">//第一种情况：writable设置为false，不能重写。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//更改newKey的值</span></span><br><span class="line">obj.newKey = <span class="string">"change value"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况：writable设置为true，可以重写</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//更改newKey的值</span></span><br><span class="line">obj.newKey = <span class="string">"change value"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//change value</span></span><br></pre></td></tr></table></figure>
<p>ENUMERABLE: 此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">//第一种情况：enumerable设置为false，不能被枚举。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举对象的属性</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> attr <span class="keyword">in</span> obj )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( attr );  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种情况：enumerable设置为true，可以被枚举。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举对象的属性</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> attr <span class="keyword">in</span> obj )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( attr );  <span class="comment">//newKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>configurable: 是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。</p>
<p>这个属性起到两个作用：</p>
<ol>
<li>目标属性是否可以使用delete删除</li>
<li>目标属性是否可以再次设置特性</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/-----------------测试目标属性是否能被删除------------------------</span></span><br><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">//第一种情况：configurable设置为false，不能被删除。</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,"newKey",&#123;</span></span><br><span class="line"><span class="attr">    value:</span><span class="string">"hello"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    writable:</span><span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    enumerable:</span><span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span><span class="literal">false</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">//删除属性</span></span><br><span class="line"><span class="string">delete</span> <span class="string">obj.newKey;</span></span><br><span class="line"><span class="string">console.log(</span> <span class="string">obj.newKey</span> <span class="string">);</span> <span class="string">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="string">//第二种情况：configurable设置为true，可以被删除。</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,"newKey",&#123;</span></span><br><span class="line"><span class="attr">    value:</span><span class="string">"hello"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    writable:</span><span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    enumerable:</span><span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span><span class="literal">true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">//删除属性</span></span><br><span class="line"><span class="string">delete</span> <span class="string">obj.newKey;</span></span><br><span class="line"><span class="string">console.log(</span> <span class="string">obj.newKey</span> <span class="string">);</span> <span class="string">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="string">//-----------------测试是否可以再次修改特性------------------------</span></span><br><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">//第一种情况：configurable设置为false，不能再次修改特性。</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,"newKey",&#123;</span></span><br><span class="line"><span class="attr">    value:</span><span class="string">"hello"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    writable:</span><span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    enumerable:</span><span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span><span class="literal">false</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="string">//重新修改特性</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,"newKey",&#123;</span></span><br><span class="line"><span class="attr">    value:</span><span class="string">"hello"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    writable:</span><span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    enumerable:</span><span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span><span class="literal">true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">console.log(</span> <span class="string">obj.newKey</span> <span class="string">);</span> <span class="string">//报错：Uncaught</span> <span class="attr">TypeError:</span> <span class="string">Cannot</span> <span class="string">redefine</span> <span class="attr">property:</span> <span class="string">newKey</span></span><br><span class="line"></span><br><span class="line"><span class="string">//第二种情况：configurable设置为true，可以再次修改特性。</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,"newKey",&#123;</span></span><br><span class="line"><span class="attr">    value:</span><span class="string">"hello"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    writable:</span><span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    enumerable:</span><span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span><span class="literal">true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="string">//重新修改特性</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,"newKey",&#123;</span></span><br><span class="line"><span class="attr">    value:</span><span class="string">"hello"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    writable:</span><span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    enumerable:</span><span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span><span class="literal">true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">console.log(</span> <span class="string">obj.newKey</span> <span class="string">);</span> <span class="string">//hello</span></span><br></pre></td></tr></table></figure>
<p>除了可以给新定义的属性设置特性，也可以给已有的属性设置特性</p>
<p>提示：一旦<strong>使用Object.defineProperty</strong>给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的false</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">//定义的新属性后，这个属性的特性中configurable，enumerable，writable都为默认的值false</span></span><br><span class="line"><span class="comment">//这就导致了neykey这个是不能重写、不能枚举、不能再次设置特性</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Object.defineProperty(obj,<span class="string">'newKey'</span>,&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">obj.<span class="keyword">new</span><span class="type">Key</span> = <span class="string">'hello'</span>;</span><br><span class="line">console.log(obj.<span class="keyword">new</span><span class="type">Key</span>);  <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> attr <span class="keyword">in</span> obj )&#123;</span><br><span class="line">    console.log(attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的例子是使用defineProperty给对象添加属性，而不是自建对象属性</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义对象的时候添加的属性，是可删除、可重写、可枚举的。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="keyword">test</span>:<span class="string">"hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改写值</span></span><br><span class="line">obj.<span class="keyword">test</span> = 'change value';</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>( obj.<span class="keyword">test</span> ); <span class="comment">//'change value'</span></span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,<span class="string">"test"</span>,&#123;</span><br><span class="line">    writable:false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//再次改写值</span></span><br><span class="line">obj.<span class="keyword">test</span> = 'change value again';</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>( obj.<span class="keyword">test</span> ); <span class="comment">//依然是：'change value'</span></span><br></pre></td></tr></table></figure>
<h4 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter/setter"></a>getter/setter</h4><p>当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。</p>
<ul>
<li>getter 是一种获得属性值的方法</li>
<li>setter是一种设置属性值的方法。</li>
</ul>
<p>在特性中使用get/set属性来定义对应的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> initValue = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function ()&#123;</span><br><span class="line">        <span class="comment">//当获取值的时候触发的函数</span></span><br><span class="line">        <span class="keyword">return</span> initValue;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function (value)&#123;</span><br><span class="line">        <span class="comment">//当设置值的时候触发的函数,设置的新值通过参数value拿到</span></span><br><span class="line">        initValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">obj.newKey = <span class="string">'change value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey ); <span class="comment">//change value</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined</strong></p>
<p><img src="https://images.linjiahong.top/Note9.png" alt="1597654074343"></p>
<p>我们也可以这样写：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> val = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="keyword">get</span> [<span class="string">'sum'</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> [<span class="string">'sum'</span>](<span class="keyword">new</span><span class="type">Value</span>) &#123;</span><br><span class="line">            val += <span class="keyword">new</span><span class="type">Value</span></span><br><span class="line"><span class="type"></span>        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这段代码和上面代码结果是一样的。</p>
<p>这里的<code>&#39;sum&#39;</code>就是被监听的属性名，也就是我们需要监听的“一个”属性。</p>
<p>正是因为使用defineProperty每次只能绑定一个属性监听，所以Vue在遍历 + 递归时要有更大的性能消耗和更多的代码。</p>
<h3 id="关于proxy"><a href="#关于proxy" class="headerlink" title="关于proxy"></a>关于proxy</h3><p>介绍proxy之前先丢一段代码，开门见山</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Proxy(obj, &#123;</span><br><span class="line">  <span class="built_in">get</span>(target, <span class="built_in">key</span>, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> === <span class="string">'c'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'我是自定义的一个结果'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[<span class="built_in">key</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">set</span>(target, <span class="built_in">key</span>, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="number">4</span>) &#123;</span><br><span class="line">      target[<span class="built_in">key</span>] = <span class="string">'我是自定义的一个结果'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[<span class="built_in">key</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj.a) <span class="comment">// 1</span></span><br><span class="line">console.<span class="built_in">log</span>(obj.c) <span class="comment">// undefined</span></span><br><span class="line">console.<span class="built_in">log</span>(p.a) <span class="comment">// 1</span></span><br><span class="line">console.<span class="built_in">log</span>(p.c) <span class="comment">// 我是自定义的一个结果</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'李白'</span>;</span><br><span class="line">console.<span class="built_in">log</span>(obj.name); <span class="comment">// 李白</span></span><br><span class="line">obj.age = <span class="number">4</span>;</span><br><span class="line">console.<span class="built_in">log</span>(obj.age); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'李白'</span>;</span><br><span class="line">console.<span class="built_in">log</span>(p.name); <span class="comment">// 李白</span></span><br><span class="line">p.age = <span class="number">4</span>;</span><br><span class="line">console.<span class="built_in">log</span>(p.age); <span class="comment">// 我是自定义的一个结果</span></span><br></pre></td></tr></table></figure>
<p>在上面代码中,我们看到了构造一个代理对象时所传的第二个参数<code>handler</code>,这个<code>handler</code>对象是由<code>get</code>和<code>set</code>两个函数方法组成的.这两个方法会在一个对象被<code>get</code>和<code>set</code>时被调用执行,以代替原生对象上的操作.那么为什么在<code>handler</code>,定义<code>get</code>和<code>set</code>这两个函数名之后就代理对象上的<code>get</code>和<code>set</code>操作了呢?</p>
<p>实际上<code>handler</code>本身就是ES6所新设计的一个对象.它的作用就是用来<strong>自定义代理对象的各种可代理操作</strong>。它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下:(Proxy支持13种拦截行为（handle）)</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">handler</span>.getPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在读取代理对象的原型时触发该操作，比如在执行Object.getPrototypeOf(proxy) 时。</span></span><br><span class="line"><span class="comment">// Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.setPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.isExtensible()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.preventExtensions()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.getOwnPropertyDescriptor()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, "foo") 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.defineProperty()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, "foo", &#123;&#125;) 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.has()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 "foo" in proxy 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.get()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.set()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.deleteProperty()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.ownKeys()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.apply()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">handler</span>.construct()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span></span><br></pre></td></tr></table></figure>
<h3 id="Proxy的作用"><a href="#Proxy的作用" class="headerlink" title="Proxy的作用"></a>Proxy的作用</h3><p>对于代理模式<code>Proxy</code>的作用主要体现在三个</p>
<h4 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h4><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，<strong>而不是针对目标对象</strong>（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>
<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler) &#125;;</span><br></pre></td></tr></table></figure>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<p>Create方法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.create</span>(<span class="selector-tag">proto</span><span class="selector-attr">[, propertiesObject]</span>)</span><br><span class="line"><span class="selector-tag">proto</span>: 新创建对象的原型对象。</span><br><span class="line"><span class="selector-tag">propertiesObject</span>:可选。如果没有指定为 <span class="selector-tag">undefined</span>，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应<span class="selector-tag">Object</span><span class="selector-class">.defineProperties</span>()的第二个参数。</span><br></pre></td></tr></table></figure>
<h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p><strong>双向绑定</strong>其实已经是一个老掉牙的问题了,只要涉及到MVVM框架就不得不谈的知识点,但它毕竟是Vue的三要素之一</p>
<h4 id="Vue三要素"><a href="#Vue三要素" class="headerlink" title="Vue三要素"></a>Vue三要素</h4><ul>
<li>响应式: 例如如何监听数据变化,其中的实现方法就是我们提到的双向绑定</li>
<li>模板引擎: 如何解析模板</li>
<li>渲染: Vue如何将监听到的数据变化和解析后的HTML进行渲染</li>
</ul>
<p>可以实现双向绑定的方法有很多,KnockoutJS基于观察者模式的双向绑定,Ember基于数据模型的双向绑定,Angular基于脏检查的双向绑定, 我们重点讲面试中常见的基于<strong>数据劫持</strong>的双向绑定。</p>
<p>常见的基于数据劫持的双向绑定有两种实现,一个是目前Vue在用的<code>Object.defineProperty</code>,另一个是ES2015中新增的<code>Proxy</code>,而Vue的作者宣称将在Vue3.0版本后加入<code>Proxy</code>从而代替<code>Object.defineProperty</code>,通过本文你也可以知道为什么Vue未来会选择<code>Proxy</code>。</p>
<blockquote>
<p>严格来讲Proxy应该被称为『代理』而非『劫持』,不过由于作用有很多相似之处,我们在下文中就不再做区分,统一叫『劫持』。</p>
</blockquote>
<p>我们可以通过下图清楚看到以上两种方法在<strong>双向绑定</strong>体系中的关系.</p>
<p><img src="https://images.linjiahong.top/Note10.png" alt="1597660580614"></p>
<h3 id="基于数据劫持实现的双向绑定的特点"><a href="#基于数据劫持实现的双向绑定的特点" class="headerlink" title="基于数据劫持实现的双向绑定的特点"></a>基于数据劫持实现的双向绑定的特点</h3><h4 id="什么是数据劫持"><a href="#什么是数据劫持" class="headerlink" title="什么是数据劫持"></a>什么是数据劫持</h4><p>数据劫持比较好理解,通常我们利用<code>Object.defineProperty</code>劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是将要被劫持的对象</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  name: <span class="string">''</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'古天乐'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'给大家推荐一款超好玩的游戏'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'渣渣辉'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'戏我演过很多,可游戏我只玩贪玩懒月'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'来做我的兄弟'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象,对其属性值进行劫持</span></span><br><span class="line"><span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">      <span class="comment">// 当属性值发生变化时我们可以进行额外操作</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`大家好,我系<span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">      say(newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.name = <span class="string">'渣渣辉'</span>;</span><br><span class="line"><span class="comment">//大家好,我系渣渣辉</span></span><br><span class="line"><span class="comment">//戏我演过很多,可游戏我只玩贪玩懒月</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="数据劫持的优势"><a href="#数据劫持的优势" class="headerlink" title="数据劫持的优势"></a>数据劫持的优势</h4><p>目前业界分为两个大的流派,一个是以React为首的单向数据绑定,另一个是以Angular、Vue为主的双向数据绑定。</p>
<blockquote>
<p>其实三大框架都是既可以双向绑定也可以单向绑定,比如React可以手动绑定onChange和value实现双向绑定,也可以调用一些双向绑定库,Vue也加入了props这种单向流的api,不过都并非主流卖点。</p>
</blockquote>
<p>单向或者双向的优劣不在我们的讨论范围,我们需要讨论一下对比其他双向绑定的实现方法,数据劫持的优势所在。</p>
<p>无需显示调用: 例如Vue运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现<code>data.name = &#39;渣渣辉&#39;</code>后直接触发变更,而比如Angular的脏检测则需要显示调用<code>markForCheck</code>(可以用zone.js避免显示调用,不展开),react需要显示调用<code>setState</code>。</p>
<p>可精确得知变化数据：还是上面的小例子，我们劫持了属性的setter,当属性值改变,我们可以精确获知变化的内容<code>newVal</code>,因此在这部分不需要额外的diff操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量diff来找出变化值,这是额外性能损耗。</p>
<h4 id="基于数据劫持双向绑定的实现思路"><a href="#基于数据劫持双向绑定的实现思路" class="headerlink" title="基于数据劫持双向绑定的实现思路"></a>基于数据劫持双向绑定的实现思路</h4><p><strong>数据劫持</strong>是双向绑定各种方案中比较流行的一种,最著名的实现就是Vue</p>
<p>基于数据劫持的双向绑定离不开<code>Proxy</code>与<code>Object.defineProperty</code>等方法对对象/对象属性的”劫持”,我们要实现一个完整的双向绑定需要以下几个要点。</p>
<p>利用<code>Proxy</code>或<code>Object.defineProperty</code>生成的Observer针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者</p>
<p>解析器Compile解析模板中的<code>Directive</code>(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染</p>
<p>Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化</p>
<blockquote>
<p>虽然Vue运用了数据劫持，但是依然离不开<strong>发布订阅</strong>的模式(Event Bus的实现就是因为我们不管在学习一些框架的原理还是一些流行库（例如Redux、Vuex）,基本上都离不开<strong>发布订阅</strong>模式,而<em>Event</em>模块则是此模式的经典实现)</p>
</blockquote>
<h3 id="基于Object-defineProperty双向绑定的特点"><a href="#基于Object-defineProperty双向绑定的特点" class="headerlink" title="基于Object.defineProperty双向绑定的特点"></a>基于Object.defineProperty双向绑定的特点</h3><p>关于<code>Object.defineProperty</code>的文章在网络上已经汗牛充栋,我们不想花过多时间在<code>Object.defineProperty</code>上面,本节我们主要讲解<code>Object.defineProperty</code>的特点,方便接下来与<code>Proxy</code>进行对比。</p>
<h4 id="极简版的双向绑定"><a href="#极简版的双向绑定" class="headerlink" title="极简版的双向绑定"></a>极简版的双向绑定</h4><p>我们都知道,<code>Object.defineProperty</code>的作用就是劫持一个对象的属性,通常我们对属性的<code>getter</code>和<code>setter</code>方法进行劫持,在对象的属性发生变化时进行特定的操作。</p>
<p>我们就对对象<code>obj</code>的<code>text</code>属性进行劫持,在获取此属性的值时打印<code>&#39;get val&#39;</code>,在更改属性值的时候对DOM进行操作,这就是一个极简的双向绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'text'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get val'</span>);&amp;emsp;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set val:'</span> + newVal);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>).value = newVal;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'span'</span>).innerHTML = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  obj.text = e.target.value;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="升级改造-1"><a href="#升级改造-1" class="headerlink" title="升级改造"></a>升级改造</h4><p>我们很快会发现，这个所谓的<em>双向绑定</em>貌似并没有什么乱用。。。</p>
<p>原因如下:</p>
<ol>
<li>我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。</li>
<li>违反开放封闭原则,我们如果了解<a href="https://zh.wikipedia.org/zh-hans/开闭原则" target="_blank" rel="noopener">开放封闭原则</a>的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。</li>
<li>代码耦合严重,我们的数据、方法和DOM都是耦合在一起的，就是传说中的面条代码。</li>
</ol>
<h5 id="拓展：开放封闭原则（Open-Closed-Principle）"><a href="#拓展：开放封闭原则（Open-Closed-Principle）" class="headerlink" title="拓展：开放封闭原则（Open Closed Principle）"></a>拓展：开放封闭原则（Open Closed Principle）</h5><p>在面向对象的设计中有很多流行的思想，比如说 “所有的成员变量都应该设置为私有（Private）”，”要避免使用全局变量（Global Variables）”，”使用运行时类型识别（RTTI：Run Time Type Identification，例如 dynamic_cast）是危险的” 等等</p>
<p><strong>开放封闭原则（Open Closed Principle）描述</strong></p>
<p>符合开放封闭原则的模块都有两个主要特性：</p>
<p><strong>1. 它们 “面向扩展开放（Open For Extension）”。</strong></p>
<p>也就是说模块的行为是能够被扩展的。当应用程序的需求变化时，我们可以使模块表现出全新的或与以往不同的行为，以满足新的需求。</p>
<p><strong>2. 它们 “面向修改封闭（Closed For Modification）”。</strong></p>
<p>模块的源代码是不能被侵犯的，任何人都不允许修改已有源代码</p>
<h5 id="回归正题-1"><a href="#回归正题-1" class="headerlink" title="回归正题"></a>回归正题</h5><p>那么如何解决上述问题？</p>
<p>Vue的操作就是加入了<strong>发布订阅</strong>模式，结合<code>Object.defineProperty</code>的劫持能力，实现了可用性很高的双向绑定。</p>
<p>首先，我们以<strong>发布订阅</strong>的角度看我们第一部分写的那一坨代码,会发现它的<em>监听</em>、<em>发布</em>和<em>订阅</em>都是写在一起的,我们首先要做的就是解耦。</p>
<p>我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let uid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 用于储存订阅者并发布消息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher</span></span><br><span class="line">    <span class="keyword">this</span>.id = uid++;</span><br><span class="line">    <span class="comment">// 储存订阅者的数组</span></span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发target上的Watcher中的addDep方法,参数为dep的实例本身</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理</span></span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(sub =&gt; sub.update());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>现在我们需要实现监听者(Observer),用于监听属性值的变化。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听者,监听对象属性值的变化</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title">Observer</span> &#123;</span><br><span class="line">    constructor(<span class="keyword">value</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">      <span class="keyword">this</span>.walk(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历属性值并监听</span></span><br><span class="line">    walk(<span class="keyword">value</span>) &#123;</span><br><span class="line">      Object.keys(<span class="keyword">value</span>).forEach(key =&gt; <span class="keyword">this</span>.convert(key, <span class="keyword">value</span>[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行监听的具体方法</span></span><br><span class="line">    convert(key, val) &#123;</span><br><span class="line">      defineReactive(<span class="keyword">this</span>.<span class="keyword">value</span>, key, val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="comment">// 给当前属性的值添加监听</span></span><br><span class="line">    <span class="keyword">let</span> chlidOb = observe(val);</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 如果Dep类存在target属性，将其添加到dep实例的subs数组中</span></span><br><span class="line">        <span class="comment">// target指向一个Watcher实例，每个Watcher都是一个订阅者</span></span><br><span class="line">        <span class="comment">// Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法</span></span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">          dep.depend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: newVal =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        <span class="comment">// 对新值进行监听</span></span><br><span class="line">        chlidOb = observe(newVal);</span><br><span class="line">        <span class="comment">// 通知所有订阅者，数值被改变了</span></span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">function <span class="title">observe</span>(<span class="params"><span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">value</span> || <span class="keyword">typeof</span> <span class="keyword">value</span> !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observer(<span class="keyword">value</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>那么接下来就简单了,我们需要实现一个订阅者(Watcher)。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class="line">      <span class="keyword">this</span>.depIds = &#123;&#125;; <span class="comment">// hash储存订阅者的id,避免重复的订阅者</span></span><br><span class="line">      <span class="keyword">this</span>.vm = vm; <span class="comment">// 被订阅的数据一定来自于当前Vue实例</span></span><br><span class="line">      <span class="keyword">this</span>.cb = cb; <span class="comment">// 当数据更新时想要做的事情</span></span><br><span class="line">      <span class="keyword">this</span>.expOrFn = expOrFn; <span class="comment">// 被订阅的数据</span></span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(); <span class="comment">// 维护更新之前的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用</span></span><br><span class="line">    update() &#123;</span><br><span class="line">      <span class="keyword">this</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">    addDep(dep) &#123;</span><br><span class="line">      <span class="comment">// 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存</span></span><br><span class="line">      <span class="comment">// 此判断是避免同id的Watcher被多次储存</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.hasOwnProperty(dep.id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.depIds[dep.id] = dep;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">val</span> = <span class="keyword">this</span>.<span class="keyword">get</span>();</span><br><span class="line">      console.log(<span class="keyword">val</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">val</span> !== <span class="keyword">this</span>.<span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">val</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="comment">// 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者</span></span><br><span class="line">      Dep.target = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">val</span> = <span class="keyword">this</span>.vm._data[<span class="keyword">this</span>.expOrFn];</span><br><span class="line">      <span class="comment">// 置空，用于下一个Watcher使用</span></span><br><span class="line">      Dep.target = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>那么我们最后完成Vue,将上述方法挂载在Vue上。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 简化了$options的处理</span></span><br><span class="line">    <span class="keyword">this</span>.$options = options;</span><br><span class="line">    <span class="comment">// 简化了对data的处理</span></span><br><span class="line">    let <span class="keyword">data</span> = (<span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.<span class="keyword">data</span>);</span><br><span class="line">    <span class="comment">// 将所有data最外层属性代理到Vue实例上</span></span><br><span class="line">    Object.keys(<span class="keyword">data</span>).forEach(key =&gt; <span class="keyword">this</span>._proxy(key));</span><br><span class="line">    <span class="comment">// 监听数据</span></span><br><span class="line">    observe(<span class="keyword">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者</span></span><br><span class="line">  $watch(expOrFn, cb) &#123;</span><br><span class="line">    new Watcher(<span class="keyword">this</span>, expOrFn, cb);</span><br><span class="line">  &#125;</span><br><span class="line">  _proxy(key) &#123;</span><br><span class="line">    Object.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; <span class="keyword">this</span>._data[key],</span><br><span class="line">      <span class="keyword">set</span>: <span class="keyword">val</span> =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>._data[key] = <span class="keyword">val</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"input"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = (function() &#123;</span><br><span class="line">  let uid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 用于储存订阅者并发布消息</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="comment">// 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher</span></span><br><span class="line">      <span class="keyword">this</span>.id = uid++;</span><br><span class="line">      <span class="comment">// 储存订阅者的数组</span></span><br><span class="line">      <span class="keyword">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发target上的Watcher中的addDep方法,参数为dep的实例本身</span></span><br><span class="line">    depend() &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加订阅者</span></span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    notify() &#123;</span><br><span class="line">      <span class="comment">// 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理</span></span><br><span class="line">      <span class="keyword">this</span>.subs.forEach(sub =&gt; sub.update());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher</span></span><br><span class="line">  Dep.target = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 监听者,监听对象属性值的变化</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历属性值并监听</span></span><br><span class="line">    walk(value) &#123;</span><br><span class="line">      Object.keys(value).forEach(key =&gt; <span class="keyword">this</span>.convert(key, value[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行监听的具体方法</span></span><br><span class="line">    convert(key, <span class="keyword">val</span>) &#123;</span><br><span class="line">      defineReactive(<span class="keyword">this</span>.value, key, <span class="keyword">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function defineReactive(obj, key, <span class="keyword">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = new Dep();</span><br><span class="line">    <span class="comment">// 给当前属性的值添加监听</span></span><br><span class="line">    let chlidOb = observe(<span class="keyword">val</span>);</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 如果Dep类存在target属性，将其添加到dep实例的subs数组中</span></span><br><span class="line">        <span class="comment">// target指向一个Watcher实例，每个Watcher都是一个订阅者</span></span><br><span class="line">        <span class="comment">// Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法</span></span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">          dep.depend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">val</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: newVal =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">val</span> === newVal) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">val</span> = newVal;</span><br><span class="line">        <span class="comment">// 对新值进行监听</span></span><br><span class="line">        chlidOb = observe(newVal);</span><br><span class="line">        <span class="comment">// 通知所有订阅者，数值被改变了</span></span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function observe(value) &#123;</span><br><span class="line">    <span class="comment">// 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听</span></span><br><span class="line">    <span class="keyword">if</span> (!value || typeof value !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class="line">      <span class="keyword">this</span>.depIds = &#123;&#125;; <span class="comment">// hash储存订阅者的id,避免重复的订阅者</span></span><br><span class="line">      <span class="keyword">this</span>.vm = vm; <span class="comment">// 被订阅的数据一定来自于当前Vue实例</span></span><br><span class="line">      <span class="keyword">this</span>.cb = cb; <span class="comment">// 当数据更新时想要做的事情</span></span><br><span class="line">      <span class="keyword">this</span>.expOrFn = expOrFn; <span class="comment">// 被订阅的数据</span></span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(); <span class="comment">// 维护更新之前的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用</span></span><br><span class="line">    update() &#123;</span><br><span class="line">      <span class="keyword">this</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">    addDep(dep) &#123;</span><br><span class="line">      <span class="comment">// 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存</span></span><br><span class="line">      <span class="comment">// 此判断是避免同id的Watcher被多次储存</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.hasOwnProperty(dep.id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.depIds[dep.id] = dep;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">val</span> = <span class="keyword">this</span>.<span class="keyword">get</span>();</span><br><span class="line">      console.log(<span class="keyword">val</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">val</span> !== <span class="keyword">this</span>.<span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">val</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="comment">// 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者</span></span><br><span class="line">      Dep.target = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">val</span> = <span class="keyword">this</span>.vm._data[<span class="keyword">this</span>.expOrFn];</span><br><span class="line">      <span class="comment">// 置空，用于下一个Watcher使用</span></span><br><span class="line">      Dep.target = <span class="literal">null</span>;</span><br><span class="line">      console.log(Dep.target, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">      <span class="comment">// 简化了$options的处理</span></span><br><span class="line">      <span class="keyword">this</span>.$options = options;</span><br><span class="line">      <span class="comment">// 简化了对data的处理</span></span><br><span class="line">      let <span class="keyword">data</span> = (<span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.<span class="keyword">data</span>);</span><br><span class="line">      <span class="comment">// 将所有data最外层属性代理到Vue实例上</span></span><br><span class="line">      Object.keys(<span class="keyword">data</span>).forEach(key =&gt; <span class="keyword">this</span>._proxy(key));</span><br><span class="line">      <span class="comment">// 监听数据</span></span><br><span class="line">      observe(<span class="keyword">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者</span></span><br><span class="line">    $watch(expOrFn, cb) &#123;</span><br><span class="line">      new Watcher(<span class="keyword">this</span>, expOrFn, cb);</span><br><span class="line">    &#125;</span><br><span class="line">    _proxy(key) &#123;</span><br><span class="line">      Object.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; <span class="keyword">this</span>._data[key],</span><br><span class="line">        <span class="keyword">set</span>: <span class="keyword">val</span> =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>._data[key] = <span class="keyword">val</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Vue;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let demo = new Vue(&#123;</span><br><span class="line">  <span class="keyword">data</span>: &#123;</span><br><span class="line">    text: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = document.getElementById(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">const</span> input = document.getElementById(<span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, function(e) &#123;</span><br><span class="line">  demo.text = e.target.value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">demo.$watch(<span class="string">'text'</span>, str =&gt; p.innerHTML = str);</span><br></pre></td></tr></table></figure>
<h4 id="Object-defineProperty的缺陷"><a href="#Object-defineProperty的缺陷" class="headerlink" title="Object.defineProperty的缺陷"></a>Object.defineProperty的缺陷</h4><p>其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组。</p>
<p>补充：下面用到的createDocumentFragment()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="comment">// fragment 是一个指向空DocumentFragment对象的引用。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DocumentFragments</code> 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。</p>
<p>因为文档片段存在于<strong>内存中</strong>，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow" target="_blank" rel="noopener">回流</a>（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</p>
</blockquote>
<p>用法如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element  = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>); <span class="comment">// assuming ul exists</span></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">var</span> browsers = [<span class="string">'Firefox'</span>, <span class="string">'Chrome'</span>, <span class="string">'Opera'</span>, </span><br><span class="line">    <span class="string">'Safari'</span>, <span class="string">'Internet Explorer'</span>];</span><br><span class="line"></span><br><span class="line">browsers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">browser</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">    li.textContent = browser;</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">element.appendChild(fragment);</span><br></pre></td></tr></table></figure>
<p>回归正题：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> demo = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="keyword">list</span>: [<span class="number">1</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">list</span> = document.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">const</span> btn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  demo.<span class="keyword">list</span>.push(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fragment = document.createDocumentFragment();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> li = document.createElement(<span class="string">'li'</span>);</span><br><span class="line">    li.textContent = arr[i];</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">list</span>.appendChild(fragment);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数组,每次数组变化则触发渲染函数,然而...无法监听</span></span><br><span class="line">demo.$watch(<span class="string">'list'</span>, <span class="keyword">list</span> =&gt; render(<span class="keyword">list</span>));</span><br><span class="line"></span><br><span class="line">setTimeout(</span><br><span class="line">  <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alert(demo.<span class="keyword">list</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">5000</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>是的,<code>Object.defineProperty</code>的第一个缺陷,无法监听数组变化。 然而<a href="https://cn.vuejs.org/v2/guide/list.html#数组更新检测" target="_blank" rel="noopener">Vue的文档</a>提到了Vue是可以检测到数组变化的，但是只有以下八种方法,<code>vm.items[indexOfItem] = newValue</code>这种是无法检测的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shift</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">unshift</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">splice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">reverse</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>其实作者在这里用了一些奇技淫巧,把无法监听数组的情况hack掉了,以下是方法示例。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aryMethods = [<span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span>];</span><br><span class="line"><span class="keyword">const</span> arrayAugmentations = [];</span><br><span class="line"></span><br><span class="line">aryMethods.forEach((method)=&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是原生Array的原型方法</span></span><br><span class="line">    <span class="keyword">let</span> original = <span class="built_in">Array</span>.prototype[method];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上</span></span><br><span class="line">   <span class="comment">// 注意：是属性而非原型属性</span></span><br><span class="line">    arrayAugmentations[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我被改变啦!'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用对应的原生方法并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">list</span> = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// 将我们要监听的数组的原型指针指向上面定义的空数组对象</span></span><br><span class="line"><span class="comment">// 别忘了这个空数组的属性上定义了我们封装好的push等方法</span></span><br><span class="line"><span class="built_in">list</span>.__proto__ = arrayAugmentations;</span><br><span class="line"><span class="built_in">list</span>.push(<span class="string">'d'</span>);  <span class="comment">// 我被改变啦！ 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的list2没有被重新定义原型指针，所以就正常输出</span></span><br><span class="line"><span class="keyword">let</span> list2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">list2.push(<span class="string">'d'</span>);  <span class="comment">// 4</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>由于只针对了八种方法进行了hack,所以其他数组的属性也是检测不到的,其中的坑很多,可以阅读上面提到的文档。</p>
<p>我们应该注意到在上文中的实现里,我们多次用遍历方法遍历对象的属性，这就引出了<code>Object.defineProperty</code>的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.<span class="built_in">keys</span>(<span class="built_in">value</span>).forEach(<span class="built_in">key</span> =&gt; this.convert(<span class="built_in">key</span>, <span class="built_in">value</span>[<span class="built_in">key</span>]));</span><br></pre></td></tr></table></figure>
<h3 id="Proxy实现的双向绑定的特点"><a href="#Proxy实现的双向绑定的特点" class="headerlink" title="Proxy实现的双向绑定的特点"></a>Proxy实现的双向绑定的特点</h3><p>Proxy在ES2015规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy是<code>Object.defineProperty</code>的全方位加强版</p>
<p>注意：proxy在使用中，调用new proxy之后，我们调用的是new完之后的结果，这点要做出跟defineProperty的区别。</p>
<h4 id="Proxy可以直接监听对象而非属性"><a href="#Proxy可以直接监听对象而非属性" class="headerlink" title="Proxy可以直接监听对象而非属性"></a>Proxy可以直接监听对象而非属性</h4><p>我们还是以上文中用<code>Object.defineProperty</code>实现的极简版双向绑定为例,用Proxy进行改写</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"input"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'text'</span>) &#123;</span><br><span class="line">      input.value = value;</span><br><span class="line">      p.innerHTML = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  newObj.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以看到,Proxy直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于<code>Object.defineProperty</code>。</p>
<h4 id="Proxy可以直接监听数组的变化"><a href="#Proxy可以直接监听数组的变化" class="headerlink" title="Proxy可以直接监听数组的变化"></a>Proxy可以直接监听数组的变化</h4><p>当我们对数组进行操作(push、shift、splice等)时，会触发对应的方法名称和<em>length</em>的变化，我们可以借此进行操作,以上文中<code>Object.defineProperty</code>无法生效的列表渲染为例。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">list</span> = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染列表</span></span><br><span class="line"><span class="keyword">const</span> Render = &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="attribute">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">      li.textContent = arr[i];</span><br><span class="line">      fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>.appendChild(fragment);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 我们只考虑了增加的情况,仅作为示例</span></span><br><span class="line">  <span class="attribute">change</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">    li.textContent = val;</span><br><span class="line">    <span class="built_in">list</span>.appendChild(li);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数组</span></span><br><span class="line"><span class="keyword">const</span> newArr = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="attribute">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attribute">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">'length'</span>) &#123;</span><br><span class="line">      Render.change(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Render.init(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push数字</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  newArr.push(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>很显然,Proxy不需要那么多hack（即使hack也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于hack。</p>
<h4 id="Proxy的其他优势"><a href="#Proxy的其他优势" class="headerlink" title="Proxy的其他优势"></a>Proxy的其他优势</h4><p>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是<code>Object.defineProperty</code>不具备的。</p>
<p>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改。</p>
<p>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。</p>
<p>当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。</p>
<h2 id="你为什么使用前端框架？（⭐⭐）"><a href="#你为什么使用前端框架？（⭐⭐）" class="headerlink" title="你为什么使用前端框架？（⭐⭐）"></a>你为什么使用前端框架？（⭐⭐）</h2><h3 id="前端框架的根本意义"><a href="#前端框架的根本意义" class="headerlink" title="前端框架的根本意义"></a>前端框架的根本意义</h3><h4 id="前端框架的好处"><a href="#前端框架的好处" class="headerlink" title="前端框架的好处"></a>前端框架的好处</h4><p>最开始学习前端框架的时候并不理解框架能带来什么,只是因为大家都在用框架,最实际的一个用途就是所有企业几乎都在用框架,不用框架就 out 了.</p>
<p>随着使用的深入我逐渐理解到框架的好处:</p>
<ol>
<li>组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</li>
<li>天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li>
<li>生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。</li>
</ol>
<h4 id="前端框架的根本意义-1"><a href="#前端框架的根本意义-1" class="headerlink" title="前端框架的根本意义"></a>前端框架的根本意义</h4><p>你以为的原因：</p>
<ul>
<li>组件化。</li>
<li>拥有强大的开源社区。</li>
<li>拥有大量第三方库解决大部分问题。</li>
<li>拥有大量现成的第三方组件。</li>
<li>拥有浏览器拓展/工具帮助快速 debug。</li>
<li>友好的支持单页应用。</li>
</ul>
<p>不，这些都不是根本原因，最多算前端框架的营销手段</p>
<p>简单来说,前端框架的根本意义是解决了<strong>UI 与状态同步问题</strong>。</p>
<p>在 Vue 中我们如果要在<code>todos</code>中添加一条,只需要<code>app4.todos.push({ text: &#39;新项目&#39; })</code>,这时由于 Vue 内置的响应式系统会自动帮我们进行 UI 与状态的同步工作.</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-4"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123; todo.text &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var app4 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span> <span class="string">'#app-4'</span>,</span><br><span class="line">  dat<span class="variable">a:</span> &#123;</span><br><span class="line">    todo<span class="variable">s:</span> [</span><br><span class="line">      &#123; tex<span class="variable">t:</span> <span class="string">'学习 JavaScript'</span> &#125;,</span><br><span class="line">      &#123; tex<span class="variable">t:</span> <span class="string">'学习 Vue'</span> &#125;,</span><br><span class="line">      &#123; tex<span class="variable">t:</span> <span class="string">'整个牛项目'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果我们用 JQuery 或者 JS 进行操作,免不了一大堆<code>li.appendChild</code>、<code>document.createElement</code>等 DOM 操作,我们需要一长串 DOM 操作保证状态与 UI 的同步,其中一个环节出错就会导致 BUG,手动操作的缺点如下：</p>
<ol>
<li>频繁操作 DOM 性能低下.</li>
<li>中间步骤过多,易产生 bug且不易维护,而且心智要求较高不利于开发效率</li>
</ol>
<p>不管是 vue 的数据劫持、Angular 的脏检测还是 React 的组件级 reRender都是帮助我们解决 ui 与状态同步问题的利器。</p>
<p>这也解释了<strong>Backbone</strong>作为前端框架鼻祖在之后落寞的原因,Backbone只是引入了 MVC 的思想,并没有解决 View 与 Modal 同步的问题,相比于现代的三大框架直接操作 Modal 就可以同步 UI 的特性, Backbone 仍然与 JQuery 绑定,在 View 里操作 Dom来达到同步 UI 的目的，这显然是不符合现代前端框架设计要求的。</p>
<h3 id="Vue-如何保证-UI-与状态同步"><a href="#Vue-如何保证-UI-与状态同步" class="headerlink" title="Vue 如何保证 UI 与状态同步"></a>Vue 如何保证 UI 与状态同步</h3><p>UI 在 MVVM 中指的是 View，状态在 MVVM 中指的是 Modal，而保证 View 和 Modal 同步的是 View-Modal。</p>
<p>Vue 通过一个<a href="https://cn.vuejs.org/v2/guide/reactivity.html#ad" target="_blank" rel="noopener">响应式系统</a>保证了View 与 Modal的同步,由于要兼容IE,Vue 选择了 <code>Object.defineProperty</code>作为响应式系统的实现,但是如果不考虑 IE 用户的话,<code>Object.defineProperty</code>并不是一个好的选择,具体请看基于proxy数据劫持的双向绑定优势所在</p>
<p>我们用 Proxy 实现一个响应式系统</p>
<p><img src="https://images.linjiahong.top/Note11.png" alt="1597897550017"></p>
<h4 id="发布订阅中心"><a href="#发布订阅中心" class="headerlink" title="发布订阅中心"></a>发布订阅中心</h4><p>一个响应式系统离不开发布订阅模式,因为我们需要一个 <code>Dep</code>保存订阅者,并在 Observer 发生变化时通知保存在 Dep 中的订阅者,让订阅者得知变化并更新视图,这样才能保证视图与状态的同步。</p>
<blockquote>
<p>发布订阅模式请阅读Event Bus的实现</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [subs description] 订阅器,储存订阅者,通知订阅者</span></span><br><span class="line"><span class="comment"> * @type &#123;Map&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">export <span class="keyword">default</span> class Dep &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="comment">// 我们用 hash 储存订阅者</span></span><br><span class="line">    <span class="keyword">this</span>.subs = <span class="keyword">new</span> Map();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  addSub(<span class="built_in">key</span>, sub) &#123;</span><br><span class="line">    <span class="comment">// 取出键为 key 的订阅者</span></span><br><span class="line">    <span class="keyword">const</span> currentSub = <span class="keyword">this</span>.subs.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="comment">// 如果能取出说明有相同的 key 的订阅者已经存在,直接添加</span></span><br><span class="line">    <span class="keyword">if</span> (currentSub) &#123;</span><br><span class="line">      currentSub.<span class="built_in">add</span>(sub);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用 Set 数据结构储存,保证唯一值</span></span><br><span class="line">      <span class="keyword">this</span>.subs.<span class="built_in">set</span>(<span class="built_in">key</span>, <span class="keyword">new</span> Set([sub]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知</span></span><br><span class="line">  notify(<span class="built_in">key</span>) &#123;</span><br><span class="line">  <span class="comment">// 触发键为 key 的订阅者们</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.subs.<span class="built_in">get</span>(<span class="built_in">key</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subs.<span class="built_in">get</span>(<span class="built_in">key</span>).forEach(sub =&gt; &#123;</span><br><span class="line">        sub.update();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="监听者的实现"><a href="#监听者的实现" class="headerlink" title="监听者的实现"></a>监听者的实现</h4><p>我们在订阅器 <code>Dep</code> 中实现了一个<code>notify</code>方法来通知相应的订阅这们,然而<code>notify</code>方法到底什么时候被触发呢?</p>
<p>当然是当状态发生变化时,即 MVVM 中的 Modal 变化时触发通知,然而<code>Dep</code> 显然无法得知 Modal 是否发生了变化,因此我们需要创建一个监听者<code>Observer</code>来监听 Modal, 当 Modal 发生变化的时候我们就执行通知操作。</p>
<p>vue 基于<code>Object.defineProperty</code>来实现了监听者，我们用 Proxy 来实现监听者.</p>
<p>与<code>Object.defineProperty</code>监听属性不同, Proxy 可以监听(实际是代理)整个对象,因此就不需要遍历对象的属性依次监听了,但是如果对象的属性依然是个对象,那么 Proxy 也无法监听,所以我们实现了一个<code>observify</code>进行递归监听即可。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * [Observer description] 监听器,监听对象,触发后通知订阅</span><br><span class="line"> * @param &#123;[type]&#125;   obj [description] 需要被监听的对象</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">const</span> Observer = obj =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Proxy(obj, &#123;</span><br><span class="line">    <span class="built_in">get</span>: function(target, <span class="built_in">key</span>, receiver) &#123;</span><br><span class="line">      <span class="comment">// 如果订阅者存在，直接添加订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.addSub(<span class="built_in">key</span>, Dep.target);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Reflect.<span class="built_in">get</span>(target, <span class="built_in">key</span>, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: function(target, <span class="built_in">key</span>, value, receiver) &#123;</span><br><span class="line">       <span class="comment">// 如果对象值没有变,那么不触发下面的操作直接返回    </span></span><br><span class="line">      <span class="keyword">if</span> (Reflect.<span class="built_in">get</span>(receiver, <span class="built_in">key</span>) === value) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//此处值为receiver，是因为我们修改值是可以针对proxy实例返回的新对象。</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> res = Reflect.<span class="built_in">set</span>(target, <span class="built_in">key</span>, observify(value), receiver);</span><br><span class="line">      <span class="comment">// 当值被触发更改的时候,触发 Dep 的通知方法</span></span><br><span class="line">      dep.notify(<span class="built_in">key</span>);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将对象转为监听对象</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; obj 要监听的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">export <span class="keyword">default</span> function observify(obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 深度监听</span></span><br><span class="line">  <span class="keyword">Object</span>.keys(obj).forEach(<span class="built_in">key</span> =&gt; &#123;</span><br><span class="line">    obj[<span class="built_in">key</span>] = observify(obj[<span class="built_in">key</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Observer(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="订阅者的实现"><a href="#订阅者的实现" class="headerlink" title="订阅者的实现"></a>订阅者的实现</h4><p>我们目前已经解决了两个问题,一个是如何得知 Modal 发生了改变(利用监听者 Observer 监听 Modal 对象),一个是如何收集订阅者并通知其变化(利用订阅器收集订阅者,并用notify通知订阅者)。</p>
<p>我们目前还差一个订阅者（Watcher）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, exp, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm; <span class="comment">// vm 是 vue 的实例</span></span><br><span class="line">    <span class="keyword">this</span>.exp = exp; <span class="comment">// 被订阅的数据</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb; <span class="comment">// 触发更新后的回调</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.<span class="keyword">get</span>(); <span class="comment">// 获取老数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> exp = <span class="keyword">this</span>.exp;</span><br><span class="line">    let value;</span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (typeof exp === <span class="string">'function'</span>) &#123;</span><br><span class="line">      value = exp.call(<span class="keyword">this</span>.vm);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeof exp === <span class="string">'string'</span>) &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.vm[exp];</span><br><span class="line">    &#125;</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将订阅者放入待更新队列等待批量更新</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    pushQueue(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发真正的更新操作</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(); <span class="comment">// 获取新数据</span></span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">val</span>, <span class="keyword">this</span>.value);</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">val</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="批量更新的实现"><a href="#批量更新的实现" class="headerlink" title="批量更新的实现"></a>批量更新的实现</h4><p>我们在上一节中实现了订阅者( Watcher),但是其中的<code>update</code>方法是将订阅者放入了一个待更新的队列中,而不是直接触发,原因如下:</p>
<p><img src="https://images.linjiahong.top/Note12.png" alt="1598001616177"></p>
<p>因此这个队列需要做的是<strong>异步</strong>且<strong>去重</strong>,因此我们用 <code>Set</code>作为数据结构储存 Watcher 来去重,同时用<code>Promise</code>模拟异步更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建异步更新队列</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Promise模拟nextTick</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(cb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行刷新队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushQueue</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    queue.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> &#123;</span><br><span class="line">            watcher.run()</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    queue = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到队列</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">pushQueue</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">    queue.add(watcher)</span><br><span class="line">    <span class="comment">// 下一个循环调用</span></span><br><span class="line">    nextTick(flushQueue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们梳理一下流程, 一个响应式系统是如何做到 UI(View)与状态(Modal)同步的?</p>
<p>我们首先需要监听 Modal, 本文中我们用 Proxy 来监听了 Modal 对象,因此在 Modal 对象被修改的时候我们的 Observer 就可以得知。</p>
<p>我们得知Modal发生变化后如何通知 View 呢？要知道，一个 Modal 的改变可能触发多个 UI 的更新，比如一个用户的用户名改变了，它的个人信息组件、通知组件等等组件中的用户名都需要改变，对于这种情况我们很容易想到利用<strong>发布订阅</strong>模式来解决,我们需要一个订阅器(Dep)来储存订阅者(Watcher),当监听到 Modal 改变时,我们只需要通知相关的订阅者进行更新即可。</p>
<p>那么订阅者来自哪里呢？其实每一个组件实例对应着一个订阅者（正因为一个组件实例对应一个订阅者，才能利用 Dep 通知到相应组件，不然乱套了，通知订阅者就相当于间接通知了组件）。</p>
<p>当订阅者得知了具体变化后它会进行相应的更新,将更新体现在 UI(View)上,至此UI 与 Modal 的同步完成了。</p>
<blockquote>
<p>github: <a href="https://github.com/xiaomuzhu/proxy-vue" target="_blank" rel="noopener">https://github.com/xiaomuzhu/proxy-vue</a></p>
</blockquote>
<h3 id="响应式系统并不是全部"><a href="#响应式系统并不是全部" class="headerlink" title="响应式系统并不是全部"></a>响应式系统并不是全部</h3><p>响应式系统虽然是 Vue 的核心概念,但是一个响应式系统并不够.</p>
<p>响应式系统虽然得知了数据值的变化,但是当值不能完整映射 UI 时,我们依然需要进行组件级别的 reRender,这种情况并不高效,因此 Vue 在2.0版本引入了虚拟 DOM, 虚拟 DOM进行进一步的 diff 操作可以进行细粒度更高的操作,可以保证 reReander 的下限(保证不那么慢)。</p>
<p>除此之外为了方便开发者，vue 内置了众多的指令，因此我们还需要一个 vue 模板解析器.</p>
<h2 id="观察者模式与订阅发布模式的区别（⭐）"><a href="#观察者模式与订阅发布模式的区别（⭐）" class="headerlink" title="观察者模式与订阅发布模式的区别（⭐）"></a>观察者模式与订阅发布模式的区别（⭐）</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。</p>
<p>观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。</p>
<h3 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅-发布模式"></a>订阅-发布模式</h3><p>其实24种基本的设计模式中并没有发布订阅模式，上面也说了，他只是观察者模式的一个别称。</p>
<p>但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。</p>
<p>在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。</p>
<p>举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）。</p>
<h3 id="两种模式的区别"><a href="#两种模式的区别" class="headerlink" title="两种模式的区别"></a><strong>两种模式的区别</strong></h3><p><img src="https://images.linjiahong.top/Note13.png" alt="1598011406792"></p>
<p>可以看出，发布订阅模式相比观察者模式多了个事件通道，事件通道作为调度中心，管理事件的订阅和发布工作，彻底隔绝了订阅者和发布者的依赖关系。即订阅者在订阅事件的时候，只关注事件本身，而不关心谁会发布这个事件；发布者在发布事件的时候，只关注事件本身，而不关心谁订阅了这个事件。</p>
<p>观察者模式有两个重要的角色，即目标和观察者。在目标和观察者之间是没有事件通道的。一方面，观察者要想订阅目标事件，由于没有事件通道，因此必须将自己添加到目标(Subject) 中进行管理；另一方面，目标在触发事件的时候，也无法将通知操作(notify) 委托给事件通道，因此只能亲自去通知所有的观察者。</p>
<p>发布-订阅模式是面向调度中心编程的，而观察者模式则是面向目标和观察者编程的。前者用于解耦发布者和订阅者，后者用于耦合目标和观察者，不可同日而语也</p>
<p>我们把这些差异快速总结一下：</p>
<ul>
<li>在<strong>观察者</strong>模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在<strong>发布订阅</strong>模式中，发布者和订阅者<strong>不知道对方的存在</strong>。它们只有通过消息代理进行通信。</li>
<li>在<strong>发布订阅</strong>模式中，组件是松散耦合的，正好和观察者模式相反。</li>
<li><strong>观察者模式</strong>大多数时候是<strong>同步</strong>的，比如当事件触发，Subject就会去调用观察者的方法。而<strong>发布-订阅</strong>模式大多数时候是<strong>异步的</strong>（使用消息队列）。</li>
<li><strong>观察者</strong> 模式需要在单个应用程序地址空间中实现，而<strong>发布-订阅</strong>更像交叉应用模式。</li>
</ul>
<p>尽管它们之间有区别，但有些人可能会说<strong>发布-订阅</strong>模式是<strong>观察者</strong>模式的变异，因为它们概念上是相似的。</p>
<h2 id="写过『通用前端组件』吗-（⭐⭐⭐）"><a href="#写过『通用前端组件』吗-（⭐⭐⭐）" class="headerlink" title="写过『通用前端组件』吗?（⭐⭐⭐）"></a>写过『通用前端组件』吗?（⭐⭐⭐）</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>设计前端组件是最能考验开发者基本功的测试之一,因为调用Material design、Antd、iView 等现成组件库的 API 每个人都可以做到,但是很多人并不知道很多常用组件的设计原理。</p>
<p>能否设计出通用前端组件也是区分前端工程师和前端api调用师的标准之一,那么应该如何设计出一个通用组件呢?</p>
<p>下文中提到的<strong>组件库</strong>通常是指单个组件,而非集合的概念,集合概念的组件库是 Antd iView这种,我们所说的组件库是指集合中的单个组件,集合性质的组件库需要考虑的要更多.</p>
<h3 id="前端组件库的设计原则"><a href="#前端组件库的设计原则" class="headerlink" title="前端组件库的设计原则"></a>前端组件库的设计原则</h3><h4 id="细粒度的考量"><a href="#细粒度的考量" class="headerlink" title="细粒度的考量"></a>细粒度的考量</h4><p>我们在学习设计模式的时候会遇到很多种设计原则,其中一个设计原则就是<strong>单一职责原则</strong>,在组件库的开发中同样适用,我们原则上一个组件只专注一件事情,单一职责的组件的好处很明显,由于职责单一就可以最大可能性地复用组件,但是这也带来一个问题,过度单一职责的组件也可能会导致过度抽象,造成组件库的碎片化。</p>
<p>举个例子，一个自动完成组件(AutoComplete),他其实是由 Input 组件和 Select 组件组合而成的,因此我们完全可以复用之前的相关组件,就比如 Antd 的AutoComplete组件中就复用了Select组件,同时Calendar、 Form 等等一系列组件都复用了 Select 组件,那么Select 的细粒度就是合适的,因为 Select 保持的这种细粒度很容易被复用.</p>
<p>那么还有一个例子,一个徽章数组件(Badge),它的右上角会有红点提示,可能是数字也可能是 icon,他的职责当然也很单一，这个红点提示也理所当然也可以被单独抽象为一个独立组件,但是我们通常不会将他作为独立组件,因为在其他场景中这个组件是无法被复用的，因为没有类似的场景再需要小红点这个小组件了，所以作为独立组件就属于细粒度过小,因此我们往往将它作为 Badge 的内部组件,比如在 Antd 中它以ScrollNumber的名称作为Badge的内部组件存在。</p>
<p>所以，所谓的单一职责组件要建立在可复用的基础上，对于不可复用的单一职责组件我们仅仅作为独立组件的内部组件即可。</p>
<h4 id="通用性考量"><a href="#通用性考量" class="headerlink" title="通用性考量"></a>通用性考量</h4><p>我们要设计的本身就是通用组件库,不同于我们常见的业务组件,通用组件是与业务解耦但是又服务于业务开发的,那么问题来了,如何保证组件的通用性,通用性高一定是好事吗?</p>
<p>比如我们设计一个选择器(Select)组件,通常我们会设计成这样</p>
<p><img src="https://images.linjiahong.top/Note14.png" alt="1598029876951"></p>
<p>这是一个我们最常见也最常用的选择器,但是问题是其通用性大打折扣</p>
<p>当我们有一个需求是长这样的时候,我们之前的选择器组件就不符合要求了,因为这个 Select 组件的最下部需要有一个可拓展的条目的按钮</p>
<p><img src="https://images.linjiahong.top/Note15.png" alt="1598029894873"></p>
<p>这个时候我们难道要重新修改之前的选择器组件,甚至再造一个符合要求的选择器组件吗?一旦有这种情况发生,那么只能说明之前的选择器组件通用性不够,需要我们重新设计.</p>
<p>Antd 的 Select 组件预留了<code>dropdownRender</code>来进行自定义渲染,其依赖的 <code>rc-select</code>组件中的代码如下</p>
<p>当然类似的设计还有很多,通用性设计其实是一定意义上放弃对 DOM 的掌控,而将 DOM 结构的决定权转移给开发者,<code>dropdownRender</code>其实就是放弃对 Select 下拉菜单中条目的掌控,Antd 的 Select 组件其实还有一个没有在文档中体现的方法<code>getInputElement</code>应该是对 Input 组件的自定义方法,Antd整个 Select 的组件设计非常复杂,基本将所有的 DOM 结构控制权全部暴露给了开发者,其本身只负责底层逻辑和最基本的 DOM 结构.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Select</span> <span class="attr">defaultValue</span>=<span class="string">"lucy"</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">120</span> &#125;&#125; <span class="attr">disabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"lucy"</span>&gt;</span>Lucy<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>组件的形态(DOM结构)永远是千变万化的,但是其行为(逻辑)是固定的,因此通用组件的秘诀之一就是将 DOM 结构的控制权交给开发者,组件只负责行为和最基本的 DOM 结构</p>
</blockquote>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><h4 id="css-解决方案"><a href="#css-解决方案" class="headerlink" title="css 解决方案"></a>css 解决方案</h4><p>由于CSS 本身的众多缺陷，如书写繁琐（不支持嵌套）、样式易冲突（没有作用域概念）、缺少变量（不便于一键换主题）等不一而足。为了解决这些问题，社区里的解决方案也是出了一茬又一茬，从最早的 CSS prepocessor（SASS、LESS、Stylus）到后来的后起之秀 PostCSS，再到 CSS Modules、Styled-Components 等</p>
<p>Antd 选择了 less 作为 css 的预处理方案,Bootstrap 选择了 Scss,这两种方案孰优孰劣已经争论了很多年了:</p>
<p><a href="https://www.zhihu.com/question/34606506" target="_blank" rel="noopener">SCSS和LESS相比有什么优势？</a></p>
<p>但是不管是哪种方案都有一个很烦人的点,就是需要额外引入 css,比如 Antd 需要这样显示引入:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'antd/lib/button'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/lib/button/style'</span>;</span><br></pre></td></tr></table></figure>
<p>为了解决这种尴尬的情况,Antd 用 <a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">Babel 插件</a>将这种情况 Hack 掉了</p>
<p>而<code>material-ui</code>并不存在这种情况,他不需要显示引入 css,这个最流行的 React 前端组件库里面只有 js 和 ts 两种代码,并不存在 css 相关的代码,为什么呢?</p>
<p>他们用 <code>jss</code> 作为css-in-js 的解决方案,jsx 的引入已经将 js 和 html 耦合,css-in-js将 css 也耦合进去,此时组件便不需要显示引入 css,而是直接引用 js 即可.</p>
<p>这不是退化到史前前端那种写内联样式的时代了吗?</p>
<p>并不是,史前前端的内联样式是整个项目耦合的状态,当然要被抛弃到历史的垃圾堆中,后来的样式和逻辑分离,实际上是以页面为维度将 js css html 解耦的过程,如今的时代是组件化的时代了,jsx 已经将 js 和 html 框定到一个组件中,css 依然处于分离状态,这就导致了每次引用组件却还需要显示引入 css,css-in-js 正式彻底组件化的解决方案.</p>
<h4 id="js-解决方案"><a href="#js-解决方案" class="headerlink" title="js 解决方案"></a>js 解决方案</h4><p>选 Typescript ,因为巨硬大法好…</p>
<p><a href="https://www.zhihu.com/question/273619114/answer/369180721" target="_blank" rel="noopener">你为什么不用 Typescript</a></p>
<h3 id="如何快速启动一个组件库项目"><a href="#如何快速启动一个组件库项目" class="headerlink" title="如何快速启动一个组件库项目"></a>如何快速启动一个组件库项目</h3><p>组件的具体实现部分当然是组件库的核心,但是在现代前端库中其他部分也必不可少,我们需要一堆工具来辅助我们开发,例如编译工具、代码检测工具、打包工具等等。</p>
<h4 id="打包工具-rollup-vs-webpack"><a href="#打包工具-rollup-vs-webpack" class="headerlink" title="打包工具(rollup vs webpack)"></a>打包工具(rollup vs webpack)</h4><p>市面上打包工具数不胜数,最火爆的当然是需要<em>配置工程师</em>专门配置的webpack,但是在类库开发领域它有一个强大的对手就是 rollup。</p>
<p>现代市面上主流的库基本都选择了 rollup 作为打包工具，包括Angular React 和 Vue, 作为基础类库的打包工具 rollup 的优势如下:</p>
<ul>
<li>Tree Shaking: 自动移除未使用的代码, 输出更小的文件</li>
<li>Scope Hoisting: 所有模块构建在一个函数内, 执行效率更高</li>
<li>Config 文件支持通过 ESM 模块格式书写 可以一次输出多种格式:</li>
<li>模块规范: IIFE, AMD, CJS, UMD, ESM Development 与 production 版本: .js, .min.js</li>
</ul>
<p>虽然上面部分功能已经被 webpack 实现了,但是 rollup 明显引入得更早,而Scope Hoisting更是杀手锏,由于 webpack 不得不在打包代码中构建模块系统来适应 app 开发(模块系统对于单一类库用处很小),Scope Hoisting将模块构建在一个函数内的做法更适合类库的打包.</p>
<h4 id="代码检测"><a href="#代码检测" class="headerlink" title="代码检测"></a>代码检测</h4><p>由于 JavaScript 各种诡异的特性和大型前端项目的出现,代码检测工具已经是前端开发者的标配了,Douglas Crockford最早于2002创造出了 JSLint,但是其无法拓展,具有极强的Douglas Crockford个人色彩,Anton Kovalyov由于无法忍受 JSLint 无法拓展的行为在2011年发布了可拓展的JSHint,一时之间JSHint成为了前端代码检测的流行解决方案.</p>
<p>随后的2013年,Nicholas C. Zakas鉴于JSHint拓展的灵活度不够的问题开发了全新的基于 AST 的 Lint 工具 ESLint,并随着 ES6的流行统治了前端界,ESLint 基于Esprima进行 JavaScript 解析的特性极易拓展,JSHint 在很长一段时间无法支持 ES6语法导致被 ESLint 超越.</p>
<p>代码检测工具是一方面,代码检测风格也需要我们做选择,市面上最流行的代码检测风格应该是 Airbnb 出品的<code>eslint-config-airbnb</code>,其最大的特点就是极其严格,没有给开发者任何选择的余地,当然在大型前端项目的开发中这种严格的代码风格是有利于协作的,但是作为一个类库的代码检测工具而言并不适合,所以我们选择了<code>eslint-config-standard</code>这种相对更为宽松的代码检测风格</p>
<h4 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h4><p>写好 commit message 不仅有助于他人 review, 还可以有效的输出 CHANGELOG, 对项目的管理实际至关重要.</p>
<p>目前流行的方案是 Angular 团队的<a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines" target="_blank" rel="noopener">规范</a>,其关于 head 的大致规范如下:</p>
<ul>
<li>type: commit 的类型</li>
<li>feat: 新特性</li>
<li>fix: 修改问题</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理.</li>
<li>scope: commit 影响的范围, 比如: route, component, utils, build…</li>
<li>subject: commit 的概述, 建议符合  50/72 formatting</li>
<li>body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting</li>
<li>footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</li>
</ul>
<p>当然规范人们不一定会遵守,我最初知道此类规范的时候也并没有严格遵循,因为人总会偷懒,直到用<code>commitizen</code>将此规范集成到工具流中,每个 commit 就不得不遵循规范了.</p>
<p><a href="https://juejin.im/post/6844903606815064077" target="_blank" rel="noopener">优雅的提交你的 Git Commit Message</a></p>
<h4 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h4><p>业务开发中由于前端需求变动频繁的特性,导致前端对测试的要求并没有后端那么高,后端业务逻辑一旦定型变动很少,比较适合测试.</p>
<p>但是基础类库作为被反复依赖的模块和较为稳定的需求是必须做测试的,前端测试库也可谓是种类繁多了,经过比对之后我还是选择了目前最流行也是被三大框架同时选择了的 Jest 作为测试工具,其优点很明显:</p>
<ol>
<li>开箱即用,内置断言、测试覆盖率工具,如果你用 MoCha 那可得自己手动配置 n 多了</li>
<li>快照功能,Jest 可以利用其特有的快照测试功能，通过比对 UI 代码生成的快照文件</li>
<li>速度优势,Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度</li>
</ol>
<h4 id="快速启动脚手架"><a href="#快速启动脚手架" class="headerlink" title="快速启动脚手架"></a>快速启动脚手架</h4><p>那么以上这么多配置难道要我们每次都自己写吗?组件的具体实现才是组件库的核心,我们为什么要花这么多时间在配置上面?</p>
<p>我们在建立 APP 项目时通常会用到框架官方提供的脚手架,比如 React 的 create-react-app,Angular 的 Angular-Cli，Vue的Vue-Cli 等等,那么能不能有一个专门用于组件开发的快速启动的脚手架呢?</p>
<p>能否开发一款自定义的脚手架！</p>
<h3 id="如何设计一个轮播图组件"><a href="#如何设计一个轮播图组件" class="headerlink" title="如何设计一个轮播图组件"></a>如何设计一个轮播图组件</h3><h4 id="轮播图基本原理"><a href="#轮播图基本原理" class="headerlink" title="轮播图基本原理"></a>轮播图基本原理</h4><p>轮播图(Carousel),在 Antd 中被称为走马灯,可能是前端开发者最常见的组件之一了,不管是在 PC 端还是在移动端我们总能见到他的身影.</p>
<p>Antd</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Carousel</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>2<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>4<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Carousel</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><h2 id="聊一聊-Babel-（⭐）"><a href="#聊一聊-Babel-（⭐）" class="headerlink" title="聊一聊 Babel?（⭐）"></a>聊一聊 Babel?（⭐）</h2><p>Babel 是现代 JavaScript 语法转换器,几乎在任何现代前端项目中都能看到他的身影,其背后的原理对于大部分开发者还属于黑盒,不过 Babel 作为一个工具真的有了解背后原理的必要吗?</p>
<p>如果只是 Babel 可能真没有必要,问题是其背后的原理在我们开发中应用过于广泛了,包括不限于: eslint jshint stylelint css-in-js prettier jsx vue-template uglify-js postcss less 等等等等,从模板到代码检测,从混淆压缩到代码转换,甚至编辑器的代码高亮都与之息息相关.</p>
<p>如果有兴趣就可以搞一些黑魔法: <a href="https://www.zhihu.com/question/274357154" target="_blank" rel="noopener">前端工程师可以用编译原理做什么？</a></p>
<h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>Babel 大概分为三大部分:</p>
<ul>
<li>解析: 将代码(其实就是字符串)转换成 AST( 抽象语法树)</li>
<li>转换: 访问 AST 的节点进行变换操作生成新的 AST</li>
<li>生成: 以新的 AST 为基础生成代码</li>
</ul>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><h4 id="parser-概念"><a href="#parser-概念" class="headerlink" title="parser 概念"></a>parser 概念</h4><p>代码解析,也就是我们常说的 Parser, 用于将一段代码(文本)解析成一个数据结构.</p>
<p>例如这段 es6的代码</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add = (<span class="selector-tag">a</span>, b) =&gt; <span class="selector-tag">a</span> + b</span><br></pre></td></tr></table></figure>
<p>我们用 babel 解析后便是这种形式:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"File"</span>,</span><br><span class="line">  <span class="attr">"start"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"end"</span>: <span class="number">27</span>,</span><br><span class="line">  <span class="attr">"loc"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: &#123;</span><br><span class="line">      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"column"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"end"</span>: &#123;</span><br><span class="line">      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"column"</span>: <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"program"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">    <span class="attr">"start"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"end"</span>: <span class="number">27</span>,</span><br><span class="line">    <span class="attr">"loc"</span>: &#123;</span><br><span class="line">      <span class="attr">"start"</span>: &#123;</span><br><span class="line">        <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"column"</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"end"</span>: &#123;</span><br><span class="line">        <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"column"</span>: <span class="number">27</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sourceType"</span>: <span class="string">"module"</span>,</span><br><span class="line">    <span class="attr">"body"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"VariableDeclaration"</span>,</span><br><span class="line">        <span class="attr">"start"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"end"</span>: <span class="number">27</span>,</span><br><span class="line">        <span class="attr">"loc"</span>: &#123;</span><br><span class="line">          <span class="attr">"start"</span>: &#123;</span><br><span class="line">            <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"column"</span>: <span class="number">0</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"end"</span>: &#123;</span><br><span class="line">            <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"column"</span>: <span class="number">27</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"declarations"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"VariableDeclarator"</span>,</span><br><span class="line">            <span class="attr">"start"</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">"end"</span>: <span class="number">27</span>,</span><br><span class="line">            <span class="attr">"loc"</span>: &#123;</span><br><span class="line">              <span class="attr">"start"</span>: &#123;</span><br><span class="line">                <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"column"</span>: <span class="number">6</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"end"</span>: &#123;</span><br><span class="line">                <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"column"</span>: <span class="number">27</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"id"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">              <span class="attr">"start"</span>: <span class="number">6</span>,</span><br><span class="line">              <span class="attr">"end"</span>: <span class="number">9</span>,</span><br><span class="line">              <span class="attr">"loc"</span>: &#123;</span><br><span class="line">                <span class="attr">"start"</span>: &#123;</span><br><span class="line">                  <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">"column"</span>: <span class="number">6</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"end"</span>: &#123;</span><br><span class="line">                  <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">"column"</span>: <span class="number">9</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"identifierName"</span>: <span class="string">"add"</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"name"</span>: <span class="string">"add"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"init"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"ArrowFunctionExpression"</span>,</span><br><span class="line">              <span class="attr">"start"</span>: <span class="number">12</span>,</span><br><span class="line">              <span class="attr">"end"</span>: <span class="number">27</span>,</span><br><span class="line">              <span class="attr">"loc"</span>: &#123;</span><br><span class="line">                <span class="attr">"start"</span>: &#123;</span><br><span class="line">                  <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">"column"</span>: <span class="number">12</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"end"</span>: &#123;</span><br><span class="line">                  <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">"column"</span>: <span class="number">27</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"id"</span>: <span class="literal">null</span>,</span><br><span class="line">              <span class="attr">"generator"</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">"expression"</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">"async"</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">"params"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">                  <span class="attr">"start"</span>: <span class="number">13</span>,</span><br><span class="line">                  <span class="attr">"end"</span>: <span class="number">14</span>,</span><br><span class="line">                  <span class="attr">"loc"</span>: &#123;</span><br><span class="line">                    <span class="attr">"start"</span>: &#123;</span><br><span class="line">                      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">"column"</span>: <span class="number">13</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"end"</span>: &#123;</span><br><span class="line">                      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">"column"</span>: <span class="number">14</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"identifierName"</span>: <span class="string">"a"</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">"name"</span>: <span class="string">"a"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">                  <span class="attr">"start"</span>: <span class="number">16</span>,</span><br><span class="line">                  <span class="attr">"end"</span>: <span class="number">17</span>,</span><br><span class="line">                  <span class="attr">"loc"</span>: &#123;</span><br><span class="line">                    <span class="attr">"start"</span>: &#123;</span><br><span class="line">                      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">"column"</span>: <span class="number">16</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"end"</span>: &#123;</span><br><span class="line">                      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">"column"</span>: <span class="number">17</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"identifierName"</span>: <span class="string">"b"</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">"name"</span>: <span class="string">"b"</span></span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">"body"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"BinaryExpression"</span>,</span><br><span class="line">                <span class="attr">"start"</span>: <span class="number">22</span>,</span><br><span class="line">                <span class="attr">"end"</span>: <span class="number">27</span>,</span><br><span class="line">                <span class="attr">"loc"</span>: &#123;</span><br><span class="line">                  <span class="attr">"start"</span>: &#123;</span><br><span class="line">                    <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"column"</span>: <span class="number">22</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">"end"</span>: &#123;</span><br><span class="line">                    <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"column"</span>: <span class="number">27</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"left"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">                  <span class="attr">"start"</span>: <span class="number">22</span>,</span><br><span class="line">                  <span class="attr">"end"</span>: <span class="number">23</span>,</span><br><span class="line">                  <span class="attr">"loc"</span>: &#123;</span><br><span class="line">                    <span class="attr">"start"</span>: &#123;</span><br><span class="line">                      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">"column"</span>: <span class="number">22</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"end"</span>: &#123;</span><br><span class="line">                      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">"column"</span>: <span class="number">23</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"identifierName"</span>: <span class="string">"a"</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">"name"</span>: <span class="string">"a"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"operator"</span>: <span class="string">"+"</span>,</span><br><span class="line">                <span class="attr">"right"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">                  <span class="attr">"start"</span>: <span class="number">26</span>,</span><br><span class="line">                  <span class="attr">"end"</span>: <span class="number">27</span>,</span><br><span class="line">                  <span class="attr">"loc"</span>: &#123;</span><br><span class="line">                    <span class="attr">"start"</span>: &#123;</span><br><span class="line">                      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">"column"</span>: <span class="number">26</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"end"</span>: &#123;</span><br><span class="line">                      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">"column"</span>: <span class="number">27</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"identifierName"</span>: <span class="string">"b"</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">"name"</span>: <span class="string">"b"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"kind"</span>: <span class="string">"const"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"directives"</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以解析上面的 es6箭头函数为目标,来写一个简单的 parser.</p>
<p>文本 —&gt; AST 的过程中有两个关键步骤:</p>
<ul>
<li>词法分析: 将代码(字符串)分割为token流,即<strong>语法单元</strong>成的数组</li>
<li>语法分析: 分析token流(上面生成的数组)并生成 AST</li>
</ul>
<h4 id="词法分析-Tokenizer-–-词法分析器"><a href="#词法分析-Tokenizer-–-词法分析器" class="headerlink" title="词法分析(Tokenizer – 词法分析器)"></a>词法分析(Tokenizer – 词法分析器)</h4><p>要做词法分析,首先我们需要明白在 JavaScript 中哪些属于<strong>语法单元</strong></p>
<ul>
<li>数字：JavaScript 中的科学记数法以及普通数组都属于语法单元.</li>
<li>括号：『(』『)』只要出现,不管任何意义都算是语法单元</li>
<li>标识符：连续字符,常见的有变量,常量(例如: null true),关键字(if break)等等</li>
<li>运算符：+、-、*、/等等</li>
<li>当然还有注释,中括号等</li>
</ul>
<blockquote>
<p>在我们 parser 的过程中,应该换一个角度看待代码,我们平时工作用的代码.本质是就是字符串或者一段文本,它没有任何意义,是 JavaScript 引擎赋予了它意义,所以我们在解析过程中代码只是一段字符串.</p>
</blockquote>
<p>仍然以下面代码为例</p>
<blockquote>
<p><strong>const</strong> add = (a, b) =&gt; a + b</p>
</blockquote>
<p>我们期望的结果是类似这样的</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="string">type:</span> <span class="string">"identifier"</span>, <span class="string">value:</span> <span class="string">"const"</span> &#125;,</span><br><span class="line">  &#123; <span class="string">type:</span> <span class="string">"whitespace"</span>, <span class="string">value:</span> <span class="string">" "</span> &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>那么我们现在开始打造一个Tokenizer(词法分析器)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 词法分析器,接收字符串返回token数组</span></span><br><span class="line">export <span class="keyword">const</span> tokenizer = (code) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 储存 token 的数组</span></span><br><span class="line">    <span class="keyword">const</span> tokens  = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current &lt; code.length) &#123;</span><br><span class="line">        <span class="comment">// 获取指针指向的字符</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> = code[current];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们先处理单字符的语法单元 类似于`;` `(` `)`等等这种</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">char</span> === <span class="string">'('</span> || <span class="keyword">char</span> === <span class="string">')'</span>) &#123;</span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: <span class="string">'parens'</span>,</span><br><span class="line">                <span class="keyword">value</span>: <span class="keyword">char</span>,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            current ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们接着处理标识符,标识符一般为以字母、_、$开头的连续字符</span></span><br><span class="line">        <span class="keyword">if</span> (/[a-zA-Z\$\_]/.test(<span class="keyword">char</span>)) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">value</span> += <span class="keyword">char</span>;</span><br><span class="line">            current ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是连续字那么将其拼接在一起,随后指针后移</span></span><br><span class="line">            <span class="keyword">while</span> (/[a-zA-Z0<span class="number">-9</span>\$\_]/.test(code[current]) &amp;&amp; current &lt; code.length) &#123;</span><br><span class="line">                <span class="keyword">value</span> += code[current];</span><br><span class="line">                current ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: <span class="string">'identifier'</span>,</span><br><span class="line">                <span class="keyword">value</span>,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理空白字符</span></span><br><span class="line">        <span class="keyword">if</span> (/\s/.test(<span class="keyword">char</span>)) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">value</span> += <span class="keyword">char</span>;</span><br><span class="line">            current ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//道理同上</span></span><br><span class="line">            <span class="keyword">while</span> (/\s]/.test(code[current]) &amp;&amp; current &lt; code.length) &#123;</span><br><span class="line">                <span class="keyword">value</span> += code[current];</span><br><span class="line">                current ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: <span class="string">'whitespace'</span>,</span><br><span class="line">                <span class="keyword">value</span>,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理逗号分隔符</span></span><br><span class="line">        <span class="keyword">if</span> (/,/.test(<span class="keyword">char</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: <span class="string">','</span>,</span><br><span class="line">                <span class="keyword">value</span>: <span class="string">','</span>,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            current ++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理运算符</span></span><br><span class="line">        <span class="keyword">if</span> (/=|\+|&gt;/.test(<span class="keyword">char</span>)) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">value</span> += <span class="keyword">char</span>;</span><br><span class="line">            current ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (/=|\+|&gt;/.test(code[current])) &#123;</span><br><span class="line">                <span class="keyword">value</span> += code[current];</span><br><span class="line">                current ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 = 后面有 &gt; 时为箭头函数而非运算符</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> === <span class="string">'=&gt;'</span>) &#123;</span><br><span class="line">                tokens.push(&#123;</span><br><span class="line">                    type: <span class="string">'ArrowFunctionExpression'</span>,</span><br><span class="line">                    <span class="keyword">value</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: <span class="string">'operator'</span>,</span><br><span class="line">                <span class="keyword">value</span>,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果碰到我们词法分析器以外的字符,则报错</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'I dont know what this character is: '</span> + <span class="keyword">char</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么我们基本的词法分析器就打造完成,因为只针对这一个es6函数,所以没有做额外的工作(额外的工作量会非常庞大).</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const result = tokenizer(<span class="symbol">'const</span> add = (a, b) =&gt; a + b')</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">[ &#123; <span class="keyword">type</span>: <span class="symbol">'identifier'</span>, <span class="keyword">value</span>: <span class="symbol">'const'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'whitespace'</span>, <span class="keyword">value</span>: <span class="string">' '</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'identifier'</span>, <span class="keyword">value</span>: <span class="symbol">'add'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'whitespace'</span>, <span class="keyword">value</span>: <span class="string">' '</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'operator'</span>, <span class="keyword">value</span>: <span class="string">'='</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'whitespace'</span>, <span class="keyword">value</span>: <span class="string">' '</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'parens'</span>, <span class="keyword">value</span>: <span class="string">'('</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'identifier'</span>, <span class="keyword">value</span>: <span class="string">'a'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="string">','</span>, <span class="keyword">value</span>: <span class="string">','</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'whitespace'</span>, <span class="keyword">value</span>: <span class="string">' '</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'identifier'</span>, <span class="keyword">value</span>: <span class="string">'b'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'parens'</span>, <span class="keyword">value</span>: <span class="string">')'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'whitespace'</span>, <span class="keyword">value</span>: <span class="string">' '</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'ArrowFunctionExpression'</span>, <span class="keyword">value</span>: <span class="string">'=&gt;'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'whitespace'</span>, <span class="keyword">value</span>: <span class="string">' '</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'identifier'</span>, <span class="keyword">value</span>: <span class="string">'a'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'whitespace'</span>, <span class="keyword">value</span>: <span class="string">' '</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'operator'</span>, <span class="keyword">value</span>: <span class="string">'+'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'whitespace'</span>, <span class="keyword">value</span>: <span class="string">' '</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="symbol">'identifier'</span>, <span class="keyword">value</span>: <span class="string">'b'</span> &#125; ]</span><br><span class="line">**/</span><br></pre></td></tr></table></figure>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>法分析要比词法分析复杂得多,因为我们接下来的是<em>示意代码</em>,所以做了很多“武断”的判断来省略代码,即使这样也是整个微型 babel 中代码量最多的.</p>
<p>语法分析之所以复杂,是因为要分析各种语法的可能性,需要开发者根据token流(上一节我们生成的 token 数组)提供的信息来分析出代码之间的逻辑关系,只有经过词法分析 token 流才能成为有结构的抽象语法树.</p>
<p>做语法分析最好依照标准,大多数 JavaScript Parser 都遵循<a href="https://github.com/estree/estree" target="_blank" rel="noopener">estree规范</a></p>
<p>由于标准内容很多,感兴趣的可以去阅读,我们目前只介绍几个比较重要的标准:</p>
<p>语句(Statements): 语句是 JavaScript 中非常常见的语法,我们常见的循环、if 判断、异常处理语句、with 语句等等都属于语句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型的for 循环语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式(Expressions): <em>表达式是一组代码的集合，它返回一个值</em>,表达式是另一个十分常见的语法,函数表达式就是一种典型的表达式,如果你不理解什么是表达式, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#表达式" target="_blank" rel="noopener">MDN</a>上有很详细的解释.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="selector-tag">var</span> add = function(<span class="selector-tag">a</span>, b) &#123;</span><br><span class="line">  return  <span class="selector-tag">a</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明(Declarations): 声明分为变量声明和函数声明,表达式(Expressions)中的函数表达式的例子用声明的写法就是下面这样.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line">function add(<span class="selector-tag">a</span>, b) &#123;</span><br><span class="line">  return <span class="selector-tag">a</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能有点糊涂,为了理清其中的关系,我们就下面的代码为例来解读</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="selector-tag">var</span> add = function(<span class="selector-tag">a</span>, b) &#123;</span><br><span class="line">  return  <span class="selector-tag">a</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先这段代码的整体本质是是一个变量声明(VariableDeclarator)</p>
<p>而变量被声明为一个函数表达式(FunctionExpression)</p>
<p>函数表达式中的大括号在内的为块状语句(BlockStatement)</p>
<p>块状语句内 return 的部分是返回语句(ReturnStatement)</p>
<p>而 return 的其实是一个二元运算符或者叫二元表达式(BinaryExpression)</p>
<p>上面提到的这些有些属于表达式,有些属于声明也有些属于语句,当然还有更多我们没提到的,它们被语法分析之后被叫做AST(抽象语法树).</p>
<p>我们做语法分析的时候思路也是类似的,要分析哪一层的 token 到底属于表达式或者说语句,如果是语句那么是块状语句(BlockStatement)还是Loops,如果是 Loops 那么属于while 循环(WhileStatement)还是for 循环(ForStatement)等等,其中甚至难免要考虑作用域的问题,因此语法分析的复杂也体现在此.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">tokens</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个全时指针，它会一直存在</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个暂存栈,用于存放临时指针</span></span><br><span class="line">    <span class="keyword">const</span> tem = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针指向的当前token</span></span><br><span class="line">    <span class="keyword">let</span> token = tokens[current];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parseDeclarations = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暂存当前指针</span></span><br><span class="line">        setTem();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针后移</span></span><br><span class="line">        next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字符为'const'可见是一个声明</span></span><br><span class="line">        <span class="keyword">if</span> (token.type === <span class="string">'identifier'</span> &amp;&amp; token.value === <span class="string">'const'</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> declarations = &#123;</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">'VariableDeclaration'</span>,</span><br><span class="line">                kind: token.value</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// const 后面要跟变量的,如果不是则报错</span></span><br><span class="line">            <span class="keyword">if</span> (token.type !== <span class="string">'identifier'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected Variable after const'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们获取到了变量名称</span></span><br><span class="line">            declarations.identifierName = token.value;</span><br><span class="line"></span><br><span class="line">            next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果跟着 '=' 那么后面应该是个表达式或者常量之类的,额外判断的代码就忽略了,直接解析函数表达式</span></span><br><span class="line">            <span class="keyword">if</span> (token.type === <span class="string">'operator'</span> &amp;&amp; token.value === <span class="string">'='</span>) &#123;</span><br><span class="line">                declarations.init = parseFunctionExpression();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> declarations;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parseFunctionExpression = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> init;</span><br><span class="line">        <span class="comment">// 如果 '=' 后面跟着括号或者字符那基本判断是一个表达式</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            (token.type === <span class="string">'parens'</span> &amp;&amp; token.value === <span class="string">'('</span>) ||</span><br><span class="line">            token.type === <span class="string">'identifier'</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            setTem();</span><br><span class="line">            next();</span><br><span class="line">            <span class="keyword">while</span> (token.type === <span class="string">'identifier'</span> || token.type === <span class="string">','</span>) &#123;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果括号后跟着箭头,那么判断是箭头函数表达式</span></span><br><span class="line">            <span class="keyword">if</span> (token.type === <span class="string">'parens'</span> &amp;&amp; token.value === <span class="string">')'</span>) &#123;</span><br><span class="line">                next();</span><br><span class="line">                <span class="keyword">if</span> (token.type === <span class="string">'ArrowFunctionExpression'</span>) &#123;</span><br><span class="line">                    init = &#123;</span><br><span class="line">                        <span class="keyword">type</span>: <span class="string">'ArrowFunctionExpression'</span>,</span><br><span class="line">                        params: [],</span><br><span class="line">                        body: &#123;&#125;</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    backTem();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 解析箭头函数的参数</span></span><br><span class="line">                    init.params = parseParams();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 解析箭头函数的函数主体</span></span><br><span class="line">                    init.body = parseExpression();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    backTem();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parseParams = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> params = [];</span><br><span class="line">        <span class="keyword">if</span> (token.type === <span class="string">'parens'</span> &amp;&amp; token.value === <span class="string">'('</span>) &#123;</span><br><span class="line">            next();</span><br><span class="line">            <span class="keyword">while</span> (token.type !== <span class="string">'parens'</span> &amp;&amp; token.value !== <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (token.type === <span class="string">'identifier'</span>) &#123;</span><br><span class="line">                    params.push(&#123;</span><br><span class="line">                        <span class="keyword">type</span>: token.type,</span><br><span class="line">                        identifierName: token.value</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parseExpression = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">        <span class="keyword">let</span> body;</span><br><span class="line">        <span class="keyword">while</span> (token.type === <span class="string">'ArrowFunctionExpression'</span>) &#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果以(开头或者变量开头说明不是 BlockStatement,我们以二元表达式来解析</span></span><br><span class="line">        <span class="keyword">if</span> (token.type === <span class="string">'identifier'</span>) &#123;</span><br><span class="line">            body = &#123;</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">'BinaryExpression'</span>,</span><br><span class="line">                left: &#123;</span><br><span class="line">                    <span class="keyword">type</span>: <span class="string">'identifier'</span>,</span><br><span class="line">                    identifierName: token.value</span><br><span class="line">                &#125;,</span><br><span class="line">                operator: <span class="string">''</span>,</span><br><span class="line">                right: &#123;</span><br><span class="line">                    <span class="keyword">type</span>: <span class="string">''</span>,</span><br><span class="line">                    identifierName: <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (token.type === <span class="string">'operator'</span>) &#123;</span><br><span class="line">                body.operator = token.value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (token.type === <span class="string">'identifier'</span>) &#123;</span><br><span class="line">                body.right = &#123;</span><br><span class="line">                    <span class="keyword">type</span>: <span class="string">'identifier'</span>,</span><br><span class="line">                    identifierName: token.value</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针后移的函数</span></span><br><span class="line">    <span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ++current;</span><br><span class="line">            token = tokens[current]</span><br><span class="line">                ? tokens[current]</span><br><span class="line">                : &#123; <span class="keyword">type</span>: <span class="string">'eof'</span>, value: <span class="string">''</span> &#125;;</span><br><span class="line">        &#125; <span class="keyword">while</span> (token.type === <span class="string">'whitespace'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针暂存的函数</span></span><br><span class="line">    <span class="keyword">const</span> setTem = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        tem.push(current);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针回退的函数</span></span><br><span class="line">    <span class="keyword">const</span> backTem = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        current = tem.pop();</span><br><span class="line">        token = tokens[current];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ast = &#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">'Program'</span>,</span><br><span class="line">        body: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current &lt; tokens.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> statement = parseDeclarations();</span><br><span class="line">        <span class="keyword">if</span> (!statement) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ast.body.push(statement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ast;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至此我们<em>暴力</em> parser 了token 流,最终得到了简陋的抽象语法树:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">    <span class="attr">"body"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"VariableDeclaration"</span>,</span><br><span class="line">            <span class="attr">"identifierName"</span>: <span class="string">"add"</span>,</span><br><span class="line">            <span class="attr">"init"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"ArrowFunctionExpression"</span>,</span><br><span class="line">                <span class="attr">"params"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"identifier"</span>,</span><br><span class="line">                        <span class="attr">"identifierName"</span>: <span class="string">"a"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"identifier"</span>,</span><br><span class="line">                        <span class="attr">"identifierName"</span>: <span class="string">"b"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"body"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"BinaryExpression"</span>,</span><br><span class="line">                    <span class="attr">"left"</span>: &#123;</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"identifier"</span>,</span><br><span class="line">                        <span class="attr">"identifierName"</span>: <span class="string">"a"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"operator"</span>: <span class="string">"+"</span>,</span><br><span class="line">                    <span class="attr">"right"</span>: &#123;</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"identifier"</span>,</span><br><span class="line">                        <span class="attr">"identifierName"</span>: <span class="string">"b"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码转换"><a href="#代码转换" class="headerlink" title="代码转换"></a>代码转换</h3><h4 id="如何转换代码"><a href="#如何转换代码" class="headerlink" title="如何转换代码?"></a>如何转换代码?</h4><p>在 Babel 中我们使用者最常使用的地方就是代码转换,大家常用的 Babel 插件就是定义代码转换规则而生的,而代码解析和生成这一头一尾都主要是 Babel 负责。</p>
<p>比如我们要用 babel 做一个React 转小程序的转换器，babel工作流程的粗略情况是这样的：</p>
<ol>
<li>babel 将 React 代码解析为抽象语法树</li>
<li>开发者利用 babel 插件定义转换规则，根据原本的抽象语法树生成一个符合小程序规则的新抽象语法树</li>
<li>babel 则根据新的抽象语法树生成代码，此时的代码就是符合小程序规则的新代码</li>
</ol>
<p>例如 <a href="https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15" target="_blank" rel="noopener">Taro</a>就是用 babel 完成的小程序语法转换.</p>
<p>到这里大家就明白了,我们转换代码的关键就是根据当前的抽象语法树,以我们定义的规则生成新的抽象语法树,转换的过程就是生成新抽象语法树的过程.</p>
<h4 id="遍历抽象语法树-实现遍历器traverser"><a href="#遍历抽象语法树-实现遍历器traverser" class="headerlink" title="遍历抽象语法树(实现遍历器traverser)"></a>遍历抽象语法树(实现遍历器traverser)</h4><p>抽象语法树是一个树状数据结构,我们要生成新语法树,那么一定需要访问 AST 上的节点,因此我们需要一个工具来遍历抽象语法树的节点.</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const traverser = (ast, visitor) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 如果节点是数组那么遍历数组</span><br><span class="line">    const traverseArray = (array, parent) =&gt; &#123;</span><br><span class="line">        array.forEach((child) =&gt; &#123;</span><br><span class="line">            traverseNode(child, parent);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 遍历 ast 节点</span><br><span class="line">    const traverseNode = (<span class="keyword">node</span><span class="title">, parent</span>) =&gt; &#123;</span><br><span class="line">        const method = visitor[<span class="keyword">node</span>.<span class="title">type</span>];</span><br><span class="line">        if (method) &#123;</span><br><span class="line">            method(<span class="keyword">node</span><span class="title">, parent</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (<span class="keyword">node</span>.<span class="title">type</span>) &#123;</span><br><span class="line">        case 'Program':</span><br><span class="line">            traverseArray(<span class="keyword">node</span>.<span class="title">body</span>, <span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">            break</span>;</span><br><span class="line"></span><br><span class="line">        case 'VariableDeclaration':</span><br><span class="line">            traverseArray(<span class="keyword">node</span>.<span class="title">init</span>.<span class="keyword">params</span>, <span class="keyword">node</span>.<span class="title">init</span>);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case 'identifier':</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            throw new TypeError(<span class="keyword">node</span>.<span class="title">type</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    traverseNode(ast, null);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="转换代码-实现转换器transformer"><a href="#转换代码-实现转换器transformer" class="headerlink" title="转换代码(实现转换器transformer)"></a>转换代码(实现转换器transformer)</h4><p>我们要转换的代码<code>const add = (a, b) =&gt; a + b</code>其实是个变量声明,按理来讲我们要转换为es5的代码也应该是个变量声明,比如这种:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> add = function(<span class="selector-tag">a</span>, b) &#123;</span><br><span class="line">  return  <span class="selector-tag">a</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以不按规则,直接生成一个函数声明,像这样:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(<span class="selector-tag">a</span>, b) &#123;</span><br><span class="line">  return <span class="selector-tag">a</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.linjiahong.top/Note16.png" alt="1598071209678"></p>
<p>我们之前的遍历器<code>traverser</code>接收两个参数,一个是 ast 节点对象,一个是 visitor,visitor本质是挂载不同方法的 JavaScript 对象,visitor 也叫做访问者,顾名思义它会访问 ast 上每个节点,然后根据针对不同节点用相应的方法做出不同的转换.</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const transformer = (ast) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 新 ast</span><br><span class="line">    const newAst = &#123;</span><br><span class="line">        <span class="keyword">type</span>: 'Program',</span><br><span class="line">        body: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 在老 ast 上加一个指针指向新 ast</span><br><span class="line">    ast._context = newAst.body;</span><br><span class="line"></span><br><span class="line">    traverser(ast, &#123;</span><br><span class="line">        // 对于变量声明的处理方法</span><br><span class="line">        VariableDeclaration: (<span class="keyword">node</span><span class="title">, parent</span>) =&gt; &#123;</span><br><span class="line">            let functionDeclaration = &#123;</span><br><span class="line">                <span class="keyword">params</span>: []</span><br><span class="line">            &#125;;</span><br><span class="line">            if (<span class="keyword">node</span>.<span class="title">init</span>.<span class="keyword">type</span> === 'ArrowFunctionExpression') &#123;</span><br><span class="line">                functionDeclaration.<span class="keyword">type</span> = 'FunctionDeclaration';</span><br><span class="line">                functionDeclaration.identifierName = <span class="keyword">node</span>.<span class="title">identifierName</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (<span class="keyword">node</span>.<span class="title">init</span>.body.<span class="keyword">type</span> === 'BinaryExpression') &#123;</span><br><span class="line">                functionDeclaration.body = &#123;</span><br><span class="line">                    <span class="keyword">type</span>: 'BlockStatement',</span><br><span class="line">                    body: [&#123;</span><br><span class="line">                        <span class="keyword">type</span>: 'ReturnStatement',</span><br><span class="line">                        argument: <span class="keyword">node</span>.<span class="title">init</span>.body</span><br><span class="line">                    &#125;],</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parent._context.push(functionDeclaration);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        //对于字符的处理方法</span><br><span class="line">        identifier: (<span class="keyword">node</span><span class="title">, parent</span>) =&gt; &#123;</span><br><span class="line">            if (parent.<span class="keyword">type</span> === 'ArrowFunctionExpression') &#123;</span><br><span class="line">            // 忽略我这暴力的操作....领略大意即可..</span><br><span class="line">                ast._context[<span class="number">0</span>].<span class="keyword">params</span>.push(&#123;</span><br><span class="line">                    <span class="keyword">type</span>: 'identifier',</span><br><span class="line">                    identifierName: <span class="keyword">node</span>.<span class="title">identifierName</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return newAst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="生成代码-实现生成器generator"><a href="#生成代码-实现生成器generator" class="headerlink" title="生成代码(实现生成器generator)"></a>生成代码(实现生成器generator)</h3><p>我们之前提到过,生成代码这一步实际上是根据我们转换后的抽象语法树来生成新的代码,我们会实现一个函数, 他接受一个对象( ast),通过递归生成最终的代码</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const generator = (<span class="keyword">node</span><span class="title">) =&gt; &#123;</span></span><br><span class="line"><span class="title">    switch</span> (<span class="keyword">node</span>.<span class="title">type</span>) &#123;</span><br><span class="line">    // 如果是 `Program` 结点，那么我们会遍历它的 `body` 属性中的每一个结点，并且递归地</span><br><span class="line">    // 对这些结点再次调用 codeGenerator，再把结果打印进入新的一行中。</span><br><span class="line">    case 'Program':</span><br><span class="line">        return <span class="keyword">node</span>.<span class="title">body</span>.map(generator)</span><br><span class="line">            .join('\n');</span><br><span class="line"></span><br><span class="line">    // 如果是FunctionDeclaration我们分别遍历调用其参数数组以及调用其 body 的属性</span><br><span class="line">    case 'FunctionDeclaration':</span><br><span class="line">        return 'function' + ' ' + <span class="keyword">node</span>.<span class="title">identifierName</span> + '(' + <span class="keyword">node</span>.<span class="title">params</span>.map(generator) + ')' + ' ' + generator(<span class="keyword">node</span>.<span class="title">body</span>);</span><br><span class="line"></span><br><span class="line">    // 对于 `Identifiers` 我们只是返回 `<span class="keyword">node</span><span class="title">` 的 identifierName</span></span><br><span class="line">    case 'identifier':</span><br><span class="line">        return <span class="keyword">node</span>.<span class="title">identifierName</span>;</span><br><span class="line"></span><br><span class="line">    // 如果是BlockStatement我们遍历调用其body数组</span><br><span class="line">    case 'BlockStatement':</span><br><span class="line">        return '&#123;' + <span class="keyword">node</span>.<span class="title">body</span>.map(generator) + '&#125;';</span><br><span class="line"></span><br><span class="line">    // 如果是ReturnStatement我们调用其 argument 的属性</span><br><span class="line">    case 'ReturnStatement':</span><br><span class="line">        return 'return' + ' ' + generator(<span class="keyword">node</span>.<span class="title">argument</span>);</span><br><span class="line">    </span><br><span class="line">    // 如果是ReturnStatement我们调用其左右节点并拼接</span><br><span class="line">    case 'BinaryExpression':</span><br><span class="line">        return generator(<span class="keyword">node</span>.<span class="title">left</span>) + ' ' + <span class="keyword">node</span>.<span class="title">operator</span> + ' ' + generator(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line"></span><br><span class="line">    // 没有符合的则报错</span><br><span class="line">    default:</span><br><span class="line">        throw new TypeError(<span class="keyword">node</span>.<span class="title">type</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至此我们完成了一个简陋的微型 babel,我们开始试验:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compiler = (<span class="keyword">input</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> tokens = tokenizer(<span class="keyword">input</span>);  <span class="comment">//词法分析得抽象语法树节点，注意还不是树</span></span><br><span class="line">    <span class="keyword">const</span> ast =  parser(tokens);  <span class="comment">// 语法分析得到抽象语法树结构</span></span><br><span class="line">    <span class="keyword">const</span> newAst = transformer(ast);  <span class="comment">//转换成目标AST(新)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">output</span> = generator(newAst);  <span class="comment">//根据抽象语法树生成代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">output</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = '<span class="keyword">const</span> add = (a, b) =&gt; a + b';</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = compiler(str);</span><br><span class="line"></span><br><span class="line">console<span class="variable">.log</span>(result);</span><br><span class="line"><span class="comment">// function add(a,b) &#123;return a + b&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>语法分析之后被叫做AST(抽象语法树).</p>
</blockquote>
<p>我们成功地将一个es6的箭头函数转换为es5的function函数.</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我们可以通过这个微型 babel 了解 babel 的工作原理,如果让你对编译原理产生兴趣并去深入那是更好的, babel集合包 是有数十万行代码的巨大工程,我们用区区几百行代码只能展示其最基本的原理,代码有很多不合理之处,如果想真正的了解 babel 欢迎阅读器<a href="https://github.com/babel/babel" target="_blank" rel="noopener">源码</a>.</p>
<p>前端可以利用编译原理相关的东西还有很多,除了我们常见的es6转换工具 babel,代码检测的 eslint等等,我们还可以:</p>
<ol>
<li>小程序多端转义<a href="https://github.com/NervJS/taro" target="_blank" rel="noopener"> Taro</a></li>
<li>小程序热更新<a href="https://zhuanlan.zhihu.com/p/34191831" target="_blank" rel="noopener">js 解释器</a></li>
<li>babel与错误监控<a href="http://2016.qconshanghai.com/presentation/3068/" target="_blank" rel="noopener">浏览器端 JavaScript 异常监控</a></li>
<li>模板引擎</li>
<li>css 预处理后处理等等</li>
<li>…</li>
</ol>
<hr>
      
    </div>

    <div>
      
        

      
    </div>
  
        <div class="post-tags">
          
            <a href="/tags/Vue/" rel="tag"><i class="fa fa-tag"></i> Vue</a>
          
            <a href="/tags/前端/" rel="tag"><i class="fa fa-tag"></i> 前端</a>
          
            <a href="/tags/双向绑定/" rel="tag"><i class="fa fa-tag"></i> 双向绑定</a>
          
            <a href="/tags/消息通信/" rel="tag"><i class="fa fa-tag"></i> 消息通信</a>
          
        </div>
      


    <div>
      
        

      
    </div>


    <footer class="post-footer">

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020-10-25/webpackInterview.html" rel="prev" title="webpack入门及其使用">
                <i class="fa fa-chevron-left"></i> webpack入门及其使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020-08-25/dataType.html" rel="next" title="不为人知的数据类型">
                 不为人知的数据类型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
 <a href="/">
          <img class="site-author-image" itemprop="image" src="https://images.linjiahong.top/avatar.jpg" alt="林加鸿">
</a>
          <p class="site-author-name" itemprop="name">林加鸿</p>
          <p class="site-description motion-element" itemprop="description">欢迎来到Abo的博客，博客以分享前端web知识、数据结构与算法、计算机基础为主，希望能帮到您ㄟ(😀)ㄏ</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">81</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jhjhljh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/jhjhljh" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/jhjhljh" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-battery-3"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              神奇的链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://music.163.com/#/user/home?id=84597901" title="😆 网易云音乐 😆" target="_blank">😆 网易云音乐 😆</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.taylorswift.com/" title="😋Taylor Swift Official Website😋" target="_blank">😋Taylor Swift Official Website😋</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://tophub.today/" title="今日热榜(各大网站)" target="_blank">今日热榜(各大网站)</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.bilibili.com/video/av46959835/" title="独狼(Lone Wolf)——献给那些独自行走的人" target="_blank">独狼(Lone Wolf)——献给那些独自行走的人</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://linjiahong.top/about/" title="关于此博客" target="_blank">关于此博客</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现EVENTBUS（⭐⭐⭐）"><span class="nav-number">1.</span> <span class="nav-text">实现EVENTBUS（⭐⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用EventBus"><span class="nav-number">1.1.1.</span> <span class="nav-text">使用EventBus</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#React-Vue不同组件之间是怎么通信的"><span class="nav-number">1.1.2.</span> <span class="nav-text">React/Vue不同组件之间是怎么通信的?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本构造"><span class="nav-number">1.2.</span> <span class="nav-text">基本构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化class"><span class="nav-number">1.2.1.</span> <span class="nav-text">初始化class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监听与触发"><span class="nav-number">1.2.2.</span> <span class="nav-text">监听与触发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#关于js反射"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">关于js反射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关于Reflect-反射"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">关于Reflect(反射)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#那么为什么需要Reflect对象？"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">那么为什么需要Reflect对象？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关于Object-create"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">关于Object.create()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#回归正题"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">回归正题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#升级改造"><span class="nav-number">1.3.</span> <span class="nav-text">升级改造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发现问题"><span class="nav-number">1.3.1.</span> <span class="nav-text">发现问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前端路由的实现（⭐⭐）"><span class="nav-number">2.</span> <span class="nav-text">前端路由的实现（⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hash路由"><span class="nav-number">2.1.</span> <span class="nav-text">hash路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化class-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">初始化class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现路由hash储存与执行"><span class="nav-number">2.1.2.</span> <span class="nav-text">实现路由hash储存与执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监听对应事件"><span class="nav-number">2.1.3.</span> <span class="nav-text">监听对应事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增加回退功能"><span class="nav-number">2.2.</span> <span class="nav-text">增加回退功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现后退功能"><span class="nav-number">2.2.1.</span> <span class="nav-text">实现后退功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完整实现hash-Router"><span class="nav-number">2.2.2.</span> <span class="nav-text">完整实现hash Router</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML5新路由方案"><span class="nav-number">2.3.</span> <span class="nav-text">HTML5新路由方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#History-API"><span class="nav-number">2.3.1.</span> <span class="nav-text">History API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新标准下路由的实现"><span class="nav-number">2.3.2.</span> <span class="nav-text">新标准下路由的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现双向绑定Proxy比defineproperty优劣如何-（⭐⭐⭐⭐⭐）"><span class="nav-number">3.</span> <span class="nav-text">实现双向绑定Proxy比defineproperty优劣如何?（⭐⭐⭐⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#双向绑定原理"><span class="nav-number">3.1.</span> <span class="nav-text">双向绑定原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于defineProperty"><span class="nav-number">3.2.</span> <span class="nav-text">关于defineProperty</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据描述"><span class="nav-number">3.2.1.</span> <span class="nav-text">数据描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getter-setter"><span class="nav-number">3.2.2.</span> <span class="nav-text">getter/setter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于proxy"><span class="nav-number">3.3.</span> <span class="nav-text">关于proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy的作用"><span class="nav-number">3.4.</span> <span class="nav-text">Proxy的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单理解"><span class="nav-number">3.4.1.</span> <span class="nav-text">简单理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前言-1"><span class="nav-number">3.5.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue三要素"><span class="nav-number">3.5.1.</span> <span class="nav-text">Vue三要素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于数据劫持实现的双向绑定的特点"><span class="nav-number">3.6.</span> <span class="nav-text">基于数据劫持实现的双向绑定的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是数据劫持"><span class="nav-number">3.6.1.</span> <span class="nav-text">什么是数据劫持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据劫持的优势"><span class="nav-number">3.6.2.</span> <span class="nav-text">数据劫持的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于数据劫持双向绑定的实现思路"><span class="nav-number">3.6.3.</span> <span class="nav-text">基于数据劫持双向绑定的实现思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于Object-defineProperty双向绑定的特点"><span class="nav-number">3.7.</span> <span class="nav-text">基于Object.defineProperty双向绑定的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#极简版的双向绑定"><span class="nav-number">3.7.1.</span> <span class="nav-text">极简版的双向绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#升级改造-1"><span class="nav-number">3.7.2.</span> <span class="nav-text">升级改造</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#拓展：开放封闭原则（Open-Closed-Principle）"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">拓展：开放封闭原则（Open Closed Principle）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#回归正题-1"><span class="nav-number">3.7.2.2.</span> <span class="nav-text">回归正题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#演示"><span class="nav-number">3.7.3.</span> <span class="nav-text">演示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-defineProperty的缺陷"><span class="nav-number">3.7.4.</span> <span class="nav-text">Object.defineProperty的缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy实现的双向绑定的特点"><span class="nav-number">3.8.</span> <span class="nav-text">Proxy实现的双向绑定的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Proxy可以直接监听对象而非属性"><span class="nav-number">3.8.1.</span> <span class="nav-text">Proxy可以直接监听对象而非属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proxy可以直接监听数组的变化"><span class="nav-number">3.8.2.</span> <span class="nav-text">Proxy可以直接监听数组的变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proxy的其他优势"><span class="nav-number">3.8.3.</span> <span class="nav-text">Proxy的其他优势</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你为什么使用前端框架？（⭐⭐）"><span class="nav-number">4.</span> <span class="nav-text">你为什么使用前端框架？（⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前端框架的根本意义"><span class="nav-number">4.1.</span> <span class="nav-text">前端框架的根本意义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#前端框架的好处"><span class="nav-number">4.1.1.</span> <span class="nav-text">前端框架的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前端框架的根本意义-1"><span class="nav-number">4.1.2.</span> <span class="nav-text">前端框架的根本意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-如何保证-UI-与状态同步"><span class="nav-number">4.2.</span> <span class="nav-text">Vue 如何保证 UI 与状态同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发布订阅中心"><span class="nav-number">4.2.1.</span> <span class="nav-text">发布订阅中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监听者的实现"><span class="nav-number">4.2.2.</span> <span class="nav-text">监听者的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#订阅者的实现"><span class="nav-number">4.2.3.</span> <span class="nav-text">订阅者的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#批量更新的实现"><span class="nav-number">4.2.4.</span> <span class="nav-text">批量更新的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">4.2.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应式系统并不是全部"><span class="nav-number">4.3.</span> <span class="nav-text">响应式系统并不是全部</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者模式与订阅发布模式的区别（⭐）"><span class="nav-number">5.</span> <span class="nav-text">观察者模式与订阅发布模式的区别（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#观察者模式"><span class="nav-number">5.1.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#订阅-发布模式"><span class="nav-number">5.2.</span> <span class="nav-text">订阅-发布模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种模式的区别"><span class="nav-number">5.3.</span> <span class="nav-text">两种模式的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写过『通用前端组件』吗-（⭐⭐⭐）"><span class="nav-number">6.</span> <span class="nav-text">写过『通用前端组件』吗?（⭐⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言-2"><span class="nav-number">6.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前端组件库的设计原则"><span class="nav-number">6.2.</span> <span class="nav-text">前端组件库的设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#细粒度的考量"><span class="nav-number">6.2.1.</span> <span class="nav-text">细粒度的考量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通用性考量"><span class="nav-number">6.2.2.</span> <span class="nav-text">通用性考量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#技术选型"><span class="nav-number">6.3.</span> <span class="nav-text">技术选型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#css-解决方案"><span class="nav-number">6.3.1.</span> <span class="nav-text">css 解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#js-解决方案"><span class="nav-number">6.3.2.</span> <span class="nav-text">js 解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何快速启动一个组件库项目"><span class="nav-number">6.4.</span> <span class="nav-text">如何快速启动一个组件库项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打包工具-rollup-vs-webpack"><span class="nav-number">6.4.1.</span> <span class="nav-text">打包工具(rollup vs webpack)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码检测"><span class="nav-number">6.4.2.</span> <span class="nav-text">代码检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commit-规范"><span class="nav-number">6.4.3.</span> <span class="nav-text">commit 规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试工具"><span class="nav-number">6.4.4.</span> <span class="nav-text">测试工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速启动脚手架"><span class="nav-number">6.4.5.</span> <span class="nav-text">快速启动脚手架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何设计一个轮播图组件"><span class="nav-number">6.5.</span> <span class="nav-text">如何设计一个轮播图组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#轮播图基本原理"><span class="nav-number">6.5.1.</span> <span class="nav-text">轮播图基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现流程"><span class="nav-number">6.5.2.</span> <span class="nav-text">实现流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聊一聊-Babel-（⭐）"><span class="nav-number">7.</span> <span class="nav-text">聊一聊 Babel?（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前置"><span class="nav-number">7.1.</span> <span class="nav-text">前置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码解析"><span class="nav-number">7.2.</span> <span class="nav-text">代码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#parser-概念"><span class="nav-number">7.2.1.</span> <span class="nav-text">parser 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词法分析-Tokenizer-–-词法分析器"><span class="nav-number">7.2.2.</span> <span class="nav-text">词法分析(Tokenizer – 词法分析器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语法分析"><span class="nav-number">7.2.3.</span> <span class="nav-text">语法分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码转换"><span class="nav-number">7.3.</span> <span class="nav-text">代码转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何转换代码"><span class="nav-number">7.3.1.</span> <span class="nav-text">如何转换代码?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历抽象语法树-实现遍历器traverser"><span class="nav-number">7.3.2.</span> <span class="nav-text">遍历抽象语法树(实现遍历器traverser)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转换代码-实现转换器transformer"><span class="nav-number">7.3.3.</span> <span class="nav-text">转换代码(实现转换器transformer)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成代码-实现生成器generator"><span class="nav-number">7.4.</span> <span class="nav-text">生成代码(实现生成器generator)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最后"><span class="nav-number">7.5.</span> <span class="nav-text">最后</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林加鸿</span>
</div>






        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user-circle-o"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span><i class="fa fa-eye"></i></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  



  


  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("W0twhOKHT901IOCEADaiuynP-gzGzoHsz", "zQfRdGCiWzVvsSpXKOJsbvHe");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

	<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
<script>
 $("body").backstretch("http://images.linjiahong.top/6_29.jpg");
</script>
</body>
</html>
